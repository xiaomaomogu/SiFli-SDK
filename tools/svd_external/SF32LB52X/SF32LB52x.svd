<?xml version="1.0" encoding="utf-8" standalone="no"?>
<device schemaVersion="1.1"
xmlns:xs="http://www.w3.org/2001/XMLSchema-instance"
xs:noNamespaceSchemaLocation="CMSIS-SVD_Schema_1_1.xsd">
  <name>SF32LB52x</name>
  <version>1.0</version>
  <description>SF32LB52x</description>
  <!-- details about the cpu embedded in the device -->
  <cpu>
    <name>CM33</name>
    <revision>r0p1</revision>
    <endian>little</endian>
    <mpuPresent>true</mpuPresent>
    <fpuPresent>true</fpuPresent>
    <nvicPrioBits>3</nvicPrioBits>
    <vendorSystickConfig>false</vendorSystickConfig>
  </cpu>
  <!--Bus Interface Properties-->
  <addressUnitBits>8</addressUnitBits>
  <!--the maximum data bit width accessible within a single transfer-->
  <width>32</width>
  <!--Register Default Properties-->
  <size>0x20</size>
  <resetValue>0x0</resetValue>
  <resetMask>0xFFFFFFFF</resetMask>
  <peripherals>
    <peripheral>
      <name>HPSYS_RCC</name>
      <description></description>
      <groupName>HPSYS_RCC</groupName>
      <baseAddress>0x50000000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>RSTR1</name>
          <displayName>RSTR1</displayName>
          <description>Reset Register 1</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>PTC1</name>
              <description>
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>I2C2</name>
              <description>
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>I2C1</name>
              <description>
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PDM1</name>
              <description>
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD5</name>
              <description>
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EXTDMA</name>
              <description>
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SPI2</name>
              <description>
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SPI1</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD6</name>
              <description>
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BTIM2</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BTIM1</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GPTIM2</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GPTIM1</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TRNG</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CRC1</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>AES</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EFUSEC</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SYSCFG1</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD7</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>I2S1</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LCDC1</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EPIC</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EZIP1</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>USART2</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>USART1</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PINMUX1</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MAILBOX1</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMAC1</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSTR2</name>
          <displayName>RSTR2</displayName>
          <description>Reset Register 2</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>I2C4</name>
              <description>
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TSEN</name>
              <description>
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GPADC</name>
              <description>
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>AUDPRC</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>AUDCODEC</name>
              <description>
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD5</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD6</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD7</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD8</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD9</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>USART3</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD10</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD11</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ATIM1</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>I2C3</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD12</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>USBC</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD13</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SDMMC1</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD14</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MPI2</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MPI1</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GPIO1</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ENR1</name>
          <displayName>ENR1</displayName>
          <description>Enable Register 1</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>PTC1</name>
              <description>
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>I2C2</name>
              <description>
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>I2C1</name>
              <description>
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PDM1</name>
              <description>
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SECU1</name>
              <description>
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EXTDMA</name>
              <description>
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SPI2</name>
              <description>
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SPI1</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD5</name>
              <description>
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BTIM2</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BTIM1</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GPTIM2</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GPTIM1</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TRNG</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CRC1</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>AES</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EFUSEC</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SYSCFG1</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD6</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>I2S1</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LCDC1</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EPIC</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EZIP1</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>USART2</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD7</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PINMUX1</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MAILBOX1</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMAC1</name>
              <description>
              write 1 to set module enable, write 0 to disable module
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ENR2</name>
          <displayName>ENR2</displayName>
          <description>Enable Register 2</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>I2C4</name>
              <description>
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TSEN</name>
              <description>
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GPADC</name>
              <description>
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>AUDPRC</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>AUDCODEC</name>
              <description>
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD5</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD6</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD7</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD8</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD9</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>USART3</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD10</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD11</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ATIM1</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>I2C3</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD12</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>USBC</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD13</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SDMMC1</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD14</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MPI2</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MPI1</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GPIO1</name>
              <description>
              write 1 to set module enable, write 0 to disable module
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ESR1</name>
          <displayName>ESR1</displayName>
          <description>Enable Set Register 1</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>PTC1</name>
              <description>
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>I2C2</name>
              <description>
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>I2C1</name>
              <description>
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PDM1</name>
              <description>
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SECU1</name>
              <description>
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EXTDMA</name>
              <description>
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SPI2</name>
              <description>
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SPI1</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD5</name>
              <description>
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BTIM2</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BTIM1</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GPTIM2</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GPTIM1</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TRNG</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CRC1</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>AES</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EFUSEC</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SYSCFG1</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD6</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>I2S1</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LCDC1</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EPIC</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EZIP1</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>USART2</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD7</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PINMUX1</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MAILBOX1</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMAC1</name>
              <description>
              write 1 to set module enable, write 0 has no effect
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ESR2</name>
          <displayName>ESR2</displayName>
          <description>Enable Set Register 2</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>I2C4</name>
              <description>
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TSEN</name>
              <description>
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GPADC</name>
              <description>
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>AUDPRC</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>AUDCODEC</name>
              <description>
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD5</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD6</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD7</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD8</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD9</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>USART3</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD10</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD11</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ATIM1</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>I2C3</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD12</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>USBC</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD13</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SDMMC1</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD14</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MPI2</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MPI1</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GPIO1</name>
              <description>
              write 1 to set module enable, write 0 has no effect
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ECR1</name>
          <displayName>ECR1</displayName>
          <description>Enable Clear Register 1</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>PTC1</name>
              <description>
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>I2C2</name>
              <description>
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>I2C1</name>
              <description>
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PDM1</name>
              <description>
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SECU1</name>
              <description>
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EXTDMA</name>
              <description>
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SPI2</name>
              <description>
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SPI1</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD5</name>
              <description>
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BTIM2</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BTIM1</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GPTIM2</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GPTIM1</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TRNG</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CRC1</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>AES</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EFUSEC</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SYSCFG1</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD6</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>I2S1</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LCDC1</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EPIC</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EZIP1</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>USART2</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD7</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PINMUX1</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MAILBOX1</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMAC1</name>
              <description>
              write 1 to clear module enable, write 0 has no effect
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ECR2</name>
          <displayName>ECR2</displayName>
          <description>Enable Clear Register 2</description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>I2C4</name>
              <description>
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TSEN</name>
              <description>
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GPADC</name>
              <description>
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>AUDPRC</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>AUDCODEC</name>
              <description>
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD5</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD6</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD7</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD8</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD9</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>USART3</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD10</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD11</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ATIM1</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>I2C3</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD12</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>USBC</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD13</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SDMMC1</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD14</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MPI2</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MPI1</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GPIO1</name>
              <description>
              write 1 to clear module enable, write 0 has no effect
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CSR</name>
          <displayName>CSR</displayName>
          <description>Clock Select Register</description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>SEL_USBC</name>
              <description>
              select clock source for USBC. 0 - clk_sys; 1 - dll2
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SEL_TICK</name>
              <description>
              select clock source for systick reference. 0 - clk_rtc; 1 - RSVD; 2 - hrc48; 3 - hxt48
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>SEL_PERI</name>
              <description>
              select clock source for clk_peri. 0 - hrc48; 1 - hxt48. clk_peri is the clock source of USART/SPI/I2C/GPTIM2/BTIM2
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>SEL_MPI2</name>
              <description>
              select clock source for MPI2. 0 - clk_peri; 1 - dll1; 2 - dll2; 3 - dbl96
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>SEL_MPI1</name>
              <description>
              select clock source for MPI1. 0 - clk_peri; 1 - dll1; 2 - dll2; 3 - dbl96
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SEL_SYS_LP</name>
              <description>
              if set to 1, clk_sys will switch to clk_wdt
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SEL_SYS</name>
              <description>
              select clock source for clk_sys. 0 - hrc48; 1 - hxt48; 2 - dbl96; 3 - dll1
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CFGR</name>
          <displayName>CFGR</displayName>
          <description>Clock Configuration Register</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
            <field>
              <name>TICKDIV</name>
              <description>
              systick reference is divided by TICKDIV
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PDIV2</name>
              <description>
              PCLK2 = HCLK2 / (2^PDIV2), by default divided by 16
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PDIV1</name>
              <description>
              PCLK1 = HCLK2 / (2^PDIV1), by default divided by 2
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>HDIV</name>
              <description>
              HCLK = CLK_SYS / HDIV
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>USBCR</name>
          <displayName>USBCR</displayName>
          <description>USBC Control Register</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>29</bitWidth>
            </field>
            <field>
              <name>DIV</name>
              <description>
              USBC function clock is divided by DIV. USBC function clock should keep at 60MHz. For example, if USBC clock source is 240MHz dll2, DIV should be 4.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DLL1CR</name>
          <displayName>DLL1CR</displayName>
          <description>DLL1 Control Register</description>
          <addressOffset>0x2c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>READY</name>
              <description>
              0: dll not ready
              1: dll ready
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
            <field>
              <name>OUT_DIV2_EN</name>
              <description>
              0: dll output not divided
              1: dll output divided by 2
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
            <field>
              <name>STG</name>
              <description>
              dll lock frequency is (STG+1)*24MHz
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EN</name>
              <description>
              0: dll disabled
              1: dll enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DLL2CR</name>
          <displayName>DLL2CR</displayName>
          <description>DLL2 Control Register</description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>READY</name>
              <description>
              0: dll not ready
              1: dll ready
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
            <field>
              <name>OUT_DIV2_EN</name>
              <description>
              0: dll output not divided
              1: dll output divided by 2
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
            <field>
              <name>STG</name>
              <description>
              dll lock frequency is (STG+1)*24MHz
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EN</name>
              <description>
              0: dll disabled
              1: dll enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>HRCCAL1</name>
          <displayName>HRCCAL1</displayName>
          <description>HRC Calibration Register 1</description>
          <addressOffset>0x34</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>CAL_DONE</name>
              <description>
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CAL_EN</name>
              <description>
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>14</bitWidth>
            </field>
            <field>
              <name>CAL_LENGTH</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>HRCCAL2</name>
          <displayName>HRCCAL2</displayName>
          <description>HRC Calibration Register 2</description>
          <addressOffset>0x38</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>HXT_CNT</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>HRC_CNT</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD1</name>
          <displayName>RSVD1</displayName>
          <description></description>
          <addressOffset>0x3C</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>DWCFGR</name>
          <displayName>DWCFGR</displayName>
          <description>Deep WFI mode Clock Configuration Register</description>
          <addressOffset>0x44</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>13</bitWidth>
            </field>
            <field>
              <name>SEL_SYS_LP</name>
              <description>
              0 - SYSCLK; 1 - CLK_LP
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SEL_SYS</name>
              <description>
              0 - HRC48; 1 - HXT48; 2 - RSVD; 3 - DLL1
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>DIV_EN</name>
              <description>
              enable PDIV1, PDIV2 and HDIV reconfiguration during deep wfi
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PDIV2</name>
              <description>
              PCLK2 = HCLK / (2^PDIV2)  during deep wfi
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PDIV1</name>
              <description>
              PCLK = HCLK / (2^PDIV1)  during deep wfi
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>HDIV</name>
              <description>
              HCLK = CLK_SYS / HDIV  during deep wfi
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>ATIM1</name>
      <description></description>
      <groupName>ATIM</groupName>
      <baseAddress>0x50004000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CR1</name>
          <displayName>CR1</displayName>
          <description>TIM control register 1</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>UIFREMAP</name>
              <description>
              UIF status bit remapping
              0: No remapping. UIF status bit is not copied to CNT register bit 31
              1: Remapping enabled. UIF status bit is copied to CNT register bit 31.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>ARPE</name>
              <description>
              Auto-reload preload enable
              0: ARR register is not buffered
              1: ARR register is buffered
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CMS</name>
              <description>
              Center-aligned mode selection
              00: Edge-aligned mode. The counter counts up or down depending on the direction bit (DIR).
              01: Center-aligned mode 1. The counter counts up and down alternatively. Output compare interrupt flags of channels configured in output (CCxS=00 in CCMRx register) are set only when the counter is counting down.
              10: Center-aligned mode 2. The counter counts up and down alternatively. Output compare interrupt flags of channels configured in output (CCxS=00 in CCMRx register) are set only when the counter is counting up.
              11: Center-aligned mode 3. The counter counts up and down alternatively. Output compare interrupt flags of channels configured in output (CCxS=00 in CCMRx register) are set both when the counter is counting up or down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>DIR</name>
              <description>
              Direction
              0: Counter used as upcounter
              1: Counter used as downcounter
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OPM</name>
              <description>
              One-pulse mode
              0: Counter is not stopped at update event
              1: Counter stops counting at the next update event (clearing the bit CEN)
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>URS</name>
              <description>
              Update request source
              This bit is set and cleared by software to select the UEV event sources.
              0: Any of the following events generate an update interrupt or DMA request if enabled. 
              These events can be: 
               Counter overflow/underflow
               Setting the UG bit
               Update generation through the slave mode controller
              1: Only counter overflow/underflow generates an update interrupt or DMA request if enabled.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UDIS</name>
              <description>
              Update disable
              This bit is set and cleared by software to enable/disable UEV event generation.
              0: UEV enabled. The Update (UEV) event is generated by one of the following events:
               Counter overflow/underflow
               Setting the UG bit
               Update generation through the slave mode controller
              Buffered registers are then loaded with their preload values.
              1: UEV disabled. The Update event is not generated, shadow registers keep their value (ARR, PSC, CCRx). However the counter and the prescaler are reinitialized if the UG bit is set or if a hardware reset is received from the slave mode controller.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CEN</name>
              <description>
              Counter enable
              0: Counter disabled
              1: Counter enabled
              External clock, gated mode and encoder mode can work only if the CEN bit has been previously set by software. However trigger mode can set the CEN bit automatically by hardware. CEN is cleared automatically in one-pulse mode, when an update event occurs.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CR2</name>
          <displayName>CR2</displayName>
          <description>TIM control register 2</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>13</bitWidth>
            </field>
            <field>
              <name>OIS6</name>
              <description>
              Output Idle state 6 (OC6 output)
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OIS5</name>
              <description>
              Output Idle state 5 (OC5 output)
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OIS4</name>
              <description>
              Output Idle state 4 (OC4 output)
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OIS3N</name>
              <description>
              Output Idle state 3 (OC3N output)
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OIS3</name>
              <description>
              Output Idle state 3 (OC3 output)
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OIS2N</name>
              <description>
              Output Idle state 2 (OC2N output)
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OIS2</name>
              <description>
              Output Idle state 2 (OC2 output)
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OIS1N</name>
              <description>
              Output Idle state 1 (OC1N output)
              0: OC1N=0 after a dead-time when MOE=0
              1: OC1N=1 after a dead-time when MOE=0
              This bit, as well as other OISxN, can not be modified as long as LOCK level 1, 2 or 3 has been programmed
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OIS1</name>
              <description>
              Output Idle state 1 (OC1 output)
              0: OC1=0 (after a dead-time if OC1N is implemented) when MOE=0
              1: OC1=1 (after a dead-time if OC1N is implemented) when MOE=0
              This bit, as well as other OISx, can not be modified as long as LOCK level 1, 2 or 3 has been programmed
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TI1S</name>
              <description>
              TI1 selection
              0: The CH1 pin is connected to TI1 input
              1: The CH1, CH2 and CH3 pins are connected to the TI1 input (XOR combination) 
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MMS</name>
              <description>
              Master mode selection
              These bits allow to select the information to be sent in master mode to slave timers for synchronization (TRGO). The combination is as follows:
              000: Reset - the UG bit from the EGR register is used as trigger output (TRGO). If the reset is generated by the trigger input (slave mode controller configured in reset mode) then the signal on TRGO is delayed compared to the actual reset.
              001: Enable - the Counter enable signal, CNT_EN, is used as trigger output (TRGO). It is useful to start several timers at the same time or to control a window in which a slave timer is enabled. The Counter Enable signal is generated by a logic OR between CEN control bit and the trigger input when configured in gated mode. 
              When the Counter Enable signal is controlled by the trigger input, there is a delay on TRGO, except if the master/slave mode is selected.
              010: Update - The update event is selected as trigger output (TRGO). For instance a master timer can then be used as a prescaler for a slave timer.
              011: Compare Pulse - The trigger output send a positive pulse when the CC1IF flag is to be set (even if it was already high), as soon as a capture or a compare match occurred. (TRGO)
              100: Compare - OC1REFC signal is used as trigger output (TRGO)
              101: Compare - OC2REFC signal is used as trigger output (TRGO)
              110: Compare - OC3REFC signal is used as trigger output (TRGO)
              111: Compare - OC4REFC signal is used as trigger output (TRGO)
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>CCDS</name>
              <description>
              Capture/compare DMA selection
              0: CCx DMA request sent when CCx event occurs
              1: CCx DMA requests sent when update event occurs
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CCUS</name>
              <description>
              Capture/compare control update selection
              0: When capture/compare control bits are preloaded (CCPC=1), they are updated by setting the COMG bit only
              1: When capture/compare control bits are preloaded (CCPC=1), they are updated by setting the COMG bit or when an edge occurs on TRGI after Trigger selection
              This bit acts only on channels that have a complementary output.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CCPC</name>
              <description>
              Capture/compare preloaded control
              0: CCxE, CCxNE and OCxM bits are not preloaded
              1: CCxE, CCxNE and OCxM bits are preloaded, after having been written, they are updated only when a commutation event (COM) occurs (COMG bit set or edge detected on TRGI after Trigger selection, depending on the CCUS bit).
              This bit acts only on channels that have a complementary output.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SMCR</name>
          <displayName>SMCR</displayName>
          <description>TIM slave mode control register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
            <field>
              <name>SMS</name>
              <description>
              Slave mode selection
              When external signals are selected the active edge of the trigger signal (TRGI) is linked to the polarity selected on the external input.
              0000: Slave mode disabled.
              0001: Encoder mode 1 - Counter counts up/down on TI1FP1 edge depending on TI2FP2 level.
              0010: Encoder mode 2 - Counter counts up/down on TI2FP2 edge depending on TI1FP1 level.
              0011: Encoder mode 3 - Counter counts up/down on both TI1FP1 and TI2FP2 edges depending on the level of the other input.
              0100: Reset Mode - Rising edge of the selected trigger input (TRGI) reinitializes the counter and generates an update of the registers.
              0101: Gated Mode - The counter clock is enabled when the trigger input (TRGI) is high. The counter stops (but is not reset) as soon as the trigger becomes low. Both start and stop of the counter are controlled.
              0110: Trigger Mode - The counter starts at a rising edge of the trigger TRGI (but it is not reset). Only the start of the counter is controlled.
              0111: External Clock Mode 1 - Rising edges of the selected trigger (TRGI) clock the counter.
              1000: Combined reset + trigger mode - Rising edge of the selected trigger input (TRGI) reinitializes the counter, generates an update of the registers and starts the counter.
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>ETP</name>
              <description>
              External trigger polarity
              This bit selects whether ETR or ETR is used for trigger operations 
              0: ETR is non-inverted, active at high level or rising edge
              1: ETR is inverted, active at low level or falling edge
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ECE</name>
              <description>
              External clock enable
              This bit enables External clock mode 2.
              0: External clock mode 2 disabled
              1: External clock mode 2 enabled. The counter is clocked by any active edge on the ETRF signal.
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ETPS</name>
              <description>
              External trigger prescaler
              External trigger signal ETRP frequency must be at most 1/4 of CK_INT frequency. A prescaler can be enabled to reduce ETRP frequency. It is useful when inputting fast external clocks.
              00: Prescaler OFF
              01: ETRP frequency divided by 2
              10: ETRP frequency divided by 4
              11: ETRP frequency divided by 8
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>ETF</name>
              <description>
              External trigger filter
              This bit-field then defines the frequency used to sample ETRP signal and the length of the digital filter applied to ETRP. The digital filter is made of an event counter in which N 
              consecutive events are needed to validate a transition on the output:
              0000: No filter, sampling is done at fCLK
              0001:   fSAMPLING=fCLK, N=2
              0010:   fSAMPLING=fCLK, N=4
              0011:   fSAMPLING=fCLK, N=8
              0100:   fSAMPLING=fCLK/2, N=6
              0101:   fSAMPLING=fCLK/2, N=8
              0110:   fSAMPLING=fCLK/4, N=6
              0111:   fSAMPLING=fCLK/4, N=8
              1000:   fSAMPLING=fCLK/8, N=6
              1001:   fSAMPLING=fCLK/8, N=8
              1010:   fSAMPLING=fCLK/16, N=5
              1011:   fSAMPLING=fCLK/16, N=6
              1100:   fSAMPLING=fCLK/16, N=8
              1101:   fSAMPLING=fCLK/32, N=5
              1110:   fSAMPLING=fCLK/32, N=6
              1111:   fSAMPLING=fCLK/32, N=8
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>MSM</name>
              <description>
              Master/Slave mode
              0: No action
              1: The effect of an event on the trigger input (TRGI) is delayed to allow a perfect synchronization between the current timer and its slaves (through TRGO). It is useful if we want to synchronize several timers on a single external event.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TS</name>
              <description>
              Trigger selection
              This bit-field selects the trigger input to be used to synchronize the counter.
              000: Internal Trigger 0 (ITR0)
              001: Internal Trigger 1 (ITR1) 
              010: Internal Trigger 2 (ITR2)
              011: Internal Trigger 3 (ITR3)
              100: TI1 Edge Detector (TI1F_ED)
              101: Filtered Timer Input 1 (TI1FP1)
              110: Filtered Timer Input 2 (TI2FP2)
              111: External Trigger input (ETRF)
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DIER</name>
          <displayName>DIER</displayName>
          <description>TIM DMA/Interrupt enable register</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>14</bitWidth>
            </field>
            <field>
              <name>CC6IE</name>
              <description>
              Capture/Compare 6 interrupt enable
              0: CC6 interrupt disabled.
              1: CC6 interrupt enabled
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC5IE</name>
              <description>
              Capture/Compare 5 interrupt enable
              0: CC5 interrupt disabled.
              1: CC5 interrupt enabled
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TDE</name>
              <description>
              Trigger DMA request enable
              0: Trigger DMA request disabled.
              1: Trigger DMA request enabled.
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>COMDE</name>
              <description>
              COM DMA request enable
              0: COM DMA request disabled
              1: COM DMA request enabled
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC4DE</name>
              <description>
              Capture/Compare 4 DMA request enable
              0: CC4 DMA request disabled.
              1: CC4 DMA request enabled
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC3DE</name>
              <description>
              Capture/Compare 3 DMA request enable
              0: CC3 DMA request disabled.
              1: CC3 DMA request enabled.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC2DE</name>
              <description>
              Capture/Compare 2 DMA request enable
              0: CC2 DMA request disabled.
              1: CC2 DMA request enabled.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC1DE</name>
              <description>
              Capture/Compare 1 DMA request enable
              0: CC1 DMA request disabled.
              1: CC1 DMA request enabled.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UDE</name>
              <description>
              Update DMA request enable
              0: Update DMA request disabled.
              1: Update DMA request enabled
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BIE</name>
              <description>
              Break interrupt enable
              0: Break interrupt disabled
              1: Break interrupt enabled
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TIE</name>
              <description>
              Trigger interrupt enable
              0: Trigger interrupt disabled.
              1: Trigger interrupt enabled
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>COMIE</name>
              <description>
              COM interrupt enable
              0: COM interrupt disabled
              1: COM interrupt enabled
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC4IE</name>
              <description>
              Capture/Compare 4 interrupt enable
              0: CC4 interrupt disabled.
              1: CC4 interrupt enabled
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC3IE</name>
              <description>
              Capture/Compare 3 interrupt enable
              0: CC3 interrupt disabled.
              1: CC3 interrupt enabled
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC2IE</name>
              <description>
              Capture/Compare 2 interrupt enable
              0: CC2 interrupt disabled.
              1: CC2 interrupt enabled.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC1IE</name>
              <description>
              Capture/Compare 1 interrupt enable
              0: CC1 interrupt disabled.
              1: CC1 interrupt enabled
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UIE</name>
              <description>
              Update interrupt enable
              0: Update interrupt disabled.
              1: Update interrupt enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SR</name>
          <displayName>SR</displayName>
          <description>TIM status register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>14</bitWidth>
            </field>
            <field>
              <name>CC6IF</name>
              <description>
              Compare 6 interrupt flag
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC5IF</name>
              <description>
              Compare 5 interrupt flag
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SBIF</name>
              <description>
              System Break interrupt flag
              This flag is set by hardware as soon as the system break input goes active. It can be cleared by software if the system break input is not active.
              This flag must be reset to re-start PWM operation.
              0: No break event occurred.
              1: An active level has been detected on the system break input. An interrupt is generated if BIE=1 in the DIER register.
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC4OF</name>
              <description>
              Capture/Compare 4 overcapture flag
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC3OF</name>
              <description>
              Capture/Compare 3 overcapture flag
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC2OF</name>
              <description>
              Capture/Compare 2 overcapture flag
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC1OF</name>
              <description>
              Capture/Compare 1 overcapture flag
              This flag is set by hardware only when the corresponding channel is configured in input capture mode. It is cleared by software by writing it to 0.
              0: No overcapture has been detected.
              1: The counter value has been captured in CCR1 register while CC1IF flag was already set
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>B2IF</name>
              <description>
              Break 2 interrupt flag
              This flag is set by hardware as soon as the break 2 input goes active. It can be cleared by software if the break 2 input is not active.
              0: No break event occurred.
              1: An active level has been detected on the break 2 input. An interrupt is generated if BIE=1 in the DIER register.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BIF</name>
              <description>
              Break interrupt flag
              This flag is set by hardware as soon as the break input goes active. It can be cleared by software if the break input is not active.
              0: No break event occurred.
              1: An active level has been detected on the break input. An interrupt is generated if BIE=1 in the DIER register.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TIF</name>
              <description>
              Trigger interrupt flag
              This flag is set by hardware on trigger event. It is set when the counter starts or stops when gated mode is selected. It is cleared by software.
              0: No trigger event occurred.
              1: Trigger interrupt pending.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>COMIF</name>
              <description>
              COM interrupt flag
              This flag is set by hardware on COM event (when Capture/compare Control bits - CCxE, CCxNE, OCxM - have been updated). It is cleared by software.
              0: No COM event occurred.
              1: COM interrupt pending.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC4IF</name>
              <description>
              Capture/Compare 4 interrupt flag
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC3IF</name>
              <description>
              Capture/Compare 3 interrupt flag
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC2IF</name>
              <description>
              Capture/Compare 2 interrupt flag
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC1IF</name>
              <description>
              Capture/Compare 1 interrupt flag
              If channel CC1 is configured as output: This flag is set by hardware when the counter matches the compare value and in retriggerable one pulse mode. It is cleared by software.
              0: No match.
              1: The content of the counter CNT has matched the content of the CCR1 register.
              If channel CC1 is configured as input: This bit is set by hardware on a capture. It is cleared by software or by reading the CCR1 register.
              0: No input capture occurred.
              1: The counter value has been captured in CCR1 register.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UIF</name>
              <description>
              Update interrupt flag
              This bit is set by hardware on an update event. It is cleared by software.
              0: No update occurred
              1: Update interrupt pending. This bit is set by hardware when the registers are updated:
              - At overflow or underflow regarding the repetition counter value (update if repetition counter = 0)  and if UDIS=0 in the CR1 register.
              - When CNT is reinitialized by software using the UG bit in EGR register, if URS=0 and UDIS=0 in the CR1 register.
              - When CNT is reinitialized by a trigger event, if URS=0 and UDIS=0 in the CR1 register.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>EGR</name>
          <displayName>EGR</displayName>
          <description>Event generation register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>B2G</name>
              <description>
              Break 2 generation
              This bit is set by software in order to generate an event, it is automatically cleared by hardware.
              0: No action
              1: A break 2 event is generated. MOE bit is cleared and B2IF flag is set. Related interrupt can occur if enabled.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BG</name>
              <description>
              Break generation
              This bit is set by software in order to generate an event, it is automatically cleared by hardware.
              0: No action
              1: A break event is generated. MOE bit is cleared and BIF flag is set. Related interrupt or DMA transfer can occur if enabled.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TG</name>
              <description>
              Trigger generation
              This bit is set by software in order to generate an event, it is automatically cleared by hardware.
              0: No action
              1: The TIF flag is set in SR register. Related interrupt or DMA transfer can occur if enabled.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>COMG</name>
              <description>
              Capture/Compare control update generation
              This bit can be set by software, it is automatically cleared by hardware
              0: No action
              1: When CCPC bit is set, it allows to update CCxE, CCxNE and OCxM bits
              This bit acts only on channels having a complementary output.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC4G</name>
              <description>
              Capture/compare 4 generation
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC3G</name>
              <description>
              Capture/compare 3 generation
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC2G</name>
              <description>
              Capture/compare 2 generation
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC1G</name>
              <description>
              Capture/compare 1 generation
              This bit is set by software in order to generate an event, it is automatically cleared by hardware.
              0: No action
              1: A capture/compare event is generated on channel 1:
              If channel CC1 is configured as output:
              CC1IF flag is set, Corresponding interrupt or DMA request is sent if enabled.
              If channel CC1 is configured as input:
              The current value of the counter is captured in CCR1 register. The CC1IF flag is set, the corresponding interrupt or DMA request is sent if enabled. The CC1OF flag is set if the CC1IF flag was already high.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UG</name>
              <description>
              Update generation
              This bit can be set by software, it is automatically cleared by hardware.
              0: No action
              1: Re-initialize the counter and generates an update of the registers. The prescaler counter is cleared too (anyway the prescaler ratio is not affected). The counter is cleared if the center-aligned mode is selected or if DIR=0 (upcounting), else it takes the auto-reload value (ARR) if DIR=1 (downcounting).
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCMR1</name>
          <displayName>CCMR1</displayName>
          <description>TIM capture/compare mode register 1</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>OC2M</name>
              <description>
              Output compare 2 mode
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>OC2PE</name>
              <description>
              Output compare 2 preload enable
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>OC2CE</name>
              <description>
              Output compare 2 clear enable
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OC1M</name>
              <description>
              Output compare 1 mode
              These bits define the behavior of the output reference signal OC1REF from which OC1 and OC1N are derived. OC1REF is active high whereas OC1 and OC1N active level depends on CC1P and CC1NP bits.
              0000: Frozen - The comparison between the output compare register CCR1 and the counter CNT has no effect on the outputs.
              0001: Set channel 1 to active level on match. OC1REF signal is forced high when the counter CNT matches the capture/compare register 1 (CCR1).
              0010: Set channel 1 to inactive level on match. OC1REF signal is forced low when the counter CNT matches the capture/compare register 1 (CCR1).
              0011: Toggle - OC1REF toggles when CNT=CCR1.
              0100: Force inactive level - OC1REF is forced low.
              0101: Force active level - OC1REF is forced high.
              0110: PWM mode 1 - In upcounting, channel 1 is active as long as CNT&lt;CCR1 else inactive. In downcounting, channel 1 is inactive (OC1REF=0) as long as CNT>CCR1 else active (OC1REF=1).
              0111: PWM mode 2 - In upcounting, channel 1 is inactive as long as CNT&lt;CCR1 else active. In downcounting, channel 1 is active as long as CNT>CCR1 else inactive.
              1000: Retriggerable OPM mode 1 - In up-counting mode, the channel is active until a trigger event is detected (on TRGI signal). Then, a comparison is performed as in PWM mode 1 and the channels becomes inactive again at the next update. In down-counting mode, the channel is inactive until a trigger event is detected (on TRGI signal). Then, a comparison is performed as in PWM mode 1 and the channels becomes inactive again at the next update.
              1001: Retriggerable OPM mode 2 - In up-counting mode, the channel is inactive until a trigger event is detected (on TRGI signal). Then, a comparison is performed as in PWM mode 2 and the channels becomes inactive again at the next update. In down-counting mode, the channel is active until a trigger event is detected (on TRGI signal). Then, a comparison is performed as in PWM mode 1 and the channels becomes active again at the next update.
              1010: Reserved,
              1011: Reserved,
              1100: Combined PWM mode 1 - OC1REF has the same behavior as in PWM mode 1. OC1REFC is the logical OR between OC1REF and OC2REF.
              1101: Combined PWM mode 2 - OC1REF has the same behavior as in PWM mode 2. OC1REFC is the logical AND between OC1REF and OC2REF.
              1110: Asymmetric PWM mode 1 - OC1REF has the same behavior as in PWM mode 1. OC1REFC outputs OC1REF when the counter is counting up, OC2REF when it is counting down.
              1111: Asymmetric PWM mode 2 - OC1REF has the same behavior as in PWM mode 2. OC1REFC outputs OC1REF when the counter is counting up, OC2REF when it is counting down.
              These bits can not be modified as long as LOCK level 3 has been programmed and CC1S=00 (the channel is configured in output).
              On channels having a complementary output, this bit field is preloaded. If the CCPC bit is set in the CR2 register then the OC1M active bits take the new value from the preloaded bits only when a COM event is generated.
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>OC1PE</name>
              <description>
              Output compare 1 preload enable
              0: Preload register on CCR1 disabled. CCR1 can be written at anytime, the new value is taken in account immediately.
              1: Preload register on CCR1 enabled. Read/Write operations access the preload register. CCR1 preload value is loaded in the active register at each update event.
              These bits can not be modified as long as LOCK level 3 has been programmed and CC1S=00 (the channel is configured in output).
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>OC1CE</name>
              <description>
              Output compare 1 clear enable
              0: OC1Ref is not affected by the ETRF input
              1: OC1Ref is cleared as soon as a High level is detected on ETRF input
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IC2F</name>
              <description>
              Input capture 2 filter
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>IC2PSC</name>
              <description>
              Input capture 2 prescaler
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>CC2S</name>
              <description>
              Capture/Compare 2 selection
              This bit-field defines the direction of the channel (input/output) as well as the used input. 
              00: CC2 channel is configured as output
              01: CC2 channel is configured as input, IC2 is mapped on TI2
              10: CC2 channel is configured as input, IC2 is mapped on TI1
              11: CC2 channel is configured as input, IC2 is mapped on TRC. This mode is working only if an internal trigger input is selected through the TS bit (SMCR register)
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>IC1F</name>
              <description>
              Input capture 1 filter
              This bit-field defines the frequency used to sample TI1 input and the length of the digital filter applied to TI1. The digital filter is made of an event counter in which N consecutive events are needed to validate a transition on the output:
              0000: No filter, sampling is done at fCLK
              0001: fSAMPLING=fCLK, N=2
              0010: fSAMPLING=fCLK, N=4
              0011: fSAMPLING=fCLK, N=8
              0100: fSAMPLING=fCLK/2, N=6
              0101: fSAMPLING=fCLK/2, N=8
              0110: fSAMPLING=fCLK/4, N=6
              0111: fSAMPLING=fCLK/4, N=8
              1000: fSAMPLING=fCLK/8, N=6
              1001: fSAMPLING=fCLK/8, N=8
              1010: fSAMPLING=fCLK/16, N=5
              1011: fSAMPLING=fCLK/16, N=6
              1100: fSAMPLING=fCLK/16, N=8
              1101: fSAMPLING=fCLK/32, N=5
              1110: fSAMPLING=fCLK/32, N=6
              1111: fSAMPLING=fCLK/32, N=8
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>IC1PSC</name>
              <description>
              Input capture 1 prescaler
              This bit-field defines the ratio of the prescaler acting on CC1 input (IC1). The prescaler is reset as soon as CC1E=0 (CCER register).
              00: no prescaler, capture is done each time an edge is detected on the capture input
              01: capture is done once every 2 events
              10: capture is done once every 4 events
              11: capture is done once every 8 events
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>CC1S</name>
              <description>
              Capture/Compare 1 selection
              This bit-field defines the direction of the channel (input/output) as well as the used input. 
              00: CC1 channel is configured as output
              01: CC1 channel is configured as input, IC1 is mapped on TI1
              10: CC1 channel is configured as input, IC1 is mapped on TI2
              11: CC1 channel is configured as input, IC1 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (SMCR register)
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCMR2</name>
          <displayName>CCMR2</displayName>
          <description>TIM capture/compare mode register 2</description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>OC4M</name>
              <description>
              Output compare 4 mode
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>OC4PE</name>
              <description>
              Output compare 4 preload enable
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>OC4CE</name>
              <description>
              Output compare 4 clear enable
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OC3M</name>
              <description>
              Output compare 3 mode
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>OC3PE</name>
              <description>
              Output compare 3 preload enable
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>OC3CE</name>
              <description>
              Output compare 3 clear enable
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IC4F</name>
              <description>
              Input capture 4 filter
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>IC4PSC</name>
              <description>
              Input capture 4 prescaler
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>CC4S</name>
              <description>
              Capture/Compare 4 selection
              This bit-field defines the direction of the channel (input/output) as well as the used input. 
              00: CC4 channel is configured as output
              01: CC4 channel is configured as input, IC4 is mapped on TI4
              10: CC4 channel is configured as input, IC4 is mapped on TI3
              11: CC4 channel is configured as input, IC4 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (SMCR register)
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>IC3F</name>
              <description>
              Input capture 3 filter
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>IC3PSC</name>
              <description>
              Input capture 3 prescaler
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>CC3S</name>
              <description>
              Capture/Compare 3 selection
              This bit-field defines the direction of the channel (input/output) as well as the used input. 
              00: CC3 channel is configured as output
              01: CC3 channel is configured as input, IC3 is mapped on TI3
              10: CC3 channel is configured as input, IC3 is mapped on TI4
              11: CC3 channel is configured as input, IC3 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (SMCR register)
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCER</name>
          <displayName>CCER</displayName>
          <description>Capture/Compare enable register</description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
            <field>
              <name>CC6P</name>
              <description>
              Capture/Compare 6 output Polarity.
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC6E</name>
              <description>
              Capture/Compare 6 output enable.
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC5P</name>
              <description>
              Capture/Compare 5 output Polarity.
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC5E</name>
              <description>
              Capture/Compare 5 output enable.
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC4NP</name>
              <description>
              Capture/Compare 4 complementary output polarity
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC4P</name>
              <description>
              Capture/Compare 4 output Polarity.
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC4E</name>
              <description>
              Capture/Compare 4 output enable.
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC3NP</name>
              <description>
              Capture/Compare 3 complementary output polarity
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC3NE</name>
              <description>
              Capture/Compare 3 complementary output enable
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC3P</name>
              <description>
              Capture/Compare 3 output Polarity.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC3E</name>
              <description>
              Capture/Compare 3 output enable.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC2NP</name>
              <description>
              Capture/Compare 2 complementary output polarity
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC2NE</name>
              <description>
              Capture/Compare 2 complementary output enable
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC2P</name>
              <description>
              Capture/Compare 2 output Polarity.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC2E</name>
              <description>
              Capture/Compare 2 output enable.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC1NP</name>
              <description>
              Capture/Compare 1 complementary output polarity
              CC1 channel configured as output:
              0: OC1N active high.
              1: OC1N active low.
              CC1 channel configured as input:
              This bit is used in conjunction with CC1P to define the polarity of TI1FP1 and TI2FP1. Refer to CC1P description.
              On channels having a complementary output, this bit is preloaded. If the CCPC bit is set in the CR2 register then the CC1NP active bit takes the new value from the preloaded bit only when a Commutation event is generated.
              This bit as well as other CCxNP is not writable as soon as LOCK level 2 or 3 has been programmed and CC1S=00 (channel configured as output).
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC1NE</name>
              <description>
              Capture/Compare 1 complementary output enable
              0: Off - OC1N is not active. OC1N level is then function of MOE, OSSI, OSSR, OIS1, OIS1N and CC1E bits.
              1: On - OC1N signal is output on the corresponding output pin depending on MOE, OSSI, OSSR, OIS1, OIS1N and CC1E bits.
              On channels having a complementary output, this bit is preloaded. If the CCPC bit is set in the CR2 register then the CC1NE active bit takes the new value from the preloaded bit only when a Commutation event is generated.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC1P</name>
              <description>
              Capture/Compare 1 output Polarity.
              CC1 channel configured as output:
              0: OC1 active high
              1: OC1 active low
              CC1 channel configured as input: CC1NP/CC1P bits select TI1FP1 and TI2FP1 polarity for trigger or capture operations.
              00: noninverted/rising edge. Circuit is sensitive to TIxFP1 rising edge (capture, trigger in reset, external clock or trigger mode), TIxFP1 is not inverted (trigger in gated mode, encoder mode).
              01: inverted/falling edge. Circuit is sensitive to TIxFP1 falling edge (capture, trigger in reset, external clock or trigger mode), TIxFP1 is inverted (trigger in gated mode, encoder mode).
              10: reserved, do not use this configuration.
              11: noninverted/both edges. Circuit is sensitive to both TIxFP1 rising and falling edges (capture, trigger in reset, external clock or trigger mode), TIxFP1 is not inverted (trigger in gated mode). This configuration must not be used for encoder mode.
              On channels having a complementary output, this bit is preloaded. If the CCPC bit is set in the CR2 register then the CC1P active bit takes the new value from the preloaded bit only when a Commutation event is generated.
              This bit as well as other CCxP is not writable as soon as LOCK level 2 or 3 has been programmed.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC1E</name>
              <description>
              Capture/Compare 1 output enable
              CC1 channel configured as output:
              0: Off - OC1 is not active. OC1 level is then function of MOE, OSSI, OSSR, OIS1, OIS1N and CC1NE bits.
              1: On - OC1 signal is output on the corresponding output pin depending on MOE, OSSI, OSSR, OIS1, OIS1N and CC1NE bits.
              CC1 channel configured as input: This bit determines if a capture of the counter value can actually be done into the input capture/compare register 1 (CCR1) or not.
              0: Capture disabled.
              1: Capture enabled.
              On channels having a complementary output, this bit is preloaded. If the CCPC bit is set in the CR2 register then the CC1E active bit takes the new value from the preloaded bit only when a Commutation event is generated.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CNT</name>
          <displayName>CNT</displayName>
          <description>Counter</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>CNT</name>
              <description>
              bit 30 to 0 is the lower bits of counter value
              bit 31 depends on IUFREMAP in CR1.
              If UIFREMAP = 1 this bit is a read-only copy of the UIF bit of the ISR register
              If UIFREMAP = 0 this bit is counter value bit 31
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PSC</name>
          <displayName>PSC</displayName>
          <description>Prescaler</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>PSC</name>
              <description>
              Prescaler value
              The counter clock frequency is fCLK/(PSC+1).
              PSC contains the value to be loaded in the active prescaler register at each update event (including when the counter is cleared through UG bit of EGR register or through trigger controller when configured in reset mode).
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ARR</name>
          <displayName>ARR</displayName>
          <description>Auto-reload register</description>
          <addressOffset>0x2c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ARR</name>
              <description>
              Auto-reload value
              ARR is the value to be loaded in the actual auto-reload register.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RCR</name>
          <displayName>RCR</displayName>
          <description>Repetition counter register</description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>REP</name>
              <description>
              Repetition counter value
              These bits allow the user to set-up the update rate of the compare registers when preload registers are enable, as well as the update interrupt generation rate, if this interrupt is enable.
              Each time the REP_CNT related downcounter reaches zero, an update event is generated and it restarts counting from REP value. As REP_CNT is reloaded with REP value only at the repetition update event, any write to the RCR register is not taken in account until the next repetition update event.
              It means in PWM mode (REP+1) corresponds to the number of PWM periods in edge-aligned mode or the number of half PWM period in center-aligned mode..
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR1</name>
          <displayName>CCR1</displayName>
          <description>Capture/Compare register 1</description>
          <addressOffset>0x34</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>CCR1</name>
              <description>
              Capture/Compare 1 value
              If channel CC1 is configured as output:
              CCR1 is the value to be loaded in the actual capture/compare 1 register (preload value).It is loaded permanently if the preload feature is not selected in the CCMR1 register (bit OC1PE). Else the preload value is copied in the active capture/compare 1 register when an update event occurs.
              The active capture/compare register contains the value to be compared to the counter CNT and signaled on OC1 output.
              If channel CC1is configured as input:
              CCR1 is the counter value transferred by the last input capture 1 event (IC1).
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR2</name>
          <displayName>CCR2</displayName>
          <description>Capture/Compare register 2</description>
          <addressOffset>0x38</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>CCR2</name>
              <description>
              Capture/Compare 2 value
              If channel CC2 is configured as output:
              CCR2 is the value to be loaded in the actual capture/compare 2 register (preload value).It is loaded permanently if the preload feature is not selected in the CCMR1 register (bit OC2PE). Else the preload value is copied in the active capture/compare 2 register when an update event occurs.
              The active capture/compare register contains the value to be compared to the counter CNT and signalled on OC2 output.
              If channel CC2 is configured as input:
              CCR2 is the counter value transferred by the last input capture 2 event (IC2).
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR3</name>
          <displayName>CCR3</displayName>
          <description>Capture/Compare register 3</description>
          <addressOffset>0x3c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>CCR3</name>
              <description>
              Capture/Compare value
              If channel CC3 is configured as output:
              CCR3 is the value to be loaded in the actual capture/compare 3 register (preload value).It is loaded permanently if the preload feature is not selected in the CCMR2 register (bit OC3PE). Else the preload value is copied in the active capture/compare 3 register when an update event occurs.
              The active capture/compare register contains the value to be compared to the counter CNT and signalled on OC3 output.
              If channel CC3is configured as input:
              CCR3 is the counter value transferred by the last input capture 3 event (IC3).
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR4</name>
          <displayName>CCR4</displayName>
          <description>Capture/Compare register 4</description>
          <addressOffset>0x40</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>CCR4</name>
              <description>
              Capture/Compare value
              1. if CC4 channel is configured as output (CC4S bits):
              CCR4 is the value to be loaded in the actual capture/compare 4 register (preload value).It is loaded permanently if the preload feature is not selected in the CCMR2 register (bit OC4PE). Else the preload value is copied in the active capture/compare 4 register when an update event occurs.
              The active capture/compare register contains the value to be compared to the counter CNT and signalled on OC4 output.
              2.  if CC4 channel is configured as input (CC4S bits in CCMR4 register):
              CCR4 is the counter value transferred by the last input capture 4 event (IC4).
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BDTR</name>
          <displayName>BDTR</displayName>
          <description>TIM break and dead-time register</description>
          <addressOffset>0x44</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>OSSR</name>
              <description>
              Off-state selection for Run mode
              This bit is used when MOE=1 on channels having a complementary output which are configured as outputs. OSSR is not implemented if no complementary output is implemented in the timer.
              0: When inactive, OC/OCN outputs are disabled (the timer releases the output control, forces a Hi-Z state).
              1: When inactive, OC/OCN outputs are enabled with their inactive level as soon as CCxE=1 or CCxNE=1 (the output is still controlled by the timer).
              This bit can not be modified as soon as the LOCK level 2 has been programmed.
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OSSI</name>
              <description>
              Off-state selection for Idle mode
              This bit is used when MOE=0 due to a break event or by a software write, on channels configured as outputs.
              0: When inactive, OC/OCN outputs are disabled (the timer releases the output control, imposes a Hi-Z state). 
              1: When inactive, OC/OCN outputs are first forced with their inactive level then forced to their idle level after the deadtime. The timer maintains its control over the output.
              This bit can not be modified as soon as the LOCK level 2 has been programmed.
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BK2BID</name>
              <description>
              Break2 bidirectional
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BKBID</name>
              <description>
              Break Bidirectional
              0: Break input BRK in input mode
              1: Break input BRK in bidirectional mode
              In the bidirectional mode (BKBID bit set to 1), the break input is configured both in input mode and in open drain output mode. Any active break event asserts a low logic level on the Break input to indicate an internal break event to external devices.
              This bit cannot be modified as long as LOCK level 1 has been programmed (LOCK bits in BDTR register).
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BK2DSRM</name>
              <description>
              Break2 Disarm
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BKDSRM</name>
              <description>
              Break Disarm
              0: Break input BRK is armed
              1: Break input BRK is disarmed
              This bit is cleared by hardware when no break source is active.
              The BKDSRM bit must be set by software to release the bidirectional output control (open-drain output in Hi-Z state) and then be polled it until it is reset by hardware, indicating that the fault condition has disappeared.
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BK2P</name>
              <description>
              BK2P: Break 2 polarity
              0: Break input BRK2 is active low
              1: Break input BRK2 is active high
              This bit cannot be modified as long as LOCK level 1 has been programmed.
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BK2E</name>
              <description>
              Break 2 enable
              This bit enables the complete break 2 protection.
              0: Break2 function disabled
              1: Break2 function enabled
              This bit cannot be modified as long as LOCK level 1 has been programmed.
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BK2F</name>
              <description>
              Break 2 filter
              This bit-field defines the frequency used to sample BRK2 input and the length of the digital filter applied to BRK2. The digital filter is made of an event counter in which N consecutive events are needed to validate a transition on the output:
              0000: No filter, BRK2 acts asynchronously
              0001: fSAMPLING=fCLK, N=2
              0010: fSAMPLING=fCLK, N=4
              0011: fSAMPLING=fCLK, N=8
              0100: fSAMPLING=fCLK/2, N=6
              0101: fSAMPLING=fCLK/2, N=8
              0110: fSAMPLING=fCLK/4, N=6
              0111: fSAMPLING=fCLK/4, N=8
              1000: fSAMPLING=fCLK/8, N=6
              1001: fSAMPLING=fCLK/8, N=8
              1010: fSAMPLING=fCLK/16, N=5
              1011: fSAMPLING=fCLK/16, N=6
              1100: fSAMPLING=fCLK/16, N=8
              1101: fSAMPLING=fCLK/32, N=5
              1110: fSAMPLING=fCLK/32, N=6
              1111: fSAMPLING=fCLK/32, N=8
              This bit cannot be modified as long as LOCK level 1 has been programmed.
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>BKF</name>
              <description>
              Break filter
              This bit-field defines the frequency used to sample BRK input and the length of the digital filter applied to BRK. The digital filter is made of an event counter in which N consecutive events are needed to validate a transition on the output:
              0000: No filter, BRK acts asynchronously
              0001: fSAMPLING=fCLK, N=2
              0010: fSAMPLING=fCLK, N=4
              0011: fSAMPLING=fCLK, N=8
              0100: fSAMPLING=fCLK/2, N=6
              0101: fSAMPLING=fCLK/2, N=8
              0110: fSAMPLING=fCLK/4, N=6
              0111: fSAMPLING=fCLK/4, N=8
              1000: fSAMPLING=fCLK/8, N=6
              1001: fSAMPLING=fCLK/8, N=8
              1010: fSAMPLING=fCLK/16, N=5
              1011: fSAMPLING=fCLK/16, N=6
              1100: fSAMPLING=fCLK/16, N=8
              1101: fSAMPLING=fCLK/32, N=5
              1110: fSAMPLING=fCLK/32, N=6
              1111: fSAMPLING=fCLK/32, N=8
              This bit cannot be modified as long as LOCK level 1 has been programmed.
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>MOE</name>
              <description>
              Main output enable
              This bit is cleared asynchronously by hardware as soon as one of the break inputs is active (BRK or BRK2). It is set by software or automatically depending on the AOE bit. It is acting only on the channels which are configured in output. 
              0: In response to a break 2 event. OC and OCN outputs are disabled
              In response to a break event or if MOE is written to 0: OC and OCN outputs are disabled or forced to idle state depending on the OSSI bit.
              1: OC and OCN outputs are enabled if their respective enable bits are set (CCxE, CCxNE in CCER register).
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>AOE</name>
              <description>
              Automatic output enable
              0: MOE can be set only by software
              1: MOE can be set by software or automatically at the next update event (if none of the break inputs BRK and BRK2 is active)
              This bit cannot be modified as long as LOCK level 1 has been programmed.
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BKP</name>
              <description>
              Break polarity
              0: Break input BRK is active low
              1: Break input BRK is active high
              This bit cannot be modified as long as LOCK level 1 has been programmed.
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BKE</name>
              <description>
              Break enable
              This bit enables the complete break protection.
              0: Break function disabled
              1: Break function enabled
              This bit cannot be modified as long as LOCK level 1 has been programmed.
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DTPSC</name>
              <description>
              Dead-time prescaler
              This bit-field enables dead-time prescaler. 
              0: dead-time is tCLK*(DTG+1) if DTG is not zero
              1: dead-time is tCLK*(DTG+1)*16 if DTG is not zero
              This bit cannot be modified as long as LOCK level 1 has been programmed.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DTG</name>
              <description>
              Dead-time generator setup
              This bit-field, together with DTPSC, defines the duration of the dead-time inserted between the complementary outputs.
              If DTG=0, dead-time is disabled. 
              Example if tCLK=8.33ns (120MHz), dead-time possible values are:
              16.67ns to 8533.33 ns by 8.33 ns steps if DTPSC=0,
              266.67ns to 136.53 us by 133.33 ns steps if DTPSC=1
              This bit cannot be modified as long as LOCK level 1 has been programmed.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD1</name>
          <displayName>RSVD1</displayName>
          <description></description>
          <addressOffset>0x48</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>CCMR3</name>
          <displayName>CCMR3</displayName>
          <description>TIM capture/compare mode register 3</description>
          <addressOffset>0x54</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>OC6M</name>
              <description>
              Output compare 6 mode
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>OC6PE</name>
              <description>
              Output compare 6 preload enable
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>OC6CE</name>
              <description>
              Output compare 6 clear enable
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OC5M</name>
              <description>
              Output compare 5 mode
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>OC5PE</name>
              <description>
              Output compare 5 preload enable
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>OC5CE</name>
              <description>
              Output compare 5 clear enable
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GC5C3</name>
              <description>
              Group Channel 5 and Channel 3
              Distortion on Channel 3 output:
              0: No effect of OC5REF on OC3REFC
              1: OC3REFC is the logical AND of OC3REFC and OC5REF
              This bit can either have immediate effect or be preloaded and taken into account after an update event (if preload feature is selected in TIMxCCMR2).
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GC5C2</name>
              <description>
              Group Channel 5 and Channel 2
              Distortion on Channel 2 output:
              0: No effect of OC5REF on OC2REFC
              1: OC2REFC is the logical AND of OC2REFC and OC5REF
              This bit can either have immediate effect or be preloaded and taken into account after an update event (if preload feature is selected in TIMxCCMR1).
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GC5C1</name>
              <description>
              Group Channel 5 and Channel 1
              Distortion on Channel 1 output:
              0: No effect of OC5REF on OC1REFC5
              1: OC1REFC is the logical AND of OC1REFC and OC5REF
              This bit can either have immediate effect or be preloaded and taken into account after an update event (if preload feature is selected in TIMxCCMR1).
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>13</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR5</name>
          <displayName>CCR5</displayName>
          <description>Capture/Compare register 5</description>
          <addressOffset>0x58</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>CCR5</name>
              <description>
              Capture/Compare 5 value
              CCR5 is the value to be loaded in the actual capture/compare 5 register (preload value). It is loaded permanently if the preload feature is not selected in the CCMR3 register (bit OC5PE). Else the preload value is copied in the active capture/compare 5 register when an update event occurs.
              The active capture/compare register contains the value to be compared to the counter CNT and signaled on OC5 output.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR6</name>
          <displayName>CCR6</displayName>
          <description>Capture/Compare register 6</description>
          <addressOffset>0x5c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>CCR6</name>
              <description>
              Capture/Compare 6 value
              CCR6 is the value to be loaded in the actual capture/compare 6 register (preload value). It is loaded permanently if the preload feature is not selected in the CCMR3 register (bit OC6PE). Else the preload value is copied in the active capture/compare 6 register when an update event occurs.
              The active capture/compare register contains the value to be compared to the counter CNT and signaled on OC6 output.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>AF1</name>
          <displayName>AF1</displayName>
          <description>Alternate function option register</description>
          <addressOffset>0x60</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <fields>
            <field>
              <name>LOCK</name>
              <description>
              Lock configuration
              These bits offer a write protection against software errors.
              00: LOCK OFF - No bit is write protected.
              01: LOCK Level 1 = OISx and OISxN bits in CR2 register, BK2BID, BKBID, BK2DSRM, BKDSRM, BK2P, BK2E, BK2F[3:0], BKF[3:0], AOE, BKP, BKE, OSSI, OSSR, DTPSC and DTG bits in BDTR register, AF1 register and AF2 register can no longer be written.
              10: LOCK Level 2 = LOCK Level 1 + CC Polarity bits (CCxP/CCxNP bits in CCER register, as long as the related channel is configured in output through the CCxS bits) as well as OSSR and OSSI bits can no longer be written.
              11: LOCK Level 3 = LOCK Level 2 + CC Control bits (OCxM and OCxPE bits in CCMRx registers, as long as the related channel is configured in output through the CCxS bits) can no longer be written.
              The LOCK bits can be written to non-zero only once after reset. 
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>14</bitWidth>
            </field>
            <field>
              <name>ETRSEL</name>
              <description>
              ETR source selection
              00: ETR input is connected to I/O
              01: LPCOMP output1 (if LPCOMP integrated)
              10: LPCOMP output2 (if LPCOMP integrated)
              11: ETR input is connected to I/O
              This bit cannot be modified as long as LOCK level 1 has been programmed.
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>BKCMP2P</name>
              <description>
              BRK LPCOMP output2 polarity
              This bit selects the LPCOMP output2 sensitivity (if LPCOMP integrated). It must be programmed together with the BKP polarity bit.
              0: LPCOMP output2 is active high
              1: LPCOMP output2 is active low
              This bit cannot be modified as long as LOCK level 1 has been programmed.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BKCMP1P</name>
              <description>
              BRK LPCOMP output1 polarity
              This bit selects the LPCOMP output1 sensitivity (if LPCOMP integrated). It must be programmed together with the BKP polarity bit.
              0: LPCOMP output1 is active high
              1: LPCOMP output1 is active low
              This bit cannot be modified as long as LOCK level 1 has been programmed.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BKINP</name>
              <description>
              BRK BKIN input polarity
              This bit selects the BKIN input sensitivity. It must be programmed together with the BKP polarity bit.
              0: BKIN input is active high
              1: BKIN input is active low
              This bit cannot be modified as long as LOCK level 1 has been programmed.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>BKCMP2E</name>
              <description>
              BRK LPCOMP output2 enable
              This bit enables the LPCOMP output2 (if LPCOMP integrated) for the timers BRK input. LPCOMP output2 is ORed with the other BRK sources.
              0: LPCOMP output2 disabled
              1: LPCOMP output2 enabled
              This bit cannot be modified as long as LOCK level 1 has been programmed.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BKCMP1E</name>
              <description>
              BRK LPCOMP output1 enable
              This bit enables the LPCOMP output1 (if LPCOMP integrated) for the timers BRK input. LPCOMP output1 is ORed with the other BRK sources.
              0: LPCOMP output1 disabled
              1: LPCOMP output1 enabled
              This bit cannot be modified as long as LOCK level 1 has been programmed.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BKINE</name>
              <description>
              BRK BKIN input enable
              This bit enables the BKIN input. BKIN input is ORed with the other BRK sources.
              0: BKIN input disabled
              1: BKIN input enabled
              This bit cannot be modified as long as LOCK level 1 has been programmed.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>AF2</name>
          <displayName>AF2</displayName>
          <description>Alternate function option register 2</description>
          <addressOffset>0x64</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>BK2CMP2P</name>
              <description>
              BRK2 LPCOMP output2 polarity
              This bit selects the LPCOMP output2 sensitivity (if LPCOMP integrated). It must be programmed together with the BK2P polarity bit.
              0: LPCOMP output2 is active high
              1: LPCOMP output2 is active low
              This bit cannot be modified as long as LOCK level 1 has been programmed.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BK2CMP1P</name>
              <description>
              BRK2 LPCOMP output1 polarity
              This bit selects the LPCOMP output1 sensitivity (if LPCOMP integrated). It must be programmed together with the BK2P polarity bit.
              0: LPCOMP output1 is active high
              1: LPCOMP output1 is active low
              This bit cannot be modified as long as LOCK level 1 has been programmed.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BK2INP</name>
              <description>
              BRK2 BKIN2 input polarity
              This bit selects the BKIN2 input sensitivity. It must be programmed together with the BK2P polarity bit.
              0: BKIN2 input is active low
              1: BKIN2 input is active high
              This bit cannot be modified as long as LOCK level 1 has been programmed.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>BK2CMP2E</name>
              <description>
              BRK2 LPCOMP output2 enable
              This bit enables the LPCOMP output2 (if LPCOMP integrated) for the timers BRK2 input. LPCOMP output2 is ORed with the other BRK2 sources.
              0: LPCOMP output2 disabled
              1: LPCOMP output2 enabled
              This bit cannot be modified as long as LOCK level 1 has been programmed.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BK2CMP1E</name>
              <description>
              BRK2 LPCOMP output1 enable
              This bit enables the LPCOMP output1 (if LPCOMP integrated) for the timers BRK2 input. LPCOMP output1 is ORed with the other BRK2 sources.
              0: LPCOMP output1 disabled
              1: LPCOMP output1 enabled
              This bit cannot be modified as long as LOCK level 1 has been programmed.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BK2INE</name>
              <description>
              BRK2 BKIN input enable
              This bit enables the BKIN2 input. BKIN2 input is ORed with the other BRK2 sources.
              0: BKIN2 input disabled
              1: BKIN2 input enabled
              This bit cannot be modified as long as LOCK level 1 has been programmed.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>I2S1</name>
      <description></description>
      <groupName>I2S</groupName>
      <baseAddress>0x50009000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>RSVD41</name>
          <displayName>RSVD41</displayName>
          <description></description>
          <addressOffset>0x0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>TX_PCM_FORMAT</name>
          <displayName>TX_PCM_FORMAT</displayName>
          <description></description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000010</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>26</bitWidth>
            </field>
            <field>
              <name>TRACK_FLAG</name>
              <description>
              0: stereo
              1: mono
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DW</name>
              <description>
              tx source pcm data width N(N>=8)
              common value is 8,13,14,16,18,20,22,24
              This data width indicate the tx fifo output data width.
              When writing to tx fifo, please refer to following format:
              Mono 8 bit: fifo_data[31:0] = {L3,L2,L1,L0}, each word contains 4 samples, so four samples need read one word
              Stereo 8 bit: fifo_data[31:0] = { R1,L1,R0,L0 }, each word contains 2 samples, so two samples need read one word
              Mono 13/14/16 bit: fifo_data[31:0] = {L1,L0}, each word contains 2 samples, so two samples need read one word
              Stereo 13/14/16 bit: fifo_data[31:0] = {R0,L0}, each word contains 1 samples, so each sample need read one word
              Mono 18/20/22/24 bit: fifo_data[31:0] = L0, each word contains 1 samples, so each sample need read one word 
              Stereo 18/20/22/24 bit: fifo_data[31:0][0] = {L0}, fifo_data[31:0][1]={R0}, each 2 words contain 1 samples, so each sample need read two word
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD40</name>
          <displayName>RSVD40</displayName>
          <description></description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>TX_PCM_SAMPLE_CLK</name>
          <displayName>TX_PCM_SAMPLE_CLK</displayName>
          <description></description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x000000FA</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>19</bitWidth>
            </field>
            <field>
              <name>FS_DUTY</name>
              <description>
              source PCM sample clock duty cycle(with GCLK=12MHz):
              250 for 48K FS
              272 for 44.1K FS
              375 for 32K FS
              500 for 24K FS
              544 for 22.05K FS
              750 for 16K FS
              1000 for 12K FS
              1088 for 11.025K FS
              1500 for 8K FS
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>13</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD39</name>
          <displayName>RSVD39</displayName>
          <description></description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>TX_RS_SMOOTH</name>
          <displayName>TX_RS_SMOOTH</displayName>
          <description></description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>31</bitWidth>
            </field>
            <field>
              <name>EN</name>
              <description>
              0: Disable TX re-sample smooth filter
              1: Enable TX re-sample smooth filter
              This function is not implemented.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD38</name>
          <displayName>RSVD38</displayName>
          <description></description>
          <addressOffset>0x34</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>TX_PCM_CH_SEL</name>
          <displayName>TX_PCM_CH_SEL</displayName>
          <description></description>
          <addressOffset>0x40</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>28</bitWidth>
            </field>
            <field>
              <name>LEFT_CHANNEL_SEL</name>
              <description>
              TX re-sampling module setting:
              00: TX left = source left
              01: TX left = source right
              10,11: TX left = (source left + source right)/2
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RIGHT_CHANNEL_SEL</name>
              <description>
              TX re-sampling module setting:
              00: TX right = source right
              01: TX right = source left
              10,11: TX right = (source left + source right)/2
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD37</name>
          <displayName>RSVD37</displayName>
          <description></description>
          <addressOffset>0x44</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>TX_VOL_CTRL</name>
          <displayName>TX_VOL_CTRL</displayName>
          <description></description>
          <addressOffset>0x50</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0000000F</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>28</bitWidth>
            </field>
            <field>
              <name>VOL</name>
              <description>
              volume control:
              0000: +6dB,    0001: +4.5dB,
              0010: +3dB,    0011: +1.5dB,
              0100: 0dB,     0101: -1.5dB,
              0110: -3.0dB,  0111: -4.5dB,
              1000: -6.0dB,  1001: -7.5dB,
              1010: -9dB,    1011: -10.5dB,
              1100: -12dB,   1101: -13.5dB,
              1110: -15dB,   1111: mute
              Note:
              1) +1.5db = 20log(1+1/4-1/16+1/1024)
              2) -1.5dB = 20log(1-1/8-1/32-1/512-1/2048)
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD36</name>
          <displayName>RSVD36</displayName>
          <description></description>
          <addressOffset>0x54</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>TX_LR_BAL_CTRL</name>
          <displayName>TX_LR_BAL_CTRL</displayName>
          <description></description>
          <addressOffset>0x60</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>26</bitWidth>
            </field>
            <field>
              <name>EN</name>
              <description>
              LR balance enable:
              00: both left and right in full volume
              10: left channel balance volume adjustment enable
              01: right channel balance volume adjustment enable
              11: reserved, still kepp left and right in full volume
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>BAL_VOL</name>
              <description>
              Balance volume control:
              0000: Reserved,  0001: -1.5dB,
              0010: -3.0dB,  0011: -4.5dB,
              0100: -6.0dB,  0101: -7.5dB,
              0110: -9.0dB,  0111: -10.5dB,
              1000: -12dB,   1001: -13.5dB,
              1010: -15dB,   1011: -16.5dB,
              1100: -18dB,   1101: -19.5dB,
              1110: -21dB,   1111: mute
              Note:
                1) bit[5:0] = 101111 for left mute
                2) bit[5:0] = 011111 for right mute
                3) bit[5:4] = 00 or 11, bit[3:0] is don't care
                4) +1.5db = 20log(1+1/4-1/16+1/1024)
                5) -1.5dB = 20log(1-1/8-1/32-1/512-1/2048)
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD35</name>
          <displayName>RSVD35</displayName>
          <description></description>
          <addressOffset>0x64</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>AUDIO_TX_LRCK_DIV</name>
          <displayName>AUDIO_TX_LRCK_DIV</displayName>
          <description></description>
          <addressOffset>0x70</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x007D007D</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>DUTY_HIGH</name>
              <description>
              TX LRCK duty cycle high:
              125 for 48K FS
              136 for 44.1K FS
              185 for 32K FS
              250 for 24K FS
              272 for 22.05K FS
              375 for 16K FS
              500 for 12K FS
              544 for 11.025K FS
              750 for 8K FS      
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>DUTY_LOW</name>
              <description>
              TX LRCK duty cycle low:
              125 for 48K FS
              136 for 44.1K FS
              190 for 32K FS
              250 for 24K FS
              272 for 22.05K FS
              375 for 16K FS
              500 for 12K FS
              544 for 11.025K FS
              750 for 8K FS
              Note:
              1)duty_cycle = 12M/FS
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD34</name>
          <displayName>RSVD34</displayName>
          <description></description>
          <addressOffset>0x74</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>AUDIO_TX_BCLK_DIV</name>
          <displayName>AUDIO_TX_BCLK_DIV</displayName>
          <description></description>
          <addressOffset>0x80</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>26</bitWidth>
            </field>
            <field>
              <name>DUTY</name>
              <description>
              TX serial bit clock duty cycle
              5 for 48K FS
              4 for 44.1K FS
              5 for 32KFS
              10 for 24K FS
              8 for 22.05K FS
              15 for 16K FS
              20 for 12K FS
              16 for 11.025K FS
              30 for 8KFs
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD33</name>
          <displayName>RSVD33</displayName>
          <description></description>
          <addressOffset>0x84</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>AUDIO_TX_FORMAT</name>
          <displayName>AUDIO_TX_FORMAT</displayName>
          <description></description>
          <addressOffset>0x90</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>27</bitWidth>
            </field>
            <field>
              <name>PCM_DATA_WIDTH</name>
              <description>
              I2S out pcm data width
              M >= 16,
              common value: 16, 18, 20, 22, 24
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD32</name>
          <displayName>RSVD32</displayName>
          <description></description>
          <addressOffset>0x94</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>AUDIO_SERIAL_TIMING</name>
          <displayName>AUDIO_SERIAL_TIMING</displayName>
          <description></description>
          <addressOffset>0xa0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>28</bitWidth>
            </field>
            <field>
              <name>LRCK_POL</name>
              <description>
              TX LRCK polarity control.
              0: disable TX_LRCK inventor
              1: enable TX_LRCK inventor
              for standard I2S, set tx_lrck_pol to low
              for Left/Right Justified, set tx_lrck_pol to hgih
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SLAVE_EN</name>
              <description>
              audio code transmit mode select.
              0: master mode, 1: slave mode
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TIMING</name>
              <description>
              00: I2S mode
              01: Left justified
              10: right justified
              11: reserved
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD31</name>
          <displayName>RSVD31</displayName>
          <description></description>
          <addressOffset>0xA4</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>AUDIO_TX_FUNC_EN</name>
          <displayName>AUDIO_TX_FUNC_EN</displayName>
          <description></description>
          <addressOffset>0xb0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>30</bitWidth>
            </field>
            <field>
              <name>TX_INTF_SEL</name>
              <description>
              1: select external tx interface  0: select internal apb tx interface
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TX_EN</name>
              <description>
              1: enable 0:disable
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD30</name>
          <displayName>RSVD30</displayName>
          <description></description>
          <addressOffset>0xB4</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>AUDIO_TX_PAUSE</name>
          <displayName>AUDIO_TX_PAUSE</displayName>
          <description></description>
          <addressOffset>0xc0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>31</bitWidth>
            </field>
            <field>
              <name>TX_PAUSE</name>
              <description>
              TX pause control when tx_enable = 1.
              1: pause
              0: TX work
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD29</name>
          <displayName>RSVD29</displayName>
          <description></description>
          <addressOffset>0xC4</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>AUDIO_I2S_SL_MERGE</name>
          <displayName>AUDIO_I2S_SL_MERGE</displayName>
          <description></description>
          <addressOffset>0xc8</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>31</bitWidth>
            </field>
            <field>
              <name>SLAVE_TIMING_MERGE</name>
              <description>
              when work as an I2S slave, and external I2S master TX/RX share an only BCLK/LRCK, we need set this bit high.
              0: I2S slave use separated timing control port. TX_BCLK_IN/TX_LRCK_IN and RX_BCLK/RX_LRCK_IN are separated.
              1: I2S slave use the same BCLK/LRCK, the TX_BCLK_IN/TX_LRCK also is used for RX controller.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD28</name>
          <displayName>RSVD28</displayName>
          <description></description>
          <addressOffset>0xCC</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>AUDIO_RX_FUNC_EN</name>
          <displayName>AUDIO_RX_FUNC_EN</displayName>
          <description></description>
          <addressOffset>0x100</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>30</bitWidth>
            </field>
            <field>
              <name>RX_INTF_SEL</name>
              <description>
              1: select external rx interface  0: select internal apb rx interface
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RX_EN</name>
              <description>
              1: enable  0: disable
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD27</name>
          <displayName>RSVD27</displayName>
          <description></description>
          <addressOffset>0x104</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>AUDIO_RX_PAUSE</name>
          <displayName>AUDIO_RX_PAUSE</displayName>
          <description></description>
          <addressOffset>0x110</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>31</bitWidth>
            </field>
            <field>
              <name>RX_PAUSE</name>
              <description>
              RX pause control when rx_enable = 1.
              1: pause
              0: RX work
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD26</name>
          <displayName>RSVD26</displayName>
          <description></description>
          <addressOffset>0x114</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>AUDIO_RX_SERIAL_TIMING</name>
          <displayName>AUDIO_RX_SERIAL_TIMING</displayName>
          <description></description>
          <addressOffset>0x120</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00040000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>28</bitWidth>
            </field>
            <field>
              <name>LRCK_POL</name>
              <description>
              RX LRCK polarity control.
              0: disable RX_LRCK inventor
              1: enable RX_LRCK inventor
              for standard I2S, set tx_lrck_pol to low
              for Left/Right Justified, set tx_lrck_pol to hgih
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SLAVE_EN</name>
              <description>
              audio code receiver mode select.
              0: master mode, 1: slave mode
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TIMING</name>
              <description>
              00: I2S
              01: Left justified
              10: right justified
              11: reserved
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD25</name>
          <displayName>RSVD25</displayName>
          <description></description>
          <addressOffset>0x124</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>AUDIO_RX_PCM_DW</name>
          <displayName>AUDIO_RX_PCM_DW</displayName>
          <description></description>
          <addressOffset>0x130</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000010</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>27</bitWidth>
            </field>
            <field>
              <name>PCM_DATA_WIDTH</name>
              <description>
              For I2S and left justified mode, M can be 8,13,14,16
              For right justified mode, M can be 8, 13, 14, 16, 18, 20, 22, 24
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD24</name>
          <displayName>RSVD24</displayName>
          <description></description>
          <addressOffset>0x134</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>AUDIO_RX_LRCK_DIV</name>
          <displayName>AUDIO_RX_LRCK_DIV</displayName>
          <description></description>
          <addressOffset>0x140</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x007D007D</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>DUTY_HIGH</name>
              <description>
              RX LRCK duty cycle high:
              125 for 48K FS
              136 for 44.1K FS
              185 for 32K FS
              250 for 24K FS
              272 for 22.05K FS
              375 for 16K FS
              500 for 12K FS
              544 for 11.025K FS
              750 for 8K FS      
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>DUTY_LOW</name>
              <description>
              RX LRCK duty cycle low:
              125 for 48K FS
              136 for 44.1K FS
              190 for 32K FS
              250 for 24K FS
              272 for 22.05K FS
              375 for 16K FS
              500 for 12K FS
              544 for 11.025K FS
              750 for 8K FS
              Note:
              1)duty_cycle = 12M/FS
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD23</name>
          <displayName>RSVD23</displayName>
          <description></description>
          <addressOffset>0x144</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>AUDIO_RX_BCLK_DIV</name>
          <displayName>AUDIO_RX_BCLK_DIV</displayName>
          <description></description>
          <addressOffset>0x150</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000005</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>22</bitWidth>
            </field>
            <field>
              <name>DUTY</name>
              <description>
              RX serial bit clock duty cycle
              5 for 48K FS
              4 for 44.1K FS
              5 for 32KFS
              10 for 24K FS
              8 for 22.05K FS
              15 for 16K FS
              20 for 12K FS
              16 for 11.025K FS
              30 for 8KFs
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD22</name>
          <displayName>RSVD22</displayName>
          <description></description>
          <addressOffset>0x154</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>RECORD_DATA_SEL</name>
          <displayName>RECORD_DATA_SEL</displayName>
          <description></description>
          <addressOffset>0x160</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>31</bitWidth>
            </field>
            <field>
              <name>RS_DATA_SEL</name>
              <description>
              0: I2S audio recording  1: BT recording
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD21</name>
          <displayName>RSVD21</displayName>
          <description></description>
          <addressOffset>0x164</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>RX_RE_SAMPLE_CLK_DIV</name>
          <displayName>RX_RE_SAMPLE_CLK_DIV</displayName>
          <description></description>
          <addressOffset>0x170</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0000007D</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>19</bitWidth>
            </field>
            <field>
              <name>RS_DUTY</name>
              <description>
              source PCM sample clock duty cycle:
              250 for 48K FS
              272 for 44.1K FS
              375 for 32K FS
              500 for 24K FS
              544 for 22.05K FS
              750 for 16K FS
              1000 for 12K FS
              1088 for 11.025K FS
              1500 for 8K FS
              Note:
              1)duty_cycle = 12M/FS      
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>13</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD20</name>
          <displayName>RSVD20</displayName>
          <description></description>
          <addressOffset>0x174</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>RX_RE_SAMPLE</name>
          <displayName>RX_RE_SAMPLE</displayName>
          <description></description>
          <addressOffset>0x180</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>31</bitWidth>
            </field>
            <field>
              <name>SMOOTH_EN</name>
              <description>
              0: Disable RX re-sample smooth filter
              1: Enable RX re-sample smooth filter
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD19</name>
          <displayName>RSVD19</displayName>
          <description></description>
          <addressOffset>0x184</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>RECORD_FORMAT</name>
          <displayName>RECORD_FORMAT</displayName>
          <description></description>
          <addressOffset>0x190</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>30</bitWidth>
            </field>
            <field>
              <name>TRACK</name>
              <description>
              1: mono recording, 0: stereo recording
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DW</name>
              <description>
              0: 8bit 1: 16bit
              RX fifo data format:
              Mono 8 bit (unsigned): RX FIFO_DIN[31:0] = {L3,L2,L1,L0}, each four samples need one FIFO write operation
              Stereo 8 bit (unsigned): RX_FIFO_DIN[31:0] = {R1,L1,R0,L0}, each tow samples need one FIFO write operation
              Mono 16 bit (Signed 2s complement): RX_FIFO_DIN[31:0] = {L1,L0}, each two samples need one FIFO write operation
              Stereo 16 bit (Signed 2s complement): RX_FIFO_DIN[31:0] = {R0,L0}, each sample need one FIFO write operation
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD18</name>
          <displayName>RSVD18</displayName>
          <description></description>
          <addressOffset>0x194</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>RX_CH_SEL</name>
          <displayName>RX_CH_SEL</displayName>
          <description></description>
          <addressOffset>0x1a0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>28</bitWidth>
            </field>
            <field>
              <name>LEFT_CHANNEL_SEL</name>
              <description>
              RX re-sampling module setting:
              00: RD left = RX left
              01: RD left = RX right
              10,11: RD left = (RX left + RX right)/2
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RIGHT_CHANNEL_SEL</name>
              <description>
              RX re-sampling module setting:
              00: RD right = RX right
              01: RD right = RX left
              10,11: RD right = (RX left + RX right)/2
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD17</name>
          <displayName>RSVD17</displayName>
          <description></description>
          <addressOffset>0x1A4</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>BT_PHONE_CTRL</name>
          <displayName>BT_PHONE_CTRL</displayName>
          <description></description>
          <addressOffset>0x200</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>26</bitWidth>
            </field>
            <field>
              <name>BB_I2S_BPS_TO_CDC</name>
              <description>
              bypass baseband I2S interface to audio codec i2s interface
              0: no bypass, 1: bypass
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BT_PCM_IF_BPS</name>
              <description>
              bypass baseband PCM signals to BT VCI master:
              0: no bypass, 1: bypass
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BT_PATH_SEL</name>
              <description>
               BT path select
              0: digital path, 1: analog path
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BT_MIX_SMOOTH_FILTER_EN</name>
              <description>
              0: disable the smooth filter for background mixer
              1: enable the smooth filer for background mixer
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BT_BACK_MIX_EN</name>
              <description>
               background mixer enable
              0: disable, 1: enable
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BT_PH_EN</name>
              <description>
              BT phone enable
              0: disable, 1: enable
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD16</name>
          <displayName>RSVD16</displayName>
          <description></description>
          <addressOffset>0x204</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>BB_PCM_FORMAT</name>
          <displayName>BB_PCM_FORMAT</displayName>
          <description></description>
          <addressOffset>0x210</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>21</bitWidth>
            </field>
            <field>
              <name>PCM_CLK_POL</name>
              <description>
              input BB pcm clock polarity:
              0: rising edge for data transmitting, falling edge for data receiving
              1: rising edge for data receiving, falling edge for data transmitting
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>I2S_LRCK_POL</name>
              <description>
              0: no bb_i2s_lrck input inventor
              1: enable bb_i2s_lrck input inventor
              for standard I2S, set tx_lrck_pol to low
              for Left/Right Justified, set tx_lrck_pol to high
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PCM_LSB_FLAG</name>
              <description>
              Serial PCM data bit sequence.
              0: MSB first, 1: LSB first
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PCM_SYNC_FLAG</name>
              <description>
              0: short sync, 1: long sync
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PCM_TIM_SEL</name>
              <description>
              00: I2S timing, 01: Left Justified
              10: Right Justified, 11: PCM timing
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>PCM_DW</name>
              <description>
              Baseband Master PCM data width (>=8)
              Common value: 8, 13,14, 16, 18, 20, 22, 24.
              for I2S/Left Justified/Right Kistified timing, bb_pcm_dw >=16
              For PCM timing, only 8, 13, 14, 16 configure value is available.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD15</name>
          <displayName>RSVD15</displayName>
          <description></description>
          <addressOffset>0x214</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>BT_PCM_DW</name>
          <displayName>BT_PCM_DW</displayName>
          <description></description>
          <addressOffset>0x220</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000010</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>27</bitWidth>
            </field>
            <field>
              <name>DW</name>
              <description>
              BT PCM master data width (>= 8),
              common value: 8, 13,14, 16
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD14</name>
          <displayName>RSVD14</displayName>
          <description></description>
          <addressOffset>0x224</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>BT_PCM_TIMING</name>
          <displayName>BT_PCM_TIMING</displayName>
          <description></description>
          <addressOffset>0x230</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>29</bitWidth>
            </field>
            <field>
              <name>CLK_POL</name>
              <description>
              BT PCM master output pcm clock polarity:
              0: rising edge for data transmitting, falling edge for data receiving
              1: rising edge for data receiving, falling edge for data transmitting
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SYNC_FLAG</name>
              <description>
              0: short sync, 1: long sync
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LSB_FLAG</name>
              <description>
              Serial PCM data bit sequence.
              0: MSB first, 1: LSB first
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD13</name>
          <displayName>RSVD13</displayName>
          <description></description>
          <addressOffset>0x234</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>BT_PCM_CLK_DUTY</name>
          <displayName>BT_PCM_CLK_DUTY</displayName>
          <description></description>
          <addressOffset>0x240</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>22</bitWidth>
            </field>
            <field>
              <name>CLK_DUTY</name>
              <description>
              BT_PCM_CLK duty cycle
              &lt;= (GCLK/(bt_pcm_sync*bt_pcm_dw))
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD12</name>
          <displayName>RSVD12</displayName>
          <description></description>
          <addressOffset>0x244</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>BT_PCM_SYNC_DUTY</name>
          <displayName>BT_PCM_SYNC_DUTY</displayName>
          <description></description>
          <addressOffset>0x250</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>26</bitWidth>
            </field>
            <field>
              <name>SYNC_DUTY</name>
              <description>
              PCM_SYNC duty cycle  (bt_pcm_sync frequency =  bt_pclk_clk/bt_pcm_sync_duty)
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD11</name>
          <displayName>RSVD11</displayName>
          <description></description>
          <addressOffset>0x254</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>BT_VOL_CTRL</name>
          <displayName>BT_VOL_CTRL</displayName>
          <description></description>
          <addressOffset>0x260</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>28</bitWidth>
            </field>
            <field>
              <name>VOL_ADJ_EN</name>
              <description>
              BT volume adjust enable
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>VOL</name>
              <description>
              BT master volume
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD10</name>
          <displayName>RSVD10</displayName>
          <description></description>
          <addressOffset>0x264</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>INT_MASK</name>
          <displayName>INT_MASK</displayName>
          <description></description>
          <addressOffset>0x300</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000003</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>30</bitWidth>
            </field>
            <field>
              <name>TX_FIFO_INT_MASK</name>
              <description>
              Interrupt mask for TX FIFO pop underflow, high active
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RX_FIFO_INT_MASK</name>
              <description>
              Interrupt mask for RX FIFO push overflow, high active
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD9</name>
          <displayName>RSVD9</displayName>
          <description></description>
          <addressOffset>0x304</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>INT_STATUS</name>
          <displayName>INT_STATUS</displayName>
          <description></description>
          <addressOffset>0x310</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>30</bitWidth>
            </field>
            <field>
              <name>TX_FIFO_UNDERFLOW</name>
              <description>
              TX FIFO pop underflow
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RX_FIFO_OVERFLOW</name>
              <description>
              RX FIFO push overflow
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD8</name>
          <displayName>RSVD8</displayName>
          <description></description>
          <addressOffset>0x314</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>TX_DMA_ENTRY</name>
          <displayName>TX_DMA_ENTRY</displayName>
          <description></description>
          <addressOffset>0x400</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>TX_DMA_ENTRY</name>
              <description>
              TX DMA entry
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD7</name>
          <displayName>RSVD7</displayName>
          <description></description>
          <addressOffset>0x404</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>RX_DMA_ENTRY</name>
          <displayName>RX_DMA_ENTRY</displayName>
          <description></description>
          <addressOffset>0x440</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RX_DMA_ENTRY</name>
              <description>
              RX DMA entry
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD6</name>
          <displayName>RSVD6</displayName>
          <description></description>
          <addressOffset>0x444</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>DMA_MASK</name>
          <displayName>DMA_MASK</displayName>
          <description></description>
          <addressOffset>0x480</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000003</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>30</bitWidth>
            </field>
            <field>
              <name>TX_DMA_MASK</name>
              <description>
              TX DMA mask enable:1: mask0: do not mask
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RX_DMA_MASK</name>
              <description>
              RX DMA mask enable:1: mask0: do not mask
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD5</name>
          <displayName>RSVD5</displayName>
          <description></description>
          <addressOffset>0x484</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>DEBUG_LOOP</name>
          <displayName>DEBUG_LOOP</displayName>
          <description></description>
          <addressOffset>0x500</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>SP_CLK_DIV</name>
              <description>
              sp clock divider value
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
            <field>
              <name>SP_CLK_DIV_UPDATE</name>
              <description>
              update sp clock divider
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>SP_CLK_SEL</name>
              <description>
              clock select
              0: xtal clock
              1: pll clock
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>AD2DA_LOOP_BACK</name>
              <description>
              RX-->TX Loop debug control:
              0: disable
              1: enable, internally connect RX Resampled PCM to TX Resample PCM input
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DA2AD_LOOP_BACK</name>
              <description>
              TX-->RX Loop debug control:
              0: disable
              1: enable, internally connect TX SDTO to RX SDTI
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD4</name>
          <displayName>RSVD4</displayName>
          <description></description>
          <addressOffset>0x504</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>FIFO_STATUS</name>
          <displayName>FIFO_STATUS</displayName>
          <description></description>
          <addressOffset>0x600</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>FIFO_STATUS_OUT</name>
              <description>
              FIFO Status output:
               Bit [7:0] = {tx_full,tx_empty,tx_almost_full,tx_almost_empty,rx_full,rx_empty,rx_almost_full,rx_almost_empty}
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD3</name>
          <displayName>RSVD3</displayName>
          <description></description>
          <addressOffset>0x604</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>TX_EQUALIZER_EN</name>
          <displayName>TX_EQUALIZER_EN</displayName>
          <description></description>
          <addressOffset>0x700</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>31</bitWidth>
            </field>
            <field>
              <name>TX_EQUALIZER_EN</name>
              <description>
              0: Disable TX equalizer
              1: Enable TX equalizer
              equalizer is not implemented
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD2</name>
          <displayName>RSVD2</displayName>
          <description></description>
          <addressOffset>0x704</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>TX_EQUALIZER_GAIN1</name>
          <displayName>TX_EQUALIZER_GAIN1</displayName>
          <description></description>
          <addressOffset>0x710</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>BAND6_GAIN</name>
              <description>
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>BAND5_GAIN</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>BAND4_GAIN</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>BAND3_GAIN</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>BAND2_GAIN</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>BAND1_GAIN</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD1</name>
          <displayName>RSVD1</displayName>
          <description></description>
          <addressOffset>0x714</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>TX_EQUALIZER_GAIN2</name>
          <displayName>TX_EQUALIZER_GAIN2</displayName>
          <description></description>
          <addressOffset>0x720</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
            <field>
              <name>BAND10_GAIN</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>BAND9_GAIN</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>BAND8_GAIN</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>BAND7_GAIN</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>HPSYS_CFG</name>
      <description></description>
      <groupName>HPSYS_CFG</groupName>
      <baseAddress>0x5000b000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>BMR</name>
          <displayName>BMR</displayName>
          <description>Boot Mode Register</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>31</bitWidth>
            </field>
            <field>
              <name>BOOT_MODE</name>
              <description>
              0 - normal mode, 1 - download mode
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IDR</name>
          <displayName>IDR</displayName>
          <description>ID Register</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>SID</name>
              <description>
              Series ID
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>CID</name>
              <description>
              Chip ID
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>PID</name>
              <description>
              Package ID
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>REVID</name>
              <description>
              Revision ID
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD2</name>
          <displayName>RSVD2</displayName>
          <description></description>
          <addressOffset>0x8</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>SYSCR</name>
          <displayName>SYSCR</displayName>
          <description>System Configure Register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>29</bitWidth>
            </field>
            <field>
              <name>LDO_VSEL</name>
              <description>
              select work mode
              0: D0/D1
              1: S0/S1
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SDNAND</name>
              <description>
              If set to 1, MPI2 memory space is allocated to SDMMC1
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>WDT1_REBOOT</name>
              <description>
              If set to 1, WDT1 reset will reboot the whole chip
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RTC_TR</name>
          <displayName>RTC_TR</displayName>
          <description>RTC Time Register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>PM</name>
              <description>
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HT</name>
              <description>
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>HU</name>
              <description>
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>MNT</name>
              <description>
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>MNU</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>ST</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>SU</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SS</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RTC_DR</name>
          <displayName>RTC_DR</displayName>
          <description>RTC Date Register</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>ERR</name>
              <description>
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>CB</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>YT</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>YU</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>WD</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>MT</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MU</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>DT</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>DU</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD1</name>
          <displayName>RSVD1</displayName>
          <description></description>
          <addressOffset>0x1C</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>I2C1_PINR</name>
          <displayName>I2C1_PINR</displayName>
          <description>I2C1 Pin Register</description>
          <addressOffset>0x48</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>18</bitWidth>
            </field>
            <field>
              <name>SDA_PIN</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>SCL_PIN</name>
              <description>
              select PA. 0 for PA00, 44 for PA44.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C2_PINR</name>
          <displayName>I2C2_PINR</displayName>
          <description>I2C2 Pin Register</description>
          <addressOffset>0x4c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>18</bitWidth>
            </field>
            <field>
              <name>SDA_PIN</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>SCL_PIN</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C3_PINR</name>
          <displayName>I2C3_PINR</displayName>
          <description>I2C3 Pin Register</description>
          <addressOffset>0x50</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>18</bitWidth>
            </field>
            <field>
              <name>SDA_PIN</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>SCL_PIN</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C4_PINR</name>
          <displayName>I2C4_PINR</displayName>
          <description>I2C4 Pin Register</description>
          <addressOffset>0x54</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>18</bitWidth>
            </field>
            <field>
              <name>SDA_PIN</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>SCL_PIN</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>USART1_PINR</name>
          <displayName>USART1_PINR</displayName>
          <description>USART1 Pin Register</description>
          <addressOffset>0x58</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>CTS_PIN</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RTS_PIN</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RXD_PIN</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>TXD_PIN</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>USART2_PINR</name>
          <displayName>USART2_PINR</displayName>
          <description>USART2 Pin Register</description>
          <addressOffset>0x5c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>CTS_PIN</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RTS_PIN</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RXD_PIN</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>TXD_PIN</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>USART3_PINR</name>
          <displayName>USART3_PINR</displayName>
          <description>USART3 Pin Register</description>
          <addressOffset>0x60</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>CTS_PIN</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RTS_PIN</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RXD_PIN</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>TXD_PIN</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>GPTIM1_PINR</name>
          <displayName>GPTIM1_PINR</displayName>
          <description>GPTIM1 Pin Register</description>
          <addressOffset>0x64</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>CH4_PIN</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>CH3_PIN</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>CH2_PIN</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>CH1_PIN</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>GPTIM2_PINR</name>
          <displayName>GPTIM2_PINR</displayName>
          <description>GPTIM2 Pin Register</description>
          <addressOffset>0x68</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>CH4_PIN</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>CH3_PIN</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>CH2_PIN</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>CH1_PIN</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ETR_PINR</name>
          <displayName>ETR_PINR</displayName>
          <description>GPTIM ETR Pin Register</description>
          <addressOffset>0x6c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>18</bitWidth>
            </field>
            <field>
              <name>ETR2_PIN</name>
              <description>
              GPTIM2_ETR
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>ETR1_PIN</name>
              <description>
              GPTIM1_ETR
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>LPTIM1_PINR</name>
          <displayName>LPTIM1_PINR</displayName>
          <description>LPTIM1 Pin Register</description>
          <addressOffset>0x70</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
            <field>
              <name>ETR_PIN</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>OUT_PIN</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>IN_PIN</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>LPTIM2_PINR</name>
          <displayName>LPTIM2_PINR</displayName>
          <description>LPTIM2 Pin Register</description>
          <addressOffset>0x74</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
            <field>
              <name>ETR_PIN</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>OUT_PIN</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>IN_PIN</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ATIM1_PINR1</name>
          <displayName>ATIM1_PINR1</displayName>
          <description>ATIM1 Pin Register 1</description>
          <addressOffset>0x78</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>CH4_PIN</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>CH3_PIN</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>CH2_PIN</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>CH1_PIN</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ATIM1_PINR2</name>
          <displayName>ATIM1_PINR2</displayName>
          <description>ATIM1 Pin Register 2</description>
          <addressOffset>0x7c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
            <field>
              <name>CH3N_PIN</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>CH2N_PIN</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>CH1N_PIN</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ATIM1_PINR3</name>
          <displayName>ATIM1_PINR3</displayName>
          <description>ATIM1 Pin Register 3</description>
          <addressOffset>0x80</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
            <field>
              <name>ETR_PIN</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>BK2_PIN</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>BK_PIN</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>MPI1</name>
      <description></description>
      <groupName>MPI</groupName>
      <baseAddress>0x50041000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CR</name>
          <displayName>CR</displayName>
          <description>Control Register</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>ABORT</name>
              <description>
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>DFM</name>
              <description>
              Dual Flash Mode
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MX16</name>
              <description>
              Mode X16
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OPIE</name>
              <description>
              OPI interface enable
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HWIFE</name>
              <description>
              Hardware interface enable
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SMM</name>
              <description>
              Status match mode: 0 - AND mode; 1 - OR mode
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SME2</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SME1</name>
              <description>
              Status match enable. SME[0] enables CMD1, SME[1] enable CMD2. Only one CMD can be used as SM CMD
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CMD2E</name>
              <description>
              Enable CMD2. If set to 1, CMD2 will be issued after CMD1 with an interval of TI2
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>SMIE</name>
              <description>
              Status match interrupt enable
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>TCIE</name>
              <description>
              Transfer complete interrupt enable
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTRM</name>
              <description>
              AES-CTR mode. 0 - AES128, 1 - AES256
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTRE</name>
              <description>
              AES-CTR on-the-fly decryption enable
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMAE</name>
              <description>
              DMA enable in FIFO mode
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD5</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>EN</name>
              <description>
              Enable MPI
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DR</name>
          <displayName>DR</displayName>
          <description>Data Register</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DCR</name>
          <displayName>DCR</displayName>
          <description>Device Control Register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>FIXLAT</name>
              <description>
              Indicate PSRAM is fixed latency or variable latency
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TRCMIN</name>
              <description>
              Write/Read cycle minimum time
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>CSHMIN</name>
              <description>
              Minimum CS high deselect time. 0 - one cycle, 1 - two cycles, etc.
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>CSLMIN</name>
              <description>
              Minimum CS low active time. N - (n+1) cycles
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>CSLMAX</name>
              <description>
              Maximum CS low active time. 0 - no limit, n - (n+1) cycles
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
            <field>
              <name>XLEGACY</name>
              <description>
              Xccela legacy protocol
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HYPER</name>
              <description>
              HyperBus protocol
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DQSE</name>
              <description>
              DQS enable. Setting to 1 indicates device provides DQS signal for Rx data latching
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RBSIZE</name>
              <description>
              Row boundary size. 0 - no row boundary, n - row boundary at 2^(n+3) bytes
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PSCLR</name>
          <displayName>PSCLR</displayName>
          <description>Prescaler Register</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>DIV</name>
              <description>
              FCLK divided by DIV. 0/1 - SCLK=FCLK, 2 - SCLK=FCLK/2, n - SCLK=FCLK/n
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SR</name>
          <displayName>SR</displayName>
          <description>Status Register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>BUSY</name>
              <description>
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>27</bitWidth>
            </field>
            <field>
              <name>SMF</name>
              <description>
              Status match flag in Polling Mode
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>TCF</name>
              <description>
              Transfer complete flag
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SCR</name>
          <displayName>SCR</displayName>
          <description>Status Clear Register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>28</bitWidth>
            </field>
            <field>
              <name>SMFC</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>TCFC</name>
              <description>
              Write 1 to clear corresponding flag in SR
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CMDR1</name>
          <displayName>CMDR1</displayName>
          <description>Command Register</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>CMD</name>
              <description>
              command
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>AR1</name>
          <displayName>AR1</displayName>
          <description>Address Register</description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>ADDR</name>
              <description>
              address to be sent to the external Flash memory
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ABR1</name>
          <displayName>ABR1</displayName>
          <description>Alternate Byte Register</description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>ABYTE</name>
              <description>
              Alternate byte
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DLR1</name>
          <displayName>DLR1</displayName>
          <description>Data Length Register</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
            <field>
              <name>DLEN</name>
              <description>
              0 - one byte to be transferred; 1 - two bytes
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR1</name>
          <displayName>CCR1</displayName>
          <description>Communication Configuration Register</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
            <field>
              <name>FMODE</name>
              <description>
              0 - read mode, 1 - write mode
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMODE</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>DCYC</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>ABSIZE</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>ABMODE</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>ADSIZE</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>ADMODE</name>
              <description>
              Address mode
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>IMODE</name>
              <description>
              Instruction mode. 0 - No instruction; 1 - single line; 2 - two lines; 3 - four lines; 4/5/6 - reserved; 7 - four lines DDR
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CMDR2</name>
          <displayName>CMDR2</displayName>
          <description>Command Register</description>
          <addressOffset>0x2c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>CMD</name>
              <description>
              command
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>AR2</name>
          <displayName>AR2</displayName>
          <description>Address Register</description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>ADDR</name>
              <description>
              address to be sent to the external Flash memory
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ABR2</name>
          <displayName>ABR2</displayName>
          <description>Alternate Byte Register</description>
          <addressOffset>0x34</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>ABYTE</name>
              <description>
              Alternate byte
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DLR2</name>
          <displayName>DLR2</displayName>
          <description>Data Length Register</description>
          <addressOffset>0x38</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
            <field>
              <name>DLEN</name>
              <description>
              0 - one byte to be transferred; 1 - two bytes
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR2</name>
          <displayName>CCR2</displayName>
          <description>Communication Configuration Register</description>
          <addressOffset>0x3c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
            <field>
              <name>FMODE</name>
              <description>
              0 - read mode, 1 - write mode
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMODE</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>DCYC</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>ABSIZE</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>ABMODE</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>ADSIZE</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>ADMODE</name>
              <description>
              Address mode
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>IMODE</name>
              <description>
              Instruction mode. 0 - No instruction; 1 - single line; 2 - two lines; 3 - four lines; 4/5/6 - reserved; 7 - four lines DDR
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>HCMDR</name>
          <displayName>HCMDR</displayName>
          <description>AHB Command Register</description>
          <addressOffset>0x40</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>WCMD</name>
              <description>
              During XIP, the AHB write transaction will be translated into this Write Command on SPI interface
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>RCMD</name>
              <description>
              During XIP, the AHB read transaction will be translated into this Read Command on SPI interface
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>HRABR</name>
          <displayName>HRABR</displayName>
          <description>AHB Read Alternate Byte Register</description>
          <addressOffset>0x44</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>ABYTE</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>HRCCR</name>
          <displayName>HRCCR</displayName>
          <description>AHB Read Communication Configuration Register</description>
          <addressOffset>0x48</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
            <field>
              <name>DMODE</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>DCYC</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>ABSIZE</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>ABMODE</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>ADSIZE</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>ADMODE</name>
              <description>
              Address mode
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>IMODE</name>
              <description>
              Instruction mode. 0 - No instruction; 1 - single line; 2 - two lines; 3 - four lines; 4/5/6 - reserved; 7 - four lines DDR
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>HWABR</name>
          <displayName>HWABR</displayName>
          <description>AHB Write Alternate Byte Register</description>
          <addressOffset>0x4c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>ABYTE</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>HWCCR</name>
          <displayName>HWCCR</displayName>
          <description>AHB Write Communication Configuration Register</description>
          <addressOffset>0x50</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
            <field>
              <name>DMODE</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>DCYC</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>ABSIZE</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>ABMODE</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>ADSIZE</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>ADMODE</name>
              <description>
              Address mode
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>IMODE</name>
              <description>
              Instruction mode. 0 - No instruction; 1 - single line; 2 - two lines; 3 - four lines; 4/5/6 - reserved; 7 - four lines DDR
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>FIFOCR</name>
          <displayName>FIFOCR</displayName>
          <description>FIFO Control Register</description>
          <addressOffset>0x54</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>MISCR</name>
          <displayName>MISCR</displayName>
          <description>Miscelaneous Register</description>
          <addressOffset>0x58</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>DTRPRE</name>
              <description>
              Enable pre-sampling for DTR (for slow frequency)
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SCKINV</name>
              <description>
              Invert FCLK as SCK (coarse tune)
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RXCLKINV</name>
              <description>
              Invert FCLK as Rx sampling clock (coarse tune)
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DQSDLY</name>
              <description>
              select delayed version of DQS. Effective 7-bit
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>SCKDLY</name>
              <description>
              Add delay on SCK (fine tune). Effective 7-bit
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>RXCLKDLY</name>
              <description>
              Add delay on Rx sampling clock (fine tune). Effective 5-bit
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CTRSAR</name>
          <displayName>CTRSAR</displayName>
          <description></description>
          <addressOffset>0x5c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CTREAR</name>
          <displayName>CTREAR</displayName>
          <description></description>
          <addressOffset>0x60</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>NONCEA</name>
          <displayName>NONCEA</displayName>
          <description></description>
          <addressOffset>0x64</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>NONCEB</name>
          <displayName>NONCEB</displayName>
          <description></description>
          <addressOffset>0x68</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>AASAR</name>
          <displayName>AASAR</displayName>
          <description></description>
          <addressOffset>0x6c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>AAEAR</name>
          <displayName>AAEAR</displayName>
          <description></description>
          <addressOffset>0x70</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>AAOAR</name>
          <displayName>AAOAR</displayName>
          <description></description>
          <addressOffset>0x74</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CIR</name>
          <displayName>CIR</displayName>
          <description>Command Interval Register</description>
          <addressOffset>0x78</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>INTERVAL2</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>INTERVAL1</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SMR</name>
          <displayName>SMR</displayName>
          <description>Status Match Register</description>
          <addressOffset>0x7c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>STATUS</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SMKR</name>
          <displayName>SMKR</displayName>
          <description>Status Mask Register</description>
          <addressOffset>0x80</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>MASK</name>
              <description>
              0 - not considered; 1 - considered
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TIMR</name>
          <displayName>TIMR</displayName>
          <description></description>
          <addressOffset>0x84</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>WDTR</name>
          <displayName>WDTR</displayName>
          <description>WDT Register</description>
          <addressOffset>0x88</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>TOF</name>
              <description>
              Timeout flag. Self cleared when the HREADYOUT being monitored becomes ready
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>14</bitWidth>
            </field>
            <field>
              <name>EN</name>
              <description>
              WDT enable
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TIMEOUT</name>
              <description>
              Set AHB timeout value in number of clk_wdt cycles
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PRSAR</name>
          <displayName>PRSAR</displayName>
          <description></description>
          <addressOffset>0x8c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PREAR</name>
          <displayName>PREAR</displayName>
          <description></description>
          <addressOffset>0x90</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CALCR</name>
          <displayName>CALCR</displayName>
          <description>Calibration Control Register</description>
          <addressOffset>0x94</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>EN</name>
              <description>
              calibration enable
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>22</bitWidth>
            </field>
            <field>
              <name>DONE</name>
              <description>
              calibration done
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DELAY</name>
              <description>
              calibration delay result
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CALDOR</name>
          <displayName>CALDOR</displayName>
          <description></description>
          <addressOffset>0x98</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>APM32CR</name>
          <displayName>APM32CR</displayName>
          <description>APM32 Control Register</description>
          <addressOffset>0x9c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>TCPHW</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>TCPHR</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CR2</name>
          <displayName>CR2</displayName>
          <description></description>
          <addressOffset>0xa0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>MPI2</name>
      <description></description>
      <groupName>MPI</groupName>
      <baseAddress>0x50042000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CR</name>
          <displayName>CR</displayName>
          <description>Control Register</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>ABORT</name>
              <description>
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>DFM</name>
              <description>
              Dual Flash Mode
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MX16</name>
              <description>
              Mode X16
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OPIE</name>
              <description>
              OPI interface enable
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HWIFE</name>
              <description>
              Hardware interface enable
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SMM</name>
              <description>
              Status match mode: 0 - AND mode; 1 - OR mode
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SME2</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SME1</name>
              <description>
              Status match enable. SME[0] enables CMD1, SME[1] enable CMD2. Only one CMD can be used as SM CMD
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CMD2E</name>
              <description>
              Enable CMD2. If set to 1, CMD2 will be issued after CMD1 with an interval of TI2
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>SMIE</name>
              <description>
              Status match interrupt enable
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>TCIE</name>
              <description>
              Transfer complete interrupt enable
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTRM</name>
              <description>
              AES-CTR mode. 0 - AES128, 1 - AES256
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTRE</name>
              <description>
              AES-CTR on-the-fly decryption enable
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMAE</name>
              <description>
              DMA enable in FIFO mode
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD5</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>EN</name>
              <description>
              Enable MPI
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DR</name>
          <displayName>DR</displayName>
          <description>Data Register</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DCR</name>
          <displayName>DCR</displayName>
          <description>Device Control Register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>FIXLAT</name>
              <description>
              Indicate PSRAM is fixed latency or variable latency
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TRCMIN</name>
              <description>
              Write/Read cycle minimum time
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>CSHMIN</name>
              <description>
              Minimum CS high deselect time. 0 - one cycle, 1 - two cycles, etc.
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>CSLMIN</name>
              <description>
              Minimum CS low active time. N - (n+1) cycles
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>CSLMAX</name>
              <description>
              Maximum CS low active time. 0 - no limit, n - (n+1) cycles
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
            <field>
              <name>XLEGACY</name>
              <description>
              Xccela legacy protocol
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HYPER</name>
              <description>
              HyperBus protocol
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DQSE</name>
              <description>
              DQS enable. Setting to 1 indicates device provides DQS signal for Rx data latching
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RBSIZE</name>
              <description>
              Row boundary size. 0 - no row boundary, n - row boundary at 2^(n+3) bytes
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PSCLR</name>
          <displayName>PSCLR</displayName>
          <description>Prescaler Register</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>DIV</name>
              <description>
              FCLK divided by DIV. 0/1 - SCLK=FCLK, 2 - SCLK=FCLK/2, n - SCLK=FCLK/n
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SR</name>
          <displayName>SR</displayName>
          <description>Status Register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>BUSY</name>
              <description>
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>27</bitWidth>
            </field>
            <field>
              <name>SMF</name>
              <description>
              Status match flag in Polling Mode
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>TCF</name>
              <description>
              Transfer complete flag
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SCR</name>
          <displayName>SCR</displayName>
          <description>Status Clear Register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>28</bitWidth>
            </field>
            <field>
              <name>SMFC</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>TCFC</name>
              <description>
              Write 1 to clear corresponding flag in SR
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CMDR1</name>
          <displayName>CMDR1</displayName>
          <description>Command Register</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>CMD</name>
              <description>
              command
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>AR1</name>
          <displayName>AR1</displayName>
          <description>Address Register</description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>ADDR</name>
              <description>
              address to be sent to the external Flash memory
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ABR1</name>
          <displayName>ABR1</displayName>
          <description>Alternate Byte Register</description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>ABYTE</name>
              <description>
              Alternate byte
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DLR1</name>
          <displayName>DLR1</displayName>
          <description>Data Length Register</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
            <field>
              <name>DLEN</name>
              <description>
              0 - one byte to be transferred; 1 - two bytes
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR1</name>
          <displayName>CCR1</displayName>
          <description>Communication Configuration Register</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
            <field>
              <name>FMODE</name>
              <description>
              0 - read mode, 1 - write mode
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMODE</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>DCYC</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>ABSIZE</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>ABMODE</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>ADSIZE</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>ADMODE</name>
              <description>
              Address mode
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>IMODE</name>
              <description>
              Instruction mode. 0 - No instruction; 1 - single line; 2 - two lines; 3 - four lines; 4/5/6 - reserved; 7 - four lines DDR
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CMDR2</name>
          <displayName>CMDR2</displayName>
          <description>Command Register</description>
          <addressOffset>0x2c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>CMD</name>
              <description>
              command
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>AR2</name>
          <displayName>AR2</displayName>
          <description>Address Register</description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>ADDR</name>
              <description>
              address to be sent to the external Flash memory
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ABR2</name>
          <displayName>ABR2</displayName>
          <description>Alternate Byte Register</description>
          <addressOffset>0x34</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>ABYTE</name>
              <description>
              Alternate byte
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DLR2</name>
          <displayName>DLR2</displayName>
          <description>Data Length Register</description>
          <addressOffset>0x38</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
            <field>
              <name>DLEN</name>
              <description>
              0 - one byte to be transferred; 1 - two bytes
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR2</name>
          <displayName>CCR2</displayName>
          <description>Communication Configuration Register</description>
          <addressOffset>0x3c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
            <field>
              <name>FMODE</name>
              <description>
              0 - read mode, 1 - write mode
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMODE</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>DCYC</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>ABSIZE</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>ABMODE</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>ADSIZE</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>ADMODE</name>
              <description>
              Address mode
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>IMODE</name>
              <description>
              Instruction mode. 0 - No instruction; 1 - single line; 2 - two lines; 3 - four lines; 4/5/6 - reserved; 7 - four lines DDR
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>HCMDR</name>
          <displayName>HCMDR</displayName>
          <description>AHB Command Register</description>
          <addressOffset>0x40</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>WCMD</name>
              <description>
              During XIP, the AHB write transaction will be translated into this Write Command on SPI interface
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>RCMD</name>
              <description>
              During XIP, the AHB read transaction will be translated into this Read Command on SPI interface
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>HRABR</name>
          <displayName>HRABR</displayName>
          <description>AHB Read Alternate Byte Register</description>
          <addressOffset>0x44</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>ABYTE</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>HRCCR</name>
          <displayName>HRCCR</displayName>
          <description>AHB Read Communication Configuration Register</description>
          <addressOffset>0x48</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
            <field>
              <name>DMODE</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>DCYC</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>ABSIZE</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>ABMODE</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>ADSIZE</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>ADMODE</name>
              <description>
              Address mode
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>IMODE</name>
              <description>
              Instruction mode. 0 - No instruction; 1 - single line; 2 - two lines; 3 - four lines; 4/5/6 - reserved; 7 - four lines DDR
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>HWABR</name>
          <displayName>HWABR</displayName>
          <description>AHB Write Alternate Byte Register</description>
          <addressOffset>0x4c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>ABYTE</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>HWCCR</name>
          <displayName>HWCCR</displayName>
          <description>AHB Write Communication Configuration Register</description>
          <addressOffset>0x50</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
            <field>
              <name>DMODE</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>DCYC</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>ABSIZE</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>ABMODE</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>ADSIZE</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>ADMODE</name>
              <description>
              Address mode
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>IMODE</name>
              <description>
              Instruction mode. 0 - No instruction; 1 - single line; 2 - two lines; 3 - four lines; 4/5/6 - reserved; 7 - four lines DDR
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>FIFOCR</name>
          <displayName>FIFOCR</displayName>
          <description>FIFO Control Register</description>
          <addressOffset>0x54</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>MISCR</name>
          <displayName>MISCR</displayName>
          <description>Miscelaneous Register</description>
          <addressOffset>0x58</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>DTRPRE</name>
              <description>
              Enable pre-sampling for DTR (for slow frequency)
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SCKINV</name>
              <description>
              Invert FCLK as SCK (coarse tune)
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RXCLKINV</name>
              <description>
              Invert FCLK as Rx sampling clock (coarse tune)
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DQSDLY</name>
              <description>
              select delayed version of DQS. Effective 7-bit
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>SCKDLY</name>
              <description>
              Add delay on SCK (fine tune). Effective 7-bit
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>RXCLKDLY</name>
              <description>
              Add delay on Rx sampling clock (fine tune). Effective 5-bit
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CTRSAR</name>
          <displayName>CTRSAR</displayName>
          <description></description>
          <addressOffset>0x5c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CTREAR</name>
          <displayName>CTREAR</displayName>
          <description></description>
          <addressOffset>0x60</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>NONCEA</name>
          <displayName>NONCEA</displayName>
          <description></description>
          <addressOffset>0x64</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>NONCEB</name>
          <displayName>NONCEB</displayName>
          <description></description>
          <addressOffset>0x68</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>AASAR</name>
          <displayName>AASAR</displayName>
          <description></description>
          <addressOffset>0x6c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>AAEAR</name>
          <displayName>AAEAR</displayName>
          <description></description>
          <addressOffset>0x70</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>AAOAR</name>
          <displayName>AAOAR</displayName>
          <description></description>
          <addressOffset>0x74</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CIR</name>
          <displayName>CIR</displayName>
          <description>Command Interval Register</description>
          <addressOffset>0x78</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>INTERVAL2</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>INTERVAL1</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SMR</name>
          <displayName>SMR</displayName>
          <description>Status Match Register</description>
          <addressOffset>0x7c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>STATUS</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SMKR</name>
          <displayName>SMKR</displayName>
          <description>Status Mask Register</description>
          <addressOffset>0x80</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>MASK</name>
              <description>
              0 - not considered; 1 - considered
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TIMR</name>
          <displayName>TIMR</displayName>
          <description></description>
          <addressOffset>0x84</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>WDTR</name>
          <displayName>WDTR</displayName>
          <description>WDT Register</description>
          <addressOffset>0x88</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>TOF</name>
              <description>
              Timeout flag. Self cleared when the HREADYOUT being monitored becomes ready
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>14</bitWidth>
            </field>
            <field>
              <name>EN</name>
              <description>
              WDT enable
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TIMEOUT</name>
              <description>
              Set AHB timeout value in number of clk_wdt cycles
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PRSAR</name>
          <displayName>PRSAR</displayName>
          <description></description>
          <addressOffset>0x8c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PREAR</name>
          <displayName>PREAR</displayName>
          <description></description>
          <addressOffset>0x90</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CALCR</name>
          <displayName>CALCR</displayName>
          <description>Calibration Control Register</description>
          <addressOffset>0x94</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>EN</name>
              <description>
              calibration enable
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>22</bitWidth>
            </field>
            <field>
              <name>DONE</name>
              <description>
              calibration done
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DELAY</name>
              <description>
              calibration delay result
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CALDOR</name>
          <displayName>CALDOR</displayName>
          <description></description>
          <addressOffset>0x98</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>APM32CR</name>
          <displayName>APM32CR</displayName>
          <description>APM32 Control Register</description>
          <addressOffset>0x9c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>TCPHW</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>TCPHR</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CR2</name>
          <displayName>CR2</displayName>
          <description></description>
          <addressOffset>0xa0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>CRC1</name>
      <description></description>
      <groupName>CRC</groupName>
      <baseAddress>0x50048000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>DR</name>
          <displayName>DR</displayName>
          <description>Data register</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>DR</name>
              <description>
              Data register bits.
              This register is used to write new data to the CRC calculator.
              It holds the previous CRC calculation result when it is read.
              If the data size is less than 32 bits, the least significant bits are used to write/read the correct value.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SR</name>
          <displayName>SR</displayName>
          <description>Status register</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>30</bitWidth>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>
              Overflow when new data arrive while last calculation not done yet
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DONE</name>
              <description>
              Done flag. When DR written, done flag will be cleared automatically. The flag will assert after CRC operation of current DR finished.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CR</name>
          <displayName>CR</displayName>
          <description>Control register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>REV_OUT</name>
              <description>
              Reverse output data
              This bit controls the reversal of the bit order of the output data.
              0: Bit order not affected
              1: Bit-reversed output format
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>REV_IN</name>
              <description>
              Reverse input data
              These bits control the reversal of the bit order of the input data
              00: Bit order not affected
              01: Bit reversal done by byte
              10: Bit reversal done by half-word
              11: Bit reversal done by word
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>POLYSIZE</name>
              <description>
              Polynomial size
              These bits control the size of the polynomial.
              00: 32 bit polynomial
              01: 16 bit polynomial
              10: 8 bit polynomial
              11: 7 bit polynomial
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>DATASIZE</name>
              <description>
              Valid input data size
              These bits control the valid size of the input data.
              00: lower 8-bit
              01: lower 16-bit
              10: lower 24-bit
              11: all 32-bit
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RESET</name>
              <description>
              This bit is set by software to reset the CRC calculation unit and set the data register to the value stored in the CRC_INIT register. This bit can only be set, it is automatically cleared by hardware
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD1</name>
          <displayName>RSVD1</displayName>
          <description></description>
          <addressOffset>0xC</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>INIT</name>
          <displayName>INIT</displayName>
          <description>Initial CRC value</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>INIT</name>
              <description>
              Programmable initial CRC value
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>POL</name>
          <displayName>POL</displayName>
          <description>CRC polynomial</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>POL</name>
              <description>
              Programmable polynomial 
              This register is used to write the coefficients of the polynomial to be used for CRC calculation.
              If the polynomial size is less than 32 bits, the least significant bits have to be used to program the correct value.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>DMAC1</name>
      <description></description>
      <groupName>DMAC</groupName>
      <baseAddress>0x50081000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>ISR</name>
          <displayName>ISR</displayName>
          <description></description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>TEIF8</name>
              <description>
              channel transfer error flag
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HTIF8</name>
              <description>
              channel half transfer flag
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIF8</name>
              <description>
              channel transfer complete flag
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GIF8</name>
              <description>
              channel global interrupt flag
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIF7</name>
              <description>
              channel transfer error flag
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HTIF7</name>
              <description>
              channel half transfer flag
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIF7</name>
              <description>
              channel transfer complete flag
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GIF7</name>
              <description>
              channel global interrupt flag
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIF6</name>
              <description>
              channel transfer error flag
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HTIF6</name>
              <description>
              channel half transfer flag
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIF6</name>
              <description>
              channel transfer complete flag
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GIF6</name>
              <description>
              channel global interrupt flag
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIF5</name>
              <description>
              channel transfer error flag
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HTIF5</name>
              <description>
              channel half transfer flag
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIF5</name>
              <description>
              channel transfer complete flag
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GIF5</name>
              <description>
              channel global interrupt flag
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIF4</name>
              <description>
              channel transfer error flag
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HTIF4</name>
              <description>
              channel half transfer flag
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIF4</name>
              <description>
              channel transfer complete flag
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GIF4</name>
              <description>
              channel global interrupt flag
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIF3</name>
              <description>
              channel transfer error flag
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HTIF3</name>
              <description>
              channel half transfer flag
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIF3</name>
              <description>
              channel transfer complete flag
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GIF3</name>
              <description>
              channel global interrupt flag
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIF2</name>
              <description>
              channel transfer error flag
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HTIF2</name>
              <description>
              channel half transfer flag
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIF2</name>
              <description>
              channel transfer complete flag
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GIF2</name>
              <description>
              channel global interrupt flag
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIF1</name>
              <description>
              channel transfer error flag. Set when bus error detected. Cleared when write 1 to CTEIF or CGIF.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HTIF1</name>
              <description>
              channel half transfer flag. Set when half NDT are transferred. Cleared when write 1 to CHTIF or CGIF.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIF1</name>
              <description>
              channel transfer complete flag. Set when all NDT are transferred.  Cleared when write 1 to CTCIF or CGIF.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GIF1</name>
              <description>
              channel global interrupt flag. Set when any of TEIF/HTIF/TCIF asserted. Cleared when TEIF/HTIF/TCIF all cleared.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IFCR</name>
          <displayName>IFCR</displayName>
          <description></description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>CTEIF8</name>
              <description>
              CTEIF, transfer error flag clear
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CHTIF8</name>
              <description>
              CHTIF, half transfer flag clear
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTCIF8</name>
              <description>
              CTCIF, transfer complete flag clear
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CGIF8</name>
              <description>
              CGIF,  global interrupt flag clear
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTEIF7</name>
              <description>
              CTEIF, transfer error flag clear
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CHTIF7</name>
              <description>
              CHTIF, half transfer flag clear
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTCIF7</name>
              <description>
              CTCIF, transfer complete flag clear
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CGIF7</name>
              <description>
              CGIF,  global interrupt flag clear
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTEIF6</name>
              <description>
              CTEIF, transfer error flag clear
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CHTIF6</name>
              <description>
              CHTIF, half transfer flag clear
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTCIF6</name>
              <description>
              CTCIF, transfer complete flag clear
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CGIF6</name>
              <description>
              CGIF,  global interrupt flag clear
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTEIF5</name>
              <description>
              CTEIF, transfer error flag clear
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CHTIF5</name>
              <description>
              CHTIF, half transfer flag clear
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTCIF5</name>
              <description>
              CTCIF, transfer complete flag clear
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CGIF5</name>
              <description>
              CGIF,  global interrupt flag clear
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTEIF4</name>
              <description>
              CTEIF, transfer error flag clear
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CHTIF4</name>
              <description>
              CHTIF, half transfer flag clear
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTCIF4</name>
              <description>
              CTCIF, transfer complete flag clear
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CGIF4</name>
              <description>
              CGIF,  global interrupt flag clear
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTEIF3</name>
              <description>
              CTEIF, transfer error flag clear
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CHTIF3</name>
              <description>
              CHTIF, half transfer flag clear
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTCIF3</name>
              <description>
              CTCIF, transfer complete flag clear
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CGIF3</name>
              <description>
              CGIF,  global interrupt flag clear
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTEIF2</name>
              <description>
              CTEIF, transfer error flag clear
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CHTIF2</name>
              <description>
              CHTIF, half transfer flag clear
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTCIF2</name>
              <description>
              CTCIF, transfer complete flag clear
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CGIF2</name>
              <description>
              CGIF,  global interrupt flag clear
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTEIF1</name>
              <description>
              CTEIF, transfer error flag clear. Write 1 to clear TEIF.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CHTIF1</name>
              <description>
              CHTIF, half transfer flag clear. Write 1 to clear HTIF.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTCIF1</name>
              <description>
              CTCIF, transfer complete flag clear. Write 1 to clear TCIF.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CGIF1</name>
              <description>
              CGIF,  global interrupt flag clear. Write 1 to clear all TEIF/HTIF/TCIF.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR1</name>
          <displayName>CCR1</displayName>
          <description></description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
            <field>
              <name>MEM2MEM</name>
              <description>
              memory-to-memory mode
              0: disabled
              1: enabled
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PL</name>
              <description>
              priority level
              00: low
              01: medium
              10: high
              11: very high
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>MSIZE</name>
              <description>
              memory size
              Defines the data size of each DMA transfer to the identified memory.
              In memory-to-memory mode, this field identifies the memory source if DIR = 1 and the memory destination if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.
              00: 8 bits
              01: 16 bits
              10: 32 bits
              11: reserved
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>PSIZE</name>
              <description>
              peripheral size
              Defines the data size of each DMA transfer to the identified peripheral.
              In memory-to-memory mode, this field identifies the memory destination if DIR = 1 and the memory source if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR = 1 and the peripheral source if DIR = 0.
              00: 8 bits
              01: 16 bits
              10: 32 bits
              11: reserved
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>MINC</name>
              <description>
              memory increment mode
              Defines the increment mode for each DMA transfer to the identified memory.
              In memory-to-memory mode, this field identifies the memory source if DIR = 1 and the memory destination if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.
              0: disabled
              1: enabled
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PINC</name>
              <description>
              peripheral increment mode
              Defines the increment mode for each DMA transfer to the identified peripheral.
              n memory-to-memory mode, this field identifies the memory destination if DIR = 1 and the 
              memory source if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR = 1 and 
              the peripheral source if DIR = 0.
              0: disabled
              1: enabled
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CIRC</name>
              <description>
              circular mode
              0: disabled
              1: enabled
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DIR</name>
              <description>
              data transfer direction
              This bit must be set only in memory-to-peripheral and peripheral-to-memory modes.
              0: read from peripheral
               Source attributes are defined by PSIZE and PINC, plus the CPARx register. This is still valid in a memory-to-memory mode.
               Destination attributes are defined by MSIZE and MINC, plus the CM0ARx register. This is still valid in a peripheral-to-peripheral mode.
              1: read from memory
               Destination attributes are defined by PSIZE and PINC, plus the CPARx register. This is still valid in a memory-to-memory mode.
               Source attributes are defined by MSIZE and MINC, plus the CM0ARx register. This is still valid in a peripheral-to-peripheral mode.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIE</name>
              <description>
              transfer error interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HTIE</name>
              <description>
              half transfer interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIE</name>
              <description>
              transfer complete interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EN</name>
              <description>
              channel enable
              When a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the ISR register is cleared (by setting the CTEIFx bit of the IFCR register).
              0: disabled
              1: enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CNDTR1</name>
          <displayName>CNDTR1</displayName>
          <description></description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>NDT</name>
              <description>
              number of data to transfer (0 to 2^16 - 1)
              This field is updated by hardware when the channel is enabled:
               It is decremented after each single DMA read followed by write transfer, indicating the remaining amount of data items to transfer.
               It is kept at zero when the programmed amount of data to transfer is reached, if the channel is not in circular mode (CIRC = 0 in the CCRx register).
               It is reloaded automatically by the previously programmed value, when the transfer is complete, if the channel is in circular mode (CIRC = 1).
              If this field is zero, no transfer can be served whatever the channel status (enabled or not).
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CPAR1</name>
          <displayName>CPAR1</displayName>
          <description></description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>PA</name>
              <description>
              peripheral address
              It contains the base address of the peripheral data register from/to which the data will be read/written.
              In memory-to-memory mode, this register identifies the memory destination address if DIR = 1 and the memory source address if DIR = 0.
              In peripheral-to-peripheral mode, this register identifies the peripheral destination address DIR = 1 and the peripheral source address if DIR = 0.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0AR1</name>
          <displayName>CM0AR1</displayName>
          <description></description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>MA</name>
              <description>
              memory address
              It contains the base address of the memory from/to which the data will be read/written.
              In memory-to-memory mode, this register identifies the memory source address if DIR = 1 and the memory destination address if DIR = 0.
              In peripheral-to-peripheral mode, this register identifies the peripheral source address DIR = 1 and the peripheral destination address if DIR = 0.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CBSR1</name>
          <displayName>CBSR1</displayName>
          <description></description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>BS</name>
              <description>
              burst size in non-m2m mode
              When BS>1, DMA will transfer for BS times for each request if left NDT is larger than BS, or else transfer for left NDT times.
              When BS=0 or 1, DMA will always do single transfer for each request.
              In memory-to-memory mode, BS is ignored.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR2</name>
          <displayName>CCR2</displayName>
          <description></description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
            <field>
              <name>MEM2MEM</name>
              <description>
              memory-to-memory mode
              0: disabled
              1: enabled
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PL</name>
              <description>
              priority level
              00: low
              01: medium
              10: high
              11: very high
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>MSIZE</name>
              <description>
              memory size
              Defines the data size of each DMA transfer to the identified memory.
              In memory-to-memory mode, this field identifies the memory source if DIR = 1 and the memory destination if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.
              00: 8 bits
              01: 16 bits
              10: 32 bits
              11: reserved
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>PSIZE</name>
              <description>
              peripheral size
              Defines the data size of each DMA transfer to the identified peripheral.
              In memory-to-memory mode, this field identifies the memory destination if DIR = 1 and the memory source if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR = 1 and the peripheral source if DIR = 0.
              00: 8 bits
              01: 16 bits
              10: 32 bits
              11: reserved
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>MINC</name>
              <description>
              memory increment mode
              Defines the increment mode for each DMA transfer to the identified memory.
              In memory-to-memory mode, this field identifies the memory source if DIR = 1 and the memory destination if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.
              0: disabled
              1: enabled
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PINC</name>
              <description>
              peripheral increment mode
              Defines the increment mode for each DMA transfer to the identified peripheral.
              n memory-to-memory mode, this field identifies the memory destination if DIR = 1 and the 
              memory source if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR = 1 and 
              the peripheral source if DIR = 0.
              0: disabled
              1: enabled
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CIRC</name>
              <description>
              circular mode
              0: disabled
              1: enabled
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DIR</name>
              <description>
              data transfer direction
              This bit must be set only in memory-to-peripheral and peripheral-to-memory modes.
              0: read from peripheral
               Source attributes are defined by PSIZE and PINC, plus the CPARx register. This is still valid in a memory-to-memory mode.
               Destination attributes are defined by MSIZE and MINC, plus the CM0ARx register. This is still valid in a peripheral-to-peripheral mode.
              1: read from memory
               Destination attributes are defined by PSIZE and PINC, plus the CPARx register. This is still valid in a memory-to-memory mode.
               Source attributes are defined by MSIZE and MINC, plus the CM0ARx register. This is still valid in a peripheral-to-peripheral mode.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIE</name>
              <description>
              transfer error interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HTIE</name>
              <description>
              half transfer interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIE</name>
              <description>
              transfer complete interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EN</name>
              <description>
              channel enable
              When a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the ISR register is cleared (by setting the CTEIFx bit of the IFCR register).
              0: disabled
              1: enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CNDTR2</name>
          <displayName>CNDTR2</displayName>
          <description></description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>NDT</name>
              <description>
              number of data to transfer (0 to 2^16 - 1)
              This field is updated by hardware when the channel is enabled:
               It is decremented after each single DMA read followed by write transfer, indicating the remaining amount of data items to transfer.
               It is kept at zero when the programmed amount of data to transfer is reached, if the channel is not in circular mode (CIRC = 0 in the CCRx register).
               It is reloaded automatically by the previously programmed value, when the transfer is complete, if the channel is in circular mode (CIRC = 1).
              If this field is zero, no transfer can be served whatever the channel status (enabled or not).
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CPAR2</name>
          <displayName>CPAR2</displayName>
          <description></description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>PA</name>
              <description>
              peripheral address
              It contains the base address of the peripheral data register from/to which the data will be read/written.
              In memory-to-memory mode, this register identifies the memory destination address if DIR = 1 and the memory source address if DIR = 0.
              In peripheral-to-peripheral mode, this register identifies the peripheral destination address DIR = 1 and the peripheral source address if DIR = 0.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0AR2</name>
          <displayName>CM0AR2</displayName>
          <description></description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>MA</name>
              <description>
              peripheral address
              It contains the base address of the memory from/to which the data will be read/written.
              In memory-to-memory mode, this register identifies the memory source address if DIR = 1 and the memory destination address if DIR = 0.
              In peripheral-to-peripheral mode, this register identifies the peripheral source address DIR = 1 and the peripheral destination address if DIR = 0.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CBSR2</name>
          <displayName>CBSR2</displayName>
          <description></description>
          <addressOffset>0x2c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>BS</name>
              <description>
              burst size in non-m2m mode
              When BS>1, DMA will transfer for BS times for each request if left NDT is larger than BS, or else transfer for left NDT times.
              When BS=0 or 1, DMA will always do single transfer for each request.
              In memory-to-memory mode, BS is ignored.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR3</name>
          <displayName>CCR3</displayName>
          <description></description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
            <field>
              <name>MEM2MEM</name>
              <description>
              memory-to-memory mode
              0: disabled
              1: enabled
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PL</name>
              <description>
              priority level
              00: low
              01: medium
              10: high
              11: very high
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>MSIZE</name>
              <description>
              memory size
              Defines the data size of each DMA transfer to the identified memory.
              In memory-to-memory mode, this field identifies the memory source if DIR = 1 and the memory destination if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.
              00: 8 bits
              01: 16 bits
              10: 32 bits
              11: reserved
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>PSIZE</name>
              <description>
              peripheral size
              Defines the data size of each DMA transfer to the identified peripheral.
              In memory-to-memory mode, this field identifies the memory destination if DIR = 1 and the memory source if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR = 1 and the peripheral source if DIR = 0.
              00: 8 bits
              01: 16 bits
              10: 32 bits
              11: reserved
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>MINC</name>
              <description>
              memory increment mode
              Defines the increment mode for each DMA transfer to the identified memory.
              In memory-to-memory mode, this field identifies the memory source if DIR = 1 and the memory destination if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.
              0: disabled
              1: enabled
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PINC</name>
              <description>
              peripheral increment mode
              Defines the increment mode for each DMA transfer to the identified peripheral.
              n memory-to-memory mode, this field identifies the memory destination if DIR = 1 and the 
              memory source if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR = 1 and 
              the peripheral source if DIR = 0.
              0: disabled
              1: enabled
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CIRC</name>
              <description>
              circular mode
              0: disabled
              1: enabled
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DIR</name>
              <description>
              data transfer direction
              This bit must be set only in memory-to-peripheral and peripheral-to-memory modes.
              0: read from peripheral
               Source attributes are defined by PSIZE and PINC, plus the CPARx register. This is still valid in a memory-to-memory mode.
               Destination attributes are defined by MSIZE and MINC, plus the CM0ARx register. This is still valid in a peripheral-to-peripheral mode.
              1: read from memory
               Destination attributes are defined by PSIZE and PINC, plus the CPARx register. This is still valid in a memory-to-memory mode.
               Source attributes are defined by MSIZE and MINC, plus the CM0ARx register. This is still valid in a peripheral-to-peripheral mode.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIE</name>
              <description>
              transfer error interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HTIE</name>
              <description>
              half transfer interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIE</name>
              <description>
              transfer complete interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EN</name>
              <description>
              channel enable
              When a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the ISR register is cleared (by setting the CTEIFx bit of the IFCR register).
              0: disabled
              1: enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CNDTR3</name>
          <displayName>CNDTR3</displayName>
          <description></description>
          <addressOffset>0x34</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>NDT</name>
              <description>
              number of data to transfer (0 to 2^16 - 1)
              This field is updated by hardware when the channel is enabled:
               It is decremented after each single DMA read followed by write transfer, indicating the remaining amount of data items to transfer.
               It is kept at zero when the programmed amount of data to transfer is reached, if the channel is not in circular mode (CIRC = 0 in the CCRx register).
               It is reloaded automatically by the previously programmed value, when the transfer is complete, if the channel is in circular mode (CIRC = 1).
              If this field is zero, no transfer can be served whatever the channel status (enabled or not).
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CPAR3</name>
          <displayName>CPAR3</displayName>
          <description></description>
          <addressOffset>0x38</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>PA</name>
              <description>
              peripheral address
              It contains the base address of the peripheral data register from/to which the data will be read/written.
              In memory-to-memory mode, this register identifies the memory destination address if DIR = 1 and the memory source address if DIR = 0.
              In peripheral-to-peripheral mode, this register identifies the peripheral destination address DIR = 1 and the peripheral source address if DIR = 0.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0AR3</name>
          <displayName>CM0AR3</displayName>
          <description></description>
          <addressOffset>0x3c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>MA</name>
              <description>
              peripheral address
              It contains the base address of the memory from/to which the data will be read/written.
              In memory-to-memory mode, this register identifies the memory source address if DIR = 1 and the memory destination address if DIR = 0.
              In peripheral-to-peripheral mode, this register identifies the peripheral source address DIR = 1 and the peripheral destination address if DIR = 0.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CBSR3</name>
          <displayName>CBSR3</displayName>
          <description></description>
          <addressOffset>0x40</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>BS</name>
              <description>
              burst size in non-m2m mode
              When BS>1, DMA will transfer for BS times for each request if left NDT is larger than BS, or else transfer for left NDT times.
              When BS=0 or 1, DMA will always do single transfer for each request.
              In memory-to-memory mode, BS is ignored.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR4</name>
          <displayName>CCR4</displayName>
          <description></description>
          <addressOffset>0x44</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
            <field>
              <name>MEM2MEM</name>
              <description>
              memory-to-memory mode
              0: disabled
              1: enabled
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PL</name>
              <description>
              priority level
              00: low
              01: medium
              10: high
              11: very high
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>MSIZE</name>
              <description>
              memory size
              Defines the data size of each DMA transfer to the identified memory.
              In memory-to-memory mode, this field identifies the memory source if DIR = 1 and the memory destination if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.
              00: 8 bits
              01: 16 bits
              10: 32 bits
              11: reserved
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>PSIZE</name>
              <description>
              peripheral size
              Defines the data size of each DMA transfer to the identified peripheral.
              In memory-to-memory mode, this field identifies the memory destination if DIR = 1 and the memory source if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR = 1 and the peripheral source if DIR = 0.
              00: 8 bits
              01: 16 bits
              10: 32 bits
              11: reserved
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>MINC</name>
              <description>
              memory increment mode
              Defines the increment mode for each DMA transfer to the identified memory.
              In memory-to-memory mode, this field identifies the memory source if DIR = 1 and the memory destination if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.
              0: disabled
              1: enabled
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PINC</name>
              <description>
              peripheral increment mode
              Defines the increment mode for each DMA transfer to the identified peripheral.
              n memory-to-memory mode, this field identifies the memory destination if DIR = 1 and the 
              memory source if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR = 1 and 
              the peripheral source if DIR = 0.
              0: disabled
              1: enabled
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CIRC</name>
              <description>
              circular mode
              0: disabled
              1: enabled
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DIR</name>
              <description>
              data transfer direction
              This bit must be set only in memory-to-peripheral and peripheral-to-memory modes.
              0: read from peripheral
               Source attributes are defined by PSIZE and PINC, plus the CPARx register. This is still valid in a memory-to-memory mode.
               Destination attributes are defined by MSIZE and MINC, plus the CM0ARx register. This is still valid in a peripheral-to-peripheral mode.
              1: read from memory
               Destination attributes are defined by PSIZE and PINC, plus the CPARx register. This is still valid in a memory-to-memory mode.
               Source attributes are defined by MSIZE and MINC, plus the CM0ARx register. This is still valid in a peripheral-to-peripheral mode.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIE</name>
              <description>
              transfer error interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HTIE</name>
              <description>
              half transfer interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIE</name>
              <description>
              transfer complete interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EN</name>
              <description>
              channel enable
              When a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the ISR register is cleared (by setting the CTEIFx bit of the IFCR register).
              0: disabled
              1: enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CNDTR4</name>
          <displayName>CNDTR4</displayName>
          <description></description>
          <addressOffset>0x48</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>NDT</name>
              <description>
              number of data to transfer (0 to 2^16 - 1)
              This field is updated by hardware when the channel is enabled:
               It is decremented after each single DMA read followed by write transfer, indicating the remaining amount of data items to transfer.
               It is kept at zero when the programmed amount of data to transfer is reached, if the channel is not in circular mode (CIRC = 0 in the CCRx register).
               It is reloaded automatically by the previously programmed value, when the transfer is complete, if the channel is in circular mode (CIRC = 1).
              If this field is zero, no transfer can be served whatever the channel status (enabled or not).
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CPAR4</name>
          <displayName>CPAR4</displayName>
          <description></description>
          <addressOffset>0x4c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>PA</name>
              <description>
              peripheral address
              It contains the base address of the peripheral data register from/to which the data will be read/written.
              In memory-to-memory mode, this register identifies the memory destination address if DIR = 1 and the memory source address if DIR = 0.
              In peripheral-to-peripheral mode, this register identifies the peripheral destination address DIR = 1 and the peripheral source address if DIR = 0.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0AR4</name>
          <displayName>CM0AR4</displayName>
          <description></description>
          <addressOffset>0x50</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>MA</name>
              <description>
              peripheral address
              It contains the base address of the memory from/to which the data will be read/written.
              In memory-to-memory mode, this register identifies the memory source address if DIR = 1 and the memory destination address if DIR = 0.
              In peripheral-to-peripheral mode, this register identifies the peripheral source address DIR = 1 and the peripheral destination address if DIR = 0.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CBSR4</name>
          <displayName>CBSR4</displayName>
          <description></description>
          <addressOffset>0x54</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>BS</name>
              <description>
              burst size in non-m2m mode
              When BS>1, DMA will transfer for BS times for each request if left NDT is larger than BS, or else transfer for left NDT times.
              When BS=0 or 1, DMA will always do single transfer for each request.
              In memory-to-memory mode, BS is ignored.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR5</name>
          <displayName>CCR5</displayName>
          <description></description>
          <addressOffset>0x58</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
            <field>
              <name>MEM2MEM</name>
              <description>
              memory-to-memory mode
              0: disabled
              1: enabled
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PL</name>
              <description>
              priority level
              00: low
              01: medium
              10: high
              11: very high
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>MSIZE</name>
              <description>
              memory size
              Defines the data size of each DMA transfer to the identified memory.
              In memory-to-memory mode, this field identifies the memory source if DIR = 1 and the memory destination if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.
              00: 8 bits
              01: 16 bits
              10: 32 bits
              11: reserved
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>PSIZE</name>
              <description>
              peripheral size
              Defines the data size of each DMA transfer to the identified peripheral.
              In memory-to-memory mode, this field identifies the memory destination if DIR = 1 and the memory source if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR = 1 and the peripheral source if DIR = 0.
              00: 8 bits
              01: 16 bits
              10: 32 bits
              11: reserved
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>MINC</name>
              <description>
              memory increment mode
              Defines the increment mode for each DMA transfer to the identified memory.
              In memory-to-memory mode, this field identifies the memory source if DIR = 1 and the memory destination if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.
              0: disabled
              1: enabled
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PINC</name>
              <description>
              peripheral increment mode
              Defines the increment mode for each DMA transfer to the identified peripheral.
              n memory-to-memory mode, this field identifies the memory destination if DIR = 1 and the 
              memory source if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR = 1 and 
              the peripheral source if DIR = 0.
              0: disabled
              1: enabled
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CIRC</name>
              <description>
              circular mode
              0: disabled
              1: enabled
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DIR</name>
              <description>
              data transfer direction
              This bit must be set only in memory-to-peripheral and peripheral-to-memory modes.
              0: read from peripheral
               Source attributes are defined by PSIZE and PINC, plus the CPARx register. This is still valid in a memory-to-memory mode.
               Destination attributes are defined by MSIZE and MINC, plus the CM0ARx register. This is still valid in a peripheral-to-peripheral mode.
              1: read from memory
               Destination attributes are defined by PSIZE and PINC, plus the CPARx register. This is still valid in a memory-to-memory mode.
               Source attributes are defined by MSIZE and MINC, plus the CM0ARx register. This is still valid in a peripheral-to-peripheral mode.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIE</name>
              <description>
              transfer error interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HTIE</name>
              <description>
              half transfer interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIE</name>
              <description>
              transfer complete interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EN</name>
              <description>
              channel enable
              When a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the ISR register is cleared (by setting the CTEIFx bit of the IFCR register).
              0: disabled
              1: enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CNDTR5</name>
          <displayName>CNDTR5</displayName>
          <description></description>
          <addressOffset>0x5c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>NDT</name>
              <description>
              number of data to transfer (0 to 2^16 - 1)
              This field is updated by hardware when the channel is enabled:
               It is decremented after each single DMA read followed by write transfer, indicating the remaining amount of data items to transfer.
               It is kept at zero when the programmed amount of data to transfer is reached, if the channel is not in circular mode (CIRC = 0 in the CCRx register).
               It is reloaded automatically by the previously programmed value, when the transfer is complete, if the channel is in circular mode (CIRC = 1).
              If this field is zero, no transfer can be served whatever the channel status (enabled or not).
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CPAR5</name>
          <displayName>CPAR5</displayName>
          <description></description>
          <addressOffset>0x60</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>PA</name>
              <description>
              peripheral address
              It contains the base address of the peripheral data register from/to which the data will be read/written.
              In memory-to-memory mode, this register identifies the memory destination address if DIR = 1 and the memory source address if DIR = 0.
              In peripheral-to-peripheral mode, this register identifies the peripheral destination address DIR = 1 and the peripheral source address if DIR = 0.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0AR5</name>
          <displayName>CM0AR5</displayName>
          <description></description>
          <addressOffset>0x64</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>MA</name>
              <description>
              peripheral address
              It contains the base address of the memory from/to which the data will be read/written.
              In memory-to-memory mode, this register identifies the memory source address if DIR = 1 and the memory destination address if DIR = 0.
              In peripheral-to-peripheral mode, this register identifies the peripheral source address DIR = 1 and the peripheral destination address if DIR = 0.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CBSR5</name>
          <displayName>CBSR5</displayName>
          <description></description>
          <addressOffset>0x68</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>BS</name>
              <description>
              burst size in non-m2m mode
              When BS>1, DMA will transfer for BS times for each request if left NDT is larger than BS, or else transfer for left NDT times.
              When BS=0 or 1, DMA will always do single transfer for each request.
              In memory-to-memory mode, BS is ignored.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR6</name>
          <displayName>CCR6</displayName>
          <description></description>
          <addressOffset>0x6c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
            <field>
              <name>MEM2MEM</name>
              <description>
              memory-to-memory mode
              0: disabled
              1: enabled
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PL</name>
              <description>
              priority level
              00: low
              01: medium
              10: high
              11: very high
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>MSIZE</name>
              <description>
              memory size
              Defines the data size of each DMA transfer to the identified memory.
              In memory-to-memory mode, this field identifies the memory source if DIR = 1 and the memory destination if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.
              00: 8 bits
              01: 16 bits
              10: 32 bits
              11: reserved
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>PSIZE</name>
              <description>
              peripheral size
              Defines the data size of each DMA transfer to the identified peripheral.
              In memory-to-memory mode, this field identifies the memory destination if DIR = 1 and the memory source if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR = 1 and the peripheral source if DIR = 0.
              00: 8 bits
              01: 16 bits
              10: 32 bits
              11: reserved
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>MINC</name>
              <description>
              memory increment mode
              Defines the increment mode for each DMA transfer to the identified memory.
              In memory-to-memory mode, this field identifies the memory source if DIR = 1 and the memory destination if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.
              0: disabled
              1: enabled
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PINC</name>
              <description>
              peripheral increment mode
              Defines the increment mode for each DMA transfer to the identified peripheral.
              n memory-to-memory mode, this field identifies the memory destination if DIR = 1 and the 
              memory source if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR = 1 and 
              the peripheral source if DIR = 0.
              0: disabled
              1: enabled
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CIRC</name>
              <description>
              circular mode
              0: disabled
              1: enabled
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DIR</name>
              <description>
              data transfer direction
              This bit must be set only in memory-to-peripheral and peripheral-to-memory modes.
              0: read from peripheral
               Source attributes are defined by PSIZE and PINC, plus the CPARx register. This is still valid in a memory-to-memory mode.
               Destination attributes are defined by MSIZE and MINC, plus the CM0ARx register. This is still valid in a peripheral-to-peripheral mode.
              1: read from memory
               Destination attributes are defined by PSIZE and PINC, plus the CPARx register. This is still valid in a memory-to-memory mode.
               Source attributes are defined by MSIZE and MINC, plus the CM0ARx register. This is still valid in a peripheral-to-peripheral mode.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIE</name>
              <description>
              transfer error interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HTIE</name>
              <description>
              half transfer interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIE</name>
              <description>
              transfer complete interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EN</name>
              <description>
              channel enable
              When a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the ISR register is cleared (by setting the CTEIFx bit of the IFCR register).
              0: disabled
              1: enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CNDTR6</name>
          <displayName>CNDTR6</displayName>
          <description></description>
          <addressOffset>0x70</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>NDT</name>
              <description>
              number of data to transfer (0 to 2^16 - 1)
              This field is updated by hardware when the channel is enabled:
               It is decremented after each single DMA read followed by write transfer, indicating the remaining amount of data items to transfer.
               It is kept at zero when the programmed amount of data to transfer is reached, if the channel is not in circular mode (CIRC = 0 in the CCRx register).
               It is reloaded automatically by the previously programmed value, when the transfer is complete, if the channel is in circular mode (CIRC = 1).
              If this field is zero, no transfer can be served whatever the channel status (enabled or not).
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CPAR6</name>
          <displayName>CPAR6</displayName>
          <description></description>
          <addressOffset>0x74</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>PA</name>
              <description>
              peripheral address
              It contains the base address of the peripheral data register from/to which the data will be read/written.
              In memory-to-memory mode, this register identifies the memory destination address if DIR = 1 and the memory source address if DIR = 0.
              In peripheral-to-peripheral mode, this register identifies the peripheral destination address DIR = 1 and the peripheral source address if DIR = 0.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0AR6</name>
          <displayName>CM0AR6</displayName>
          <description></description>
          <addressOffset>0x78</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>MA</name>
              <description>
              peripheral address
              It contains the base address of the memory from/to which the data will be read/written.
              In memory-to-memory mode, this register identifies the memory source address if DIR = 1 and the memory destination address if DIR = 0.
              In peripheral-to-peripheral mode, this register identifies the peripheral source address DIR = 1 and the peripheral destination address if DIR = 0.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CBSR6</name>
          <displayName>CBSR6</displayName>
          <description></description>
          <addressOffset>0x7c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>BS</name>
              <description>
              burst size in non-m2m mode
              When BS>1, DMA will transfer for BS times for each request if left NDT is larger than BS, or else transfer for left NDT times.
              When BS=0 or 1, DMA will always do single transfer for each request.
              In memory-to-memory mode, BS is ignored.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR7</name>
          <displayName>CCR7</displayName>
          <description></description>
          <addressOffset>0x80</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
            <field>
              <name>MEM2MEM</name>
              <description>
              memory-to-memory mode
              0: disabled
              1: enabled
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PL</name>
              <description>
              priority level
              00: low
              01: medium
              10: high
              11: very high
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>MSIZE</name>
              <description>
              memory size
              Defines the data size of each DMA transfer to the identified memory.
              In memory-to-memory mode, this field identifies the memory source if DIR = 1 and the memory destination if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.
              00: 8 bits
              01: 16 bits
              10: 32 bits
              11: reserved
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>PSIZE</name>
              <description>
              peripheral size
              Defines the data size of each DMA transfer to the identified peripheral.
              In memory-to-memory mode, this field identifies the memory destination if DIR = 1 and the memory source if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR = 1 and the peripheral source if DIR = 0.
              00: 8 bits
              01: 16 bits
              10: 32 bits
              11: reserved
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>MINC</name>
              <description>
              memory increment mode
              Defines the increment mode for each DMA transfer to the identified memory.
              In memory-to-memory mode, this field identifies the memory source if DIR = 1 and the memory destination if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.
              0: disabled
              1: enabled
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PINC</name>
              <description>
              peripheral increment mode
              Defines the increment mode for each DMA transfer to the identified peripheral.
              n memory-to-memory mode, this field identifies the memory destination if DIR = 1 and the 
              memory source if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR = 1 and 
              the peripheral source if DIR = 0.
              0: disabled
              1: enabled
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CIRC</name>
              <description>
              circular mode
              0: disabled
              1: enabled
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DIR</name>
              <description>
              data transfer direction
              This bit must be set only in memory-to-peripheral and peripheral-to-memory modes.
              0: read from peripheral
               Source attributes are defined by PSIZE and PINC, plus the CPARx register. This is still valid in a memory-to-memory mode.
               Destination attributes are defined by MSIZE and MINC, plus the CM0ARx register. This is still valid in a peripheral-to-peripheral mode.
              1: read from memory
               Destination attributes are defined by PSIZE and PINC, plus the CPARx register. This is still valid in a memory-to-memory mode.
               Source attributes are defined by MSIZE and MINC, plus the CM0ARx register. This is still valid in a peripheral-to-peripheral mode.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIE</name>
              <description>
              transfer error interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HTIE</name>
              <description>
              half transfer interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIE</name>
              <description>
              transfer complete interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EN</name>
              <description>
              channel enable
              When a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the ISR register is cleared (by setting the CTEIFx bit of the IFCR register).
              0: disabled
              1: enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CNDTR7</name>
          <displayName>CNDTR7</displayName>
          <description></description>
          <addressOffset>0x84</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>NDT</name>
              <description>
              number of data to transfer (0 to 2^16 - 1)
              This field is updated by hardware when the channel is enabled:
               It is decremented after each single DMA read followed by write transfer, indicating the remaining amount of data items to transfer.
               It is kept at zero when the programmed amount of data to transfer is reached, if the channel is not in circular mode (CIRC = 0 in the CCRx register).
               It is reloaded automatically by the previously programmed value, when the transfer is complete, if the channel is in circular mode (CIRC = 1).
              If this field is zero, no transfer can be served whatever the channel status (enabled or not).
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CPAR7</name>
          <displayName>CPAR7</displayName>
          <description></description>
          <addressOffset>0x88</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>PA</name>
              <description>
              peripheral address
              It contains the base address of the peripheral data register from/to which the data will be read/written.
              In memory-to-memory mode, this register identifies the memory destination address if DIR = 1 and the memory source address if DIR = 0.
              In peripheral-to-peripheral mode, this register identifies the peripheral destination address DIR = 1 and the peripheral source address if DIR = 0.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0AR7</name>
          <displayName>CM0AR7</displayName>
          <description></description>
          <addressOffset>0x8c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>MA</name>
              <description>
              peripheral address
              It contains the base address of the memory from/to which the data will be read/written.
              In memory-to-memory mode, this register identifies the memory source address if DIR = 1 and the memory destination address if DIR = 0.
              In peripheral-to-peripheral mode, this register identifies the peripheral source address DIR = 1 and the peripheral destination address if DIR = 0.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CBSR7</name>
          <displayName>CBSR7</displayName>
          <description></description>
          <addressOffset>0x90</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>BS</name>
              <description>
              burst size in non memory-to-memory mode
              When BS>1, DMA will transfer for BS times for each request if left NDT is larger than BS, or else transfer for left NDT times.
              When BS=0 or 1, DMA will always do single transfer for each request.
              In memory-to-memory mode, BS is ignored.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR8</name>
          <displayName>CCR8</displayName>
          <description></description>
          <addressOffset>0x94</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
            <field>
              <name>MEM2MEM</name>
              <description>
              memory-to-memory mode
              0: disabled
              1: enabled
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PL</name>
              <description>
              priority level
              00: low
              01: medium
              10: high
              11: very high
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>MSIZE</name>
              <description>
              memory size
              Defines the data size of each DMA transfer to the identified memory.
              In memory-to-memory mode, this field identifies the memory source if DIR = 1 and the memory destination if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.
              00: 8 bits
              01: 16 bits
              10: 32 bits
              11: reserved
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>PSIZE</name>
              <description>
              peripheral size
              Defines the data size of each DMA transfer to the identified peripheral.
              In memory-to-memory mode, this field identifies the memory destination if DIR = 1 and the memory source if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR = 1 and the peripheral source if DIR = 0.
              00: 8 bits
              01: 16 bits
              10: 32 bits
              11: reserved
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>MINC</name>
              <description>
              memory increment mode
              Defines the increment mode for each DMA transfer to the identified memory.
              In memory-to-memory mode, this field identifies the memory source if DIR = 1 and the memory destination if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.
              0: disabled
              1: enabled
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PINC</name>
              <description>
              peripheral increment mode
              Defines the increment mode for each DMA transfer to the identified peripheral.
              n memory-to-memory mode, this field identifies the memory destination if DIR = 1 and the 
              memory source if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR = 1 and 
              the peripheral source if DIR = 0.
              0: disabled
              1: enabled
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CIRC</name>
              <description>
              circular mode
              0: disabled
              1: enabled
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DIR</name>
              <description>
              data transfer direction
              This bit must be set only in memory-to-peripheral and peripheral-to-memory modes.
              0: read from peripheral
               Source attributes are defined by PSIZE and PINC, plus the CPARx register. This is still valid in a memory-to-memory mode.
               Destination attributes are defined by MSIZE and MINC, plus the CM0ARx register. This is still valid in a peripheral-to-peripheral mode.
              1: read from memory
               Destination attributes are defined by PSIZE and PINC, plus the CPARx register. This is still valid in a memory-to-memory mode.
               Source attributes are defined by MSIZE and MINC, plus the CM0ARx register. This is still valid in a peripheral-to-peripheral mode.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIE</name>
              <description>
              transfer error interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HTIE</name>
              <description>
              half transfer interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIE</name>
              <description>
              transfer complete interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EN</name>
              <description>
              channel enable
              When a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the ISR register is cleared (by setting the CTEIFx bit of the IFCR register).
              0: disabled
              1: enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CNDTR8</name>
          <displayName>CNDTR8</displayName>
          <description></description>
          <addressOffset>0x98</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>NDT</name>
              <description>
              number of data to transfer (0 to 2^16 - 1)
              This field is updated by hardware when the channel is enabled:
               It is decremented after each single DMA read followed by write transfer, indicating the remaining amount of data items to transfer.
               It is kept at zero when the programmed amount of data to transfer is reached, if the channel is not in circular mode (CIRC = 0 in the CCRx register).
               It is reloaded automatically by the previously programmed value, when the transfer is complete, if the channel is in circular mode (CIRC = 1).
              If this field is zero, no transfer can be served whatever the channel status (enabled or not).
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CPAR8</name>
          <displayName>CPAR8</displayName>
          <description></description>
          <addressOffset>0x9c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>PA</name>
              <description>
              peripheral address
              It contains the base address of the peripheral data register from/to which the data will be read/written.
              In memory-to-memory mode, this register identifies the memory destination address if DIR = 1 and the memory source address if DIR = 0.
              In peripheral-to-peripheral mode, this register identifies the peripheral destination address DIR = 1 and the peripheral source address if DIR = 0.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0AR8</name>
          <displayName>CM0AR8</displayName>
          <description></description>
          <addressOffset>0xa0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>MA</name>
              <description>
              peripheral address
              It contains the base address of the memory from/to which the data will be read/written.
              In memory-to-memory mode, this register identifies the memory source address if DIR = 1 and the memory destination address if DIR = 0.
              In peripheral-to-peripheral mode, this register identifies the peripheral source address DIR = 1 and the peripheral destination address if DIR = 0.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CBSR8</name>
          <displayName>CBSR8</displayName>
          <description></description>
          <addressOffset>0xa4</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>BS</name>
              <description>
              burst size in non-m2m mode
              When BS>1, DMA will transfer for BS times for each request if left NDT is larger than BS, or else transfer for left NDT times.
              When BS=0 or 1, DMA will always do single transfer for each request.
              In memory-to-memory mode, BS is ignored.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CSELR1</name>
          <displayName>CSELR1</displayName>
          <description></description>
          <addressOffset>0xa8</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>C4S</name>
              <description>
              DMA channel 4 selection
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>C3S</name>
              <description>
              DMA channel 3 selection
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>C2S</name>
              <description>
              DMA channel 2 selection
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>C1S</name>
              <description>
              DMA channel 1 selection
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CSELR2</name>
          <displayName>CSELR2</displayName>
          <description></description>
          <addressOffset>0xac</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>C8S</name>
              <description>
              DMA channel 8 selection
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>C7S</name>
              <description>
              DMA channel 7 selection
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>C6S</name>
              <description>
              DMA channel 6 selection
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>C5S</name>
              <description>
              DMA channel 5 selection
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>USART1</name>
      <description></description>
      <groupName>USART</groupName>
      <baseAddress>0x50084000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CR1</name>
          <displayName>CR1</displayName>
          <description>Control Register 1</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>M</name>
              <description>
              0 - 6bit, 1 - 7bit, 2 - 8bit, 3 - 9bit (including data bits and parity)
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
            <field>
              <name>OVER8</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>PCE</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PEIE</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TXEIE</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIE</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RXNEIE</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IDLEIE</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TE</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RE</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UE</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CR2</name>
          <displayName>CR2</displayName>
          <description>Control Register 2</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>18</bitWidth>
            </field>
            <field>
              <name>STOP</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CR3</name>
          <displayName>CR3</displayName>
          <description>Control Register 3</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>19</bitWidth>
            </field>
            <field>
              <name>OVRDIS</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ONEBIT</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTSIE</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTSE</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RTSE</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMAT</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMAR</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>EIE</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BRR</name>
          <displayName>BRR</displayName>
          <description>Baud Rate Register</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>INT</name>
              <description>
              Baud Rate = UCLK / (int+ frac/16) / 16
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
            <field>
              <name>FRAC</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>GTPR</name>
          <displayName>GTPR</displayName>
          <description></description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RTOR</name>
          <displayName>RTOR</displayName>
          <description></description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RQR</name>
          <displayName>RQR</displayName>
          <description>Request Register</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>27</bitWidth>
            </field>
            <field>
              <name>TXFRQ</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RXFRQ</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ISR</name>
          <displayName>ISR</displayName>
          <description>Interrupt and Status Register</description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>21</bitWidth>
            </field>
            <field>
              <name>CTS</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTSIF</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TXE</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TC</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RXNE</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IDLE</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ORE</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>NF</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FE</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ICR</name>
          <displayName>ICR</displayName>
          <description>Interrupt flag Clear Register</description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>22</bitWidth>
            </field>
            <field>
              <name>CTSCF</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>TCCF</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IDLECF</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ORECF</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>NCF</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FECF</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PECF</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RDR</name>
          <displayName>RDR</displayName>
          <description>Receive Data Register</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>RDR</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TDR</name>
          <displayName>TDR</displayName>
          <description>Transmit Data Register</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>TDR</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>MISCR</name>
          <displayName>MISCR</displayName>
          <description>Miscellaneous Register</description>
          <addressOffset>0x2c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>AUTOCAL</name>
              <description>
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>RTSBIT</name>
              <description>
              assert RTS ahead of the frame completion (in number of bits)
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>SMPLINI</name>
              <description>
              initial sample count, count down from this value to zero to reach the middle of the start bit in Rx
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DRDR</name>
          <displayName>DRDR</displayName>
          <description></description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DTDR</name>
          <displayName>DTDR</displayName>
          <description></description>
          <addressOffset>0x34</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>EXR</name>
          <displayName>EXR</displayName>
          <description></description>
          <addressOffset>0x38</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>USART2</name>
      <description></description>
      <groupName>USART</groupName>
      <baseAddress>0x50085000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CR1</name>
          <displayName>CR1</displayName>
          <description>Control Register 1</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>M</name>
              <description>
              0 - 6bit, 1 - 7bit, 2 - 8bit, 3 - 9bit (including data bits and parity)
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
            <field>
              <name>OVER8</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>PCE</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PEIE</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TXEIE</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIE</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RXNEIE</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IDLEIE</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TE</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RE</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UE</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CR2</name>
          <displayName>CR2</displayName>
          <description>Control Register 2</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>18</bitWidth>
            </field>
            <field>
              <name>STOP</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CR3</name>
          <displayName>CR3</displayName>
          <description>Control Register 3</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>19</bitWidth>
            </field>
            <field>
              <name>OVRDIS</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ONEBIT</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTSIE</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTSE</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RTSE</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMAT</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMAR</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>EIE</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BRR</name>
          <displayName>BRR</displayName>
          <description>Baud Rate Register</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>INT</name>
              <description>
              Baud Rate = UCLK / (int+ frac/16) / 16
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
            <field>
              <name>FRAC</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>GTPR</name>
          <displayName>GTPR</displayName>
          <description></description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RTOR</name>
          <displayName>RTOR</displayName>
          <description></description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RQR</name>
          <displayName>RQR</displayName>
          <description>Request Register</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>27</bitWidth>
            </field>
            <field>
              <name>TXFRQ</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RXFRQ</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ISR</name>
          <displayName>ISR</displayName>
          <description>Interrupt and Status Register</description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>21</bitWidth>
            </field>
            <field>
              <name>CTS</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTSIF</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TXE</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TC</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RXNE</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IDLE</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ORE</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>NF</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FE</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ICR</name>
          <displayName>ICR</displayName>
          <description>Interrupt flag Clear Register</description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>22</bitWidth>
            </field>
            <field>
              <name>CTSCF</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>TCCF</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IDLECF</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ORECF</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>NCF</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FECF</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PECF</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RDR</name>
          <displayName>RDR</displayName>
          <description>Receive Data Register</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>RDR</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TDR</name>
          <displayName>TDR</displayName>
          <description>Transmit Data Register</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>TDR</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>MISCR</name>
          <displayName>MISCR</displayName>
          <description>Miscellaneous Register</description>
          <addressOffset>0x2c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>AUTOCAL</name>
              <description>
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>RTSBIT</name>
              <description>
              assert RTS ahead of the frame completion (in number of bits)
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>SMPLINI</name>
              <description>
              initial sample count, count down from this value to zero to reach the middle of the start bit in Rx
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DRDR</name>
          <displayName>DRDR</displayName>
          <description></description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DTDR</name>
          <displayName>DTDR</displayName>
          <description></description>
          <addressOffset>0x34</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>EXR</name>
          <displayName>EXR</displayName>
          <description></description>
          <addressOffset>0x38</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>USART3</name>
      <description></description>
      <groupName>USART</groupName>
      <baseAddress>0x50086000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CR1</name>
          <displayName>CR1</displayName>
          <description>Control Register 1</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>M</name>
              <description>
              0 - 6bit, 1 - 7bit, 2 - 8bit, 3 - 9bit (including data bits and parity)
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
            <field>
              <name>OVER8</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>PCE</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PEIE</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TXEIE</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIE</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RXNEIE</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IDLEIE</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TE</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RE</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UE</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CR2</name>
          <displayName>CR2</displayName>
          <description>Control Register 2</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>18</bitWidth>
            </field>
            <field>
              <name>STOP</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CR3</name>
          <displayName>CR3</displayName>
          <description>Control Register 3</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>19</bitWidth>
            </field>
            <field>
              <name>OVRDIS</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ONEBIT</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTSIE</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTSE</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RTSE</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMAT</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMAR</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>EIE</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BRR</name>
          <displayName>BRR</displayName>
          <description>Baud Rate Register</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>INT</name>
              <description>
              Baud Rate = UCLK / (int+ frac/16) / 16
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
            <field>
              <name>FRAC</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>GTPR</name>
          <displayName>GTPR</displayName>
          <description></description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RTOR</name>
          <displayName>RTOR</displayName>
          <description></description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RQR</name>
          <displayName>RQR</displayName>
          <description>Request Register</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>27</bitWidth>
            </field>
            <field>
              <name>TXFRQ</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RXFRQ</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ISR</name>
          <displayName>ISR</displayName>
          <description>Interrupt and Status Register</description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>21</bitWidth>
            </field>
            <field>
              <name>CTS</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTSIF</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TXE</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TC</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RXNE</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IDLE</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ORE</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>NF</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FE</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ICR</name>
          <displayName>ICR</displayName>
          <description>Interrupt flag Clear Register</description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>22</bitWidth>
            </field>
            <field>
              <name>CTSCF</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>TCCF</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IDLECF</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ORECF</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>NCF</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FECF</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PECF</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RDR</name>
          <displayName>RDR</displayName>
          <description>Receive Data Register</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>RDR</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TDR</name>
          <displayName>TDR</displayName>
          <description>Transmit Data Register</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>TDR</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>MISCR</name>
          <displayName>MISCR</displayName>
          <description>Miscellaneous Register</description>
          <addressOffset>0x2c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>AUTOCAL</name>
              <description>
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>RTSBIT</name>
              <description>
              assert RTS ahead of the frame completion (in number of bits)
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>SMPLINI</name>
              <description>
              initial sample count, count down from this value to zero to reach the middle of the start bit in Rx
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DRDR</name>
          <displayName>DRDR</displayName>
          <description></description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DTDR</name>
          <displayName>DTDR</displayName>
          <description></description>
          <addressOffset>0x34</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>EXR</name>
          <displayName>EXR</displayName>
          <description></description>
          <addressOffset>0x38</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>BTIM1</name>
      <description></description>
      <groupName>BTIM</groupName>
      <baseAddress>0x50092000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CR1</name>
          <displayName>CR1</displayName>
          <description>TIM control register 1</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>ARPE</name>
              <description>
              Auto-reload preload enable
              0: ARR register is not buffered
              1: ARR register is buffered
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>OPM</name>
              <description>
              One-pulse mode
              0: Counter is not stopped at update event
              1: Counter stops counting at the next update event (clearing the bit CEN)
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>URS</name>
              <description>
              Update request source
              This bit is set and cleared by software to select the UEV event sources.
              0: Any of the following events generate an update interrupt or DMA request if enabled. 
              These events can be: 
               Counter overflow
               Setting the UG bit
               Update generation through the slave mode controller
              1: Only counter overflow generates an update interrupt or DMA request if enabled.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UDIS</name>
              <description>
              Update disable
              This bit is set and cleared by software to enable/disable UEV event generation.
              0: UEV enabled. The Update (UEV) event is generated by one of the following events:
               Counter overflow
               Setting the UG bit
               Update generation through the slave mode controller
              Buffered registers are then loaded with their preload values.
              1: UEV disabled. The Update event is not generated, shadow registers keep their value (ARR, PSC). However the counter and the prescaler are reinitialized if the UG bit is set or if a hardware reset is received from the slave mode controller.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CEN</name>
              <description>
              Counter enable
              0: Counter disabled
              1: Counter enabled
              Note: Gated mode can work only if the CEN bit has been previously set by software. However trigger mode can set the CEN bit automatically by hardware. 
              CEN is cleared automatically in one-pulse mode, when an update event occurs.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CR2</name>
          <displayName>CR2</displayName>
          <description>TIM control register 2</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>26</bitWidth>
            </field>
            <field>
              <name>MMS</name>
              <description>
              Master mode selection
              These bits allow to select the information to be sent in master mode to slave timers for synchronization (TRGO). The combination is as follows:
              00: Reset - the UG bit from the EGR register is used as trigger output (TRGO). If the reset is generated by the trigger input (slave mode controller configured in reset mode) then the signal on TRGO is delayed compared to the actual reset.
              01: Enable - the Counter enable signal, CNT_EN, is used as trigger output (TRGO). It is useful to start several timers at the same time or to control a window in which a slave timer is enabled. The Counter Enable signal is generated by a logic OR between CEN control bit and the trigger input when configured in gated mode. 
              When the Counter Enable signal is controlled by the trigger input, there is a delay on TRGO, except if the master/slave mode is selected (see the MSM bit description in SMCR register).
              10: Update - The update event is selected as trigger output (TRGO). For instance a master timer can then be used as a prescaler for a slave timer.
              11: Gating - The delayed gating trigger is selected as trigger output (TRGO). 
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SMCR</name>
          <displayName>SMCR</displayName>
          <description>TIM slave mode control register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>GM</name>
              <description>
              Gated Mode. The counter clock is enabled when the selected trigger input (TRGI) is active (according to gating trigger polarity). The counter stops (but is not reset) as soon as the trigger becomes inactive. Both start and stop of the counter are controlled. Gated mode and slave mode can be enabled simutanuously with different trigger selection.
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GTP</name>
              <description>
              Gating trigger polarity invert
              0: active at high level
              1: active at low level
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GTS</name>
              <description>
              Gating trigger selection in gated mode
              This bit-field selects the trigger input to be used to enable the counter gating.
              00: Internal Trigger 0 (ITR0)
              01: Internal Trigger 1 (ITR1) 
              10: Internal Trigger 2 (ITR2)
              11: Internal Trigger 3 (ITR3)
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SMS</name>
              <description>
              Slave mode selection
              When external signals are selected the active edge of the trigger signal (TRGI) is linked to the polarity selected on the external input.
              000: Slave mode disabled.
              001: Reset Mode - Rising edge of the selected trigger input (TRGI) reinitializes the counter and generates an update of the registers.
              010: Trigger Mode - The counter starts at a rising edge of the trigger TRGI (but it is not reset). Only the start of the counter is controlled.
              011: Combined reset + trigger mode - Rising edge of the selected trigger input (TRGI) reinitializes the counter, generates an update of the registers and starts the counter.
              100: External Clock Mode - Rising edges of the selected trigger (TRGI) clock the counter.
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>MSM</name>
              <description>
              Master/Slave mode. This bit should be asserted on master timer if synchronization if needed.
              0: No action
              1: The effect of an event on the trigger input (TRGI) is delayed to allow a perfect synchronization between the current timer and its slaves (through TRGO). It is useful if we want to synchronize several timers on a single external event.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TS</name>
              <description>
              Trigger selection
              This bit-field selects the trigger input to be used to synchronize the counter.
              00: Internal Trigger 0 (ITR0)
              01: Internal Trigger 1 (ITR1) 
              10: Internal Trigger 2 (ITR2)
              11: Internal Trigger 3 (ITR3)
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD5</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DIER</name>
          <displayName>DIER</displayName>
          <description>TIM DMA/Interrupt enable register</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>UDE</name>
              <description>
              Update DMA request enable
              0: Update DMA request disabled.
              1: Update DMA request enabled
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
            <field>
              <name>UIE</name>
              <description>
              Update interrupt enable
              0: Update interrupt disabled.
              1: Update interrupt enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SR</name>
          <displayName>SR</displayName>
          <description>TIM status register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>31</bitWidth>
            </field>
            <field>
              <name>UIF</name>
              <description>
              Update interrupt flag
              This bit is set by hardware on an update event. It is cleared by software.
              0: No update occurred
              1: Update interrupt pending. This bit is set by hardware when the registers are updated:
              At overflow and if UDIS=0 in the CR1 register.
              When CNT is reinitialized by software using the UG bit in EGR register, if URS=0 and UDIS=0 in the CR1 register.
              When CNT is reinitialized by a trigger event (refer to the synchro control register description), if URS=0 and UDIS=0 in the CR1 register.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>EGR</name>
          <displayName>EGR</displayName>
          <description>Event generation register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>31</bitWidth>
            </field>
            <field>
              <name>UG</name>
              <description>
              Update generation
              This bit can be set by software, it is automatically cleared by hardware.
              0: No action
              1: Re-initialize the counter and generates an update of the registers. Note that the prescaler counter is cleared too (anyway the prescaler ratio is not affected). The counter is cleared if the center-aligned mode is selected or if DIR=0 (upcounting), else it takes the auto-reload value (ARR) if DIR=1 (downcounting).
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD1</name>
          <displayName>RSVD1</displayName>
          <description></description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>CNT</name>
          <displayName>CNT</displayName>
          <description>Counter</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>CNT</name>
              <description>
              counter value
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PSC</name>
          <displayName>PSC</displayName>
          <description>Prescaler</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>PSC</name>
              <description>
              Prescaler value
              The counter clock frequency is equal to fCLK / (PSC[15:0] + 1).
              PSC contains the value to be loaded in the active prescaler register at each update event (including when the counter is cleared through UG bit of EGR register or through trigger controller when configured in reset mode).
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ARR</name>
          <displayName>ARR</displayName>
          <description>Auto-reload register</description>
          <addressOffset>0x2c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ARR</name>
              <description>
              Auto-reload value
              ARR is the value to be loaded in the actual auto-reload register. The counter is blocked while the auto-reload value is null.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>WDT1</name>
      <description></description>
      <groupName>WDT</groupName>
      <baseAddress>0x50094000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>WDT_CVR0</name>
          <displayName>WDT_CVR0</displayName>
          <description>WatchDog Counter Value 0</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>COUNT_VALUE_0</name>
              <description>
              Count Value for 1st TimeOut
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_CVR1</name>
          <displayName>WDT_CVR1</displayName>
          <description>WatchDog Counter Value 1</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>COUNT_VALUE_1</name>
              <description>
              Count Value for 2nd TimeOut
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_CR</name>
          <displayName>WDT_CR</displayName>
          <description>WatchDog Control Register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>27</bitWidth>
            </field>
            <field>
              <name>RESPONSE_MODE</name>
              <description>
              0:reset only, 1:interrupt and reset
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RESET_LENGTH</name>
              <description>
              reset pulse length in number of wdt clock cycles
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_CCR</name>
          <displayName>WDT_CCR</displayName>
          <description>WatchDog Counter Control Register</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>COUNTER_CONTROL</name>
              <description>
              SinglePulse /Write 8'h76 to restart, write8'h34 to stop, else do nothing
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_ICR</name>
          <displayName>WDT_ICR</displayName>
          <description>WatchDog Interrupt Clear Register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>31</bitWidth>
            </field>
            <field>
              <name>INT_CLR</name>
              <description>
              SinglePulse /A pulse to clear interrupt
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_SR</name>
          <displayName>WDT_SR</displayName>
          <description>WatchDog Status Register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>30</bitWidth>
            </field>
            <field>
              <name>WDT_ACTIVE</name>
              <description>
              Watchdog runs when 1, else 0
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>INT_ASSERT</name>
              <description>
              Interrupt assert when 1
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_WP</name>
          <displayName>WDT_WP</displayName>
          <description>WatchDog Write Protect Register</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>WRPT_ST</name>
              <description>
              1 indicates write protect is active
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>WRPT</name>
              <description>
              write 0x58ab99fc generate write_protect, write 0x51ff8621 to release
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>31</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_FG</name>
          <displayName>WDT_FG</displayName>
          <description>WatchDog Flag Register</description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>28</bitWidth>
            </field>
            <field>
              <name>SYNC_FG</name>
              <description>
              1 indicates one transition from system clk to wdt clk has complicated
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SYNC_FG_CLR</name>
              <description>
              SinglePulse/A pulse to clear sync flag
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RST_FG</name>
              <description>
              1 indicates wdt has already reset system
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RST_FG_CLR</name>
              <description>
              SinglePulse/A pulse to clear reset flag
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>SPI1</name>
      <description></description>
      <groupName>SPI</groupName>
      <baseAddress>0x50095000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>TOP_CTRL</name>
          <displayName>TOP_CTRL</displayName>
          <description>Top Control Register</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>13</bitWidth>
            </field>
            <field>
              <name>TTELP</name>
              <description>
              TXD Three-state Enable On Last Phase 0 = TXDx is three-stated 1/2 clock cycle after the beginning of the LSB 1 = TXDx output signal is three-stated on the clock edge that ends the LSB
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TTE</name>
              <description>
              TXD Three-State Enable 0 = TXDx output signal is not three-stated 1 = TXD is three-stated when not transmitting data
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SCFR</name>
              <description>
              Slave Clock Free Running 0 = Clock input to SSPSCLKx is continuously running 1 = Clock input to SSPSCLKx is only active during data transfers. 
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IFS</name>
              <description>
              Invert Frame Signal 0 = SSPSFRMx polarity is determined by the PSP polarity bits 1 = SSPSFRMx will be inverted from normal-SSPSFRMx (as defined by the PSP polarity bits). (Works in all frame formats: SPI, SSP, and PSP)
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HOLD_FRAME_LOW</name>
              <description>
              Hold Frame Low Control 1=After this field is set to 1 and the SSP is operating in master mode, the output frame clock ssp_sfrm_gpio will hold low. Used for SPI and NMW Format Rx FIFO Auto Full Control, which makes the frame clock is still low during there's no bit clock, or the data transfers before the stop clock will be discarded.  
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TRAIL</name>
              <description>
              Trailing Byte 0 = Trailing bytes are handled by SW 1 = Trailing bytes are handled by DMA bursts
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SPH</name>
              <description>
              Motorola SPI SSPSCLK phase setting 0 = SSPSCLKx is inactive until one cycle after the start of a frame and active until 1/2 cycle before the end of a frame 1 = SSPSCLKx is inactive until 1/2 cycle after the start of a frame and active until one cycle before the end of a frame
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SPO</name>
              <description>
              Motorola SPI SSPSCLK Polarity Setting 0 = The inactive or idle state of SSPSCLKx is low 1 = The inactive or idle state of SSPSCLKx is high
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DSS</name>
              <description>
              SSP Work data size,  register bits value 0~31 indicated data size 1~32 bits,  usually use data size 8bits, 16bits, 24bits, 32bits
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>SFRMDIR</name>
              <description>
              SSP Frame (SSPSFRMx) Direction 0 = Master mode, SSPx port drives SSPSFRMx 1 = Slave mode, SSPx port receives SSPSFRMx
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SCLKDIR</name>
              <description>
              SSP Serial Bit Rate Clock (SSPSCLKx) Direction 0 = Master mode, SSPx port drives SSPSCLKx 1 = Slave mode, SSPx port receives SSPSCLKx
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FRF</name>
              <description>
              Frame Format 0x0 = Motorola* Serial Peripheral Interface (SPI)  0x1 = Texas Instruments* Synchronous Serial Protocol (SSP) 0x2 = National Semiconductor Microwire* 0x3 = Programmable Serial Protocol (PSP) 
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>SSE</name>
              <description>
              Synchronous Serial Port Enable 0 = SSPx port is disabled  1 = SSPx port is enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>FIFO_CTRL</name>
          <displayName>FIFO_CTRL</displayName>
          <description>FIFO Control Register</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
            <field>
              <name>STRF</name>
              <description>
              Select FIFO For Efwr (Test Mode Bit) Only when the &lt;Enable FIFO Write/read> field = 1 0 = TXFIFO is selected for both writes and reads through the SSP Data Register 1 = RXFIFO is selected for both writes and reads through the SSP Data Register
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EFWR</name>
              <description>
              Enable FIFO Write/read (Test Mode Bit) 0 = FIFO write/read special function is disabled (normal SSPx operational mode) 1 = FIFO write/read special function is enabled
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RXFIFO_AUTO_FULL_CTRL</name>
              <description>
              Rx FIFO Auto Full Control =1After this field is set to 1 and the SSP is operating in master mode, the SSP FSM returns to IDLE state and stops the ssp_sclk_gpio. When Rx FIFO is full, the SSP FSM continues transferring data after the Rx FIFO is not full. This field is used to avoid an Rx FIFO overrun issue. 1= Enable Rx FIFO auto full control
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FPCKE</name>
              <description>
              FIFO Packing Enable 0 = FIFO packing mode disabled 1 = FIFO packing mode enabled
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TXFIFO_WR_ENDIAN</name>
              <description>
              apb_pwdata Write to Tx FIFO Endian 0x0 = txfifo_wdata[31:0] = apb_pwdata[31:0] 0x1 = fifo_wdata[31:0] = {apb_pwdata[15:0], apb_pwdata[31:16]} 0x2 = txfifo_wdata[31:0] = {apb_pwdata[7:0], apb_pwdata[15:8], apb_pwdata[23:16], apb_pwdata[31:24]} 0x3 = txfifo_wdata[31:0] = {apb_pwdata[23:16], apb_pwdata[31:24], apb_pwdata[7:0], apb_pwdata[15:8]}
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RXFIFO_RD_ENDIAN</name>
              <description>
              apb_prdata Read from Rx FIFO Endian 0x0 = apb_prdata[31:0] = rxfifo_wdata[31:0] 0x1 = apb_prdata[31:0] = {rxfifo_wdata[15:0], rxfifo_wdata[31:16]} 0x2 = apb_prdata[31:0]= {rxfifo_wdata[7:0], rxfifo_wdata[15:8], rxfifo_wdata[23:16], rxfifo_wdata[31:24]} 0x3 = apb_prdata[31:0]= {rxfifo_wdata[23:16], rxfifo_wdata[31:24], rxfifo_wdata[7:0], rxfifo_wdata[15:8]}
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSRE</name>
              <description>
              Receive Service Request Enable 0 = DMA service request is disabled 1 = DMA service request is enabled
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TSRE</name>
              <description>
              Transmit Service Request Enable 0 = DMA service request is disabled 1 = DMA service request is enabled
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RFT</name>
              <description>
              RXFIFO Trigger Threshold This field sets the threshold level at which RXFIFO asserts interrupt. The level should be set to the preferred threshold value minus 1.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>TFT</name>
              <description>
              TXFIFO Trigger Threshold This field sets the threshold level at which TXFIFO asserts interrupt. The level should be set to the preferred threshold value minus 1. 
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>INTE</name>
          <displayName>INTE</displayName>
          <description>Interrupt Enable Register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>25</bitWidth>
            </field>
            <field>
              <name>EBCEI</name>
              <description>
              Enable Bit Count Error Interrupt 0 = Interrupt due to a bit count error is disabled 1 = Interrupt due to a bit count error is enabled
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TIM</name>
              <description>
              Transmit FIFO Underrun Interrupt Mask 0 = TUR events generate an SSP interrupt 1 = TUR events do NOT generate an SSP interrupt 
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RIM</name>
              <description>
              Receive FIFO Overrun Interrupt Mask 0 = ROR events generate an SSP interrupt 1 = ROR events do NOT generate an SSP interrupt 
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TIE</name>
              <description>
              Transmit FIFO Interrupt Enable 0 = TXFIFO threshold-level-reached interrupt is disabled 1 = TXFIFO threshold-level-reached interrupt is enabled
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RIE</name>
              <description>
              Receive FIFO Interrupt Enable 0 = RXFIFO threshold-level-reached interrupt is disabled 1 = RXFIFO threshold-level-reached interrupt is enabled
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TINTE</name>
              <description>
              Receiver Time-out Interrupt Enable 0 = Receiver time-out interrupt is disabled 1 = Receiver time-out interrupt is enabled
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PINTE</name>
              <description>
              Peripheral Trailing Byte Interrupt Enable 0 = Peripheral trailing byte interrupt is disabled 1 = Peripheral trailing byte interrupt is enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TO</name>
          <displayName>TO</displayName>
          <description>SPI Time Out Register</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>TIMEOUT</name>
              <description>
              Timeout Value TIMEOUT value is the value (0 to 2&lt;super 24>-1) that defines the time-out interval. The time-out interval is given by the equation shown in the TIMEOUT Interval Equation.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DATA</name>
          <displayName>DATA</displayName>
          <description>SPI DATA Register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              DATA This field is used for data to be written to the TXFIFO read from the RXFIFO.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS</name>
          <displayName>STATUS</displayName>
          <description>Status Register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>OSS</name>
              <description>
              Odd Sample Status 0 = RxFIFO entry has two samples 1 = RxFIFO entry has one sample  Note that this bit needs to be looked at only when FIFO Packing is enabled (&lt;FIFO Packing Enable> field in SSP FIFO Control Register is set). Otherwise, this bit is zero. When SSPx port is in Packed mode and the CPU is used instead of DMA to read the RxFIFO, the CPU should make sure that &lt;Receive FIFO Not Empty> = 1 AND this field = 0 before it attempts to read the RxFIFO.
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TX_OSS</name>
              <description>
              TX FIFO Odd Sample Status When SSPx port is in packed mode, the number of samples in the TX FIFO is:  (&lt;Transmit FIFO Level>*2 + this field), when &lt;Transmit FIFO Not Full> = 1 32, when &lt;Transmit FIFO Not Full> = 0. The TX FIFO cannot accept new data when &lt;Transmit FIFO Not Full> = 1 and &lt;Transmit FIFO Level> = 15 and this field = 1. (The TX FIFO has 31 samples).  0 = TxFIFO entry has an even number of samples 1 = TxFIFO entry has an odd number of samples Note that this bit needs to be read only when FIFO Packing is enabled (&lt;FIFO Packing Enable> in the SSP FIFO Control Register is set). Otherwise, this bit is zero.
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BCE</name>
              <description>
              Bit Count Error 0 = The SSPx port has not experienced a bit count error 1 = The SSPSFRMx signal was asserted when the bit counter was not zero
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ROR</name>
              <description>
              Receive FIFO Overrun 0 = RXFIFO has not experienced an overrun 1 = Attempted data write to full RXFIFO, causes an interrupt request
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RFL</name>
              <description>
              Receive FIFO Level This field is the number of entries minus one in RXFIFO. When the value 0x1F is read, the RXFIFO is either empty or full, and software should read the &lt;Receive FIFO Not Empty> field.
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>RNE</name>
              <description>
              Receive FIFO Not Empty 0 = RXFIFO is empty 1 = RXFIFO is not empty
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RFS</name>
              <description>
              Receive FIFO Service Request 0 = RXFIFO level is at or below RFT threshold (RFT) or SSPx port is disabled 1 = RXFIFO level exceeds RFT threshold (RFT), causes an interrupt request
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TUR</name>
              <description>
              Transmit FIFO Underrun 0 = The TXFIFO has not experienced an underrun 1 = A read from the TXFIFO was attempted when the TXFIFO was empty, causes an interrupt if it is enabled (&lt;Transmit FIFO Underrun Interrupt Mask> in the SSP INT EN Register  is 0)
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TFL</name>
              <description>
              Transmit FIFO Level This field is the number of entries in TXFIFO.When the value 0x0 is read, the TXFIFO is either empty or full, and software should read the &lt;Transmit FIFO Not Full> field.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>TNF</name>
              <description>
              Transmit FIFO Not Full 0 = TXFIFO is full 1 = TXFIFO is not full
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TFS</name>
              <description>
              Transmit FIFO Service Request 0 = TX FIFO level exceeds the TFT threshold (TFT + 1) or SSPx port disabled 1 = TXFIFO level is at or below TFT threshold (TFT + 1), causes an interrupt request
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EOC</name>
              <description>
              End Of Chain 0 = DMA has not signaled an end of chain condition 1 = DMA has signaled an end of chain condition
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TINT</name>
              <description>
              Receiver Time-out Interrupt 0 = No receiver time-out is pending 1 = Receiver time-out pending, causes an interrupt request
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PINT</name>
              <description>
              Peripheral Trailing Byte Interrupt 0 = No peripheral trailing byte interrupt is pending 1 = Peripheral trailing byte interrupt is pending
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CSS</name>
              <description>
              Clock Synchronization Status 0 = The SSPx port is ready for slave clock operations 1 = The SSPx port is currently busy synchronizing slave mode signals
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BSY</name>
              <description>
              SSP Busy 0 = SSPx port is idle or disabled 1 = SSPx port is currently transmitting or receiving framed data
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD3</name>
          <displayName>RSVD3</displayName>
          <description></description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>RWOT_CTRL</name>
          <displayName>RWOT_CTRL</displayName>
          <description>SSP RWOT Control Register</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>27</bitWidth>
            </field>
            <field>
              <name>MASK_RWOT_LAST_SAMPLE</name>
              <description>
              Mask last_sample_flag in RWOT Mode 1= Mask 0 = Unmask
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CLR_RWOT_CYCLE</name>
              <description>
              Clear SSP Internal rwot_counter This field clears the rwot_counter to 0. This field is self cleared by SSP after SSE = 1. 1 = Clear rwot_counter
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SET_RWOT_CYCLE</name>
              <description>
              Set RWOT Cycle This field is used to set the value of the SSP_RWOT_CCM register to the SSP internal rwot_counter. This field is self-cleared by SSP after SSE = 1. 1 = Set rwot_counter
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CYCLE_RWOT_EN</name>
              <description>
              Enable SSP RWOT Cycle Counter Mode 1 = Enable
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RWOT</name>
              <description>
              Receive Without Transmit 0 = Transmit/receive mode 1 = Receive without transmit mode
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RWOT_CCM</name>
          <displayName>RWOT_CCM</displayName>
          <description>SSP RWOT Counter Cycles Match Register</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>SSPRWOTCCM</name>
              <description>
              It's just total ssp_sclk_gpio Cycles The value of this register defines the total number of ssp_sclk_gpio cycles when SSP works in master and RWOT mode. When the rwot_counter matches this value, SSP returns to IDLE state and does not output ssp_sclk_gpio anymore.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RWOT_CVWRN</name>
          <displayName>RWOT_CVWRN</displayName>
          <description>SSP RWOT Counter Value Write for Red Request Register</description>
          <addressOffset>0x2c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>SSPRWOTCVWR</name>
              <description>
              SSPRWOTCVWR This register prevents the risk of instability on rwot_counter value reading, it's only valid after SSP has been enabled Write 0 = No effect Write 1 = Capture value of rwot_counter Read: Returns the captured value of rwot_counter
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD2</name>
          <displayName>RSVD2</displayName>
          <description></description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>CLK_CTRL</name>
          <displayName>CLK_CTRL</displayName>
          <description>SSP CLK  Control Register</description>
          <addressOffset>0x3c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>22</bitWidth>
            </field>
            <field>
              <name>SPI_DI_SEL</name>
              <description>
              Select spi_di source.
              0: from port DI.
              1: from port DIO.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CLK_SSP_EN</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CLK_SEL</name>
              <description>
              0: select clk_div as clk_ssp 1: select clk_sys as clk_ssp
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CLK_DIV</name>
              <description>
              div ratio from clk_sys
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD1</name>
          <displayName>RSVD1</displayName>
          <description></description>
          <addressOffset>0x40</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>TRIWIRE_CTRL</name>
          <displayName>TRIWIRE_CTRL</displayName>
          <description>SSP Three Wire Mode  Control Register</description>
          <addressOffset>0x54</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>29</bitWidth>
            </field>
            <field>
              <name>SSP_WORK_WIDTH_DYN_CHANGE</name>
              <description>
              SSP_WORK_WIDTH_DYN_CHNAGE 1=SP can dynamicly change SSP_TOP_CTRL[9:5] without disabling SSP_TOP_CTRL[0] and re-enabling SSP_TOP_CTRL[0]   
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TXD_OEN</name>
              <description>
              TXD_OEN 1=TXD is input  0=TXD is output
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SPI_TRI_WIRE_EN</name>
              <description>
              SPI_THREE_WIRE_MODE_EN 1=enable
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>SPI2</name>
      <description></description>
      <groupName>SPI</groupName>
      <baseAddress>0x50096000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>TOP_CTRL</name>
          <displayName>TOP_CTRL</displayName>
          <description>Top Control Register</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>13</bitWidth>
            </field>
            <field>
              <name>TTELP</name>
              <description>
              TXD Three-state Enable On Last Phase 0 = TXDx is three-stated 1/2 clock cycle after the beginning of the LSB 1 = TXDx output signal is three-stated on the clock edge that ends the LSB
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TTE</name>
              <description>
              TXD Three-State Enable 0 = TXDx output signal is not three-stated 1 = TXD is three-stated when not transmitting data
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SCFR</name>
              <description>
              Slave Clock Free Running 0 = Clock input to SSPSCLKx is continuously running 1 = Clock input to SSPSCLKx is only active during data transfers. 
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IFS</name>
              <description>
              Invert Frame Signal 0 = SSPSFRMx polarity is determined by the PSP polarity bits 1 = SSPSFRMx will be inverted from normal-SSPSFRMx (as defined by the PSP polarity bits). (Works in all frame formats: SPI, SSP, and PSP)
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HOLD_FRAME_LOW</name>
              <description>
              Hold Frame Low Control 1=After this field is set to 1 and the SSP is operating in master mode, the output frame clock ssp_sfrm_gpio will hold low. Used for SPI and NMW Format Rx FIFO Auto Full Control, which makes the frame clock is still low during there's no bit clock, or the data transfers before the stop clock will be discarded.  
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TRAIL</name>
              <description>
              Trailing Byte 0 = Trailing bytes are handled by SW 1 = Trailing bytes are handled by DMA bursts
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SPH</name>
              <description>
              Motorola SPI SSPSCLK phase setting 0 = SSPSCLKx is inactive until one cycle after the start of a frame and active until 1/2 cycle before the end of a frame 1 = SSPSCLKx is inactive until 1/2 cycle after the start of a frame and active until one cycle before the end of a frame
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SPO</name>
              <description>
              Motorola SPI SSPSCLK Polarity Setting 0 = The inactive or idle state of SSPSCLKx is low 1 = The inactive or idle state of SSPSCLKx is high
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DSS</name>
              <description>
              SSP Work data size,  register bits value 0~31 indicated data size 1~32 bits,  usually use data size 8bits, 16bits, 24bits, 32bits
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>SFRMDIR</name>
              <description>
              SSP Frame (SSPSFRMx) Direction 0 = Master mode, SSPx port drives SSPSFRMx 1 = Slave mode, SSPx port receives SSPSFRMx
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SCLKDIR</name>
              <description>
              SSP Serial Bit Rate Clock (SSPSCLKx) Direction 0 = Master mode, SSPx port drives SSPSCLKx 1 = Slave mode, SSPx port receives SSPSCLKx
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FRF</name>
              <description>
              Frame Format 0x0 = Motorola* Serial Peripheral Interface (SPI)  0x1 = Texas Instruments* Synchronous Serial Protocol (SSP) 0x2 = National Semiconductor Microwire* 0x3 = Programmable Serial Protocol (PSP) 
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>SSE</name>
              <description>
              Synchronous Serial Port Enable 0 = SSPx port is disabled  1 = SSPx port is enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>FIFO_CTRL</name>
          <displayName>FIFO_CTRL</displayName>
          <description>FIFO Control Register</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
            <field>
              <name>STRF</name>
              <description>
              Select FIFO For Efwr (Test Mode Bit) Only when the &lt;Enable FIFO Write/read> field = 1 0 = TXFIFO is selected for both writes and reads through the SSP Data Register 1 = RXFIFO is selected for both writes and reads through the SSP Data Register
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EFWR</name>
              <description>
              Enable FIFO Write/read (Test Mode Bit) 0 = FIFO write/read special function is disabled (normal SSPx operational mode) 1 = FIFO write/read special function is enabled
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RXFIFO_AUTO_FULL_CTRL</name>
              <description>
              Rx FIFO Auto Full Control =1After this field is set to 1 and the SSP is operating in master mode, the SSP FSM returns to IDLE state and stops the ssp_sclk_gpio. When Rx FIFO is full, the SSP FSM continues transferring data after the Rx FIFO is not full. This field is used to avoid an Rx FIFO overrun issue. 1= Enable Rx FIFO auto full control
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FPCKE</name>
              <description>
              FIFO Packing Enable 0 = FIFO packing mode disabled 1 = FIFO packing mode enabled
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TXFIFO_WR_ENDIAN</name>
              <description>
              apb_pwdata Write to Tx FIFO Endian 0x0 = txfifo_wdata[31:0] = apb_pwdata[31:0] 0x1 = fifo_wdata[31:0] = {apb_pwdata[15:0], apb_pwdata[31:16]} 0x2 = txfifo_wdata[31:0] = {apb_pwdata[7:0], apb_pwdata[15:8], apb_pwdata[23:16], apb_pwdata[31:24]} 0x3 = txfifo_wdata[31:0] = {apb_pwdata[23:16], apb_pwdata[31:24], apb_pwdata[7:0], apb_pwdata[15:8]}
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RXFIFO_RD_ENDIAN</name>
              <description>
              apb_prdata Read from Rx FIFO Endian 0x0 = apb_prdata[31:0] = rxfifo_wdata[31:0] 0x1 = apb_prdata[31:0] = {rxfifo_wdata[15:0], rxfifo_wdata[31:16]} 0x2 = apb_prdata[31:0]= {rxfifo_wdata[7:0], rxfifo_wdata[15:8], rxfifo_wdata[23:16], rxfifo_wdata[31:24]} 0x3 = apb_prdata[31:0]= {rxfifo_wdata[23:16], rxfifo_wdata[31:24], rxfifo_wdata[7:0], rxfifo_wdata[15:8]}
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSRE</name>
              <description>
              Receive Service Request Enable 0 = DMA service request is disabled 1 = DMA service request is enabled
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TSRE</name>
              <description>
              Transmit Service Request Enable 0 = DMA service request is disabled 1 = DMA service request is enabled
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RFT</name>
              <description>
              RXFIFO Trigger Threshold This field sets the threshold level at which RXFIFO asserts interrupt. The level should be set to the preferred threshold value minus 1.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>TFT</name>
              <description>
              TXFIFO Trigger Threshold This field sets the threshold level at which TXFIFO asserts interrupt. The level should be set to the preferred threshold value minus 1. 
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>INTE</name>
          <displayName>INTE</displayName>
          <description>Interrupt Enable Register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>25</bitWidth>
            </field>
            <field>
              <name>EBCEI</name>
              <description>
              Enable Bit Count Error Interrupt 0 = Interrupt due to a bit count error is disabled 1 = Interrupt due to a bit count error is enabled
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TIM</name>
              <description>
              Transmit FIFO Underrun Interrupt Mask 0 = TUR events generate an SSP interrupt 1 = TUR events do NOT generate an SSP interrupt 
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RIM</name>
              <description>
              Receive FIFO Overrun Interrupt Mask 0 = ROR events generate an SSP interrupt 1 = ROR events do NOT generate an SSP interrupt 
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TIE</name>
              <description>
              Transmit FIFO Interrupt Enable 0 = TXFIFO threshold-level-reached interrupt is disabled 1 = TXFIFO threshold-level-reached interrupt is enabled
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RIE</name>
              <description>
              Receive FIFO Interrupt Enable 0 = RXFIFO threshold-level-reached interrupt is disabled 1 = RXFIFO threshold-level-reached interrupt is enabled
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TINTE</name>
              <description>
              Receiver Time-out Interrupt Enable 0 = Receiver time-out interrupt is disabled 1 = Receiver time-out interrupt is enabled
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PINTE</name>
              <description>
              Peripheral Trailing Byte Interrupt Enable 0 = Peripheral trailing byte interrupt is disabled 1 = Peripheral trailing byte interrupt is enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TO</name>
          <displayName>TO</displayName>
          <description>SPI Time Out Register</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>TIMEOUT</name>
              <description>
              Timeout Value TIMEOUT value is the value (0 to 2&lt;super 24>-1) that defines the time-out interval. The time-out interval is given by the equation shown in the TIMEOUT Interval Equation.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DATA</name>
          <displayName>DATA</displayName>
          <description>SPI DATA Register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              DATA This field is used for data to be written to the TXFIFO read from the RXFIFO.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS</name>
          <displayName>STATUS</displayName>
          <description>Status Register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>OSS</name>
              <description>
              Odd Sample Status 0 = RxFIFO entry has two samples 1 = RxFIFO entry has one sample  Note that this bit needs to be looked at only when FIFO Packing is enabled (&lt;FIFO Packing Enable> field in SSP FIFO Control Register is set). Otherwise, this bit is zero. When SSPx port is in Packed mode and the CPU is used instead of DMA to read the RxFIFO, the CPU should make sure that &lt;Receive FIFO Not Empty> = 1 AND this field = 0 before it attempts to read the RxFIFO.
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TX_OSS</name>
              <description>
              TX FIFO Odd Sample Status When SSPx port is in packed mode, the number of samples in the TX FIFO is:  (&lt;Transmit FIFO Level>*2 + this field), when &lt;Transmit FIFO Not Full> = 1 32, when &lt;Transmit FIFO Not Full> = 0. The TX FIFO cannot accept new data when &lt;Transmit FIFO Not Full> = 1 and &lt;Transmit FIFO Level> = 15 and this field = 1. (The TX FIFO has 31 samples).  0 = TxFIFO entry has an even number of samples 1 = TxFIFO entry has an odd number of samples Note that this bit needs to be read only when FIFO Packing is enabled (&lt;FIFO Packing Enable> in the SSP FIFO Control Register is set). Otherwise, this bit is zero.
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BCE</name>
              <description>
              Bit Count Error 0 = The SSPx port has not experienced a bit count error 1 = The SSPSFRMx signal was asserted when the bit counter was not zero
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ROR</name>
              <description>
              Receive FIFO Overrun 0 = RXFIFO has not experienced an overrun 1 = Attempted data write to full RXFIFO, causes an interrupt request
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RFL</name>
              <description>
              Receive FIFO Level This field is the number of entries minus one in RXFIFO. When the value 0x1F is read, the RXFIFO is either empty or full, and software should read the &lt;Receive FIFO Not Empty> field.
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>RNE</name>
              <description>
              Receive FIFO Not Empty 0 = RXFIFO is empty 1 = RXFIFO is not empty
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RFS</name>
              <description>
              Receive FIFO Service Request 0 = RXFIFO level is at or below RFT threshold (RFT) or SSPx port is disabled 1 = RXFIFO level exceeds RFT threshold (RFT), causes an interrupt request
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TUR</name>
              <description>
              Transmit FIFO Underrun 0 = The TXFIFO has not experienced an underrun 1 = A read from the TXFIFO was attempted when the TXFIFO was empty, causes an interrupt if it is enabled (&lt;Transmit FIFO Underrun Interrupt Mask> in the SSP INT EN Register  is 0)
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TFL</name>
              <description>
              Transmit FIFO Level This field is the number of entries in TXFIFO.When the value 0x0 is read, the TXFIFO is either empty or full, and software should read the &lt;Transmit FIFO Not Full> field.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>TNF</name>
              <description>
              Transmit FIFO Not Full 0 = TXFIFO is full 1 = TXFIFO is not full
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TFS</name>
              <description>
              Transmit FIFO Service Request 0 = TX FIFO level exceeds the TFT threshold (TFT + 1) or SSPx port disabled 1 = TXFIFO level is at or below TFT threshold (TFT + 1), causes an interrupt request
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EOC</name>
              <description>
              End Of Chain 0 = DMA has not signaled an end of chain condition 1 = DMA has signaled an end of chain condition
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TINT</name>
              <description>
              Receiver Time-out Interrupt 0 = No receiver time-out is pending 1 = Receiver time-out pending, causes an interrupt request
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PINT</name>
              <description>
              Peripheral Trailing Byte Interrupt 0 = No peripheral trailing byte interrupt is pending 1 = Peripheral trailing byte interrupt is pending
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CSS</name>
              <description>
              Clock Synchronization Status 0 = The SSPx port is ready for slave clock operations 1 = The SSPx port is currently busy synchronizing slave mode signals
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BSY</name>
              <description>
              SSP Busy 0 = SSPx port is idle or disabled 1 = SSPx port is currently transmitting or receiving framed data
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD3</name>
          <displayName>RSVD3</displayName>
          <description></description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>RWOT_CTRL</name>
          <displayName>RWOT_CTRL</displayName>
          <description>SSP RWOT Control Register</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>27</bitWidth>
            </field>
            <field>
              <name>MASK_RWOT_LAST_SAMPLE</name>
              <description>
              Mask last_sample_flag in RWOT Mode 1= Mask 0 = Unmask
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CLR_RWOT_CYCLE</name>
              <description>
              Clear SSP Internal rwot_counter This field clears the rwot_counter to 0. This field is self cleared by SSP after SSE = 1. 1 = Clear rwot_counter
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SET_RWOT_CYCLE</name>
              <description>
              Set RWOT Cycle This field is used to set the value of the SSP_RWOT_CCM register to the SSP internal rwot_counter. This field is self-cleared by SSP after SSE = 1. 1 = Set rwot_counter
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CYCLE_RWOT_EN</name>
              <description>
              Enable SSP RWOT Cycle Counter Mode 1 = Enable
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RWOT</name>
              <description>
              Receive Without Transmit 0 = Transmit/receive mode 1 = Receive without transmit mode
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RWOT_CCM</name>
          <displayName>RWOT_CCM</displayName>
          <description>SSP RWOT Counter Cycles Match Register</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>SSPRWOTCCM</name>
              <description>
              It's just total ssp_sclk_gpio Cycles The value of this register defines the total number of ssp_sclk_gpio cycles when SSP works in master and RWOT mode. When the rwot_counter matches this value, SSP returns to IDLE state and does not output ssp_sclk_gpio anymore.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RWOT_CVWRN</name>
          <displayName>RWOT_CVWRN</displayName>
          <description>SSP RWOT Counter Value Write for Red Request Register</description>
          <addressOffset>0x2c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>SSPRWOTCVWR</name>
              <description>
              SSPRWOTCVWR This register prevents the risk of instability on rwot_counter value reading, it's only valid after SSP has been enabled Write 0 = No effect Write 1 = Capture value of rwot_counter Read: Returns the captured value of rwot_counter
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD2</name>
          <displayName>RSVD2</displayName>
          <description></description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>CLK_CTRL</name>
          <displayName>CLK_CTRL</displayName>
          <description>SSP CLK  Control Register</description>
          <addressOffset>0x3c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>22</bitWidth>
            </field>
            <field>
              <name>SPI_DI_SEL</name>
              <description>
              Select spi_di source.
              0: from port DI.
              1: from port DIO.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CLK_SSP_EN</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CLK_SEL</name>
              <description>
              0: select clk_div as clk_ssp 1: select clk_sys as clk_ssp
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CLK_DIV</name>
              <description>
              div ratio from clk_sys
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD1</name>
          <displayName>RSVD1</displayName>
          <description></description>
          <addressOffset>0x40</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>TRIWIRE_CTRL</name>
          <displayName>TRIWIRE_CTRL</displayName>
          <description>SSP Three Wire Mode  Control Register</description>
          <addressOffset>0x54</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>29</bitWidth>
            </field>
            <field>
              <name>SSP_WORK_WIDTH_DYN_CHANGE</name>
              <description>
              SSP_WORK_WIDTH_DYN_CHNAGE 1=SP can dynamicly change SSP_TOP_CTRL[9:5] without disabling SSP_TOP_CTRL[0] and re-enabling SSP_TOP_CTRL[0]   
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TXD_OEN</name>
              <description>
              TXD_OEN 1=TXD is input  0=TXD is output
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SPI_TRI_WIRE_EN</name>
              <description>
              SPI_THREE_WIRE_MODE_EN 1=enable
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PDM1</name>
      <description></description>
      <groupName>PDM</groupName>
      <baseAddress>0x5009a000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CFG0</name>
          <displayName>CFG0</displayName>
          <description></description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>22</bitWidth>
            </field>
            <field>
              <name>SWAP_EN</name>
              <description>
              1: Swap right channel and left channel pdm data; 0: Not swap  right channel and left channel pdm data
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>STEREO_EN</name>
              <description>
              1:Enable double channels pdm data sampling; 0: Disable double channels pdm data sampling
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RIGHT_EN</name>
              <description>
              1: Enable right channel pdm data sampling; 0: Disable right channel pdm data sampling
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LEFT_EN</name>
              <description>
              1: Enable left channel  pdm data sampling; 0: Disable left channel  pdm data sampling
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CLK_DIV</name>
              <description>
              Clock frequency division ratio of 3.072MHz or 9.6MHz according to register clk_sel
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>CLK_SEL</name>
              <description>
              1:Clk select dll 3.072MHz; 0: Clk selct xtal 9.6MHz
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PDMCOREEN</name>
              <description>
              1:Enable pdm module; 0: Disable pdm module
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CFG1</name>
          <displayName>CFG1</displayName>
          <description></description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>21</bitWidth>
            </field>
            <field>
              <name>SAMPLE_DLY_R</name>
              <description>
              The number of delay dff before the right data stream in processing
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>SAMPLE_DLY_L</name>
              <description>
              The number of delay dff before the left data stream in processing
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SINC_CFG</name>
          <displayName>SINC_CFG</displayName>
          <description></description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>SINC_ORDER_SEL</name>
              <description>
              1:select four differentiators in sinc filter; 0:select three differentiators in sinc filter
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SINC_RATE</name>
              <description>
              dowmsampling rate of  sinc filter
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD3</name>
          <displayName>RSVD3</displayName>
          <description></description>
          <addressOffset>0xC</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>HPF_CFG</name>
          <displayName>HPF_CFG</displayName>
          <description></description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>26</bitWidth>
            </field>
            <field>
              <name>HPF_RST</name>
              <description>
              1:high-pass filter normal operation ; 0:reset high-pass filter 
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HPF_BYPASS</name>
              <description>
              1:bypass-high pass filter ; 0: enable high-pass filter
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HPF_COEFF</name>
              <description>
              coefficient of high-pass filter
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PGA_CFG</name>
          <displayName>PGA_CFG</displayName>
          <description></description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>18</bitWidth>
            </field>
            <field>
              <name>PGA_GAIN_R</name>
              <description>
              right channel gain control , the range is -15dB~45dB. Resolution is 0.5dB/LSB
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
            <field>
              <name>PGA_GAIN_L</name>
              <description>
              left channel gain control , the range is -15dB~45dB. Resolution is 0.5dB/LSB
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD2</name>
          <displayName>RSVD2</displayName>
          <description></description>
          <addressOffset>0x1C</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>LPF_CFG6</name>
          <displayName>LPF_CFG6</displayName>
          <description></description>
          <addressOffset>0x34</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>18</bitWidth>
            </field>
            <field>
              <name>LPF_BYPASS</name>
              <description>
              1:bypass low-pass filter ; 0: enable low-pass filter
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LPF_DS</name>
              <description>
              1:downsampling rate of low pass filter is two;0:No downsampling of low pass filter
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>FIFO_CFG</name>
          <displayName>FIFO_CFG</displayName>
          <description></description>
          <addressOffset>0x38</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>LR_CHG</name>
              <description>
              1:exchange storage location of left and right channel; 0: don't exchange storage location of left and right channel
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RX_DMA_MSK_L</name>
              <description>
              1:disable left channel dma request; 0: enable left channel dma request
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RX_DMA_MSK_R</name>
              <description>
              1:disable right channel dma request; 0: enable right channel dma request
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PDM_SHIFT</name>
              <description>
              the number of data left shift for higher data accuracy 
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>BYTE_TRUNC</name>
              <description>
              1: 16bits output ; 0: 24bits output ;2:  8bits output ; 3: 32bits output
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>BYTE_CON</name>
              <description>
              1: combine left channel and right channel; 0: not combine left channel and right channel
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD1</name>
          <displayName>RSVD1</displayName>
          <description></description>
          <addressOffset>0x3C</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>FIFO_ST</name>
          <displayName>FIFO_ST</displayName>
          <description></description>
          <addressOffset>0x44</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>FULL_L</name>
              <description>
              1 indicates left channel fifo is full
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EMPTY_L</name>
              <description>
              1 indicates left channel fifo is empty
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ALMOST_FULL_L</name>
              <description>
              1 indicates left channel fifo is less than two full
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ALMOST_EMPTY_L</name>
              <description>
              1 indicates left channel fifo is less than two datas left
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FULL_R</name>
              <description>
              1 indicates right channel fifo is full
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EMPTY_R</name>
              <description>
              1 indicates right channel fifo is empty
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ALMOST_FULL_R</name>
              <description>
              1 indicates right channel fifo is less than two full
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ALMOST_EMPTY_R</name>
              <description>
              1 indicates right channel fifo is less than two datas left
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>INT_ST</name>
          <displayName>INT_ST</displayName>
          <description></description>
          <addressOffset>0x48</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>30</bitWidth>
            </field>
            <field>
              <name>OVERFLOW_L</name>
              <description>
              1 indicates left channel fifo has already overflowed and as irq at same time 
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OVERFLOW_R</name>
              <description>
              1 indicates right channel fifo has already overflowed  and as irq at same time
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>INT_MSK</name>
          <displayName>INT_MSK</displayName>
          <description></description>
          <addressOffset>0x4c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>30</bitWidth>
            </field>
            <field>
              <name>INT_MASK_L</name>
              <description>
              1:disable left channel irq to system; 0: enable left channel irq to system
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>INT_MASK_R</name>
              <description>
              1:disable right channel irq to system; 0: enable right channel irq to system
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>INT_CLR</name>
          <displayName>INT_CLR</displayName>
          <description></description>
          <addressOffset>0x50</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>30</bitWidth>
            </field>
            <field>
              <name>INT_CLR_L</name>
              <description>
              clear left channel irq
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>INT_CLR_R</name>
              <description>
              clear right channel irq
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>I2C1</name>
      <description></description>
      <groupName>I2C</groupName>
      <baseAddress>0x5009c000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CR</name>
          <displayName>CR</displayName>
          <description>Control register</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>UR</name>
              <description>
              Unit Reset. Software need first assert to reset then deassert to release.
              0 = No reset.
              1 = Reset I2C module.
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSTREQ</name>
              <description>
              I2C will do bus reset upon this bit set. Will be cleared by HW automatically after RSTCYC cycles of SCL generated.
              1 = request for i2c bus reset
              0 = bus reset finished
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BRGRST</name>
              <description>
              Reset bus related state machine and signals. Will be cleared by HW automatically
              1 = request for reset
              0 = reset finished
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>14</bitWidth>
            </field>
            <field>
              <name>DNF</name>
              <description>
              Digital noise filter
              These bits are used to configure the digital noise filter on SDA and SCL input. The digital filter will filter spikes with a length of up to DNF*Tfclk.
              0: Digital filter disabled 
              1: Digital filter enabled and filtering capability up to 1 Tfclk
              ...
              7: digital filter enabled and filtering capability up to 7 Tfclk
              Digital filter is added to analog filter. Digital filter will introduce delay on SCL and SDA processing, which is essential in hs-mode. 
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>SLVEN</name>
              <description>
              Slave mode Enable for SCL.
              0 = Disable slave mode. Will not monitor slave address on I2C bus.
              1 = Enable slave mode. Will monitor slave address on I2C bus.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SCLPP</name>
              <description>
              Push-pull mode Enable for SCL.
              0 = open drain output for SCL.
              1 = Push-pull output for SCL
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MSDE</name>
              <description>
              Master Stop Detected Enable:
              0 = Master Stop Detect (MSD) status is not enabled.
              1 = Master Stop Detect (MSD) status is enabled.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LASTSTOP</name>
              <description>
              Generate STOP for last DMA transfer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LASTNACK</name>
              <description>
              Generate NACK for last DMA Read transfer
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMAEN</name>
              <description>
              DMA Enable for both TX and RX
              0 = DMA mode is NOT enabled
              1 = DMA mode enabled
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SCLE</name>
              <description>
              SCL Enable:
              0 = Disables the I2C from driving the SCL line.
              1 = Enables the I2C clock output for master-mode operation.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IUE</name>
              <description>
              I2C Unit Enable:
              0 = Disables the unit and does not master any transactions or respond to any slave transactions.
              1 = Enables the I2C (defaults to slave-receive mode).
              Software must guarantee the I2C bus is idle before setting this bit.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MODE</name>
              <description>
              Bus Mode (Master operation):
              2'b00: standard-mode
              2'b01: fast-mode and fast-mode plus
              2'b10: HS-mode (standard mode when not doing a high speed transfer)
              2'b11: HS-mode (fast mode when not doing a high speed transfer)
              Bus Mode (Slave operation):
              2'b0x: HS-mode is disabled. I2C unit uses Standard/Fast mode timing on the SDA pin.
              2'b1x: HS-mode is enabled. I2C unit uses HS-mode timing on the SDA pin when a master code is received.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TCR</name>
          <displayName>TCR</displayName>
          <description>Transfer Control register</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>ABORTDMA</name>
              <description>
              Abort DMA operation. Will be cleared by HW automatically
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RXREQ</name>
              <description>
              Request DMA RX. Will be cleared by HW automatically
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TXREQ</name>
              <description>
              Request DMA TX. Will be cleared by HW automatically
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MA</name>
              <description>
              Master Abort:
              Used by the I2C in master mode to generate a Stop without transmitting another data byte:
              0 = The I2C transmits Stop on if TCR[STOP] is set.
              1 = The I2C sends Stop without data transmission.
              When in master-transmit mode, after transmitting a data byte, the TCR[TB] bit is cleared. When no more data bytes need to be sent, setting master abort bit sends the Stop. The TCR[TB] bit must remain clear.
              In master-receive mode, when a NAK is sent without a Stop (TCR[STOP] bit was not set) and CPU does not send a repeated Start, setting this bit sends the Stop. Once again, the TCR[TB] bit must remain clear. Master Abort can be done immediately after the address phase (Master Transmit mode only).
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>NACK</name>
              <description>
              The positive/negative acknowledge control bit, defines the type of acknowledge pulse sent by the I2C when in master receive mode:
              0 = Send a positive acknowledge (ACK) pulse after receiving a data byte.
              1 = Send a negative acknowledge (NACK) pulse after receiving a data byte.
              The I2C automatically sends an ACK pulse when responding to its slave address or when responding in slave-receive mode, regardless of the NACK control-bit setting.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>STOP</name>
              <description>
              Stop:
              Used to initiate a Stop condition after transferring the next data byte on the I2C bus when in master mode. In master-receive mode, the NACK control bit must be set in conjunction with the STOP bit. 
              0 = Do not send a Stop.
              1 = Send a Stop.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>START</name>
              <description>
              Start:
              Used to initiate a Start condition to the I2C unit when in master mode. 
              0 = Do not send a Start pulse.
              1 = Send a Start pulse.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TB</name>
              <description>
              Transfer Byte:
              Used to send or receive a byte on the I2C bus:
              0 = Cleared by I2C when the byte is sent/received.
              1 = Send/receive a byte. 
              CPU can monitor this bit to determine when the byte transfer has completed. In master or slave mode, after each byte transfer including acknowledge pulse, the I2C holds the SCL line low (inserting wait states) until TB is set.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IER</name>
          <displayName>IER</displayName>
          <description>Interrupt Enable register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>UFIE</name>
              <description>
              FIFO Underflow Interrupt Enable
              0 = FIFO Underflow interrupt is not enabled
              1 = FIFO Underflow interrupt is enabled
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OFIE</name>
              <description>
              FIFO Overflow Interrupt Enable
              0 = FIFO Overflow interrupt is not enabled
              1 = FIFO Overflow interrupt is enabled
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMADONEIE</name>
              <description>
              DMA Transaction Done Interrupt Enable
              0 = DMA Transaction done interrupt is not enabled.
              1 = DMA Transaction done interrupt is enabled.
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MSDIE</name>
              <description>
              Master Stop Detected Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C unit to interrupt upon detecting a Master Stop sent by the I2C unit.
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BEDIE</name>
              <description>
              Bus Error Detected Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C to interrupt for the following I2C bus errors:
              As a master transmitter, no ACK was detected after a byte was sent.
              As a slave receiver, the I2C generated a NACK pulse.
              Software is responsible for guaranteeing that misplaced Start and Stop conditions do not occur.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SADIE</name>
              <description>
              Slave Address Detected Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C to interrupt upon detecting a slave address match or a general call address.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RFIE</name>
              <description>
              DBR Receive Full Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C to interrupt when the DBR has received a data byte from the I2C bus.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIE</name>
              <description>
              DBR Transmit Empty Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C to interrupt after transmitting a byte onto the I2C bus.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ALDIE</name>
              <description>
              Arbitration Loss Detected Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C to interrupt upon losing arbitration while in master mode.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SSDIE</name>
              <description>
              Slave Stop Detected Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C to interrupt when it detects a Stop condition while in slave mode.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SR</name>
          <displayName>SR</displayName>
          <description>Status register</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>UF</name>
              <description>
              FIFO Underflow Flag. Asserted when FIFO is empty and a POP request generated without a PUSH. Cleared if write 1
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OF</name>
              <description>
              FIFO Overflow Flag. Asserted when FIFO is full and a PUSH request generated without a POP. Cleared if write 1
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMADONE</name>
              <description>
              DMA Transaction Done. Asserted when both APB and I2C bus have finished transfer. Cleared if write 1
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MSD</name>
              <description>
              Master Stop Detected:
              0 = No Master Stop Detected.
              1 = This bit is set by the I2C unit when all of the following are true:
              This bit is enabled (CR[MSDE] = 1);
              I2C unit is configured as a master;
              I2C transmits a STOP signal
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EBB</name>
              <description>
              Early Bus Busy
              0 = I2C bus is idle or the I2C is using the bus (that is, unit busy).
              1 = Set when the unit detects that the SCL or SDA line is low without a START condition. Bit will remain set until the I2C unit detects the bus is idle by detecting a STOP condition. Bit will also be set whenever the IBB bit is set.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BED</name>
              <description>
              Bus Error Detected:
              0 = No error detected.
              1 = The I2C sets this bit when it detects one of the following error conditions:
              As a master transmitter, no ACK was detected on the interface after a byte was sent.
              As a slave receiver, the I2C generates a NACK pulse.
              When an error occurs, I2C bus transactions continue. Software must guarantee that misplaced Start and Stop conditions do not occur. 
              Cleared if write 1
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SAD</name>
              <description>
              Slave Address Detected:
              0 = No slave address was detected.
              1 = The I2C detected a seven-bit address that matches the general call address or SAR. An interrupt is signalled when enabled in the CR. 
              Cleared if write 1
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RF</name>
              <description>
              DBR Receive Full:
              0 = The DBR has not received a new data byte or the I2C is idle.
              1 = The DBR register received a new data byte from the I2C bus. An interrupt is signalled when enabled in the CR. 
              Cleared if write 1
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TE</name>
              <description>
              DBR Transmit Empty:
              0 = The data byte is still being transmitted.
              1 = The I2C has finished transmitting a data byte on the I2C bus. An interrupt is signalled when enabled in the CR.
              Cleared if write 1
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ALD</name>
              <description>
              Arbitration Loss Detected:
              Used during multi-master operation:
              0 = Cleared when arbitration is won or never took place.
              1 = Set when the I2C loses arbitration. 
              Cleared if write 1
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SSD</name>
              <description>
              Slave Stop Detected:
              0 = No Stop detected.
              1 = Set when the I2C detects a Stop while in slave-receive or slave-transmit mode. 
              Cleared if write 1
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IBB</name>
              <description>
              I2C Bus Busy:
              0 = I2C bus is idle or the I2C is using the bus (that is, unit busy).
              1 = Set when the I2C bus is busy but local I2C is not involved in the transaction.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UB</name>
              <description>
              Unit Busy:
              0 = I2C not busy.
              1 = Set when local I2C is busy. This is defined as the time between the first Start and Stop. 
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>NACK</name>
              <description>
              ACK/NACK Status:
              0 = The I2C received or sent an ACK on the bus. 
              1 = The I2C received or sent a NACK.on the bus.
              This bit is used in slave-transmit mode to determine when the byte transferred is the last one. This bit is updated after each byte and ACK/NACK information is received.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RWM</name>
              <description>
              Read/write Mode:
              0 = The I2C is in master-transmit or slave-receive mode. 
              1 = The I2C is in master-receive or slave-transmit mode. 
              This is the R/nW bit of the slave address. It is cleared automatically by hardware after a Stop state.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DBR</name>
          <displayName>DBR</displayName>
          <description>Data Buffer register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>DATA</name>
              <description>
              use the I2C Data Buffer register to transmit and receive data from the I2C bus. The DBR is accessed by software on one Side and by the I2C Shift register on the other. The DBR receives data coming into the I2C unit after a full byte is received and acknowledged. CPU writes data going out of the I2C to the DBR and sends it to the serial bus. 
              When the I2C is in transmit mode (master or slave), CPU writes data to the DBR over the internal bus. CPU write data to the DBR when a master transaction is initiated or when the DBR transmit-empty interrupt is signalled. Data moves from the DBR to the Shift register when the transfer byte bit is set. The DBR transmit-empty interrupt is signalled (if enabled) when a byte is transferred on the I2C bus and the acknowledge cycle is complete. If the DBR is not written, and a Stop condition is not in place before the I2C bus is ready to transfer the next byte packet, the I2C unit inserts wait states until CPU writes the DBR and sets the transfer byte bit.
              When the I2C is in receive mode (master or slave), CPU reads DBR data over the internal bus. CPU reads data from the DBR when the DBR receive-full interrupt is signalled. The data moves from the Shift register to the DBR when the acknowledge cycle is complete. The I2C inserts wait states until the DBR is read. After the software reads the DBR, CR[NACK] are written by the software, allowing the next byte transfer to proceed to the I2C bus.
              In DMA mode, DBR is automatically filled from FIFO in master transmit mode, or fetched and stored in FIFO in master receive mode until DMA done or aborted.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SAR</name>
          <displayName>SAR</displayName>
          <description>Slave Address Register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000047</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>25</bitWidth>
            </field>
            <field>
              <name>ADDR</name>
              <description>
              The seven-bit address to which the I2C responds when in slave-receive mode
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>LCR</name>
          <displayName>LCR</displayName>
          <description>Load Count Register</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x081C72ED</resetValue>
          <fields>
            <field>
              <name>HLVH</name>
              <description>
              Decrementer Load value for High Speed Mode SCL (master mode) for high phase. 
              Thigh=Tfclk*(HLVH+4+DNF)
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>HLVL</name>
              <description>
              Decrementer Load value for High Speed Mode SCL (master mode) for low phase. 
              Tlow=Tfclk*(HLVL+3+DNF). Data rate is generated as 1/(Thigh+Tlow), or Ffclk/(HLVH+HLVL+7+2*DNF). 
              3.2Mbps data rate is generated by default if fclk is 48MHz.
              HLVL also controls setup time and hold time for START and STOP condition in High Speed Mode(master mode). 
              Thdsta=Tsusta=Tsusto=Tfclk*(HLVL+1)
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
            <field>
              <name>FLV</name>
              <description>
              Decrementer Load value for Fast Mode (or Fast Mode Plus) SCL (master mode) for both high and low phase. 
              Data rate is generated as Ffclk/(FLV+max(FLV,CNT*2+6)+7+DNF) approximately. 
              400kbps data rate is generated by default if fclk is 48MHz.
              FLV also controls setup time and hold time for START and STOP condition in Fast Mode(master mode). 
              Thdsta=Tsusta=Tsusto=Tfclk*FLV
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
            <field>
              <name>SLV</name>
              <description>
              Decrementer Load value for Standard Mode SCL (master mode) for both high & low phase. 
              Data rate is generated as Ffclk/(SLV+max(SLV,CNT*2+6)+7+DNF) approximately. 
              100kbps data rate is generated by default if fclk is 48MHz.
              SLV also controls setup time and hold time for START and STOP condition in Standard Mode(master mode). 
              Thdsta=Tsusta=Tsusto=Tfclk*SLV
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>WCR</name>
          <displayName>WCR</displayName>
          <description>Wait Count Register</description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0000000A</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>CNT</name>
              <description>
              Controls the counter values defining the setup and hold times in standard and fast mode
              Tvddat=Thddat=Tfclk*(CNT+2)
              Tsudat=max(Tlow-Thddat,Thddat)
              Lower counter values may violate setup and hold times.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RCCR</name>
          <displayName>RCCR</displayName>
          <description>Bus Reset Cycle Counter Register</description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000009</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>28</bitWidth>
            </field>
            <field>
              <name>RSTCYC</name>
              <description>
              The cycles of SCL during bus reset
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BMR</name>
          <displayName>BMR</displayName>
          <description>Bus Monitor Register</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000003</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>30</bitWidth>
            </field>
            <field>
              <name>SCL</name>
              <description>
              value of the SCL pin. Software can check bus level when the I2C bus is hung and the I2C unit must be reset.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SDA</name>
              <description>
              value of the SDA pin.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DNR</name>
          <displayName>DNR</displayName>
          <description>DMA number register</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>NDT</name>
              <description>
              Write as number of data to transfer in byte. Read as left data number to transfer
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD1</name>
          <displayName>RSVD1</displayName>
          <description></description>
          <addressOffset>0x2C</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>FIFO</name>
          <displayName>FIFO</displayName>
          <description>FIFO Register</description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>DATA</name>
              <description>
              Write to push send data into FIFO. Read to pop received data from FIFO
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>I2C2</name>
      <description></description>
      <groupName>I2C</groupName>
      <baseAddress>0x5009d000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CR</name>
          <displayName>CR</displayName>
          <description>Control register</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>UR</name>
              <description>
              Unit Reset. Software need first assert to reset then deassert to release.
              0 = No reset.
              1 = Reset I2C module.
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSTREQ</name>
              <description>
              I2C will do bus reset upon this bit set. Will be cleared by HW automatically after RSTCYC cycles of SCL generated.
              1 = request for i2c bus reset
              0 = bus reset finished
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BRGRST</name>
              <description>
              Reset bus related state machine and signals. Will be cleared by HW automatically
              1 = request for reset
              0 = reset finished
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>14</bitWidth>
            </field>
            <field>
              <name>DNF</name>
              <description>
              Digital noise filter
              These bits are used to configure the digital noise filter on SDA and SCL input. The digital filter will filter spikes with a length of up to DNF*Tfclk.
              0: Digital filter disabled 
              1: Digital filter enabled and filtering capability up to 1 Tfclk
              ...
              7: digital filter enabled and filtering capability up to 7 Tfclk
              Digital filter is added to analog filter. Digital filter will introduce delay on SCL and SDA processing, which is essential in hs-mode. 
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>SLVEN</name>
              <description>
              Slave mode Enable for SCL.
              0 = Disable slave mode. Will not monitor slave address on I2C bus.
              1 = Enable slave mode. Will monitor slave address on I2C bus.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SCLPP</name>
              <description>
              Push-pull mode Enable for SCL.
              0 = open drain output for SCL.
              1 = Push-pull output for SCL
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MSDE</name>
              <description>
              Master Stop Detected Enable:
              0 = Master Stop Detect (MSD) status is not enabled.
              1 = Master Stop Detect (MSD) status is enabled.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LASTSTOP</name>
              <description>
              Generate STOP for last DMA transfer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LASTNACK</name>
              <description>
              Generate NACK for last DMA Read transfer
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMAEN</name>
              <description>
              DMA Enable for both TX and RX
              0 = DMA mode is NOT enabled
              1 = DMA mode enabled
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SCLE</name>
              <description>
              SCL Enable:
              0 = Disables the I2C from driving the SCL line.
              1 = Enables the I2C clock output for master-mode operation.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IUE</name>
              <description>
              I2C Unit Enable:
              0 = Disables the unit and does not master any transactions or respond to any slave transactions.
              1 = Enables the I2C (defaults to slave-receive mode).
              Software must guarantee the I2C bus is idle before setting this bit.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MODE</name>
              <description>
              Bus Mode (Master operation):
              2'b00: standard-mode
              2'b01: fast-mode and fast-mode plus
              2'b10: HS-mode (standard mode when not doing a high speed transfer)
              2'b11: HS-mode (fast mode when not doing a high speed transfer)
              Bus Mode (Slave operation):
              2'b0x: HS-mode is disabled. I2C unit uses Standard/Fast mode timing on the SDA pin.
              2'b1x: HS-mode is enabled. I2C unit uses HS-mode timing on the SDA pin when a master code is received.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TCR</name>
          <displayName>TCR</displayName>
          <description>Transfer Control register</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>ABORTDMA</name>
              <description>
              Abort DMA operation. Will be cleared by HW automatically
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RXREQ</name>
              <description>
              Request DMA RX. Will be cleared by HW automatically
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TXREQ</name>
              <description>
              Request DMA TX. Will be cleared by HW automatically
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MA</name>
              <description>
              Master Abort:
              Used by the I2C in master mode to generate a Stop without transmitting another data byte:
              0 = The I2C transmits Stop on if TCR[STOP] is set.
              1 = The I2C sends Stop without data transmission.
              When in master-transmit mode, after transmitting a data byte, the TCR[TB] bit is cleared. When no more data bytes need to be sent, setting master abort bit sends the Stop. The TCR[TB] bit must remain clear.
              In master-receive mode, when a NAK is sent without a Stop (TCR[STOP] bit was not set) and CPU does not send a repeated Start, setting this bit sends the Stop. Once again, the TCR[TB] bit must remain clear. Master Abort can be done immediately after the address phase (Master Transmit mode only).
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>NACK</name>
              <description>
              The positive/negative acknowledge control bit, defines the type of acknowledge pulse sent by the I2C when in master receive mode:
              0 = Send a positive acknowledge (ACK) pulse after receiving a data byte.
              1 = Send a negative acknowledge (NACK) pulse after receiving a data byte.
              The I2C automatically sends an ACK pulse when responding to its slave address or when responding in slave-receive mode, regardless of the NACK control-bit setting.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>STOP</name>
              <description>
              Stop:
              Used to initiate a Stop condition after transferring the next data byte on the I2C bus when in master mode. In master-receive mode, the NACK control bit must be set in conjunction with the STOP bit. 
              0 = Do not send a Stop.
              1 = Send a Stop.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>START</name>
              <description>
              Start:
              Used to initiate a Start condition to the I2C unit when in master mode. 
              0 = Do not send a Start pulse.
              1 = Send a Start pulse.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TB</name>
              <description>
              Transfer Byte:
              Used to send or receive a byte on the I2C bus:
              0 = Cleared by I2C when the byte is sent/received.
              1 = Send/receive a byte. 
              CPU can monitor this bit to determine when the byte transfer has completed. In master or slave mode, after each byte transfer including acknowledge pulse, the I2C holds the SCL line low (inserting wait states) until TB is set.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IER</name>
          <displayName>IER</displayName>
          <description>Interrupt Enable register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>UFIE</name>
              <description>
              FIFO Underflow Interrupt Enable
              0 = FIFO Underflow interrupt is not enabled
              1 = FIFO Underflow interrupt is enabled
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OFIE</name>
              <description>
              FIFO Overflow Interrupt Enable
              0 = FIFO Overflow interrupt is not enabled
              1 = FIFO Overflow interrupt is enabled
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMADONEIE</name>
              <description>
              DMA Transaction Done Interrupt Enable
              0 = DMA Transaction done interrupt is not enabled.
              1 = DMA Transaction done interrupt is enabled.
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MSDIE</name>
              <description>
              Master Stop Detected Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C unit to interrupt upon detecting a Master Stop sent by the I2C unit.
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BEDIE</name>
              <description>
              Bus Error Detected Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C to interrupt for the following I2C bus errors:
              As a master transmitter, no ACK was detected after a byte was sent.
              As a slave receiver, the I2C generated a NACK pulse.
              Software is responsible for guaranteeing that misplaced Start and Stop conditions do not occur.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SADIE</name>
              <description>
              Slave Address Detected Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C to interrupt upon detecting a slave address match or a general call address.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RFIE</name>
              <description>
              DBR Receive Full Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C to interrupt when the DBR has received a data byte from the I2C bus.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIE</name>
              <description>
              DBR Transmit Empty Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C to interrupt after transmitting a byte onto the I2C bus.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ALDIE</name>
              <description>
              Arbitration Loss Detected Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C to interrupt upon losing arbitration while in master mode.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SSDIE</name>
              <description>
              Slave Stop Detected Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C to interrupt when it detects a Stop condition while in slave mode.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SR</name>
          <displayName>SR</displayName>
          <description>Status register</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>UF</name>
              <description>
              FIFO Underflow Flag. Asserted when FIFO is empty and a POP request generated without a PUSH. Cleared if write 1
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OF</name>
              <description>
              FIFO Overflow Flag. Asserted when FIFO is full and a PUSH request generated without a POP. Cleared if write 1
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMADONE</name>
              <description>
              DMA Transaction Done. Asserted when both APB and I2C bus have finished transfer. Cleared if write 1
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MSD</name>
              <description>
              Master Stop Detected:
              0 = No Master Stop Detected.
              1 = This bit is set by the I2C unit when all of the following are true:
              This bit is enabled (CR[MSDE] = 1);
              I2C unit is configured as a master;
              I2C transmits a STOP signal
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EBB</name>
              <description>
              Early Bus Busy
              0 = I2C bus is idle or the I2C is using the bus (that is, unit busy).
              1 = Set when the unit detects that the SCL or SDA line is low without a START condition. Bit will remain set until the I2C unit detects the bus is idle by detecting a STOP condition. Bit will also be set whenever the IBB bit is set.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BED</name>
              <description>
              Bus Error Detected:
              0 = No error detected.
              1 = The I2C sets this bit when it detects one of the following error conditions:
              As a master transmitter, no ACK was detected on the interface after a byte was sent.
              As a slave receiver, the I2C generates a NACK pulse.
              When an error occurs, I2C bus transactions continue. Software must guarantee that misplaced Start and Stop conditions do not occur. 
              Cleared if write 1
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SAD</name>
              <description>
              Slave Address Detected:
              0 = No slave address was detected.
              1 = The I2C detected a seven-bit address that matches the general call address or SAR. An interrupt is signalled when enabled in the CR. 
              Cleared if write 1
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RF</name>
              <description>
              DBR Receive Full:
              0 = The DBR has not received a new data byte or the I2C is idle.
              1 = The DBR register received a new data byte from the I2C bus. An interrupt is signalled when enabled in the CR. 
              Cleared if write 1
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TE</name>
              <description>
              DBR Transmit Empty:
              0 = The data byte is still being transmitted.
              1 = The I2C has finished transmitting a data byte on the I2C bus. An interrupt is signalled when enabled in the CR.
              Cleared if write 1
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ALD</name>
              <description>
              Arbitration Loss Detected:
              Used during multi-master operation:
              0 = Cleared when arbitration is won or never took place.
              1 = Set when the I2C loses arbitration. 
              Cleared if write 1
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SSD</name>
              <description>
              Slave Stop Detected:
              0 = No Stop detected.
              1 = Set when the I2C detects a Stop while in slave-receive or slave-transmit mode. 
              Cleared if write 1
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IBB</name>
              <description>
              I2C Bus Busy:
              0 = I2C bus is idle or the I2C is using the bus (that is, unit busy).
              1 = Set when the I2C bus is busy but local I2C is not involved in the transaction.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UB</name>
              <description>
              Unit Busy:
              0 = I2C not busy.
              1 = Set when local I2C is busy. This is defined as the time between the first Start and Stop. 
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>NACK</name>
              <description>
              ACK/NACK Status:
              0 = The I2C received or sent an ACK on the bus. 
              1 = The I2C received or sent a NACK.on the bus.
              This bit is used in slave-transmit mode to determine when the byte transferred is the last one. This bit is updated after each byte and ACK/NACK information is received.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RWM</name>
              <description>
              Read/write Mode:
              0 = The I2C is in master-transmit or slave-receive mode. 
              1 = The I2C is in master-receive or slave-transmit mode. 
              This is the R/nW bit of the slave address. It is cleared automatically by hardware after a Stop state.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DBR</name>
          <displayName>DBR</displayName>
          <description>Data Buffer register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>DATA</name>
              <description>
              use the I2C Data Buffer register to transmit and receive data from the I2C bus. The DBR is accessed by software on one Side and by the I2C Shift register on the other. The DBR receives data coming into the I2C unit after a full byte is received and acknowledged. CPU writes data going out of the I2C to the DBR and sends it to the serial bus. 
              When the I2C is in transmit mode (master or slave), CPU writes data to the DBR over the internal bus. CPU write data to the DBR when a master transaction is initiated or when the DBR transmit-empty interrupt is signalled. Data moves from the DBR to the Shift register when the transfer byte bit is set. The DBR transmit-empty interrupt is signalled (if enabled) when a byte is transferred on the I2C bus and the acknowledge cycle is complete. If the DBR is not written, and a Stop condition is not in place before the I2C bus is ready to transfer the next byte packet, the I2C unit inserts wait states until CPU writes the DBR and sets the transfer byte bit.
              When the I2C is in receive mode (master or slave), CPU reads DBR data over the internal bus. CPU reads data from the DBR when the DBR receive-full interrupt is signalled. The data moves from the Shift register to the DBR when the acknowledge cycle is complete. The I2C inserts wait states until the DBR is read. After the software reads the DBR, CR[NACK] are written by the software, allowing the next byte transfer to proceed to the I2C bus.
              In DMA mode, DBR is automatically filled from FIFO in master transmit mode, or fetched and stored in FIFO in master receive mode until DMA done or aborted.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SAR</name>
          <displayName>SAR</displayName>
          <description>Slave Address Register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000047</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>25</bitWidth>
            </field>
            <field>
              <name>ADDR</name>
              <description>
              The seven-bit address to which the I2C responds when in slave-receive mode
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>LCR</name>
          <displayName>LCR</displayName>
          <description>Load Count Register</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x081C72ED</resetValue>
          <fields>
            <field>
              <name>HLVH</name>
              <description>
              Decrementer Load value for High Speed Mode SCL (master mode) for high phase. 
              Thigh=Tfclk*(HLVH+4+DNF)
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>HLVL</name>
              <description>
              Decrementer Load value for High Speed Mode SCL (master mode) for low phase. 
              Tlow=Tfclk*(HLVL+3+DNF). Data rate is generated as 1/(Thigh+Tlow), or Ffclk/(HLVH+HLVL+7+2*DNF). 
              3.2Mbps data rate is generated by default if fclk is 48MHz.
              HLVL also controls setup time and hold time for START and STOP condition in High Speed Mode(master mode). 
              Thdsta=Tsusta=Tsusto=Tfclk*(HLVL+1)
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
            <field>
              <name>FLV</name>
              <description>
              Decrementer Load value for Fast Mode (or Fast Mode Plus) SCL (master mode) for both high and low phase. 
              Data rate is generated as Ffclk/(FLV+max(FLV,CNT*2+6)+7+DNF) approximately. 
              400kbps data rate is generated by default if fclk is 48MHz.
              FLV also controls setup time and hold time for START and STOP condition in Fast Mode(master mode). 
              Thdsta=Tsusta=Tsusto=Tfclk*FLV
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
            <field>
              <name>SLV</name>
              <description>
              Decrementer Load value for Standard Mode SCL (master mode) for both high & low phase. 
              Data rate is generated as Ffclk/(SLV+max(SLV,CNT*2+6)+7+DNF) approximately. 
              100kbps data rate is generated by default if fclk is 48MHz.
              SLV also controls setup time and hold time for START and STOP condition in Standard Mode(master mode). 
              Thdsta=Tsusta=Tsusto=Tfclk*SLV
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>WCR</name>
          <displayName>WCR</displayName>
          <description>Wait Count Register</description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0000000A</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>CNT</name>
              <description>
              Controls the counter values defining the setup and hold times in standard and fast mode
              Tvddat=Thddat=Tfclk*(CNT+2)
              Tsudat=max(Tlow-Thddat,Thddat)
              Lower counter values may violate setup and hold times.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RCCR</name>
          <displayName>RCCR</displayName>
          <description>Bus Reset Cycle Counter Register</description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000009</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>28</bitWidth>
            </field>
            <field>
              <name>RSTCYC</name>
              <description>
              The cycles of SCL during bus reset
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BMR</name>
          <displayName>BMR</displayName>
          <description>Bus Monitor Register</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000003</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>30</bitWidth>
            </field>
            <field>
              <name>SCL</name>
              <description>
              value of the SCL pin. Software can check bus level when the I2C bus is hung and the I2C unit must be reset.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SDA</name>
              <description>
              value of the SDA pin.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DNR</name>
          <displayName>DNR</displayName>
          <description>DMA number register</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>NDT</name>
              <description>
              Write as number of data to transfer in byte. Read as left data number to transfer
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD1</name>
          <displayName>RSVD1</displayName>
          <description></description>
          <addressOffset>0x2C</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>FIFO</name>
          <displayName>FIFO</displayName>
          <description>FIFO Register</description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>DATA</name>
              <description>
              Write to push send data into FIFO. Read to pop received data from FIFO
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>I2C3</name>
      <description></description>
      <groupName>I2C</groupName>
      <baseAddress>0x5009e000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CR</name>
          <displayName>CR</displayName>
          <description>Control register</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>UR</name>
              <description>
              Unit Reset. Software need first assert to reset then deassert to release.
              0 = No reset.
              1 = Reset I2C module.
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSTREQ</name>
              <description>
              I2C will do bus reset upon this bit set. Will be cleared by HW automatically after RSTCYC cycles of SCL generated.
              1 = request for i2c bus reset
              0 = bus reset finished
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BRGRST</name>
              <description>
              Reset bus related state machine and signals. Will be cleared by HW automatically
              1 = request for reset
              0 = reset finished
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>14</bitWidth>
            </field>
            <field>
              <name>DNF</name>
              <description>
              Digital noise filter
              These bits are used to configure the digital noise filter on SDA and SCL input. The digital filter will filter spikes with a length of up to DNF*Tfclk.
              0: Digital filter disabled 
              1: Digital filter enabled and filtering capability up to 1 Tfclk
              ...
              7: digital filter enabled and filtering capability up to 7 Tfclk
              Digital filter is added to analog filter. Digital filter will introduce delay on SCL and SDA processing, which is essential in hs-mode. 
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>SLVEN</name>
              <description>
              Slave mode Enable for SCL.
              0 = Disable slave mode. Will not monitor slave address on I2C bus.
              1 = Enable slave mode. Will monitor slave address on I2C bus.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SCLPP</name>
              <description>
              Push-pull mode Enable for SCL.
              0 = open drain output for SCL.
              1 = Push-pull output for SCL
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MSDE</name>
              <description>
              Master Stop Detected Enable:
              0 = Master Stop Detect (MSD) status is not enabled.
              1 = Master Stop Detect (MSD) status is enabled.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LASTSTOP</name>
              <description>
              Generate STOP for last DMA transfer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LASTNACK</name>
              <description>
              Generate NACK for last DMA Read transfer
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMAEN</name>
              <description>
              DMA Enable for both TX and RX
              0 = DMA mode is NOT enabled
              1 = DMA mode enabled
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SCLE</name>
              <description>
              SCL Enable:
              0 = Disables the I2C from driving the SCL line.
              1 = Enables the I2C clock output for master-mode operation.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IUE</name>
              <description>
              I2C Unit Enable:
              0 = Disables the unit and does not master any transactions or respond to any slave transactions.
              1 = Enables the I2C (defaults to slave-receive mode).
              Software must guarantee the I2C bus is idle before setting this bit.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MODE</name>
              <description>
              Bus Mode (Master operation):
              2'b00: standard-mode
              2'b01: fast-mode and fast-mode plus
              2'b10: HS-mode (standard mode when not doing a high speed transfer)
              2'b11: HS-mode (fast mode when not doing a high speed transfer)
              Bus Mode (Slave operation):
              2'b0x: HS-mode is disabled. I2C unit uses Standard/Fast mode timing on the SDA pin.
              2'b1x: HS-mode is enabled. I2C unit uses HS-mode timing on the SDA pin when a master code is received.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TCR</name>
          <displayName>TCR</displayName>
          <description>Transfer Control register</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>ABORTDMA</name>
              <description>
              Abort DMA operation. Will be cleared by HW automatically
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RXREQ</name>
              <description>
              Request DMA RX. Will be cleared by HW automatically
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TXREQ</name>
              <description>
              Request DMA TX. Will be cleared by HW automatically
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MA</name>
              <description>
              Master Abort:
              Used by the I2C in master mode to generate a Stop without transmitting another data byte:
              0 = The I2C transmits Stop on if TCR[STOP] is set.
              1 = The I2C sends Stop without data transmission.
              When in master-transmit mode, after transmitting a data byte, the TCR[TB] bit is cleared. When no more data bytes need to be sent, setting master abort bit sends the Stop. The TCR[TB] bit must remain clear.
              In master-receive mode, when a NAK is sent without a Stop (TCR[STOP] bit was not set) and CPU does not send a repeated Start, setting this bit sends the Stop. Once again, the TCR[TB] bit must remain clear. Master Abort can be done immediately after the address phase (Master Transmit mode only).
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>NACK</name>
              <description>
              The positive/negative acknowledge control bit, defines the type of acknowledge pulse sent by the I2C when in master receive mode:
              0 = Send a positive acknowledge (ACK) pulse after receiving a data byte.
              1 = Send a negative acknowledge (NACK) pulse after receiving a data byte.
              The I2C automatically sends an ACK pulse when responding to its slave address or when responding in slave-receive mode, regardless of the NACK control-bit setting.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>STOP</name>
              <description>
              Stop:
              Used to initiate a Stop condition after transferring the next data byte on the I2C bus when in master mode. In master-receive mode, the NACK control bit must be set in conjunction with the STOP bit. 
              0 = Do not send a Stop.
              1 = Send a Stop.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>START</name>
              <description>
              Start:
              Used to initiate a Start condition to the I2C unit when in master mode. 
              0 = Do not send a Start pulse.
              1 = Send a Start pulse.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TB</name>
              <description>
              Transfer Byte:
              Used to send or receive a byte on the I2C bus:
              0 = Cleared by I2C when the byte is sent/received.
              1 = Send/receive a byte. 
              CPU can monitor this bit to determine when the byte transfer has completed. In master or slave mode, after each byte transfer including acknowledge pulse, the I2C holds the SCL line low (inserting wait states) until TB is set.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IER</name>
          <displayName>IER</displayName>
          <description>Interrupt Enable register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>UFIE</name>
              <description>
              FIFO Underflow Interrupt Enable
              0 = FIFO Underflow interrupt is not enabled
              1 = FIFO Underflow interrupt is enabled
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OFIE</name>
              <description>
              FIFO Overflow Interrupt Enable
              0 = FIFO Overflow interrupt is not enabled
              1 = FIFO Overflow interrupt is enabled
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMADONEIE</name>
              <description>
              DMA Transaction Done Interrupt Enable
              0 = DMA Transaction done interrupt is not enabled.
              1 = DMA Transaction done interrupt is enabled.
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MSDIE</name>
              <description>
              Master Stop Detected Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C unit to interrupt upon detecting a Master Stop sent by the I2C unit.
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BEDIE</name>
              <description>
              Bus Error Detected Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C to interrupt for the following I2C bus errors:
              As a master transmitter, no ACK was detected after a byte was sent.
              As a slave receiver, the I2C generated a NACK pulse.
              Software is responsible for guaranteeing that misplaced Start and Stop conditions do not occur.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SADIE</name>
              <description>
              Slave Address Detected Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C to interrupt upon detecting a slave address match or a general call address.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RFIE</name>
              <description>
              DBR Receive Full Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C to interrupt when the DBR has received a data byte from the I2C bus.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIE</name>
              <description>
              DBR Transmit Empty Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C to interrupt after transmitting a byte onto the I2C bus.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ALDIE</name>
              <description>
              Arbitration Loss Detected Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C to interrupt upon losing arbitration while in master mode.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SSDIE</name>
              <description>
              Slave Stop Detected Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C to interrupt when it detects a Stop condition while in slave mode.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SR</name>
          <displayName>SR</displayName>
          <description>Status register</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>UF</name>
              <description>
              FIFO Underflow Flag. Asserted when FIFO is empty and a POP request generated without a PUSH. Cleared if write 1
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OF</name>
              <description>
              FIFO Overflow Flag. Asserted when FIFO is full and a PUSH request generated without a POP. Cleared if write 1
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMADONE</name>
              <description>
              DMA Transaction Done. Asserted when both APB and I2C bus have finished transfer. Cleared if write 1
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MSD</name>
              <description>
              Master Stop Detected:
              0 = No Master Stop Detected.
              1 = This bit is set by the I2C unit when all of the following are true:
              This bit is enabled (CR[MSDE] = 1);
              I2C unit is configured as a master;
              I2C transmits a STOP signal
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EBB</name>
              <description>
              Early Bus Busy
              0 = I2C bus is idle or the I2C is using the bus (that is, unit busy).
              1 = Set when the unit detects that the SCL or SDA line is low without a START condition. Bit will remain set until the I2C unit detects the bus is idle by detecting a STOP condition. Bit will also be set whenever the IBB bit is set.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BED</name>
              <description>
              Bus Error Detected:
              0 = No error detected.
              1 = The I2C sets this bit when it detects one of the following error conditions:
              As a master transmitter, no ACK was detected on the interface after a byte was sent.
              As a slave receiver, the I2C generates a NACK pulse.
              When an error occurs, I2C bus transactions continue. Software must guarantee that misplaced Start and Stop conditions do not occur. 
              Cleared if write 1
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SAD</name>
              <description>
              Slave Address Detected:
              0 = No slave address was detected.
              1 = The I2C detected a seven-bit address that matches the general call address or SAR. An interrupt is signalled when enabled in the CR. 
              Cleared if write 1
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RF</name>
              <description>
              DBR Receive Full:
              0 = The DBR has not received a new data byte or the I2C is idle.
              1 = The DBR register received a new data byte from the I2C bus. An interrupt is signalled when enabled in the CR. 
              Cleared if write 1
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TE</name>
              <description>
              DBR Transmit Empty:
              0 = The data byte is still being transmitted.
              1 = The I2C has finished transmitting a data byte on the I2C bus. An interrupt is signalled when enabled in the CR.
              Cleared if write 1
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ALD</name>
              <description>
              Arbitration Loss Detected:
              Used during multi-master operation:
              0 = Cleared when arbitration is won or never took place.
              1 = Set when the I2C loses arbitration. 
              Cleared if write 1
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SSD</name>
              <description>
              Slave Stop Detected:
              0 = No Stop detected.
              1 = Set when the I2C detects a Stop while in slave-receive or slave-transmit mode. 
              Cleared if write 1
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IBB</name>
              <description>
              I2C Bus Busy:
              0 = I2C bus is idle or the I2C is using the bus (that is, unit busy).
              1 = Set when the I2C bus is busy but local I2C is not involved in the transaction.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UB</name>
              <description>
              Unit Busy:
              0 = I2C not busy.
              1 = Set when local I2C is busy. This is defined as the time between the first Start and Stop. 
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>NACK</name>
              <description>
              ACK/NACK Status:
              0 = The I2C received or sent an ACK on the bus. 
              1 = The I2C received or sent a NACK.on the bus.
              This bit is used in slave-transmit mode to determine when the byte transferred is the last one. This bit is updated after each byte and ACK/NACK information is received.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RWM</name>
              <description>
              Read/write Mode:
              0 = The I2C is in master-transmit or slave-receive mode. 
              1 = The I2C is in master-receive or slave-transmit mode. 
              This is the R/nW bit of the slave address. It is cleared automatically by hardware after a Stop state.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DBR</name>
          <displayName>DBR</displayName>
          <description>Data Buffer register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>DATA</name>
              <description>
              use the I2C Data Buffer register to transmit and receive data from the I2C bus. The DBR is accessed by software on one Side and by the I2C Shift register on the other. The DBR receives data coming into the I2C unit after a full byte is received and acknowledged. CPU writes data going out of the I2C to the DBR and sends it to the serial bus. 
              When the I2C is in transmit mode (master or slave), CPU writes data to the DBR over the internal bus. CPU write data to the DBR when a master transaction is initiated or when the DBR transmit-empty interrupt is signalled. Data moves from the DBR to the Shift register when the transfer byte bit is set. The DBR transmit-empty interrupt is signalled (if enabled) when a byte is transferred on the I2C bus and the acknowledge cycle is complete. If the DBR is not written, and a Stop condition is not in place before the I2C bus is ready to transfer the next byte packet, the I2C unit inserts wait states until CPU writes the DBR and sets the transfer byte bit.
              When the I2C is in receive mode (master or slave), CPU reads DBR data over the internal bus. CPU reads data from the DBR when the DBR receive-full interrupt is signalled. The data moves from the Shift register to the DBR when the acknowledge cycle is complete. The I2C inserts wait states until the DBR is read. After the software reads the DBR, CR[NACK] are written by the software, allowing the next byte transfer to proceed to the I2C bus.
              In DMA mode, DBR is automatically filled from FIFO in master transmit mode, or fetched and stored in FIFO in master receive mode until DMA done or aborted.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SAR</name>
          <displayName>SAR</displayName>
          <description>Slave Address Register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000047</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>25</bitWidth>
            </field>
            <field>
              <name>ADDR</name>
              <description>
              The seven-bit address to which the I2C responds when in slave-receive mode
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>LCR</name>
          <displayName>LCR</displayName>
          <description>Load Count Register</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x081C72ED</resetValue>
          <fields>
            <field>
              <name>HLVH</name>
              <description>
              Decrementer Load value for High Speed Mode SCL (master mode) for high phase. 
              Thigh=Tfclk*(HLVH+4+DNF)
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>HLVL</name>
              <description>
              Decrementer Load value for High Speed Mode SCL (master mode) for low phase. 
              Tlow=Tfclk*(HLVL+3+DNF). Data rate is generated as 1/(Thigh+Tlow), or Ffclk/(HLVH+HLVL+7+2*DNF). 
              3.2Mbps data rate is generated by default if fclk is 48MHz.
              HLVL also controls setup time and hold time for START and STOP condition in High Speed Mode(master mode). 
              Thdsta=Tsusta=Tsusto=Tfclk*(HLVL+1)
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
            <field>
              <name>FLV</name>
              <description>
              Decrementer Load value for Fast Mode (or Fast Mode Plus) SCL (master mode) for both high and low phase. 
              Data rate is generated as Ffclk/(FLV+max(FLV,CNT*2+6)+7+DNF) approximately. 
              400kbps data rate is generated by default if fclk is 48MHz.
              FLV also controls setup time and hold time for START and STOP condition in Fast Mode(master mode). 
              Thdsta=Tsusta=Tsusto=Tfclk*FLV
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
            <field>
              <name>SLV</name>
              <description>
              Decrementer Load value for Standard Mode SCL (master mode) for both high & low phase. 
              Data rate is generated as Ffclk/(SLV+max(SLV,CNT*2+6)+7+DNF) approximately. 
              100kbps data rate is generated by default if fclk is 48MHz.
              SLV also controls setup time and hold time for START and STOP condition in Standard Mode(master mode). 
              Thdsta=Tsusta=Tsusto=Tfclk*SLV
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>WCR</name>
          <displayName>WCR</displayName>
          <description>Wait Count Register</description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0000000A</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>CNT</name>
              <description>
              Controls the counter values defining the setup and hold times in standard and fast mode
              Tvddat=Thddat=Tfclk*(CNT+2)
              Tsudat=max(Tlow-Thddat,Thddat)
              Lower counter values may violate setup and hold times.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RCCR</name>
          <displayName>RCCR</displayName>
          <description>Bus Reset Cycle Counter Register</description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000009</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>28</bitWidth>
            </field>
            <field>
              <name>RSTCYC</name>
              <description>
              The cycles of SCL during bus reset
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BMR</name>
          <displayName>BMR</displayName>
          <description>Bus Monitor Register</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000003</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>30</bitWidth>
            </field>
            <field>
              <name>SCL</name>
              <description>
              value of the SCL pin. Software can check bus level when the I2C bus is hung and the I2C unit must be reset.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SDA</name>
              <description>
              value of the SDA pin.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DNR</name>
          <displayName>DNR</displayName>
          <description>DMA number register</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>NDT</name>
              <description>
              Write as number of data to transfer in byte. Read as left data number to transfer
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD1</name>
          <displayName>RSVD1</displayName>
          <description></description>
          <addressOffset>0x2C</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>FIFO</name>
          <displayName>FIFO</displayName>
          <description>FIFO Register</description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>DATA</name>
              <description>
              Write to push send data into FIFO. Read to pop received data from FIFO
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>I2C4</name>
      <description></description>
      <groupName>I2C</groupName>
      <baseAddress>0x5009f000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CR</name>
          <displayName>CR</displayName>
          <description>Control register</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>UR</name>
              <description>
              Unit Reset. Software need first assert to reset then deassert to release.
              0 = No reset.
              1 = Reset I2C module.
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSTREQ</name>
              <description>
              I2C will do bus reset upon this bit set. Will be cleared by HW automatically after RSTCYC cycles of SCL generated.
              1 = request for i2c bus reset
              0 = bus reset finished
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BRGRST</name>
              <description>
              Reset bus related state machine and signals. Will be cleared by HW automatically
              1 = request for reset
              0 = reset finished
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>14</bitWidth>
            </field>
            <field>
              <name>DNF</name>
              <description>
              Digital noise filter
              These bits are used to configure the digital noise filter on SDA and SCL input. The digital filter will filter spikes with a length of up to DNF*Tfclk.
              0: Digital filter disabled 
              1: Digital filter enabled and filtering capability up to 1 Tfclk
              ...
              7: digital filter enabled and filtering capability up to 7 Tfclk
              Digital filter is added to analog filter. Digital filter will introduce delay on SCL and SDA processing, which is essential in hs-mode. 
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>SLVEN</name>
              <description>
              Slave mode Enable for SCL.
              0 = Disable slave mode. Will not monitor slave address on I2C bus.
              1 = Enable slave mode. Will monitor slave address on I2C bus.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SCLPP</name>
              <description>
              Push-pull mode Enable for SCL.
              0 = open drain output for SCL.
              1 = Push-pull output for SCL
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MSDE</name>
              <description>
              Master Stop Detected Enable:
              0 = Master Stop Detect (MSD) status is not enabled.
              1 = Master Stop Detect (MSD) status is enabled.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LASTSTOP</name>
              <description>
              Generate STOP for last DMA transfer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LASTNACK</name>
              <description>
              Generate NACK for last DMA Read transfer
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMAEN</name>
              <description>
              DMA Enable for both TX and RX
              0 = DMA mode is NOT enabled
              1 = DMA mode enabled
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SCLE</name>
              <description>
              SCL Enable:
              0 = Disables the I2C from driving the SCL line.
              1 = Enables the I2C clock output for master-mode operation.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IUE</name>
              <description>
              I2C Unit Enable:
              0 = Disables the unit and does not master any transactions or respond to any slave transactions.
              1 = Enables the I2C (defaults to slave-receive mode).
              Software must guarantee the I2C bus is idle before setting this bit.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MODE</name>
              <description>
              Bus Mode (Master operation):
              2'b00: standard-mode
              2'b01: fast-mode and fast-mode plus
              2'b10: HS-mode (standard mode when not doing a high speed transfer)
              2'b11: HS-mode (fast mode when not doing a high speed transfer)
              Bus Mode (Slave operation):
              2'b0x: HS-mode is disabled. I2C unit uses Standard/Fast mode timing on the SDA pin.
              2'b1x: HS-mode is enabled. I2C unit uses HS-mode timing on the SDA pin when a master code is received.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TCR</name>
          <displayName>TCR</displayName>
          <description>Transfer Control register</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>ABORTDMA</name>
              <description>
              Abort DMA operation. Will be cleared by HW automatically
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RXREQ</name>
              <description>
              Request DMA RX. Will be cleared by HW automatically
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TXREQ</name>
              <description>
              Request DMA TX. Will be cleared by HW automatically
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MA</name>
              <description>
              Master Abort:
              Used by the I2C in master mode to generate a Stop without transmitting another data byte:
              0 = The I2C transmits Stop on if TCR[STOP] is set.
              1 = The I2C sends Stop without data transmission.
              When in master-transmit mode, after transmitting a data byte, the TCR[TB] bit is cleared. When no more data bytes need to be sent, setting master abort bit sends the Stop. The TCR[TB] bit must remain clear.
              In master-receive mode, when a NAK is sent without a Stop (TCR[STOP] bit was not set) and CPU does not send a repeated Start, setting this bit sends the Stop. Once again, the TCR[TB] bit must remain clear. Master Abort can be done immediately after the address phase (Master Transmit mode only).
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>NACK</name>
              <description>
              The positive/negative acknowledge control bit, defines the type of acknowledge pulse sent by the I2C when in master receive mode:
              0 = Send a positive acknowledge (ACK) pulse after receiving a data byte.
              1 = Send a negative acknowledge (NACK) pulse after receiving a data byte.
              The I2C automatically sends an ACK pulse when responding to its slave address or when responding in slave-receive mode, regardless of the NACK control-bit setting.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>STOP</name>
              <description>
              Stop:
              Used to initiate a Stop condition after transferring the next data byte on the I2C bus when in master mode. In master-receive mode, the NACK control bit must be set in conjunction with the STOP bit. 
              0 = Do not send a Stop.
              1 = Send a Stop.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>START</name>
              <description>
              Start:
              Used to initiate a Start condition to the I2C unit when in master mode. 
              0 = Do not send a Start pulse.
              1 = Send a Start pulse.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TB</name>
              <description>
              Transfer Byte:
              Used to send or receive a byte on the I2C bus:
              0 = Cleared by I2C when the byte is sent/received.
              1 = Send/receive a byte. 
              CPU can monitor this bit to determine when the byte transfer has completed. In master or slave mode, after each byte transfer including acknowledge pulse, the I2C holds the SCL line low (inserting wait states) until TB is set.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IER</name>
          <displayName>IER</displayName>
          <description>Interrupt Enable register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>UFIE</name>
              <description>
              FIFO Underflow Interrupt Enable
              0 = FIFO Underflow interrupt is not enabled
              1 = FIFO Underflow interrupt is enabled
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OFIE</name>
              <description>
              FIFO Overflow Interrupt Enable
              0 = FIFO Overflow interrupt is not enabled
              1 = FIFO Overflow interrupt is enabled
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMADONEIE</name>
              <description>
              DMA Transaction Done Interrupt Enable
              0 = DMA Transaction done interrupt is not enabled.
              1 = DMA Transaction done interrupt is enabled.
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MSDIE</name>
              <description>
              Master Stop Detected Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C unit to interrupt upon detecting a Master Stop sent by the I2C unit.
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BEDIE</name>
              <description>
              Bus Error Detected Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C to interrupt for the following I2C bus errors:
              As a master transmitter, no ACK was detected after a byte was sent.
              As a slave receiver, the I2C generated a NACK pulse.
              Software is responsible for guaranteeing that misplaced Start and Stop conditions do not occur.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SADIE</name>
              <description>
              Slave Address Detected Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C to interrupt upon detecting a slave address match or a general call address.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RFIE</name>
              <description>
              DBR Receive Full Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C to interrupt when the DBR has received a data byte from the I2C bus.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIE</name>
              <description>
              DBR Transmit Empty Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C to interrupt after transmitting a byte onto the I2C bus.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ALDIE</name>
              <description>
              Arbitration Loss Detected Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C to interrupt upon losing arbitration while in master mode.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SSDIE</name>
              <description>
              Slave Stop Detected Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C to interrupt when it detects a Stop condition while in slave mode.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SR</name>
          <displayName>SR</displayName>
          <description>Status register</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>UF</name>
              <description>
              FIFO Underflow Flag. Asserted when FIFO is empty and a POP request generated without a PUSH. Cleared if write 1
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OF</name>
              <description>
              FIFO Overflow Flag. Asserted when FIFO is full and a PUSH request generated without a POP. Cleared if write 1
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMADONE</name>
              <description>
              DMA Transaction Done. Asserted when both APB and I2C bus have finished transfer. Cleared if write 1
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MSD</name>
              <description>
              Master Stop Detected:
              0 = No Master Stop Detected.
              1 = This bit is set by the I2C unit when all of the following are true:
              This bit is enabled (CR[MSDE] = 1);
              I2C unit is configured as a master;
              I2C transmits a STOP signal
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EBB</name>
              <description>
              Early Bus Busy
              0 = I2C bus is idle or the I2C is using the bus (that is, unit busy).
              1 = Set when the unit detects that the SCL or SDA line is low without a START condition. Bit will remain set until the I2C unit detects the bus is idle by detecting a STOP condition. Bit will also be set whenever the IBB bit is set.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BED</name>
              <description>
              Bus Error Detected:
              0 = No error detected.
              1 = The I2C sets this bit when it detects one of the following error conditions:
              As a master transmitter, no ACK was detected on the interface after a byte was sent.
              As a slave receiver, the I2C generates a NACK pulse.
              When an error occurs, I2C bus transactions continue. Software must guarantee that misplaced Start and Stop conditions do not occur. 
              Cleared if write 1
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SAD</name>
              <description>
              Slave Address Detected:
              0 = No slave address was detected.
              1 = The I2C detected a seven-bit address that matches the general call address or SAR. An interrupt is signalled when enabled in the CR. 
              Cleared if write 1
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RF</name>
              <description>
              DBR Receive Full:
              0 = The DBR has not received a new data byte or the I2C is idle.
              1 = The DBR register received a new data byte from the I2C bus. An interrupt is signalled when enabled in the CR. 
              Cleared if write 1
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TE</name>
              <description>
              DBR Transmit Empty:
              0 = The data byte is still being transmitted.
              1 = The I2C has finished transmitting a data byte on the I2C bus. An interrupt is signalled when enabled in the CR.
              Cleared if write 1
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ALD</name>
              <description>
              Arbitration Loss Detected:
              Used during multi-master operation:
              0 = Cleared when arbitration is won or never took place.
              1 = Set when the I2C loses arbitration. 
              Cleared if write 1
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SSD</name>
              <description>
              Slave Stop Detected:
              0 = No Stop detected.
              1 = Set when the I2C detects a Stop while in slave-receive or slave-transmit mode. 
              Cleared if write 1
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IBB</name>
              <description>
              I2C Bus Busy:
              0 = I2C bus is idle or the I2C is using the bus (that is, unit busy).
              1 = Set when the I2C bus is busy but local I2C is not involved in the transaction.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UB</name>
              <description>
              Unit Busy:
              0 = I2C not busy.
              1 = Set when local I2C is busy. This is defined as the time between the first Start and Stop. 
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>NACK</name>
              <description>
              ACK/NACK Status:
              0 = The I2C received or sent an ACK on the bus. 
              1 = The I2C received or sent a NACK.on the bus.
              This bit is used in slave-transmit mode to determine when the byte transferred is the last one. This bit is updated after each byte and ACK/NACK information is received.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RWM</name>
              <description>
              Read/write Mode:
              0 = The I2C is in master-transmit or slave-receive mode. 
              1 = The I2C is in master-receive or slave-transmit mode. 
              This is the R/nW bit of the slave address. It is cleared automatically by hardware after a Stop state.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DBR</name>
          <displayName>DBR</displayName>
          <description>Data Buffer register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>DATA</name>
              <description>
              use the I2C Data Buffer register to transmit and receive data from the I2C bus. The DBR is accessed by software on one Side and by the I2C Shift register on the other. The DBR receives data coming into the I2C unit after a full byte is received and acknowledged. CPU writes data going out of the I2C to the DBR and sends it to the serial bus. 
              When the I2C is in transmit mode (master or slave), CPU writes data to the DBR over the internal bus. CPU write data to the DBR when a master transaction is initiated or when the DBR transmit-empty interrupt is signalled. Data moves from the DBR to the Shift register when the transfer byte bit is set. The DBR transmit-empty interrupt is signalled (if enabled) when a byte is transferred on the I2C bus and the acknowledge cycle is complete. If the DBR is not written, and a Stop condition is not in place before the I2C bus is ready to transfer the next byte packet, the I2C unit inserts wait states until CPU writes the DBR and sets the transfer byte bit.
              When the I2C is in receive mode (master or slave), CPU reads DBR data over the internal bus. CPU reads data from the DBR when the DBR receive-full interrupt is signalled. The data moves from the Shift register to the DBR when the acknowledge cycle is complete. The I2C inserts wait states until the DBR is read. After the software reads the DBR, CR[NACK] are written by the software, allowing the next byte transfer to proceed to the I2C bus.
              In DMA mode, DBR is automatically filled from FIFO in master transmit mode, or fetched and stored in FIFO in master receive mode until DMA done or aborted.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SAR</name>
          <displayName>SAR</displayName>
          <description>Slave Address Register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000047</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>25</bitWidth>
            </field>
            <field>
              <name>ADDR</name>
              <description>
              The seven-bit address to which the I2C responds when in slave-receive mode
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>LCR</name>
          <displayName>LCR</displayName>
          <description>Load Count Register</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x081C72ED</resetValue>
          <fields>
            <field>
              <name>HLVH</name>
              <description>
              Decrementer Load value for High Speed Mode SCL (master mode) for high phase. 
              Thigh=Tfclk*(HLVH+4+DNF)
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>HLVL</name>
              <description>
              Decrementer Load value for High Speed Mode SCL (master mode) for low phase. 
              Tlow=Tfclk*(HLVL+3+DNF). Data rate is generated as 1/(Thigh+Tlow), or Ffclk/(HLVH+HLVL+7+2*DNF). 
              3.2Mbps data rate is generated by default if fclk is 48MHz.
              HLVL also controls setup time and hold time for START and STOP condition in High Speed Mode(master mode). 
              Thdsta=Tsusta=Tsusto=Tfclk*(HLVL+1)
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
            <field>
              <name>FLV</name>
              <description>
              Decrementer Load value for Fast Mode (or Fast Mode Plus) SCL (master mode) for both high and low phase. 
              Data rate is generated as Ffclk/(FLV+max(FLV,CNT*2+6)+7+DNF) approximately. 
              400kbps data rate is generated by default if fclk is 48MHz.
              FLV also controls setup time and hold time for START and STOP condition in Fast Mode(master mode). 
              Thdsta=Tsusta=Tsusto=Tfclk*FLV
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
            <field>
              <name>SLV</name>
              <description>
              Decrementer Load value for Standard Mode SCL (master mode) for both high & low phase. 
              Data rate is generated as Ffclk/(SLV+max(SLV,CNT*2+6)+7+DNF) approximately. 
              100kbps data rate is generated by default if fclk is 48MHz.
              SLV also controls setup time and hold time for START and STOP condition in Standard Mode(master mode). 
              Thdsta=Tsusta=Tsusto=Tfclk*SLV
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>WCR</name>
          <displayName>WCR</displayName>
          <description>Wait Count Register</description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0000000A</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>CNT</name>
              <description>
              Controls the counter values defining the setup and hold times in standard and fast mode
              Tvddat=Thddat=Tfclk*(CNT+2)
              Tsudat=max(Tlow-Thddat,Thddat)
              Lower counter values may violate setup and hold times.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RCCR</name>
          <displayName>RCCR</displayName>
          <description>Bus Reset Cycle Counter Register</description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000009</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>28</bitWidth>
            </field>
            <field>
              <name>RSTCYC</name>
              <description>
              The cycles of SCL during bus reset
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BMR</name>
          <displayName>BMR</displayName>
          <description>Bus Monitor Register</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000003</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>30</bitWidth>
            </field>
            <field>
              <name>SCL</name>
              <description>
              value of the SCL pin. Software can check bus level when the I2C bus is hung and the I2C unit must be reset.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SDA</name>
              <description>
              value of the SDA pin.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DNR</name>
          <displayName>DNR</displayName>
          <description>DMA number register</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>NDT</name>
              <description>
              Write as number of data to transfer in byte. Read as left data number to transfer
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD1</name>
          <displayName>RSVD1</displayName>
          <description></description>
          <addressOffset>0x2C</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>FIFO</name>
          <displayName>FIFO</displayName>
          <description>FIFO Register</description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>DATA</name>
              <description>
              Write to push send data into FIFO. Read to pop received data from FIFO
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>HPSYS_GPIO</name>
      <description></description>
      <groupName>HPSYS_GPIO</groupName>
      <baseAddress>0x500a0000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>DIR0</name>
          <displayName>DIR0</displayName>
          <description>Data Input Register</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>IN</name>
              <description>
              GPIO[31:0] input value
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DOR0</name>
          <displayName>DOR0</displayName>
          <description>Data Output Register</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>OUT</name>
              <description>
              GPIO[31:0] output value if output enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DOSR0</name>
          <displayName>DOSR0</displayName>
          <description>Data Output  Set Register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>DOS</name>
              <description>
              set 1 to pull up output of corresponding GPIO[31:0]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DOCR0</name>
          <displayName>DOCR0</displayName>
          <description>Data Output  Clear Register</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>DOC</name>
              <description>
              set 1 to  pull down output of corresponding GPIO[31:0]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DOER0</name>
          <displayName>DOER0</displayName>
          <description>Data Output Enable Register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>DOE</name>
              <description>
              GPIO[31:0] output enable
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DOESR0</name>
          <displayName>DOESR0</displayName>
          <description>Data Output Enable Set Register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>DOES</name>
              <description>
              set 1 to enable output of corresponding GPIO[31:0]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DOECR0</name>
          <displayName>DOECR0</displayName>
          <description>Data Output Enable Clear Register</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>DOEC</name>
              <description>
              set 1 to disable output of corresponding GPIO[31:0]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IER0</name>
          <displayName>IER0</displayName>
          <description>Interrupt Enable Register</description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>IER</name>
              <description>
              GPIO[31:0]  interrupt  enable
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IESR0</name>
          <displayName>IESR0</displayName>
          <description>Interrupt Enable Set Register</description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>IES</name>
              <description>
              set 1 to enable interrupt of corresponding GPIO[31:0]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IECR0</name>
          <displayName>IECR0</displayName>
          <description>Interrupt Enable Clear Register</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>IEC</name>
              <description>
              set 1 to disable interrupt of corresponding GPIO[31:0]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ITR0</name>
          <displayName>ITR0</displayName>
          <description>Interrupt Type Register</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>ITR</name>
              <description>
              GPIO[31:0]  interrupt  type
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ITSR0</name>
          <displayName>ITSR0</displayName>
          <description>Interrupt Type Set Register</description>
          <addressOffset>0x2c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>ITS</name>
              <description>
              set 1 for edge-sensitive interrupt mode of corresponding GPIO[31:0]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ITCR0</name>
          <displayName>ITCR0</displayName>
          <description>Interrupt Type Clear Register</description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>ITC</name>
              <description>
              set 1 for level-sensitive interrupt mode of corresponding GPIO[31:0]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IPHR0</name>
          <displayName>IPHR0</displayName>
          <description>Interrupt Polarity High Register</description>
          <addressOffset>0x34</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>IPH</name>
              <description>
              rising edge in edge mode, or high level in level mode of corresponding GPIO[31:0]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IPHSR0</name>
          <displayName>IPHSR0</displayName>
          <description>Interrupt Polarity  High Set Register</description>
          <addressOffset>0x38</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>IPHS</name>
              <description>
              set 1 for rising edge in edge mode, or high level in level mode of corresponding GPIO[31:0]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IPHCR0</name>
          <displayName>IPHCR0</displayName>
          <description>Interrupt Polarity  High Clear  Register</description>
          <addressOffset>0x3c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>IPHC</name>
              <description>
              set 1 for disable rising edge in edge mode, or high level in level mode of corresponding GPIO[31:0]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IPLR0</name>
          <displayName>IPLR0</displayName>
          <description>Interrupt Polarity Low Register</description>
          <addressOffset>0x40</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>IPL</name>
              <description>
              falling edge in edge mode, or low level in level mode of corresponding GPIO[31:0]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IPLSR0</name>
          <displayName>IPLSR0</displayName>
          <description>Interrupt Polarity Low Set Register</description>
          <addressOffset>0x44</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>IPLS</name>
              <description>
              set 1 for falling edge in edge mode, or low level in level mode of corresponding GPIO[31:0]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IPLCR0</name>
          <displayName>IPLCR0</displayName>
          <description>Interrupt Polarity Low Clear Register</description>
          <addressOffset>0x48</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>IPLC</name>
              <description>
              set 1 for disable falling edge in edge mode, or low level in level mode of corresponding GPIO[31:0]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ISR0</name>
          <displayName>ISR0</displayName>
          <description>Interrupt Status Register</description>
          <addressOffset>0x4c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>IS</name>
              <description>
              Interrupt status. Write 1 will clear interrupt status of corresponding GPIO[31:0]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD3</name>
          <displayName>RSVD3</displayName>
          <description></description>
          <addressOffset>0x50</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>OEMR0</name>
          <displayName>OEMR0</displayName>
          <description>output mode Register</description>
          <addressOffset>0x60</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>OEM</name>
              <description>
              output mode of corresponding GPIO[31:0]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>OEMSR0</name>
          <displayName>OEMSR0</displayName>
          <description>output mode Set Register</description>
          <addressOffset>0x64</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>OEMS</name>
              <description>
              output mode Set of corresponding GPIO[31:0]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>OEMCR0</name>
          <displayName>OEMCR0</displayName>
          <description>output mode Clear Register</description>
          <addressOffset>0x68</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>OEMC</name>
              <description>
              output mode Clear of corresponding GPIO[31:0]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD2</name>
          <displayName>RSVD2</displayName>
          <description></description>
          <addressOffset>0x6C</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>DIR1</name>
          <displayName>DIR1</displayName>
          <description>Data Input Register</description>
          <addressOffset>0x80</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>19</bitWidth>
            </field>
            <field>
              <name>IN</name>
              <description>
              GPIO[44:32] input value
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>13</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DOR1</name>
          <displayName>DOR1</displayName>
          <description>Data Output Register</description>
          <addressOffset>0x84</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>19</bitWidth>
            </field>
            <field>
              <name>OUT</name>
              <description>
              GPIO[44:32] output value if output enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>13</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DOSR1</name>
          <displayName>DOSR1</displayName>
          <description>Data Output  Set Register</description>
          <addressOffset>0x88</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>19</bitWidth>
            </field>
            <field>
              <name>DOS</name>
              <description>
              set 1 to pull up output of corresponding GPIO[44:32]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>13</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DOCR1</name>
          <displayName>DOCR1</displayName>
          <description>Data Output  Clear Register</description>
          <addressOffset>0x8c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>19</bitWidth>
            </field>
            <field>
              <name>DOC</name>
              <description>
              set 1 to  pull down output of corresponding GPIO[44:32]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>13</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DOER1</name>
          <displayName>DOER1</displayName>
          <description>Data Output Enable Register</description>
          <addressOffset>0x90</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>19</bitWidth>
            </field>
            <field>
              <name>DOE</name>
              <description>
              GPIO[44:32] output enable
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>13</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DOESR1</name>
          <displayName>DOESR1</displayName>
          <description>Data Output Enable Set Register</description>
          <addressOffset>0x94</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>19</bitWidth>
            </field>
            <field>
              <name>DOES</name>
              <description>
              set 1 to enable output of corresponding GPIO[44:32]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>13</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DOECR1</name>
          <displayName>DOECR1</displayName>
          <description>Data Output Enable Clear Register</description>
          <addressOffset>0x98</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>19</bitWidth>
            </field>
            <field>
              <name>DOEC</name>
              <description>
              set 1 to disable output of corresponding GPIO[44:32]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>13</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IER1</name>
          <displayName>IER1</displayName>
          <description>Interrupt Enable Register</description>
          <addressOffset>0x9c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>19</bitWidth>
            </field>
            <field>
              <name>IER</name>
              <description>
              GPIO[44:32]  interrupt  enable
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>13</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IESR1</name>
          <displayName>IESR1</displayName>
          <description>Interrupt Enable Set Register</description>
          <addressOffset>0xa0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>19</bitWidth>
            </field>
            <field>
              <name>IES</name>
              <description>
              set 1 to enable interrupt of corresponding GPIO[44:32]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>13</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IECR1</name>
          <displayName>IECR1</displayName>
          <description>Interrupt Enable Clear Register</description>
          <addressOffset>0xa4</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>19</bitWidth>
            </field>
            <field>
              <name>IEC</name>
              <description>
              set 1 to disable interrupt of corresponding GPIO[44:32]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>13</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ITR1</name>
          <displayName>ITR1</displayName>
          <description>Interrupt Type Register</description>
          <addressOffset>0xa8</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>19</bitWidth>
            </field>
            <field>
              <name>ITR</name>
              <description>
              GPIO[44:32]  interrupt  type
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>13</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ITSR1</name>
          <displayName>ITSR1</displayName>
          <description>Interrupt Type Set Register</description>
          <addressOffset>0xac</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>19</bitWidth>
            </field>
            <field>
              <name>ITS</name>
              <description>
              set 1 for edge-sensitive interrupt mode of corresponding GPIO[44:32]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>13</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ITCR1</name>
          <displayName>ITCR1</displayName>
          <description>Interrupt Type Clear Register</description>
          <addressOffset>0xb0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>19</bitWidth>
            </field>
            <field>
              <name>ITC</name>
              <description>
              set 1 for level-sensitive interrupt mode of corresponding GPIO[44:32]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>13</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IPHR1</name>
          <displayName>IPHR1</displayName>
          <description>Interrupt Polarity High Register</description>
          <addressOffset>0xb4</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>19</bitWidth>
            </field>
            <field>
              <name>IPH</name>
              <description>
              rising edge in edge mode, or high level in level mode of corresponding GPIO[44:32]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>13</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IPHSR1</name>
          <displayName>IPHSR1</displayName>
          <description>Interrupt Polarity  High Set Register</description>
          <addressOffset>0xb8</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>19</bitWidth>
            </field>
            <field>
              <name>IPHS</name>
              <description>
              set 1 for rising edge in edge mode, or high level in level mode of corresponding GPIO[44:32]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>13</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IPHCR1</name>
          <displayName>IPHCR1</displayName>
          <description>Interrupt Polarity  High Clear  Register</description>
          <addressOffset>0xbc</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>19</bitWidth>
            </field>
            <field>
              <name>IPHC</name>
              <description>
              set 1 for disable rising edge in edge mode, or high level in level mode of corresponding GPIO[44:32]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>13</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IPLR1</name>
          <displayName>IPLR1</displayName>
          <description>Interrupt Polarity Low Register</description>
          <addressOffset>0xc0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>19</bitWidth>
            </field>
            <field>
              <name>IPL</name>
              <description>
              falling edge in edge mode, or low level in level mode of corresponding GPIO[44:32]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>13</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IPLSR1</name>
          <displayName>IPLSR1</displayName>
          <description>Interrupt Polarity Low Set Register</description>
          <addressOffset>0xc4</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>19</bitWidth>
            </field>
            <field>
              <name>IPLS</name>
              <description>
              set 1 for falling edge in edge mode, or low level in level mode of corresponding GPIO[44:32]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>13</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IPLCR1</name>
          <displayName>IPLCR1</displayName>
          <description>Interrupt Polarity Low Clear Register</description>
          <addressOffset>0xc8</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>19</bitWidth>
            </field>
            <field>
              <name>IPLC</name>
              <description>
              set 1 for disable falling edge in edge mode, or low level in level mode of corresponding GPIO[44:32]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>13</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ISR1</name>
          <displayName>ISR1</displayName>
          <description>Interrupt Status Register</description>
          <addressOffset>0xcc</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>19</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Interrupt status. Write 1 will clear interrupt status of corresponding GPIO[44:32] 
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>13</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD1</name>
          <displayName>RSVD1</displayName>
          <description></description>
          <addressOffset>0xD0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>OEMR1</name>
          <displayName>OEMR1</displayName>
          <description>output mode Register</description>
          <addressOffset>0xe0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>19</bitWidth>
            </field>
            <field>
              <name>OEM</name>
              <description>
              output mode of corresponding GPIO[44:32]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>13</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>OEMSR1</name>
          <displayName>OEMSR1</displayName>
          <description>output mode Set Register</description>
          <addressOffset>0xe4</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>19</bitWidth>
            </field>
            <field>
              <name>OEMS</name>
              <description>
              output mode Set of corresponding GPIO[44:32]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>13</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>OEMCR1</name>
          <displayName>OEMCR1</displayName>
          <description>output mode Clear Register</description>
          <addressOffset>0xe8</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>19</bitWidth>
            </field>
            <field>
              <name>OEMC</name>
              <description>
              output mode Clear of corresponding GPIO[44:32]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>13</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>BTIM2</name>
      <description></description>
      <groupName>BTIM</groupName>
      <baseAddress>0x500b1000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CR1</name>
          <displayName>CR1</displayName>
          <description>TIM control register 1</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>ARPE</name>
              <description>
              Auto-reload preload enable
              0: ARR register is not buffered
              1: ARR register is buffered
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>OPM</name>
              <description>
              One-pulse mode
              0: Counter is not stopped at update event
              1: Counter stops counting at the next update event (clearing the bit CEN)
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>URS</name>
              <description>
              Update request source
              This bit is set and cleared by software to select the UEV event sources.
              0: Any of the following events generate an update interrupt or DMA request if enabled. 
              These events can be: 
               Counter overflow
               Setting the UG bit
               Update generation through the slave mode controller
              1: Only counter overflow generates an update interrupt or DMA request if enabled.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UDIS</name>
              <description>
              Update disable
              This bit is set and cleared by software to enable/disable UEV event generation.
              0: UEV enabled. The Update (UEV) event is generated by one of the following events:
               Counter overflow
               Setting the UG bit
               Update generation through the slave mode controller
              Buffered registers are then loaded with their preload values.
              1: UEV disabled. The Update event is not generated, shadow registers keep their value (ARR, PSC). However the counter and the prescaler are reinitialized if the UG bit is set or if a hardware reset is received from the slave mode controller.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CEN</name>
              <description>
              Counter enable
              0: Counter disabled
              1: Counter enabled
              Note: Gated mode can work only if the CEN bit has been previously set by software. However trigger mode can set the CEN bit automatically by hardware. 
              CEN is cleared automatically in one-pulse mode, when an update event occurs.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CR2</name>
          <displayName>CR2</displayName>
          <description>TIM control register 2</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>26</bitWidth>
            </field>
            <field>
              <name>MMS</name>
              <description>
              Master mode selection
              These bits allow to select the information to be sent in master mode to slave timers for synchronization (TRGO). The combination is as follows:
              00: Reset - the UG bit from the EGR register is used as trigger output (TRGO). If the reset is generated by the trigger input (slave mode controller configured in reset mode) then the signal on TRGO is delayed compared to the actual reset.
              01: Enable - the Counter enable signal, CNT_EN, is used as trigger output (TRGO). It is useful to start several timers at the same time or to control a window in which a slave timer is enabled. The Counter Enable signal is generated by a logic OR between CEN control bit and the trigger input when configured in gated mode. 
              When the Counter Enable signal is controlled by the trigger input, there is a delay on TRGO, except if the master/slave mode is selected (see the MSM bit description in SMCR register).
              10: Update - The update event is selected as trigger output (TRGO). For instance a master timer can then be used as a prescaler for a slave timer.
              11: Gating - The delayed gating trigger is selected as trigger output (TRGO). 
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SMCR</name>
          <displayName>SMCR</displayName>
          <description>TIM slave mode control register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>GM</name>
              <description>
              Gated Mode. The counter clock is enabled when the selected trigger input (TRGI) is active (according to gating trigger polarity). The counter stops (but is not reset) as soon as the trigger becomes inactive. Both start and stop of the counter are controlled. Gated mode and slave mode can be enabled simutanuously with different trigger selection.
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GTP</name>
              <description>
              Gating trigger polarity invert
              0: active at high level
              1: active at low level
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GTS</name>
              <description>
              Gating trigger selection in gated mode
              This bit-field selects the trigger input to be used to enable the counter gating.
              00: Internal Trigger 0 (ITR0)
              01: Internal Trigger 1 (ITR1) 
              10: Internal Trigger 2 (ITR2)
              11: Internal Trigger 3 (ITR3)
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SMS</name>
              <description>
              Slave mode selection
              When external signals are selected the active edge of the trigger signal (TRGI) is linked to the polarity selected on the external input.
              000: Slave mode disabled.
              001: Reset Mode - Rising edge of the selected trigger input (TRGI) reinitializes the counter and generates an update of the registers.
              010: Trigger Mode - The counter starts at a rising edge of the trigger TRGI (but it is not reset). Only the start of the counter is controlled.
              011: Combined reset + trigger mode - Rising edge of the selected trigger input (TRGI) reinitializes the counter, generates an update of the registers and starts the counter.
              100: External Clock Mode - Rising edges of the selected trigger (TRGI) clock the counter.
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>MSM</name>
              <description>
              Master/Slave mode. This bit should be asserted on master timer if synchronization if needed.
              0: No action
              1: The effect of an event on the trigger input (TRGI) is delayed to allow a perfect synchronization between the current timer and its slaves (through TRGO). It is useful if we want to synchronize several timers on a single external event.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TS</name>
              <description>
              Trigger selection
              This bit-field selects the trigger input to be used to synchronize the counter.
              00: Internal Trigger 0 (ITR0)
              01: Internal Trigger 1 (ITR1) 
              10: Internal Trigger 2 (ITR2)
              11: Internal Trigger 3 (ITR3)
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD5</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DIER</name>
          <displayName>DIER</displayName>
          <description>TIM DMA/Interrupt enable register</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>UDE</name>
              <description>
              Update DMA request enable
              0: Update DMA request disabled.
              1: Update DMA request enabled
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
            <field>
              <name>UIE</name>
              <description>
              Update interrupt enable
              0: Update interrupt disabled.
              1: Update interrupt enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SR</name>
          <displayName>SR</displayName>
          <description>TIM status register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>31</bitWidth>
            </field>
            <field>
              <name>UIF</name>
              <description>
              Update interrupt flag
              This bit is set by hardware on an update event. It is cleared by software.
              0: No update occurred
              1: Update interrupt pending. This bit is set by hardware when the registers are updated:
              At overflow and if UDIS=0 in the CR1 register.
              When CNT is reinitialized by software using the UG bit in EGR register, if URS=0 and UDIS=0 in the CR1 register.
              When CNT is reinitialized by a trigger event (refer to the synchro control register description), if URS=0 and UDIS=0 in the CR1 register.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>EGR</name>
          <displayName>EGR</displayName>
          <description>Event generation register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>31</bitWidth>
            </field>
            <field>
              <name>UG</name>
              <description>
              Update generation
              This bit can be set by software, it is automatically cleared by hardware.
              0: No action
              1: Re-initialize the counter and generates an update of the registers. Note that the prescaler counter is cleared too (anyway the prescaler ratio is not affected). The counter is cleared if the center-aligned mode is selected or if DIR=0 (upcounting), else it takes the auto-reload value (ARR) if DIR=1 (downcounting).
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD1</name>
          <displayName>RSVD1</displayName>
          <description></description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>CNT</name>
          <displayName>CNT</displayName>
          <description>Counter</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>CNT</name>
              <description>
              counter value
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PSC</name>
          <displayName>PSC</displayName>
          <description>Prescaler</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>PSC</name>
              <description>
              Prescaler value
              The counter clock frequency is equal to fCLK / (PSC[15:0] + 1).
              PSC contains the value to be loaded in the active prescaler register at each update event (including when the counter is cleared through UG bit of EGR register or through trigger controller when configured in reset mode).
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ARR</name>
          <displayName>ARR</displayName>
          <description>Auto-reload register</description>
          <addressOffset>0x2c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ARR</name>
              <description>
              Auto-reload value
              ARR is the value to be loaded in the actual auto-reload register. The counter is blocked while the auto-reload value is null.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>HPSYS_AON</name>
      <description></description>
      <groupName>HPSYS_AON</groupName>
      <baseAddress>0x500c0000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>PMR</name>
          <displayName>PMR</displayName>
          <description>Power Mode Register</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>30</bitWidth>
            </field>
            <field>
              <name>MODE</name>
              <description>
              Power Mode: 2'h0 - active; 2'h1 - light sleep; 2'h2 - deep sleep; 2'h3 - standby
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CR1</name>
          <displayName>CR1</displayName>
          <description>Control Register 1</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>GTIM_EN</name>
              <description>
              Enable global timer
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>19</bitWidth>
            </field>
            <field>
              <name>PIN3_MODE</name>
              <description>
              mode for wakeup PIN3 (PA27)
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>PIN2_MODE</name>
              <description>
              mode for wakeup PIN2 (PA26)
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>PIN1_MODE</name>
              <description>
              mode for wakeup PIN1 (PA25)
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>PIN0_MODE</name>
              <description>
              mode for wakeup PIN0 (PA24)
              0 - high level, 1 - low level, 2 - pos edge, 3 - neg edge, 4/5/6/7: pos or neg edge
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CR2</name>
          <displayName>CR2</displayName>
          <description>Control Register 2</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>PIN15_MODE</name>
              <description>
              mode for wakeup PIN15 (PA39)
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>PIN14_MODE</name>
              <description>
              mode for wakeup PIN14 (PA38)
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>PIN13_MODE</name>
              <description>
              mode for wakeup PIN13 (PA37)
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>PIN12_MODE</name>
              <description>
              mode for wakeup PIN12 (PA36)
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>PIN11_MODE</name>
              <description>
              mode for wakeup PIN11 (PA35)
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>PIN10_MODE</name>
              <description>
              mode for wakeup PIN10 (PA34)
              0 - high level, 1 - low level, 2 - pos edge, 3 - neg edge, 4/5/6/7: pos or neg edge
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CR3</name>
          <displayName>CR3</displayName>
          <description>Control Register 3</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
            <field>
              <name>PIN20_MODE</name>
              <description>
              mode for wakeup PIN20 (PA44)
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>PIN19_MODE</name>
              <description>
              mode for wakeup PIN19 (PA43)
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>PIN18_MODE</name>
              <description>
              mode for wakeup PIN18 (PA42)
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>PIN17_MODE</name>
              <description>
              mode for wakeup PIN17 (PA41)
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>PIN16_MODE</name>
              <description>
              mode for wakeup PIN16 (PA40)
              0 - high level, 1 - low level, 2 - pos edge, 3 - neg edge, 4/5/6/7: pos or neg edge
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ACR</name>
          <displayName>ACR</displayName>
          <description>Active Mode Control register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>HXT48_RDY</name>
              <description>
              Indicate HXT48 is ready
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HRC48_RDY</name>
              <description>
              Indicate HRC48 is ready
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>28</bitWidth>
            </field>
            <field>
              <name>HXT48_REQ</name>
              <description>
              Request HXT48 in active mode
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HRC48_REQ</name>
              <description>
              Request HRC48 in active mode
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>LSCR</name>
          <displayName>LSCR</displayName>
          <description>Light Sleep Ctrl Register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>29</bitWidth>
            </field>
            <field>
              <name>PWR_REQ</name>
              <description>
              Request power during Light Sleep mode
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HXT48_REQ</name>
              <description>
              Request HXT48 in Light Sleep mode
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HRC48_REQ</name>
              <description>
              Request HRC48 in Light Sleep mode
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DSCR</name>
          <displayName>DSCR</displayName>
          <description>Deep Sleep Ctrl Register</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>29</bitWidth>
            </field>
            <field>
              <name>PWR_REQ</name>
              <description>
              Request power during Deep Sleep mode
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HXT48_REQ</name>
              <description>
              Request HXT48 in Deep Sleep mode
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HRC48_REQ</name>
              <description>
              Request HRC48 in Deep Sleep mode
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SBCR</name>
          <displayName>SBCR</displayName>
          <description>Standby Mode Ctrl Register</description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>29</bitWidth>
            </field>
            <field>
              <name>PWR_REQ</name>
              <description>
              Request power during Standby mode
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HXT48_REQ</name>
              <description>
              Request HXT48 in Standby mode
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HRC48_REQ</name>
              <description>
              Request HRC48 in Standby mode
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>WER</name>
          <displayName>WER</displayName>
          <description>Wakeup Enable register</description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>PIN20</name>
              <description>
              Set 1 to enable PA44 as wakeup source
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN19</name>
              <description>
              Set 1 to enable PA43 as wakeup source
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN18</name>
              <description>
              Set 1 to enable PA42 as wakeup source
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN17</name>
              <description>
              Set 1 to enable PA41 as wakeup source
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN16</name>
              <description>
              Set 1 to enable PA40 as wakeup source
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN15</name>
              <description>
              Set 1 to enable PA39 as wakeup source
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN14</name>
              <description>
              Set 1 to enable PA38 as wakeup source
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN13</name>
              <description>
              Set 1 to enable PA37 as wakeup source
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN12</name>
              <description>
              Set 1 to enable PA36 as wakeup source
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN11</name>
              <description>
              Set 1 to enable PA35 as wakeup source
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN10</name>
              <description>
              Set 1 to enable PA34 as wakeup source
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>PIN3</name>
              <description>
              Set 1 to enable PA27 as wakeup source
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN2</name>
              <description>
              Set 1 to enable PA26 as wakeup source
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN1</name>
              <description>
              Set 1 to enable PA25 as wakeup source
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN0</name>
              <description>
              Set 1 to enable PA24 as wakeup source
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LP2HP_IRQ</name>
              <description>
              Set 1 to enable MAILBOX2 as wakeup source
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LP2HP_REQ</name>
              <description>
              Set 1 to enable LPSYS request as wakeup source
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>PMUC</name>
              <description>
              Set 1 to enable PMUC as wakeup source
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LPTIM1</name>
              <description>
              Set 1 to enable LPTIM1 as wakeup source
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GPIO1</name>
              <description>
              Set 1 to enable IO(PA) as wakeup source
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RTC</name>
              <description>
              Set 1 to enable RTC as wakeup source
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>WSR</name>
          <displayName>WSR</displayName>
          <description>Wakeup Status register</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>PIN20</name>
              <description>
              Indicates the wakeup status from PA44 request. Note: the status is masked by WER
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN19</name>
              <description>
              Indicates the wakeup status from PA43 request. Note: the status is masked by WER
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN18</name>
              <description>
              Indicates the wakeup status from PA42 request. Note: the status is masked by WER
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN17</name>
              <description>
              Indicates the wakeup status from PA41 request. Note: the status is masked by WER
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN16</name>
              <description>
              Indicates the wakeup status from PA40 request. Note: the status is masked by WER
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN15</name>
              <description>
              Indicates the wakeup status from PA39 request. Note: the status is masked by WER
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN14</name>
              <description>
              Indicates the wakeup status from PA38 request. Note: the status is masked by WER
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN13</name>
              <description>
              Indicates the wakeup status from PA37 request. Note: the status is masked by WER
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN12</name>
              <description>
              Indicates the wakeup status from PA36 request. Note: the status is masked by WER
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN11</name>
              <description>
              Indicates the wakeup status from PA35 request. Note: the status is masked by WER
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN10</name>
              <description>
              Indicates the wakeup status from PA34 request. Note: the status is masked by WER
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>PIN3</name>
              <description>
              Indicates the wakeup status from PA27 request. Note: the status is masked by WER
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN2</name>
              <description>
              Indicates the wakeup status from PA26 request. Note: the status is masked by WER
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN1</name>
              <description>
              Indicates the wakeup status from PA25 request. Note: the status is masked by WER
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN0</name>
              <description>
              Indicates the wakeup status from PA24 request. Note: the status is masked by WER
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LP2HP_IRQ</name>
              <description>
              Indicates the wakeup status from MAILBOX2. Note: the status is masked by WER
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LP2HP_REQ</name>
              <description>
              Indicates the wakeup status from LPSYS request. Note: the status is masked by WER
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>PMUC</name>
              <description>
              Indicates the wakeup status from PMUC. Note: the status is masked by WER
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LPTIM1</name>
              <description>
              Indicates the wakeup status from LPTIM1. Note: the status is masked by WER
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GPIO1</name>
              <description>
              Indicates the wakeup status from IO(PA). Note: the status is masked by WER
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RTC</name>
              <description>
              Indicates the wakeup status from RTC. Note: the status is masked by WER
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>WCR</name>
          <displayName>WCR</displayName>
          <description>Wakeup Clear register</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>AON</name>
              <description>
              Write 1 to clear the AON wakeup IRQ status
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>PIN20</name>
              <description>
              Write 1 to clear PA44 wakeup source. Only valid if PIN wakeup is configured as edge trigger
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN19</name>
              <description>
              Write 1 to clear PA43 wakeup source. Only valid if PIN wakeup is configured as edge trigger
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN18</name>
              <description>
              Write 1 to clear PA42 wakeup source. Only valid if PIN wakeup is configured as edge trigger
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN17</name>
              <description>
              Write 1 to clear PA41 wakeup source. Only valid if PIN wakeup is configured as edge trigger
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN16</name>
              <description>
              Write 1 to clear PA40 wakeup source. Only valid if PIN wakeup is configured as edge trigger
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN15</name>
              <description>
              Write 1 to clear PA39 wakeup source. Only valid if PIN wakeup is configured as edge trigger
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN14</name>
              <description>
              Write 1 to clear PA38 wakeup source. Only valid if PIN wakeup is configured as edge trigger
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN13</name>
              <description>
              Write 1 to clear PA37 wakeup source. Only valid if PIN wakeup is configured as edge trigger
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN12</name>
              <description>
              Write 1 to clear PA36 wakeup source. Only valid if PIN wakeup is configured as edge trigger
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN11</name>
              <description>
              Write 1 to clear PA35 wakeup source. Only valid if PIN wakeup is configured as edge trigger
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN10</name>
              <description>
              Write 1 to clear PA34 wakeup source. Only valid if PIN wakeup is configured as edge trigger
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>PIN3</name>
              <description>
              Write 1 to clear PA27 wakeup source. Only valid if PIN wakeup is configured as edge trigger
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN2</name>
              <description>
              Write 1 to clear PA26 wakeup source. Only valid if PIN wakeup is configured as edge trigger
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN1</name>
              <description>
              Write 1 to clear PA25 wakeup source. Only valid if PIN wakeup is configured as edge trigger
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN0</name>
              <description>
              Write 1 to clear PA24 wakeup source. Only valid if PIN wakeup is configured as edge trigger
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              Note: for RTC/IO(PA)/LPTIM/PMUC, clear the wakeup status directly in the orignal module
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ISSR</name>
          <displayName>ISSR</displayName>
          <description>Inter System Wakeup Register</description>
          <addressOffset>0x2c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>26</bitWidth>
            </field>
            <field>
              <name>LP_ACTIVE</name>
              <description>
              read 1 indicates LPSYS is active
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HP_ACTIVE</name>
              <description>
              write 1 to indicates HPSYS is active
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>LP2HP_REQ</name>
              <description>
              indicate LPSYS request exists
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HP2LP_REQ</name>
              <description>
              write 1 to request LPSYS to stay in active mode
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ANACR</name>
          <displayName>ANACR</displayName>
          <description>Analog Control Register</description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>30</bitWidth>
            </field>
            <field>
              <name>VHP_ISO</name>
              <description>
              Set 1 to force off all HPSYS related analog modules
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PA_ISO</name>
              <description>
              Set 1 to force IO(PA) into retention mode
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>GTIMR</name>
          <displayName>GTIMR</displayName>
          <description>Global Timer Register</description>
          <addressOffset>0x34</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>CNT</name>
              <description>
              Global timer value
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RESERVE0</name>
          <displayName>RESERVE0</displayName>
          <description>Reserve Register 0</description>
          <addressOffset>0x38</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RESERVE1</name>
          <displayName>RESERVE1</displayName>
          <description>Reserve Register 1</description>
          <addressOffset>0x3c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>LPTIM1</name>
      <description></description>
      <groupName>LPTIM</groupName>
      <baseAddress>0x500c1000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>ISR</name>
          <displayName>ISR</displayName>
          <description>LPTIM interrupt and status register</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>21</bitWidth>
            </field>
            <field>
              <name>OCWKUP</name>
              <description>
              Indicates output compare wakeup occurred
              The OCWKUP bit is set by hardware when LPTIM_CNT register value reached the LPTIM_CMP registers value. To clear OCWKUP, first  write 0 to the OCWE bit in the LPTIM_IER register to disable, then write 1 to the WKUPCLR bit in the LPTIM_ICR register. 
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OFWKUP</name>
              <description>
              Indicates overflow wakeup occurred
              OFWKUP is set by hardware when LPTIM_CNT registers value reached the LPTIM_ARR registers value and count from zero again. To clear OFWKUP, first  write 0 to the OFWE bit in the LPTIM_IER register to disable, then write 1 to the WKUPCLR bit in the LPTIM_ICR register. 
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UEWKUP</name>
              <description>
              Indicates update event wakeup occurred
              UEWKUP is set by hardware when an update event was generated (overflow occurred while repetition counter reached zero). To clear UEWKUP, first  write 0 to the UEWE bit in the LPTIM_IER register to disable, then write 1 to the WKUPCLR bit in the LPTIM_ICR register. 
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>ET</name>
              <description>
              External trigger edge event
              ET is set by hardware to inform application that a valid edge on the selected external trigger input has occurred. If the trigger is ignored because the timer has already started, then this flag is not set. ET flag can be cleared by writing 1 to the ETCLR bit in the LPTIM_ICR register.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OC</name>
              <description>
              Output compare match
              The OC bit is set by hardware to inform application that LPTIM_CNT register value reached the LPTIM_CMP registers value. OC flag can be cleared by writing 1 to the OCCLR bit in the LPTIM_ICR register.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OF</name>
              <description>
              Overflow occurred
              OF is set by hardware to inform application that LPTIM_CNT registers value reached the LPTIM_ARR registers value and count from zero again. OF flag can be cleared by writing 1 to the OFCLR bit in the LPTIM_ICR register.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UE</name>
              <description>
              LPTIM update event occurred
              UE is set by hardware to inform application that an update event was generated when overflow occurred while repetition counter reached zero. UE flag can be cleared by writing 1 to the UECLR bit in the LPTIM_ICR register. 
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ICR</name>
          <displayName>ICR</displayName>
          <description>LPTIM interrupt and status clear register</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>WKUPCLR</name>
              <description>
              wakeup status clear flag
              Writing 1 to this bit clears all wakeup status flags in the LPTIM_ISR register.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>ETCLR</name>
              <description>
              External trigger valid edge clear flag
              Writing 1 to this bit clears the ET flag in the LPTIM_ISR register
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OCCLR</name>
              <description>
              Output compare clear flag
              Writing 1 to this bit clears the OC flag in the LPTIM_ISR register
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OFCLR</name>
              <description>
              Overflow clear flag
              Writing 1 to this bit clears the OF flag in the LPTIM_ISR register
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UECLR</name>
              <description>
              Update event clear flag
              Writing 1 to this bit clear the UE flag in the LPTIM_ISR register.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IER</name>
          <displayName>IER</displayName>
          <description>LPTIM interrupt and wakeup enable register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>21</bitWidth>
            </field>
            <field>
              <name>OCWE</name>
              <description>
              Output compare Wakeup Enable
              0: Output compare wakeup disabled
              1: Output compare wakeup enabled
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OFWE</name>
              <description>
              Overflow Wakeup Enable
              0: Overflow Wakeup disabled
              1: Overflow Wakeup enabled
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UEWE</name>
              <description>
              Update event Wakeup enable
              0: Update event Wakeup disabled
              1: Update event Wakeup enabled
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>ETIE</name>
              <description>
              External trigger valid edge Interrupt Enable
              0: External trigger interrupt disabled
              1: External trigger interrupt enabled
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OCIE</name>
              <description>
              Output compare Interrupt Enable
              0: Output compare interrupt disabled
              1: Output compare interrupt enabled
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OFIE</name>
              <description>
              Overflow Interrupt Enable
              0: Overflow interrupt disabled
              1: Overflow interrupt enabled
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UEIE</name>
              <description>
              Update event interrupt enable
              0: Update event interrupt disabled
              1: Update event interrupt enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CFGR</name>
          <displayName>CFGR</displayName>
          <description>LPTIM configuration register</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>COUNTMODE</name>
              <description>
              counter mode in internal clock source mode (CKSEL=0). If CKSEL=1, this bit has no effect.
              0: the counter is incremented following each internal clock pulse
              1: the counter is incremented following each valid pulse on the external clock
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>WAVPOL</name>
              <description>
              Waveform shape polarity
              The WAVEPOL bit controls the output polarity
              0: The LPTIM output reflects the compare results between LPTIM_ARR and LPTIM_CMP registers
              1: The LPTIM output reflects the inverse of the compare results between LPTIM_ARR and LPTIM_CMP registers
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>WAVE</name>
              <description>
              Waveform shape
              The WAVE bit controls the output shape
              0: Deactivate Set-once mode
              1: Activate the Set-once mode
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TIMOUT</name>
              <description>
              Timeout enable
              The TIMOUT bit controls the Timeout feature
              0: A trigger event arriving when the timer is already started will be ignored
              1: A trigger event arriving when the timer is already started will reset and restart the LPTIM counter and the repetition counter
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TRIGEN</name>
              <description>
              Trigger enable and polarity
              The TRIGEN bits controls whether the LPTIM counter is started by an external trigger or not. If the external trigger option is selected, three configurations are possible for the trigger active edge:
              00: software trigger (counting start is initiated by software)
              01: rising edge is the active edge
              10: falling edge is the active edge
              11: both edges are active edges
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TRIGSEL</name>
              <description>
              Trigger selector
              The TRIGSEL bits select the trigger source that will serve as a trigger event for the LPTIM among the below 8 available sources:
              000: lptim_ext0
              001: lptim_ext1
              010: lptim_ext2
              011: lptim_ext3
              100: lptim_ext4
              101: lptim_ext5
              110: lptim_ext6
              111: lptim_ext7
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PRESC</name>
              <description>
              Clock prescaler
              The PRESC bits configure the prescaler division factor. It can be one among the following division factors:
              000: /1
              001: /2
              010: /4
              011: /8
              100: /16
              101: /32
              110: /64
              111: /128
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>EXTCKSEL</name>
              <description>
              External clock source selector
              0: external clock source is from lptim_in
              1: external clock source is from LPCOMP (if LPCOMP integrated)
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TRGFLT</name>
              <description>
              Configurable digital filter for trigger
              The TRGFLT value sets the number of consecutive equal samples that should be detected when a level change occurs on an internal trigger before it is considered as a valid level transition. An internal clock source must be present to use this feature
              00: any trigger active level change is considered as a valid trigger
              01: trigger active level change must be stable for at least 2 clock periods before it is considered as valid trigger.
              10: trigger active level change must be stable for at least 4 clock periods before it is considered as valid trigger.
              11: trigger active level change must be stable for at least 8 clock periods before it is considered as valid trigger.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>INTCKSEL</name>
              <description>
              Internal clock source selector
              0: internal clock source is clk_lp
              1: internal clock source is pclk2
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CKFLT</name>
              <description>
              Configurable digital filter for external clock
              The CKFLT value sets the number of consecutive equal samples that should be detected when a level change occurs on an external clock signal before it is considered as a valid level transition. An internal clock source must be present to use this feature
              00: any external clock signal level change is considered as a valid transition
              01: external clock signal level change must be stable for at least 2 clock periods before it is considered as valid transition.
              10: external clock signal level change must be stable for at least 4 clock periods before it is considered as valid transition.
              11: external clock signal level change must be stable for at least 8 clock periods before it is considered as valid transition.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>CKPOL</name>
              <description>
              Clock Polarity
              If LPTIM is clocked by an external clock source, CKPOL bits is used to configure the active edge or edges used by the counter:
              00: the rising edge is the active edge used for counting
              01: the falling edge is the active edge used for counting
              10: both edges are active edges. When both external clock signal edges are considered active ones, the LPTIM must also be clocked by an internal clock source with a frequency equal to at least four time the external clock frequency.
              11: not allowed
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>CKSEL</name>
              <description>
              Clock selector
              The CKSEL bit selects which clock source the LPTIM will use:
              0: LPTIM is clocked by internal clock source, according to INTCKSEL
              1: LPTIM is clocked by external clock source, according to EXTCKSEL
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CR</name>
          <displayName>CR</displayName>
          <description>LPTIM control register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>28</bitWidth>
            </field>
            <field>
              <name>COUNTRST</name>
              <description>
              Counter reset
              This bit is set by software and cleared by hardware. When set to 1 this bit will trigger a synchronous reset of the CNT register. Due to the synchronous nature of this reset, it only takes place after a synchronization delay.
              COUNTRST must never be set to 1 by software before it is already cleared to 0 by hardware. Software should consequently check that COUNTRST bit is already cleared to 0 before attempting to set it to 1.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CNTSTRT</name>
              <description>
              Timer start in Continuous mode
              This bit is set by software and cleared by hardware.
              In case of software start (TRIGEN[1:0] = 00), setting this bit starts the LPTIM in Continuous mode.
              If the software start is disabled (TRIGEN[1:0] different than 00), setting this bit starts the timer in Continuous mode as soon as an external trigger is detected.
              If this bit is set when a single pulse mode counting is ongoing, then the timer will not stop at the next match between ARR and CNT registers and the LPTIM counter keeps counting in Continuous mode.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SNGSTRT</name>
              <description>
              LPTIM start in Single mode
              This bit is set by software and cleared by hardware.
              In case of software start (TRIGEN[1:0] = 00), setting this bit starts the LPTIM in single pulse mode.
              If the software start is disabled (TRIGEN[1:0] different than 00), setting this bit starts the LPTIM in single pulse mode as soon as an external trigger is detected.
              If this bit is set when the LPTIM is in continuous counting mode, then the LPTIM will stop at the following match between ARR and CNT registers.
              If this bit is set simultaneously with CNTSTRT, then LPTIM will be in continuous counting mode.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ENABLE</name>
              <description>
              LPTIM enable
              The ENABLE bit is set and cleared by software. 
              0:LPTIM is disabled
              1:LPTIM is enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CMP</name>
          <displayName>CMP</displayName>
          <description>LPTIM compare register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>CMP</name>
              <description>
              Compare value
              CMP is the compare value used by the LPTIM.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ARR</name>
          <displayName>ARR</displayName>
          <description>LPTIM autoreload register</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>ARR</name>
              <description>
              Auto reload value
              ARR is the autoreload value for the LPTIM. This value must be strictly greater than the CMP[15:0] value.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CNT</name>
          <displayName>CNT</displayName>
          <description>LPTIM counter register</description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>CNT</name>
              <description>
              Counter value
              When the LPTIM is running with an asynchronous clock, reading the CNT register may return unreliable values. So in this case it is necessary to perform two consecutive read accesses and verify that the two returned values are identical.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RCR</name>
          <displayName>RCR</displayName>
          <description>LPTIM repetition register</description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>REP</name>
              <description>
              Repetition register value
              REP is the repetition value for the LPTIM.
              Read REP will return left repetition times. It should be noted that for a reliable REP register read access, two consecutive read accesses must be performed and compared. A read access can be considered reliable when the values of the two consecutive read accesses are equal.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>LPTIM2</name>
      <description></description>
      <groupName>LPTIM</groupName>
      <baseAddress>0x500c2000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>ISR</name>
          <displayName>ISR</displayName>
          <description>LPTIM interrupt and status register</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>21</bitWidth>
            </field>
            <field>
              <name>OCWKUP</name>
              <description>
              Indicates output compare wakeup occurred
              The OCWKUP bit is set by hardware when LPTIM_CNT register value reached the LPTIM_CMP registers value. To clear OCWKUP, first  write 0 to the OCWE bit in the LPTIM_IER register to disable, then write 1 to the WKUPCLR bit in the LPTIM_ICR register. 
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OFWKUP</name>
              <description>
              Indicates overflow wakeup occurred
              OFWKUP is set by hardware when LPTIM_CNT registers value reached the LPTIM_ARR registers value and count from zero again. To clear OFWKUP, first  write 0 to the OFWE bit in the LPTIM_IER register to disable, then write 1 to the WKUPCLR bit in the LPTIM_ICR register. 
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UEWKUP</name>
              <description>
              Indicates update event wakeup occurred
              UEWKUP is set by hardware when an update event was generated (overflow occurred while repetition counter reached zero). To clear UEWKUP, first  write 0 to the UEWE bit in the LPTIM_IER register to disable, then write 1 to the WKUPCLR bit in the LPTIM_ICR register. 
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>ET</name>
              <description>
              External trigger edge event
              ET is set by hardware to inform application that a valid edge on the selected external trigger input has occurred. If the trigger is ignored because the timer has already started, then this flag is not set. ET flag can be cleared by writing 1 to the ETCLR bit in the LPTIM_ICR register.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OC</name>
              <description>
              Output compare match
              The OC bit is set by hardware to inform application that LPTIM_CNT register value reached the LPTIM_CMP registers value. OC flag can be cleared by writing 1 to the OCCLR bit in the LPTIM_ICR register.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OF</name>
              <description>
              Overflow occurred
              OF is set by hardware to inform application that LPTIM_CNT registers value reached the LPTIM_ARR registers value and count from zero again. OF flag can be cleared by writing 1 to the OFCLR bit in the LPTIM_ICR register.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UE</name>
              <description>
              LPTIM update event occurred
              UE is set by hardware to inform application that an update event was generated when overflow occurred while repetition counter reached zero. UE flag can be cleared by writing 1 to the UECLR bit in the LPTIM_ICR register. 
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ICR</name>
          <displayName>ICR</displayName>
          <description>LPTIM interrupt and status clear register</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>WKUPCLR</name>
              <description>
              wakeup status clear flag
              Writing 1 to this bit clears all wakeup status flags in the LPTIM_ISR register.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>ETCLR</name>
              <description>
              External trigger valid edge clear flag
              Writing 1 to this bit clears the ET flag in the LPTIM_ISR register
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OCCLR</name>
              <description>
              Output compare clear flag
              Writing 1 to this bit clears the OC flag in the LPTIM_ISR register
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OFCLR</name>
              <description>
              Overflow clear flag
              Writing 1 to this bit clears the OF flag in the LPTIM_ISR register
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UECLR</name>
              <description>
              Update event clear flag
              Writing 1 to this bit clear the UE flag in the LPTIM_ISR register.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IER</name>
          <displayName>IER</displayName>
          <description>LPTIM interrupt and wakeup enable register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>21</bitWidth>
            </field>
            <field>
              <name>OCWE</name>
              <description>
              Output compare Wakeup Enable
              0: Output compare wakeup disabled
              1: Output compare wakeup enabled
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OFWE</name>
              <description>
              Overflow Wakeup Enable
              0: Overflow Wakeup disabled
              1: Overflow Wakeup enabled
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UEWE</name>
              <description>
              Update event Wakeup enable
              0: Update event Wakeup disabled
              1: Update event Wakeup enabled
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>ETIE</name>
              <description>
              External trigger valid edge Interrupt Enable
              0: External trigger interrupt disabled
              1: External trigger interrupt enabled
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OCIE</name>
              <description>
              Output compare Interrupt Enable
              0: Output compare interrupt disabled
              1: Output compare interrupt enabled
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OFIE</name>
              <description>
              Overflow Interrupt Enable
              0: Overflow interrupt disabled
              1: Overflow interrupt enabled
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UEIE</name>
              <description>
              Update event interrupt enable
              0: Update event interrupt disabled
              1: Update event interrupt enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CFGR</name>
          <displayName>CFGR</displayName>
          <description>LPTIM configuration register</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>COUNTMODE</name>
              <description>
              counter mode in internal clock source mode (CKSEL=0). If CKSEL=1, this bit has no effect.
              0: the counter is incremented following each internal clock pulse
              1: the counter is incremented following each valid pulse on the external clock
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>WAVPOL</name>
              <description>
              Waveform shape polarity
              The WAVEPOL bit controls the output polarity
              0: The LPTIM output reflects the compare results between LPTIM_ARR and LPTIM_CMP registers
              1: The LPTIM output reflects the inverse of the compare results between LPTIM_ARR and LPTIM_CMP registers
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>WAVE</name>
              <description>
              Waveform shape
              The WAVE bit controls the output shape
              0: Deactivate Set-once mode
              1: Activate the Set-once mode
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TIMOUT</name>
              <description>
              Timeout enable
              The TIMOUT bit controls the Timeout feature
              0: A trigger event arriving when the timer is already started will be ignored
              1: A trigger event arriving when the timer is already started will reset and restart the LPTIM counter and the repetition counter
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TRIGEN</name>
              <description>
              Trigger enable and polarity
              The TRIGEN bits controls whether the LPTIM counter is started by an external trigger or not. If the external trigger option is selected, three configurations are possible for the trigger active edge:
              00: software trigger (counting start is initiated by software)
              01: rising edge is the active edge
              10: falling edge is the active edge
              11: both edges are active edges
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TRIGSEL</name>
              <description>
              Trigger selector
              The TRIGSEL bits select the trigger source that will serve as a trigger event for the LPTIM among the below 8 available sources:
              000: lptim_ext0
              001: lptim_ext1
              010: lptim_ext2
              011: lptim_ext3
              100: lptim_ext4
              101: lptim_ext5
              110: lptim_ext6
              111: lptim_ext7
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PRESC</name>
              <description>
              Clock prescaler
              The PRESC bits configure the prescaler division factor. It can be one among the following division factors:
              000: /1
              001: /2
              010: /4
              011: /8
              100: /16
              101: /32
              110: /64
              111: /128
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>EXTCKSEL</name>
              <description>
              External clock source selector
              0: external clock source is from lptim_in
              1: external clock source is from LPCOMP (if LPCOMP integrated)
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TRGFLT</name>
              <description>
              Configurable digital filter for trigger
              The TRGFLT value sets the number of consecutive equal samples that should be detected when a level change occurs on an internal trigger before it is considered as a valid level transition. An internal clock source must be present to use this feature
              00: any trigger active level change is considered as a valid trigger
              01: trigger active level change must be stable for at least 2 clock periods before it is considered as valid trigger.
              10: trigger active level change must be stable for at least 4 clock periods before it is considered as valid trigger.
              11: trigger active level change must be stable for at least 8 clock periods before it is considered as valid trigger.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>INTCKSEL</name>
              <description>
              Internal clock source selector
              0: internal clock source is clk_lp
              1: internal clock source is pclk2
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CKFLT</name>
              <description>
              Configurable digital filter for external clock
              The CKFLT value sets the number of consecutive equal samples that should be detected when a level change occurs on an external clock signal before it is considered as a valid level transition. An internal clock source must be present to use this feature
              00: any external clock signal level change is considered as a valid transition
              01: external clock signal level change must be stable for at least 2 clock periods before it is considered as valid transition.
              10: external clock signal level change must be stable for at least 4 clock periods before it is considered as valid transition.
              11: external clock signal level change must be stable for at least 8 clock periods before it is considered as valid transition.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>CKPOL</name>
              <description>
              Clock Polarity
              If LPTIM is clocked by an external clock source, CKPOL bits is used to configure the active edge or edges used by the counter:
              00: the rising edge is the active edge used for counting
              01: the falling edge is the active edge used for counting
              10: both edges are active edges. When both external clock signal edges are considered active ones, the LPTIM must also be clocked by an internal clock source with a frequency equal to at least four time the external clock frequency.
              11: not allowed
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>CKSEL</name>
              <description>
              Clock selector
              The CKSEL bit selects which clock source the LPTIM will use:
              0: LPTIM is clocked by internal clock source, according to INTCKSEL
              1: LPTIM is clocked by external clock source, according to EXTCKSEL
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CR</name>
          <displayName>CR</displayName>
          <description>LPTIM control register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>28</bitWidth>
            </field>
            <field>
              <name>COUNTRST</name>
              <description>
              Counter reset
              This bit is set by software and cleared by hardware. When set to 1 this bit will trigger a synchronous reset of the CNT register. Due to the synchronous nature of this reset, it only takes place after a synchronization delay.
              COUNTRST must never be set to 1 by software before it is already cleared to 0 by hardware. Software should consequently check that COUNTRST bit is already cleared to 0 before attempting to set it to 1.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CNTSTRT</name>
              <description>
              Timer start in Continuous mode
              This bit is set by software and cleared by hardware.
              In case of software start (TRIGEN[1:0] = 00), setting this bit starts the LPTIM in Continuous mode.
              If the software start is disabled (TRIGEN[1:0] different than 00), setting this bit starts the timer in Continuous mode as soon as an external trigger is detected.
              If this bit is set when a single pulse mode counting is ongoing, then the timer will not stop at the next match between ARR and CNT registers and the LPTIM counter keeps counting in Continuous mode.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SNGSTRT</name>
              <description>
              LPTIM start in Single mode
              This bit is set by software and cleared by hardware.
              In case of software start (TRIGEN[1:0] = 00), setting this bit starts the LPTIM in single pulse mode.
              If the software start is disabled (TRIGEN[1:0] different than 00), setting this bit starts the LPTIM in single pulse mode as soon as an external trigger is detected.
              If this bit is set when the LPTIM is in continuous counting mode, then the LPTIM will stop at the following match between ARR and CNT registers.
              If this bit is set simultaneously with CNTSTRT, then LPTIM will be in continuous counting mode.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ENABLE</name>
              <description>
              LPTIM enable
              The ENABLE bit is set and cleared by software. 
              0:LPTIM is disabled
              1:LPTIM is enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CMP</name>
          <displayName>CMP</displayName>
          <description>LPTIM compare register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>CMP</name>
              <description>
              Compare value
              CMP is the compare value used by the LPTIM.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ARR</name>
          <displayName>ARR</displayName>
          <description>LPTIM autoreload register</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>ARR</name>
              <description>
              Auto reload value
              ARR is the autoreload value for the LPTIM. This value must be strictly greater than the CMP[15:0] value.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CNT</name>
          <displayName>CNT</displayName>
          <description>LPTIM counter register</description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>CNT</name>
              <description>
              Counter value
              When the LPTIM is running with an asynchronous clock, reading the CNT register may return unreliable values. So in this case it is necessary to perform two consecutive read accesses and verify that the two returned values are identical.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RCR</name>
          <displayName>RCR</displayName>
          <description>LPTIM repetition register</description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>REP</name>
              <description>
              Repetition register value
              REP is the repetition value for the LPTIM.
              Read REP will return left repetition times. It should be noted that for a reliable REP register read access, two consecutive read accesses must be performed and compared. A read access can be considered reliable when the values of the two consecutive read accesses are equal.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>RTC</name>
      <description></description>
      <groupName>RTC</groupName>
      <baseAddress>0x500cb000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>TR</name>
          <displayName>TR</displayName>
          <description>Time Register</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>PM</name>
              <description>
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HT</name>
              <description>
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>HU</name>
              <description>
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>MNT</name>
              <description>
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>MNU</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>ST</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>SU</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SS</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DR</name>
          <displayName>DR</displayName>
          <description>Date Register</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>ERR</name>
              <description>
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>CB</name>
              <description>
              century bit, 0 - 2000s, 1 - 1900s/2100s
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>YT</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>YU</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>WD</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>MT</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MU</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>DT</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>DU</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CR</name>
          <displayName>CR</displayName>
          <description>Control Register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>18</bitWidth>
            </field>
            <field>
              <name>TSIE</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>WUTIE</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ALRMIE</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TSE</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>WUTE</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ALRME</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FMT</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>TSEDGE</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>WUCKSEL</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ISR</name>
          <displayName>ISR</displayName>
          <description>Initialization and Status Register</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>21</bitWidth>
            </field>
            <field>
              <name>INIT</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>INITF</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>INITS</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSF</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SHPF</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TSOVF</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TSF</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>WUTF</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>WUTWF</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ALRMF</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ALRMWF</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PSCLR</name>
          <displayName>PSCLR</displayName>
          <description>Prescaler Register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>DIVA_INT</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>DIVA_FRAC</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>14</bitWidth>
            </field>
            <field>
              <name>DIVB</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>WUTR</name>
          <displayName>WUTR</displayName>
          <description>Wakeup Timer Register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>14</bitWidth>
            </field>
            <field>
              <name>WUT</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>18</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ALRMTR</name>
          <displayName>ALRMTR</displayName>
          <description>Alarm Time Register</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>PM</name>
              <description>
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HT</name>
              <description>
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>HU</name>
              <description>
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>MNT</name>
              <description>
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>MNU</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>ST</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>SU</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SS</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ALRMDR</name>
          <displayName>ALRMDR</displayName>
          <description>Alarm Date Register</description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>MSKWD</name>
              <description>
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MSKM</name>
              <description>
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MSKD</name>
              <description>
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MSKH</name>
              <description>
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MSKMN</name>
              <description>
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MSKS</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MSKSS</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>WD</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>MT</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MU</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>DT</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>DU</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SHIFTR</name>
          <displayName>SHIFTR</displayName>
          <description>Shift Control Register</description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>ADD1S</name>
              <description>
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>21</bitWidth>
            </field>
            <field>
              <name>SUBFS</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TSTR</name>
          <displayName>TSTR</displayName>
          <description>Timestamp Time Register</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>PM</name>
              <description>
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HT</name>
              <description>
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>HU</name>
              <description>
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>MNT</name>
              <description>
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>MNU</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>ST</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>SU</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SS</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TSDR</name>
          <displayName>TSDR</displayName>
          <description>Timestamp Date Register</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>WD</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>MT</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MU</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>DT</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>DU</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>OR</name>
          <displayName>OR</displayName>
          <description></description>
          <addressOffset>0x2c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BKP0R</name>
          <displayName>BKP0R</displayName>
          <description>Backup 0 Register</description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>BKP</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BKP1R</name>
          <displayName>BKP1R</displayName>
          <description>Backup 1 Register</description>
          <addressOffset>0x34</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>BKP</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BKP2R</name>
          <displayName>BKP2R</displayName>
          <description>Backup 2 Register</description>
          <addressOffset>0x38</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>BKP</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BKP3R</name>
          <displayName>BKP3R</displayName>
          <description>Backup 3 Register</description>
          <addressOffset>0x3c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>BKP</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BKP4R</name>
          <displayName>BKP4R</displayName>
          <description>Backup 4 Register</description>
          <addressOffset>0x40</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>BKP</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BKP5R</name>
          <displayName>BKP5R</displayName>
          <description>Backup 5 Register</description>
          <addressOffset>0x44</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>BKP</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BKP6R</name>
          <displayName>BKP6R</displayName>
          <description>Backup 6 Register</description>
          <addressOffset>0x48</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>BKP</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BKP7R</name>
          <displayName>BKP7R</displayName>
          <description>Backup 7 Register</description>
          <addressOffset>0x4c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>BKP</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BKP8R</name>
          <displayName>BKP8R</displayName>
          <description>Backup 8 Register</description>
          <addressOffset>0x50</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>BKP</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BKP9R</name>
          <displayName>BKP9R</displayName>
          <description>Backup 9 Register</description>
          <addressOffset>0x54</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>BKP</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PBRCR</name>
          <displayName>PBRCR</displayName>
          <description>PBR Control Register</description>
          <addressOffset>0x58</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>30</bitWidth>
            </field>
            <field>
              <name>SNS</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RTO</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PBR0R</name>
          <displayName>PBR0R</displayName>
          <description>PBR0 Register</description>
          <addressOffset>0x5c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>FORCE1</name>
              <description>
              special use. Set 1 to force output 1
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>SEL</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>IN</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OE</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OUT</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PBR1R</name>
          <displayName>PBR1R</displayName>
          <description>PBR1 Register</description>
          <addressOffset>0x60</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
            <field>
              <name>SEL</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>IN</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OE</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OUT</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PBR2R</name>
          <displayName>PBR2R</displayName>
          <description>PBR2 Register</description>
          <addressOffset>0x64</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
            <field>
              <name>SEL</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>IN</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OE</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OUT</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PBR3R</name>
          <displayName>PBR3R</displayName>
          <description>PBR3 Register</description>
          <addressOffset>0x68</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
            <field>
              <name>SEL</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>IN</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OE</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OUT</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAWK1R</name>
          <displayName>PAWK1R</displayName>
          <description>PA Wakeup Register 1</description>
          <addressOffset>0x6c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>15</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Enable PA34 WKUP pull-down by default
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAWK2R</name>
          <displayName>PAWK2R</displayName>
          <description>PA Wakeup Register 2</description>
          <addressOffset>0x70</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>15</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAWK3R</name>
          <displayName>PAWK3R</displayName>
          <description>PA Wakeup Register 3</description>
          <addressOffset>0x74</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>15</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>IWDT</name>
      <description></description>
      <groupName>WDT</groupName>
      <baseAddress>0x500cc000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>WDT_CVR0</name>
          <displayName>WDT_CVR0</displayName>
          <description>WatchDog Counter Value 0</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>COUNT_VALUE_0</name>
              <description>
              Count Value for 1st TimeOut
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_CVR1</name>
          <displayName>WDT_CVR1</displayName>
          <description>WatchDog Counter Value 1</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>COUNT_VALUE_1</name>
              <description>
              Count Value for 2nd TimeOut
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_CR</name>
          <displayName>WDT_CR</displayName>
          <description>WatchDog Control Register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>27</bitWidth>
            </field>
            <field>
              <name>RESPONSE_MODE</name>
              <description>
              0:reset only, 1:interrupt and reset
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RESET_LENGTH</name>
              <description>
              reset pulse length in number of wdt clock cycles
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_CCR</name>
          <displayName>WDT_CCR</displayName>
          <description>WatchDog Counter Control Register</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>COUNTER_CONTROL</name>
              <description>
              SinglePulse /Write 8'h76 to restart, write8'h34 to stop, else do nothing
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_ICR</name>
          <displayName>WDT_ICR</displayName>
          <description>WatchDog Interrupt Clear Register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>31</bitWidth>
            </field>
            <field>
              <name>INT_CLR</name>
              <description>
              SinglePulse /A pulse to clear interrupt
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_SR</name>
          <displayName>WDT_SR</displayName>
          <description>WatchDog Status Register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>30</bitWidth>
            </field>
            <field>
              <name>WDT_ACTIVE</name>
              <description>
              Watchdog runs when 1, else 0
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>INT_ASSERT</name>
              <description>
              Interrupt assert when 1
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_WP</name>
          <displayName>WDT_WP</displayName>
          <description>WatchDog Write Protect Register</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>WRPT_ST</name>
              <description>
              1 indicates write protect is active
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>WRPT</name>
              <description>
              write 0x58ab99fc generate write_protect, write 0x51ff8621 to release
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>31</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_FG</name>
          <displayName>WDT_FG</displayName>
          <description>WatchDog Flag Register</description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>28</bitWidth>
            </field>
            <field>
              <name>SYNC_FG</name>
              <description>
              1 indicates one transition from system clk to wdt clk has complicated
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SYNC_FG_CLR</name>
              <description>
              SinglePulse/A pulse to clear sync flag
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RST_FG</name>
              <description>
              1 indicates wdt has already reset system
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RST_FG_CLR</name>
              <description>
              SinglePulse/A pulse to clear reset flag
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>DMAC2</name>
      <description></description>
      <groupName>DMAC</groupName>
      <baseAddress>0x40001000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>ISR</name>
          <displayName>ISR</displayName>
          <description></description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>TEIF8</name>
              <description>
              channel transfer error flag
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HTIF8</name>
              <description>
              channel half transfer flag
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIF8</name>
              <description>
              channel transfer complete flag
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GIF8</name>
              <description>
              channel global interrupt flag
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIF7</name>
              <description>
              channel transfer error flag
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HTIF7</name>
              <description>
              channel half transfer flag
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIF7</name>
              <description>
              channel transfer complete flag
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GIF7</name>
              <description>
              channel global interrupt flag
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIF6</name>
              <description>
              channel transfer error flag
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HTIF6</name>
              <description>
              channel half transfer flag
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIF6</name>
              <description>
              channel transfer complete flag
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GIF6</name>
              <description>
              channel global interrupt flag
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIF5</name>
              <description>
              channel transfer error flag
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HTIF5</name>
              <description>
              channel half transfer flag
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIF5</name>
              <description>
              channel transfer complete flag
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GIF5</name>
              <description>
              channel global interrupt flag
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIF4</name>
              <description>
              channel transfer error flag
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HTIF4</name>
              <description>
              channel half transfer flag
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIF4</name>
              <description>
              channel transfer complete flag
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GIF4</name>
              <description>
              channel global interrupt flag
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIF3</name>
              <description>
              channel transfer error flag
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HTIF3</name>
              <description>
              channel half transfer flag
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIF3</name>
              <description>
              channel transfer complete flag
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GIF3</name>
              <description>
              channel global interrupt flag
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIF2</name>
              <description>
              channel transfer error flag
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HTIF2</name>
              <description>
              channel half transfer flag
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIF2</name>
              <description>
              channel transfer complete flag
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GIF2</name>
              <description>
              channel global interrupt flag
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIF1</name>
              <description>
              channel transfer error flag. Set when bus error detected. Cleared when write 1 to CTEIF or CGIF.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HTIF1</name>
              <description>
              channel half transfer flag. Set when half NDT are transferred. Cleared when write 1 to CHTIF or CGIF.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIF1</name>
              <description>
              channel transfer complete flag. Set when all NDT are transferred.  Cleared when write 1 to CTCIF or CGIF.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GIF1</name>
              <description>
              channel global interrupt flag. Set when any of TEIF/HTIF/TCIF asserted. Cleared when TEIF/HTIF/TCIF all cleared.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IFCR</name>
          <displayName>IFCR</displayName>
          <description></description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>CTEIF8</name>
              <description>
              CTEIF, transfer error flag clear
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CHTIF8</name>
              <description>
              CHTIF, half transfer flag clear
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTCIF8</name>
              <description>
              CTCIF, transfer complete flag clear
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CGIF8</name>
              <description>
              CGIF,  global interrupt flag clear
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTEIF7</name>
              <description>
              CTEIF, transfer error flag clear
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CHTIF7</name>
              <description>
              CHTIF, half transfer flag clear
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTCIF7</name>
              <description>
              CTCIF, transfer complete flag clear
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CGIF7</name>
              <description>
              CGIF,  global interrupt flag clear
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTEIF6</name>
              <description>
              CTEIF, transfer error flag clear
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CHTIF6</name>
              <description>
              CHTIF, half transfer flag clear
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTCIF6</name>
              <description>
              CTCIF, transfer complete flag clear
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CGIF6</name>
              <description>
              CGIF,  global interrupt flag clear
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTEIF5</name>
              <description>
              CTEIF, transfer error flag clear
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CHTIF5</name>
              <description>
              CHTIF, half transfer flag clear
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTCIF5</name>
              <description>
              CTCIF, transfer complete flag clear
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CGIF5</name>
              <description>
              CGIF,  global interrupt flag clear
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTEIF4</name>
              <description>
              CTEIF, transfer error flag clear
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CHTIF4</name>
              <description>
              CHTIF, half transfer flag clear
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTCIF4</name>
              <description>
              CTCIF, transfer complete flag clear
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CGIF4</name>
              <description>
              CGIF,  global interrupt flag clear
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTEIF3</name>
              <description>
              CTEIF, transfer error flag clear
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CHTIF3</name>
              <description>
              CHTIF, half transfer flag clear
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTCIF3</name>
              <description>
              CTCIF, transfer complete flag clear
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CGIF3</name>
              <description>
              CGIF,  global interrupt flag clear
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTEIF2</name>
              <description>
              CTEIF, transfer error flag clear
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CHTIF2</name>
              <description>
              CHTIF, half transfer flag clear
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTCIF2</name>
              <description>
              CTCIF, transfer complete flag clear
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CGIF2</name>
              <description>
              CGIF,  global interrupt flag clear
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTEIF1</name>
              <description>
              CTEIF, transfer error flag clear. Write 1 to clear TEIF.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CHTIF1</name>
              <description>
              CHTIF, half transfer flag clear. Write 1 to clear HTIF.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTCIF1</name>
              <description>
              CTCIF, transfer complete flag clear. Write 1 to clear TCIF.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CGIF1</name>
              <description>
              CGIF,  global interrupt flag clear. Write 1 to clear all TEIF/HTIF/TCIF.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR1</name>
          <displayName>CCR1</displayName>
          <description></description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
            <field>
              <name>MEM2MEM</name>
              <description>
              memory-to-memory mode
              0: disabled
              1: enabled
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PL</name>
              <description>
              priority level
              00: low
              01: medium
              10: high
              11: very high
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>MSIZE</name>
              <description>
              memory size
              Defines the data size of each DMA transfer to the identified memory.
              In memory-to-memory mode, this field identifies the memory source if DIR = 1 and the memory destination if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.
              00: 8 bits
              01: 16 bits
              10: 32 bits
              11: reserved
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>PSIZE</name>
              <description>
              peripheral size
              Defines the data size of each DMA transfer to the identified peripheral.
              In memory-to-memory mode, this field identifies the memory destination if DIR = 1 and the memory source if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR = 1 and the peripheral source if DIR = 0.
              00: 8 bits
              01: 16 bits
              10: 32 bits
              11: reserved
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>MINC</name>
              <description>
              memory increment mode
              Defines the increment mode for each DMA transfer to the identified memory.
              In memory-to-memory mode, this field identifies the memory source if DIR = 1 and the memory destination if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.
              0: disabled
              1: enabled
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PINC</name>
              <description>
              peripheral increment mode
              Defines the increment mode for each DMA transfer to the identified peripheral.
              n memory-to-memory mode, this field identifies the memory destination if DIR = 1 and the 
              memory source if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR = 1 and 
              the peripheral source if DIR = 0.
              0: disabled
              1: enabled
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CIRC</name>
              <description>
              circular mode
              0: disabled
              1: enabled
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DIR</name>
              <description>
              data transfer direction
              This bit must be set only in memory-to-peripheral and peripheral-to-memory modes.
              0: read from peripheral
               Source attributes are defined by PSIZE and PINC, plus the CPARx register. This is still valid in a memory-to-memory mode.
               Destination attributes are defined by MSIZE and MINC, plus the CM0ARx register. This is still valid in a peripheral-to-peripheral mode.
              1: read from memory
               Destination attributes are defined by PSIZE and PINC, plus the CPARx register. This is still valid in a memory-to-memory mode.
               Source attributes are defined by MSIZE and MINC, plus the CM0ARx register. This is still valid in a peripheral-to-peripheral mode.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIE</name>
              <description>
              transfer error interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HTIE</name>
              <description>
              half transfer interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIE</name>
              <description>
              transfer complete interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EN</name>
              <description>
              channel enable
              When a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the ISR register is cleared (by setting the CTEIFx bit of the IFCR register).
              0: disabled
              1: enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CNDTR1</name>
          <displayName>CNDTR1</displayName>
          <description></description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>NDT</name>
              <description>
              number of data to transfer (0 to 2^16 - 1)
              This field is updated by hardware when the channel is enabled:
               It is decremented after each single DMA read followed by write transfer, indicating the remaining amount of data items to transfer.
               It is kept at zero when the programmed amount of data to transfer is reached, if the channel is not in circular mode (CIRC = 0 in the CCRx register).
               It is reloaded automatically by the previously programmed value, when the transfer is complete, if the channel is in circular mode (CIRC = 1).
              If this field is zero, no transfer can be served whatever the channel status (enabled or not).
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CPAR1</name>
          <displayName>CPAR1</displayName>
          <description></description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>PA</name>
              <description>
              peripheral address
              It contains the base address of the peripheral data register from/to which the data will be read/written.
              In memory-to-memory mode, this register identifies the memory destination address if DIR = 1 and the memory source address if DIR = 0.
              In peripheral-to-peripheral mode, this register identifies the peripheral destination address DIR = 1 and the peripheral source address if DIR = 0.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0AR1</name>
          <displayName>CM0AR1</displayName>
          <description></description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>MA</name>
              <description>
              memory address
              It contains the base address of the memory from/to which the data will be read/written.
              In memory-to-memory mode, this register identifies the memory source address if DIR = 1 and the memory destination address if DIR = 0.
              In peripheral-to-peripheral mode, this register identifies the peripheral source address DIR = 1 and the peripheral destination address if DIR = 0.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CBSR1</name>
          <displayName>CBSR1</displayName>
          <description></description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>BS</name>
              <description>
              burst size in non-m2m mode
              When BS>1, DMA will transfer for BS times for each request if left NDT is larger than BS, or else transfer for left NDT times.
              When BS=0 or 1, DMA will always do single transfer for each request.
              In memory-to-memory mode, BS is ignored.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR2</name>
          <displayName>CCR2</displayName>
          <description></description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
            <field>
              <name>MEM2MEM</name>
              <description>
              memory-to-memory mode
              0: disabled
              1: enabled
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PL</name>
              <description>
              priority level
              00: low
              01: medium
              10: high
              11: very high
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>MSIZE</name>
              <description>
              memory size
              Defines the data size of each DMA transfer to the identified memory.
              In memory-to-memory mode, this field identifies the memory source if DIR = 1 and the memory destination if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.
              00: 8 bits
              01: 16 bits
              10: 32 bits
              11: reserved
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>PSIZE</name>
              <description>
              peripheral size
              Defines the data size of each DMA transfer to the identified peripheral.
              In memory-to-memory mode, this field identifies the memory destination if DIR = 1 and the memory source if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR = 1 and the peripheral source if DIR = 0.
              00: 8 bits
              01: 16 bits
              10: 32 bits
              11: reserved
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>MINC</name>
              <description>
              memory increment mode
              Defines the increment mode for each DMA transfer to the identified memory.
              In memory-to-memory mode, this field identifies the memory source if DIR = 1 and the memory destination if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.
              0: disabled
              1: enabled
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PINC</name>
              <description>
              peripheral increment mode
              Defines the increment mode for each DMA transfer to the identified peripheral.
              n memory-to-memory mode, this field identifies the memory destination if DIR = 1 and the 
              memory source if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR = 1 and 
              the peripheral source if DIR = 0.
              0: disabled
              1: enabled
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CIRC</name>
              <description>
              circular mode
              0: disabled
              1: enabled
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DIR</name>
              <description>
              data transfer direction
              This bit must be set only in memory-to-peripheral and peripheral-to-memory modes.
              0: read from peripheral
               Source attributes are defined by PSIZE and PINC, plus the CPARx register. This is still valid in a memory-to-memory mode.
               Destination attributes are defined by MSIZE and MINC, plus the CM0ARx register. This is still valid in a peripheral-to-peripheral mode.
              1: read from memory
               Destination attributes are defined by PSIZE and PINC, plus the CPARx register. This is still valid in a memory-to-memory mode.
               Source attributes are defined by MSIZE and MINC, plus the CM0ARx register. This is still valid in a peripheral-to-peripheral mode.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIE</name>
              <description>
              transfer error interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HTIE</name>
              <description>
              half transfer interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIE</name>
              <description>
              transfer complete interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EN</name>
              <description>
              channel enable
              When a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the ISR register is cleared (by setting the CTEIFx bit of the IFCR register).
              0: disabled
              1: enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CNDTR2</name>
          <displayName>CNDTR2</displayName>
          <description></description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>NDT</name>
              <description>
              number of data to transfer (0 to 2^16 - 1)
              This field is updated by hardware when the channel is enabled:
               It is decremented after each single DMA read followed by write transfer, indicating the remaining amount of data items to transfer.
               It is kept at zero when the programmed amount of data to transfer is reached, if the channel is not in circular mode (CIRC = 0 in the CCRx register).
               It is reloaded automatically by the previously programmed value, when the transfer is complete, if the channel is in circular mode (CIRC = 1).
              If this field is zero, no transfer can be served whatever the channel status (enabled or not).
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CPAR2</name>
          <displayName>CPAR2</displayName>
          <description></description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>PA</name>
              <description>
              peripheral address
              It contains the base address of the peripheral data register from/to which the data will be read/written.
              In memory-to-memory mode, this register identifies the memory destination address if DIR = 1 and the memory source address if DIR = 0.
              In peripheral-to-peripheral mode, this register identifies the peripheral destination address DIR = 1 and the peripheral source address if DIR = 0.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0AR2</name>
          <displayName>CM0AR2</displayName>
          <description></description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>MA</name>
              <description>
              peripheral address
              It contains the base address of the memory from/to which the data will be read/written.
              In memory-to-memory mode, this register identifies the memory source address if DIR = 1 and the memory destination address if DIR = 0.
              In peripheral-to-peripheral mode, this register identifies the peripheral source address DIR = 1 and the peripheral destination address if DIR = 0.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CBSR2</name>
          <displayName>CBSR2</displayName>
          <description></description>
          <addressOffset>0x2c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>BS</name>
              <description>
              burst size in non-m2m mode
              When BS>1, DMA will transfer for BS times for each request if left NDT is larger than BS, or else transfer for left NDT times.
              When BS=0 or 1, DMA will always do single transfer for each request.
              In memory-to-memory mode, BS is ignored.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR3</name>
          <displayName>CCR3</displayName>
          <description></description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
            <field>
              <name>MEM2MEM</name>
              <description>
              memory-to-memory mode
              0: disabled
              1: enabled
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PL</name>
              <description>
              priority level
              00: low
              01: medium
              10: high
              11: very high
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>MSIZE</name>
              <description>
              memory size
              Defines the data size of each DMA transfer to the identified memory.
              In memory-to-memory mode, this field identifies the memory source if DIR = 1 and the memory destination if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.
              00: 8 bits
              01: 16 bits
              10: 32 bits
              11: reserved
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>PSIZE</name>
              <description>
              peripheral size
              Defines the data size of each DMA transfer to the identified peripheral.
              In memory-to-memory mode, this field identifies the memory destination if DIR = 1 and the memory source if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR = 1 and the peripheral source if DIR = 0.
              00: 8 bits
              01: 16 bits
              10: 32 bits
              11: reserved
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>MINC</name>
              <description>
              memory increment mode
              Defines the increment mode for each DMA transfer to the identified memory.
              In memory-to-memory mode, this field identifies the memory source if DIR = 1 and the memory destination if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.
              0: disabled
              1: enabled
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PINC</name>
              <description>
              peripheral increment mode
              Defines the increment mode for each DMA transfer to the identified peripheral.
              n memory-to-memory mode, this field identifies the memory destination if DIR = 1 and the 
              memory source if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR = 1 and 
              the peripheral source if DIR = 0.
              0: disabled
              1: enabled
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CIRC</name>
              <description>
              circular mode
              0: disabled
              1: enabled
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DIR</name>
              <description>
              data transfer direction
              This bit must be set only in memory-to-peripheral and peripheral-to-memory modes.
              0: read from peripheral
               Source attributes are defined by PSIZE and PINC, plus the CPARx register. This is still valid in a memory-to-memory mode.
               Destination attributes are defined by MSIZE and MINC, plus the CM0ARx register. This is still valid in a peripheral-to-peripheral mode.
              1: read from memory
               Destination attributes are defined by PSIZE and PINC, plus the CPARx register. This is still valid in a memory-to-memory mode.
               Source attributes are defined by MSIZE and MINC, plus the CM0ARx register. This is still valid in a peripheral-to-peripheral mode.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIE</name>
              <description>
              transfer error interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HTIE</name>
              <description>
              half transfer interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIE</name>
              <description>
              transfer complete interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EN</name>
              <description>
              channel enable
              When a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the ISR register is cleared (by setting the CTEIFx bit of the IFCR register).
              0: disabled
              1: enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CNDTR3</name>
          <displayName>CNDTR3</displayName>
          <description></description>
          <addressOffset>0x34</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>NDT</name>
              <description>
              number of data to transfer (0 to 2^16 - 1)
              This field is updated by hardware when the channel is enabled:
               It is decremented after each single DMA read followed by write transfer, indicating the remaining amount of data items to transfer.
               It is kept at zero when the programmed amount of data to transfer is reached, if the channel is not in circular mode (CIRC = 0 in the CCRx register).
               It is reloaded automatically by the previously programmed value, when the transfer is complete, if the channel is in circular mode (CIRC = 1).
              If this field is zero, no transfer can be served whatever the channel status (enabled or not).
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CPAR3</name>
          <displayName>CPAR3</displayName>
          <description></description>
          <addressOffset>0x38</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>PA</name>
              <description>
              peripheral address
              It contains the base address of the peripheral data register from/to which the data will be read/written.
              In memory-to-memory mode, this register identifies the memory destination address if DIR = 1 and the memory source address if DIR = 0.
              In peripheral-to-peripheral mode, this register identifies the peripheral destination address DIR = 1 and the peripheral source address if DIR = 0.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0AR3</name>
          <displayName>CM0AR3</displayName>
          <description></description>
          <addressOffset>0x3c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>MA</name>
              <description>
              peripheral address
              It contains the base address of the memory from/to which the data will be read/written.
              In memory-to-memory mode, this register identifies the memory source address if DIR = 1 and the memory destination address if DIR = 0.
              In peripheral-to-peripheral mode, this register identifies the peripheral source address DIR = 1 and the peripheral destination address if DIR = 0.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CBSR3</name>
          <displayName>CBSR3</displayName>
          <description></description>
          <addressOffset>0x40</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>BS</name>
              <description>
              burst size in non-m2m mode
              When BS>1, DMA will transfer for BS times for each request if left NDT is larger than BS, or else transfer for left NDT times.
              When BS=0 or 1, DMA will always do single transfer for each request.
              In memory-to-memory mode, BS is ignored.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR4</name>
          <displayName>CCR4</displayName>
          <description></description>
          <addressOffset>0x44</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
            <field>
              <name>MEM2MEM</name>
              <description>
              memory-to-memory mode
              0: disabled
              1: enabled
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PL</name>
              <description>
              priority level
              00: low
              01: medium
              10: high
              11: very high
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>MSIZE</name>
              <description>
              memory size
              Defines the data size of each DMA transfer to the identified memory.
              In memory-to-memory mode, this field identifies the memory source if DIR = 1 and the memory destination if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.
              00: 8 bits
              01: 16 bits
              10: 32 bits
              11: reserved
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>PSIZE</name>
              <description>
              peripheral size
              Defines the data size of each DMA transfer to the identified peripheral.
              In memory-to-memory mode, this field identifies the memory destination if DIR = 1 and the memory source if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR = 1 and the peripheral source if DIR = 0.
              00: 8 bits
              01: 16 bits
              10: 32 bits
              11: reserved
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>MINC</name>
              <description>
              memory increment mode
              Defines the increment mode for each DMA transfer to the identified memory.
              In memory-to-memory mode, this field identifies the memory source if DIR = 1 and the memory destination if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.
              0: disabled
              1: enabled
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PINC</name>
              <description>
              peripheral increment mode
              Defines the increment mode for each DMA transfer to the identified peripheral.
              n memory-to-memory mode, this field identifies the memory destination if DIR = 1 and the 
              memory source if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR = 1 and 
              the peripheral source if DIR = 0.
              0: disabled
              1: enabled
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CIRC</name>
              <description>
              circular mode
              0: disabled
              1: enabled
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DIR</name>
              <description>
              data transfer direction
              This bit must be set only in memory-to-peripheral and peripheral-to-memory modes.
              0: read from peripheral
               Source attributes are defined by PSIZE and PINC, plus the CPARx register. This is still valid in a memory-to-memory mode.
               Destination attributes are defined by MSIZE and MINC, plus the CM0ARx register. This is still valid in a peripheral-to-peripheral mode.
              1: read from memory
               Destination attributes are defined by PSIZE and PINC, plus the CPARx register. This is still valid in a memory-to-memory mode.
               Source attributes are defined by MSIZE and MINC, plus the CM0ARx register. This is still valid in a peripheral-to-peripheral mode.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIE</name>
              <description>
              transfer error interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HTIE</name>
              <description>
              half transfer interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIE</name>
              <description>
              transfer complete interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EN</name>
              <description>
              channel enable
              When a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the ISR register is cleared (by setting the CTEIFx bit of the IFCR register).
              0: disabled
              1: enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CNDTR4</name>
          <displayName>CNDTR4</displayName>
          <description></description>
          <addressOffset>0x48</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>NDT</name>
              <description>
              number of data to transfer (0 to 2^16 - 1)
              This field is updated by hardware when the channel is enabled:
               It is decremented after each single DMA read followed by write transfer, indicating the remaining amount of data items to transfer.
               It is kept at zero when the programmed amount of data to transfer is reached, if the channel is not in circular mode (CIRC = 0 in the CCRx register).
               It is reloaded automatically by the previously programmed value, when the transfer is complete, if the channel is in circular mode (CIRC = 1).
              If this field is zero, no transfer can be served whatever the channel status (enabled or not).
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CPAR4</name>
          <displayName>CPAR4</displayName>
          <description></description>
          <addressOffset>0x4c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>PA</name>
              <description>
              peripheral address
              It contains the base address of the peripheral data register from/to which the data will be read/written.
              In memory-to-memory mode, this register identifies the memory destination address if DIR = 1 and the memory source address if DIR = 0.
              In peripheral-to-peripheral mode, this register identifies the peripheral destination address DIR = 1 and the peripheral source address if DIR = 0.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0AR4</name>
          <displayName>CM0AR4</displayName>
          <description></description>
          <addressOffset>0x50</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>MA</name>
              <description>
              peripheral address
              It contains the base address of the memory from/to which the data will be read/written.
              In memory-to-memory mode, this register identifies the memory source address if DIR = 1 and the memory destination address if DIR = 0.
              In peripheral-to-peripheral mode, this register identifies the peripheral source address DIR = 1 and the peripheral destination address if DIR = 0.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CBSR4</name>
          <displayName>CBSR4</displayName>
          <description></description>
          <addressOffset>0x54</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>BS</name>
              <description>
              burst size in non-m2m mode
              When BS>1, DMA will transfer for BS times for each request if left NDT is larger than BS, or else transfer for left NDT times.
              When BS=0 or 1, DMA will always do single transfer for each request.
              In memory-to-memory mode, BS is ignored.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR5</name>
          <displayName>CCR5</displayName>
          <description></description>
          <addressOffset>0x58</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
            <field>
              <name>MEM2MEM</name>
              <description>
              memory-to-memory mode
              0: disabled
              1: enabled
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PL</name>
              <description>
              priority level
              00: low
              01: medium
              10: high
              11: very high
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>MSIZE</name>
              <description>
              memory size
              Defines the data size of each DMA transfer to the identified memory.
              In memory-to-memory mode, this field identifies the memory source if DIR = 1 and the memory destination if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.
              00: 8 bits
              01: 16 bits
              10: 32 bits
              11: reserved
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>PSIZE</name>
              <description>
              peripheral size
              Defines the data size of each DMA transfer to the identified peripheral.
              In memory-to-memory mode, this field identifies the memory destination if DIR = 1 and the memory source if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR = 1 and the peripheral source if DIR = 0.
              00: 8 bits
              01: 16 bits
              10: 32 bits
              11: reserved
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>MINC</name>
              <description>
              memory increment mode
              Defines the increment mode for each DMA transfer to the identified memory.
              In memory-to-memory mode, this field identifies the memory source if DIR = 1 and the memory destination if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.
              0: disabled
              1: enabled
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PINC</name>
              <description>
              peripheral increment mode
              Defines the increment mode for each DMA transfer to the identified peripheral.
              n memory-to-memory mode, this field identifies the memory destination if DIR = 1 and the 
              memory source if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR = 1 and 
              the peripheral source if DIR = 0.
              0: disabled
              1: enabled
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CIRC</name>
              <description>
              circular mode
              0: disabled
              1: enabled
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DIR</name>
              <description>
              data transfer direction
              This bit must be set only in memory-to-peripheral and peripheral-to-memory modes.
              0: read from peripheral
               Source attributes are defined by PSIZE and PINC, plus the CPARx register. This is still valid in a memory-to-memory mode.
               Destination attributes are defined by MSIZE and MINC, plus the CM0ARx register. This is still valid in a peripheral-to-peripheral mode.
              1: read from memory
               Destination attributes are defined by PSIZE and PINC, plus the CPARx register. This is still valid in a memory-to-memory mode.
               Source attributes are defined by MSIZE and MINC, plus the CM0ARx register. This is still valid in a peripheral-to-peripheral mode.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIE</name>
              <description>
              transfer error interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HTIE</name>
              <description>
              half transfer interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIE</name>
              <description>
              transfer complete interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EN</name>
              <description>
              channel enable
              When a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the ISR register is cleared (by setting the CTEIFx bit of the IFCR register).
              0: disabled
              1: enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CNDTR5</name>
          <displayName>CNDTR5</displayName>
          <description></description>
          <addressOffset>0x5c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>NDT</name>
              <description>
              number of data to transfer (0 to 2^16 - 1)
              This field is updated by hardware when the channel is enabled:
               It is decremented after each single DMA read followed by write transfer, indicating the remaining amount of data items to transfer.
               It is kept at zero when the programmed amount of data to transfer is reached, if the channel is not in circular mode (CIRC = 0 in the CCRx register).
               It is reloaded automatically by the previously programmed value, when the transfer is complete, if the channel is in circular mode (CIRC = 1).
              If this field is zero, no transfer can be served whatever the channel status (enabled or not).
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CPAR5</name>
          <displayName>CPAR5</displayName>
          <description></description>
          <addressOffset>0x60</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>PA</name>
              <description>
              peripheral address
              It contains the base address of the peripheral data register from/to which the data will be read/written.
              In memory-to-memory mode, this register identifies the memory destination address if DIR = 1 and the memory source address if DIR = 0.
              In peripheral-to-peripheral mode, this register identifies the peripheral destination address DIR = 1 and the peripheral source address if DIR = 0.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0AR5</name>
          <displayName>CM0AR5</displayName>
          <description></description>
          <addressOffset>0x64</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>MA</name>
              <description>
              peripheral address
              It contains the base address of the memory from/to which the data will be read/written.
              In memory-to-memory mode, this register identifies the memory source address if DIR = 1 and the memory destination address if DIR = 0.
              In peripheral-to-peripheral mode, this register identifies the peripheral source address DIR = 1 and the peripheral destination address if DIR = 0.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CBSR5</name>
          <displayName>CBSR5</displayName>
          <description></description>
          <addressOffset>0x68</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>BS</name>
              <description>
              burst size in non-m2m mode
              When BS>1, DMA will transfer for BS times for each request if left NDT is larger than BS, or else transfer for left NDT times.
              When BS=0 or 1, DMA will always do single transfer for each request.
              In memory-to-memory mode, BS is ignored.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR6</name>
          <displayName>CCR6</displayName>
          <description></description>
          <addressOffset>0x6c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
            <field>
              <name>MEM2MEM</name>
              <description>
              memory-to-memory mode
              0: disabled
              1: enabled
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PL</name>
              <description>
              priority level
              00: low
              01: medium
              10: high
              11: very high
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>MSIZE</name>
              <description>
              memory size
              Defines the data size of each DMA transfer to the identified memory.
              In memory-to-memory mode, this field identifies the memory source if DIR = 1 and the memory destination if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.
              00: 8 bits
              01: 16 bits
              10: 32 bits
              11: reserved
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>PSIZE</name>
              <description>
              peripheral size
              Defines the data size of each DMA transfer to the identified peripheral.
              In memory-to-memory mode, this field identifies the memory destination if DIR = 1 and the memory source if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR = 1 and the peripheral source if DIR = 0.
              00: 8 bits
              01: 16 bits
              10: 32 bits
              11: reserved
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>MINC</name>
              <description>
              memory increment mode
              Defines the increment mode for each DMA transfer to the identified memory.
              In memory-to-memory mode, this field identifies the memory source if DIR = 1 and the memory destination if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.
              0: disabled
              1: enabled
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PINC</name>
              <description>
              peripheral increment mode
              Defines the increment mode for each DMA transfer to the identified peripheral.
              n memory-to-memory mode, this field identifies the memory destination if DIR = 1 and the 
              memory source if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR = 1 and 
              the peripheral source if DIR = 0.
              0: disabled
              1: enabled
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CIRC</name>
              <description>
              circular mode
              0: disabled
              1: enabled
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DIR</name>
              <description>
              data transfer direction
              This bit must be set only in memory-to-peripheral and peripheral-to-memory modes.
              0: read from peripheral
               Source attributes are defined by PSIZE and PINC, plus the CPARx register. This is still valid in a memory-to-memory mode.
               Destination attributes are defined by MSIZE and MINC, plus the CM0ARx register. This is still valid in a peripheral-to-peripheral mode.
              1: read from memory
               Destination attributes are defined by PSIZE and PINC, plus the CPARx register. This is still valid in a memory-to-memory mode.
               Source attributes are defined by MSIZE and MINC, plus the CM0ARx register. This is still valid in a peripheral-to-peripheral mode.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIE</name>
              <description>
              transfer error interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HTIE</name>
              <description>
              half transfer interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIE</name>
              <description>
              transfer complete interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EN</name>
              <description>
              channel enable
              When a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the ISR register is cleared (by setting the CTEIFx bit of the IFCR register).
              0: disabled
              1: enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CNDTR6</name>
          <displayName>CNDTR6</displayName>
          <description></description>
          <addressOffset>0x70</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>NDT</name>
              <description>
              number of data to transfer (0 to 2^16 - 1)
              This field is updated by hardware when the channel is enabled:
               It is decremented after each single DMA read followed by write transfer, indicating the remaining amount of data items to transfer.
               It is kept at zero when the programmed amount of data to transfer is reached, if the channel is not in circular mode (CIRC = 0 in the CCRx register).
               It is reloaded automatically by the previously programmed value, when the transfer is complete, if the channel is in circular mode (CIRC = 1).
              If this field is zero, no transfer can be served whatever the channel status (enabled or not).
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CPAR6</name>
          <displayName>CPAR6</displayName>
          <description></description>
          <addressOffset>0x74</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>PA</name>
              <description>
              peripheral address
              It contains the base address of the peripheral data register from/to which the data will be read/written.
              In memory-to-memory mode, this register identifies the memory destination address if DIR = 1 and the memory source address if DIR = 0.
              In peripheral-to-peripheral mode, this register identifies the peripheral destination address DIR = 1 and the peripheral source address if DIR = 0.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0AR6</name>
          <displayName>CM0AR6</displayName>
          <description></description>
          <addressOffset>0x78</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>MA</name>
              <description>
              peripheral address
              It contains the base address of the memory from/to which the data will be read/written.
              In memory-to-memory mode, this register identifies the memory source address if DIR = 1 and the memory destination address if DIR = 0.
              In peripheral-to-peripheral mode, this register identifies the peripheral source address DIR = 1 and the peripheral destination address if DIR = 0.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CBSR6</name>
          <displayName>CBSR6</displayName>
          <description></description>
          <addressOffset>0x7c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>BS</name>
              <description>
              burst size in non-m2m mode
              When BS>1, DMA will transfer for BS times for each request if left NDT is larger than BS, or else transfer for left NDT times.
              When BS=0 or 1, DMA will always do single transfer for each request.
              In memory-to-memory mode, BS is ignored.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR7</name>
          <displayName>CCR7</displayName>
          <description></description>
          <addressOffset>0x80</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
            <field>
              <name>MEM2MEM</name>
              <description>
              memory-to-memory mode
              0: disabled
              1: enabled
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PL</name>
              <description>
              priority level
              00: low
              01: medium
              10: high
              11: very high
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>MSIZE</name>
              <description>
              memory size
              Defines the data size of each DMA transfer to the identified memory.
              In memory-to-memory mode, this field identifies the memory source if DIR = 1 and the memory destination if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.
              00: 8 bits
              01: 16 bits
              10: 32 bits
              11: reserved
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>PSIZE</name>
              <description>
              peripheral size
              Defines the data size of each DMA transfer to the identified peripheral.
              In memory-to-memory mode, this field identifies the memory destination if DIR = 1 and the memory source if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR = 1 and the peripheral source if DIR = 0.
              00: 8 bits
              01: 16 bits
              10: 32 bits
              11: reserved
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>MINC</name>
              <description>
              memory increment mode
              Defines the increment mode for each DMA transfer to the identified memory.
              In memory-to-memory mode, this field identifies the memory source if DIR = 1 and the memory destination if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.
              0: disabled
              1: enabled
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PINC</name>
              <description>
              peripheral increment mode
              Defines the increment mode for each DMA transfer to the identified peripheral.
              n memory-to-memory mode, this field identifies the memory destination if DIR = 1 and the 
              memory source if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR = 1 and 
              the peripheral source if DIR = 0.
              0: disabled
              1: enabled
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CIRC</name>
              <description>
              circular mode
              0: disabled
              1: enabled
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DIR</name>
              <description>
              data transfer direction
              This bit must be set only in memory-to-peripheral and peripheral-to-memory modes.
              0: read from peripheral
               Source attributes are defined by PSIZE and PINC, plus the CPARx register. This is still valid in a memory-to-memory mode.
               Destination attributes are defined by MSIZE and MINC, plus the CM0ARx register. This is still valid in a peripheral-to-peripheral mode.
              1: read from memory
               Destination attributes are defined by PSIZE and PINC, plus the CPARx register. This is still valid in a memory-to-memory mode.
               Source attributes are defined by MSIZE and MINC, plus the CM0ARx register. This is still valid in a peripheral-to-peripheral mode.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIE</name>
              <description>
              transfer error interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HTIE</name>
              <description>
              half transfer interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIE</name>
              <description>
              transfer complete interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EN</name>
              <description>
              channel enable
              When a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the ISR register is cleared (by setting the CTEIFx bit of the IFCR register).
              0: disabled
              1: enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CNDTR7</name>
          <displayName>CNDTR7</displayName>
          <description></description>
          <addressOffset>0x84</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>NDT</name>
              <description>
              number of data to transfer (0 to 2^16 - 1)
              This field is updated by hardware when the channel is enabled:
               It is decremented after each single DMA read followed by write transfer, indicating the remaining amount of data items to transfer.
               It is kept at zero when the programmed amount of data to transfer is reached, if the channel is not in circular mode (CIRC = 0 in the CCRx register).
               It is reloaded automatically by the previously programmed value, when the transfer is complete, if the channel is in circular mode (CIRC = 1).
              If this field is zero, no transfer can be served whatever the channel status (enabled or not).
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CPAR7</name>
          <displayName>CPAR7</displayName>
          <description></description>
          <addressOffset>0x88</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>PA</name>
              <description>
              peripheral address
              It contains the base address of the peripheral data register from/to which the data will be read/written.
              In memory-to-memory mode, this register identifies the memory destination address if DIR = 1 and the memory source address if DIR = 0.
              In peripheral-to-peripheral mode, this register identifies the peripheral destination address DIR = 1 and the peripheral source address if DIR = 0.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0AR7</name>
          <displayName>CM0AR7</displayName>
          <description></description>
          <addressOffset>0x8c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>MA</name>
              <description>
              peripheral address
              It contains the base address of the memory from/to which the data will be read/written.
              In memory-to-memory mode, this register identifies the memory source address if DIR = 1 and the memory destination address if DIR = 0.
              In peripheral-to-peripheral mode, this register identifies the peripheral source address DIR = 1 and the peripheral destination address if DIR = 0.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CBSR7</name>
          <displayName>CBSR7</displayName>
          <description></description>
          <addressOffset>0x90</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>BS</name>
              <description>
              burst size in non memory-to-memory mode
              When BS>1, DMA will transfer for BS times for each request if left NDT is larger than BS, or else transfer for left NDT times.
              When BS=0 or 1, DMA will always do single transfer for each request.
              In memory-to-memory mode, BS is ignored.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR8</name>
          <displayName>CCR8</displayName>
          <description></description>
          <addressOffset>0x94</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
            <field>
              <name>MEM2MEM</name>
              <description>
              memory-to-memory mode
              0: disabled
              1: enabled
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PL</name>
              <description>
              priority level
              00: low
              01: medium
              10: high
              11: very high
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>MSIZE</name>
              <description>
              memory size
              Defines the data size of each DMA transfer to the identified memory.
              In memory-to-memory mode, this field identifies the memory source if DIR = 1 and the memory destination if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.
              00: 8 bits
              01: 16 bits
              10: 32 bits
              11: reserved
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>PSIZE</name>
              <description>
              peripheral size
              Defines the data size of each DMA transfer to the identified peripheral.
              In memory-to-memory mode, this field identifies the memory destination if DIR = 1 and the memory source if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR = 1 and the peripheral source if DIR = 0.
              00: 8 bits
              01: 16 bits
              10: 32 bits
              11: reserved
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>MINC</name>
              <description>
              memory increment mode
              Defines the increment mode for each DMA transfer to the identified memory.
              In memory-to-memory mode, this field identifies the memory source if DIR = 1 and the memory destination if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.
              0: disabled
              1: enabled
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PINC</name>
              <description>
              peripheral increment mode
              Defines the increment mode for each DMA transfer to the identified peripheral.
              n memory-to-memory mode, this field identifies the memory destination if DIR = 1 and the 
              memory source if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR = 1 and 
              the peripheral source if DIR = 0.
              0: disabled
              1: enabled
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CIRC</name>
              <description>
              circular mode
              0: disabled
              1: enabled
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DIR</name>
              <description>
              data transfer direction
              This bit must be set only in memory-to-peripheral and peripheral-to-memory modes.
              0: read from peripheral
               Source attributes are defined by PSIZE and PINC, plus the CPARx register. This is still valid in a memory-to-memory mode.
               Destination attributes are defined by MSIZE and MINC, plus the CM0ARx register. This is still valid in a peripheral-to-peripheral mode.
              1: read from memory
               Destination attributes are defined by PSIZE and PINC, plus the CPARx register. This is still valid in a memory-to-memory mode.
               Source attributes are defined by MSIZE and MINC, plus the CM0ARx register. This is still valid in a peripheral-to-peripheral mode.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIE</name>
              <description>
              transfer error interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HTIE</name>
              <description>
              half transfer interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIE</name>
              <description>
              transfer complete interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EN</name>
              <description>
              channel enable
              When a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the ISR register is cleared (by setting the CTEIFx bit of the IFCR register).
              0: disabled
              1: enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CNDTR8</name>
          <displayName>CNDTR8</displayName>
          <description></description>
          <addressOffset>0x98</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>NDT</name>
              <description>
              number of data to transfer (0 to 2^16 - 1)
              This field is updated by hardware when the channel is enabled:
               It is decremented after each single DMA read followed by write transfer, indicating the remaining amount of data items to transfer.
               It is kept at zero when the programmed amount of data to transfer is reached, if the channel is not in circular mode (CIRC = 0 in the CCRx register).
               It is reloaded automatically by the previously programmed value, when the transfer is complete, if the channel is in circular mode (CIRC = 1).
              If this field is zero, no transfer can be served whatever the channel status (enabled or not).
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CPAR8</name>
          <displayName>CPAR8</displayName>
          <description></description>
          <addressOffset>0x9c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>PA</name>
              <description>
              peripheral address
              It contains the base address of the peripheral data register from/to which the data will be read/written.
              In memory-to-memory mode, this register identifies the memory destination address if DIR = 1 and the memory source address if DIR = 0.
              In peripheral-to-peripheral mode, this register identifies the peripheral destination address DIR = 1 and the peripheral source address if DIR = 0.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0AR8</name>
          <displayName>CM0AR8</displayName>
          <description></description>
          <addressOffset>0xa0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>MA</name>
              <description>
              peripheral address
              It contains the base address of the memory from/to which the data will be read/written.
              In memory-to-memory mode, this register identifies the memory source address if DIR = 1 and the memory destination address if DIR = 0.
              In peripheral-to-peripheral mode, this register identifies the peripheral source address DIR = 1 and the peripheral destination address if DIR = 0.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CBSR8</name>
          <displayName>CBSR8</displayName>
          <description></description>
          <addressOffset>0xa4</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>BS</name>
              <description>
              burst size in non-m2m mode
              When BS>1, DMA will transfer for BS times for each request if left NDT is larger than BS, or else transfer for left NDT times.
              When BS=0 or 1, DMA will always do single transfer for each request.
              In memory-to-memory mode, BS is ignored.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CSELR1</name>
          <displayName>CSELR1</displayName>
          <description></description>
          <addressOffset>0xa8</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>C4S</name>
              <description>
              DMA channel 4 selection
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>C3S</name>
              <description>
              DMA channel 3 selection
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>C2S</name>
              <description>
              DMA channel 2 selection
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>C1S</name>
              <description>
              DMA channel 1 selection
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CSELR2</name>
          <displayName>CSELR2</displayName>
          <description></description>
          <addressOffset>0xac</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>C8S</name>
              <description>
              DMA channel 8 selection
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>C7S</name>
              <description>
              DMA channel 7 selection
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>C6S</name>
              <description>
              DMA channel 6 selection
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>C5S</name>
              <description>
              DMA channel 5 selection
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>USART4</name>
      <description></description>
      <groupName>USART</groupName>
      <baseAddress>0x40005000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CR1</name>
          <displayName>CR1</displayName>
          <description>Control Register 1</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>M</name>
              <description>
              0 - 6bit, 1 - 7bit, 2 - 8bit, 3 - 9bit (including data bits and parity)
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
            <field>
              <name>OVER8</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>PCE</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PEIE</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TXEIE</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIE</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RXNEIE</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IDLEIE</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TE</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RE</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UE</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CR2</name>
          <displayName>CR2</displayName>
          <description>Control Register 2</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>18</bitWidth>
            </field>
            <field>
              <name>STOP</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CR3</name>
          <displayName>CR3</displayName>
          <description>Control Register 3</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>19</bitWidth>
            </field>
            <field>
              <name>OVRDIS</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ONEBIT</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTSIE</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTSE</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RTSE</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMAT</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMAR</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>EIE</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BRR</name>
          <displayName>BRR</displayName>
          <description>Baud Rate Register</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>INT</name>
              <description>
              Baud Rate = UCLK / (int+ frac/16) / 16
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
            <field>
              <name>FRAC</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>GTPR</name>
          <displayName>GTPR</displayName>
          <description></description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RTOR</name>
          <displayName>RTOR</displayName>
          <description></description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RQR</name>
          <displayName>RQR</displayName>
          <description>Request Register</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>27</bitWidth>
            </field>
            <field>
              <name>TXFRQ</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RXFRQ</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ISR</name>
          <displayName>ISR</displayName>
          <description>Interrupt and Status Register</description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>21</bitWidth>
            </field>
            <field>
              <name>CTS</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTSIF</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TXE</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TC</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RXNE</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IDLE</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ORE</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>NF</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FE</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ICR</name>
          <displayName>ICR</displayName>
          <description>Interrupt flag Clear Register</description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>22</bitWidth>
            </field>
            <field>
              <name>CTSCF</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>TCCF</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IDLECF</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ORECF</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>NCF</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FECF</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PECF</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RDR</name>
          <displayName>RDR</displayName>
          <description>Receive Data Register</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>RDR</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TDR</name>
          <displayName>TDR</displayName>
          <description>Transmit Data Register</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>TDR</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>MISCR</name>
          <displayName>MISCR</displayName>
          <description>Miscellaneous Register</description>
          <addressOffset>0x2c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>AUTOCAL</name>
              <description>
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>RTSBIT</name>
              <description>
              assert RTS ahead of the frame completion (in number of bits)
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>SMPLINI</name>
              <description>
              initial sample count, count down from this value to zero to reach the middle of the start bit in Rx
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DRDR</name>
          <displayName>DRDR</displayName>
          <description></description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DTDR</name>
          <displayName>DTDR</displayName>
          <description></description>
          <addressOffset>0x34</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>EXR</name>
          <displayName>EXR</displayName>
          <description></description>
          <addressOffset>0x38</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>USART5</name>
      <description></description>
      <groupName>USART</groupName>
      <baseAddress>0x40006000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CR1</name>
          <displayName>CR1</displayName>
          <description>Control Register 1</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>M</name>
              <description>
              0 - 6bit, 1 - 7bit, 2 - 8bit, 3 - 9bit (including data bits and parity)
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
            <field>
              <name>OVER8</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>PCE</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PEIE</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TXEIE</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIE</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RXNEIE</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IDLEIE</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TE</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RE</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UE</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CR2</name>
          <displayName>CR2</displayName>
          <description>Control Register 2</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>18</bitWidth>
            </field>
            <field>
              <name>STOP</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CR3</name>
          <displayName>CR3</displayName>
          <description>Control Register 3</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>19</bitWidth>
            </field>
            <field>
              <name>OVRDIS</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ONEBIT</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTSIE</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTSE</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RTSE</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMAT</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMAR</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>EIE</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BRR</name>
          <displayName>BRR</displayName>
          <description>Baud Rate Register</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>INT</name>
              <description>
              Baud Rate = UCLK / (int+ frac/16) / 16
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
            <field>
              <name>FRAC</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>GTPR</name>
          <displayName>GTPR</displayName>
          <description></description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RTOR</name>
          <displayName>RTOR</displayName>
          <description></description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RQR</name>
          <displayName>RQR</displayName>
          <description>Request Register</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>27</bitWidth>
            </field>
            <field>
              <name>TXFRQ</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RXFRQ</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ISR</name>
          <displayName>ISR</displayName>
          <description>Interrupt and Status Register</description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>21</bitWidth>
            </field>
            <field>
              <name>CTS</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTSIF</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TXE</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TC</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RXNE</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IDLE</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ORE</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>NF</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FE</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ICR</name>
          <displayName>ICR</displayName>
          <description>Interrupt flag Clear Register</description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>22</bitWidth>
            </field>
            <field>
              <name>CTSCF</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>TCCF</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IDLECF</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ORECF</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>NCF</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FECF</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PECF</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RDR</name>
          <displayName>RDR</displayName>
          <description>Receive Data Register</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>RDR</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TDR</name>
          <displayName>TDR</displayName>
          <description>Transmit Data Register</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>TDR</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>MISCR</name>
          <displayName>MISCR</displayName>
          <description>Miscellaneous Register</description>
          <addressOffset>0x2c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>AUTOCAL</name>
              <description>
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>RTSBIT</name>
              <description>
              assert RTS ahead of the frame completion (in number of bits)
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>SMPLINI</name>
              <description>
              initial sample count, count down from this value to zero to reach the middle of the start bit in Rx
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DRDR</name>
          <displayName>DRDR</displayName>
          <description></description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DTDR</name>
          <displayName>DTDR</displayName>
          <description></description>
          <addressOffset>0x34</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>EXR</name>
          <displayName>EXR</displayName>
          <description></description>
          <addressOffset>0x38</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>BTIM3</name>
      <description></description>
      <groupName>BTIM</groupName>
      <baseAddress>0x40009000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CR1</name>
          <displayName>CR1</displayName>
          <description>TIM control register 1</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>ARPE</name>
              <description>
              Auto-reload preload enable
              0: ARR register is not buffered
              1: ARR register is buffered
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>OPM</name>
              <description>
              One-pulse mode
              0: Counter is not stopped at update event
              1: Counter stops counting at the next update event (clearing the bit CEN)
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>URS</name>
              <description>
              Update request source
              This bit is set and cleared by software to select the UEV event sources.
              0: Any of the following events generate an update interrupt or DMA request if enabled. 
              These events can be: 
               Counter overflow
               Setting the UG bit
               Update generation through the slave mode controller
              1: Only counter overflow generates an update interrupt or DMA request if enabled.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UDIS</name>
              <description>
              Update disable
              This bit is set and cleared by software to enable/disable UEV event generation.
              0: UEV enabled. The Update (UEV) event is generated by one of the following events:
               Counter overflow
               Setting the UG bit
               Update generation through the slave mode controller
              Buffered registers are then loaded with their preload values.
              1: UEV disabled. The Update event is not generated, shadow registers keep their value (ARR, PSC). However the counter and the prescaler are reinitialized if the UG bit is set or if a hardware reset is received from the slave mode controller.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CEN</name>
              <description>
              Counter enable
              0: Counter disabled
              1: Counter enabled
              Note: Gated mode can work only if the CEN bit has been previously set by software. However trigger mode can set the CEN bit automatically by hardware. 
              CEN is cleared automatically in one-pulse mode, when an update event occurs.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CR2</name>
          <displayName>CR2</displayName>
          <description>TIM control register 2</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>26</bitWidth>
            </field>
            <field>
              <name>MMS</name>
              <description>
              Master mode selection
              These bits allow to select the information to be sent in master mode to slave timers for synchronization (TRGO). The combination is as follows:
              00: Reset - the UG bit from the EGR register is used as trigger output (TRGO). If the reset is generated by the trigger input (slave mode controller configured in reset mode) then the signal on TRGO is delayed compared to the actual reset.
              01: Enable - the Counter enable signal, CNT_EN, is used as trigger output (TRGO). It is useful to start several timers at the same time or to control a window in which a slave timer is enabled. The Counter Enable signal is generated by a logic OR between CEN control bit and the trigger input when configured in gated mode. 
              When the Counter Enable signal is controlled by the trigger input, there is a delay on TRGO, except if the master/slave mode is selected (see the MSM bit description in SMCR register).
              10: Update - The update event is selected as trigger output (TRGO). For instance a master timer can then be used as a prescaler for a slave timer.
              11: Gating - The delayed gating trigger is selected as trigger output (TRGO). 
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SMCR</name>
          <displayName>SMCR</displayName>
          <description>TIM slave mode control register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>GM</name>
              <description>
              Gated Mode. The counter clock is enabled when the selected trigger input (TRGI) is active (according to gating trigger polarity). The counter stops (but is not reset) as soon as the trigger becomes inactive. Both start and stop of the counter are controlled. Gated mode and slave mode can be enabled simutanuously with different trigger selection.
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GTP</name>
              <description>
              Gating trigger polarity invert
              0: active at high level
              1: active at low level
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GTS</name>
              <description>
              Gating trigger selection in gated mode
              This bit-field selects the trigger input to be used to enable the counter gating.
              00: Internal Trigger 0 (ITR0)
              01: Internal Trigger 1 (ITR1) 
              10: Internal Trigger 2 (ITR2)
              11: Internal Trigger 3 (ITR3)
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SMS</name>
              <description>
              Slave mode selection
              When external signals are selected the active edge of the trigger signal (TRGI) is linked to the polarity selected on the external input.
              000: Slave mode disabled.
              001: Reset Mode - Rising edge of the selected trigger input (TRGI) reinitializes the counter and generates an update of the registers.
              010: Trigger Mode - The counter starts at a rising edge of the trigger TRGI (but it is not reset). Only the start of the counter is controlled.
              011: Combined reset + trigger mode - Rising edge of the selected trigger input (TRGI) reinitializes the counter, generates an update of the registers and starts the counter.
              100: External Clock Mode - Rising edges of the selected trigger (TRGI) clock the counter.
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>MSM</name>
              <description>
              Master/Slave mode. This bit should be asserted on master timer if synchronization if needed.
              0: No action
              1: The effect of an event on the trigger input (TRGI) is delayed to allow a perfect synchronization between the current timer and its slaves (through TRGO). It is useful if we want to synchronize several timers on a single external event.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TS</name>
              <description>
              Trigger selection
              This bit-field selects the trigger input to be used to synchronize the counter.
              00: Internal Trigger 0 (ITR0)
              01: Internal Trigger 1 (ITR1) 
              10: Internal Trigger 2 (ITR2)
              11: Internal Trigger 3 (ITR3)
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD5</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DIER</name>
          <displayName>DIER</displayName>
          <description>TIM DMA/Interrupt enable register</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>UDE</name>
              <description>
              Update DMA request enable
              0: Update DMA request disabled.
              1: Update DMA request enabled
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
            <field>
              <name>UIE</name>
              <description>
              Update interrupt enable
              0: Update interrupt disabled.
              1: Update interrupt enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SR</name>
          <displayName>SR</displayName>
          <description>TIM status register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>31</bitWidth>
            </field>
            <field>
              <name>UIF</name>
              <description>
              Update interrupt flag
              This bit is set by hardware on an update event. It is cleared by software.
              0: No update occurred
              1: Update interrupt pending. This bit is set by hardware when the registers are updated:
              At overflow and if UDIS=0 in the CR1 register.
              When CNT is reinitialized by software using the UG bit in EGR register, if URS=0 and UDIS=0 in the CR1 register.
              When CNT is reinitialized by a trigger event (refer to the synchro control register description), if URS=0 and UDIS=0 in the CR1 register.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>EGR</name>
          <displayName>EGR</displayName>
          <description>Event generation register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>31</bitWidth>
            </field>
            <field>
              <name>UG</name>
              <description>
              Update generation
              This bit can be set by software, it is automatically cleared by hardware.
              0: No action
              1: Re-initialize the counter and generates an update of the registers. Note that the prescaler counter is cleared too (anyway the prescaler ratio is not affected). The counter is cleared if the center-aligned mode is selected or if DIR=0 (upcounting), else it takes the auto-reload value (ARR) if DIR=1 (downcounting).
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD1</name>
          <displayName>RSVD1</displayName>
          <description></description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>CNT</name>
          <displayName>CNT</displayName>
          <description>Counter</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>CNT</name>
              <description>
              counter value
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PSC</name>
          <displayName>PSC</displayName>
          <description>Prescaler</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>PSC</name>
              <description>
              Prescaler value
              The counter clock frequency is equal to fCLK / (PSC[15:0] + 1).
              PSC contains the value to be loaded in the active prescaler register at each update event (including when the counter is cleared through UG bit of EGR register or through trigger controller when configured in reset mode).
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ARR</name>
          <displayName>ARR</displayName>
          <description>Auto-reload register</description>
          <addressOffset>0x2c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ARR</name>
              <description>
              Auto-reload value
              ARR is the value to be loaded in the actual auto-reload register. The counter is blocked while the auto-reload value is null.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>BTIM4</name>
      <description></description>
      <groupName>BTIM</groupName>
      <baseAddress>0x4000a000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CR1</name>
          <displayName>CR1</displayName>
          <description>TIM control register 1</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>ARPE</name>
              <description>
              Auto-reload preload enable
              0: ARR register is not buffered
              1: ARR register is buffered
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>OPM</name>
              <description>
              One-pulse mode
              0: Counter is not stopped at update event
              1: Counter stops counting at the next update event (clearing the bit CEN)
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>URS</name>
              <description>
              Update request source
              This bit is set and cleared by software to select the UEV event sources.
              0: Any of the following events generate an update interrupt or DMA request if enabled. 
              These events can be: 
               Counter overflow
               Setting the UG bit
               Update generation through the slave mode controller
              1: Only counter overflow generates an update interrupt or DMA request if enabled.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UDIS</name>
              <description>
              Update disable
              This bit is set and cleared by software to enable/disable UEV event generation.
              0: UEV enabled. The Update (UEV) event is generated by one of the following events:
               Counter overflow
               Setting the UG bit
               Update generation through the slave mode controller
              Buffered registers are then loaded with their preload values.
              1: UEV disabled. The Update event is not generated, shadow registers keep their value (ARR, PSC). However the counter and the prescaler are reinitialized if the UG bit is set or if a hardware reset is received from the slave mode controller.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CEN</name>
              <description>
              Counter enable
              0: Counter disabled
              1: Counter enabled
              Note: Gated mode can work only if the CEN bit has been previously set by software. However trigger mode can set the CEN bit automatically by hardware. 
              CEN is cleared automatically in one-pulse mode, when an update event occurs.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CR2</name>
          <displayName>CR2</displayName>
          <description>TIM control register 2</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>26</bitWidth>
            </field>
            <field>
              <name>MMS</name>
              <description>
              Master mode selection
              These bits allow to select the information to be sent in master mode to slave timers for synchronization (TRGO). The combination is as follows:
              00: Reset - the UG bit from the EGR register is used as trigger output (TRGO). If the reset is generated by the trigger input (slave mode controller configured in reset mode) then the signal on TRGO is delayed compared to the actual reset.
              01: Enable - the Counter enable signal, CNT_EN, is used as trigger output (TRGO). It is useful to start several timers at the same time or to control a window in which a slave timer is enabled. The Counter Enable signal is generated by a logic OR between CEN control bit and the trigger input when configured in gated mode. 
              When the Counter Enable signal is controlled by the trigger input, there is a delay on TRGO, except if the master/slave mode is selected (see the MSM bit description in SMCR register).
              10: Update - The update event is selected as trigger output (TRGO). For instance a master timer can then be used as a prescaler for a slave timer.
              11: Gating - The delayed gating trigger is selected as trigger output (TRGO). 
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SMCR</name>
          <displayName>SMCR</displayName>
          <description>TIM slave mode control register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>GM</name>
              <description>
              Gated Mode. The counter clock is enabled when the selected trigger input (TRGI) is active (according to gating trigger polarity). The counter stops (but is not reset) as soon as the trigger becomes inactive. Both start and stop of the counter are controlled. Gated mode and slave mode can be enabled simutanuously with different trigger selection.
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GTP</name>
              <description>
              Gating trigger polarity invert
              0: active at high level
              1: active at low level
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GTS</name>
              <description>
              Gating trigger selection in gated mode
              This bit-field selects the trigger input to be used to enable the counter gating.
              00: Internal Trigger 0 (ITR0)
              01: Internal Trigger 1 (ITR1) 
              10: Internal Trigger 2 (ITR2)
              11: Internal Trigger 3 (ITR3)
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SMS</name>
              <description>
              Slave mode selection
              When external signals are selected the active edge of the trigger signal (TRGI) is linked to the polarity selected on the external input.
              000: Slave mode disabled.
              001: Reset Mode - Rising edge of the selected trigger input (TRGI) reinitializes the counter and generates an update of the registers.
              010: Trigger Mode - The counter starts at a rising edge of the trigger TRGI (but it is not reset). Only the start of the counter is controlled.
              011: Combined reset + trigger mode - Rising edge of the selected trigger input (TRGI) reinitializes the counter, generates an update of the registers and starts the counter.
              100: External Clock Mode - Rising edges of the selected trigger (TRGI) clock the counter.
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>MSM</name>
              <description>
              Master/Slave mode. This bit should be asserted on master timer if synchronization if needed.
              0: No action
              1: The effect of an event on the trigger input (TRGI) is delayed to allow a perfect synchronization between the current timer and its slaves (through TRGO). It is useful if we want to synchronize several timers on a single external event.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TS</name>
              <description>
              Trigger selection
              This bit-field selects the trigger input to be used to synchronize the counter.
              00: Internal Trigger 0 (ITR0)
              01: Internal Trigger 1 (ITR1) 
              10: Internal Trigger 2 (ITR2)
              11: Internal Trigger 3 (ITR3)
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD5</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DIER</name>
          <displayName>DIER</displayName>
          <description>TIM DMA/Interrupt enable register</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>UDE</name>
              <description>
              Update DMA request enable
              0: Update DMA request disabled.
              1: Update DMA request enabled
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
            <field>
              <name>UIE</name>
              <description>
              Update interrupt enable
              0: Update interrupt disabled.
              1: Update interrupt enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SR</name>
          <displayName>SR</displayName>
          <description>TIM status register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>31</bitWidth>
            </field>
            <field>
              <name>UIF</name>
              <description>
              Update interrupt flag
              This bit is set by hardware on an update event. It is cleared by software.
              0: No update occurred
              1: Update interrupt pending. This bit is set by hardware when the registers are updated:
              At overflow and if UDIS=0 in the CR1 register.
              When CNT is reinitialized by software using the UG bit in EGR register, if URS=0 and UDIS=0 in the CR1 register.
              When CNT is reinitialized by a trigger event (refer to the synchro control register description), if URS=0 and UDIS=0 in the CR1 register.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>EGR</name>
          <displayName>EGR</displayName>
          <description>Event generation register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>31</bitWidth>
            </field>
            <field>
              <name>UG</name>
              <description>
              Update generation
              This bit can be set by software, it is automatically cleared by hardware.
              0: No action
              1: Re-initialize the counter and generates an update of the registers. Note that the prescaler counter is cleared too (anyway the prescaler ratio is not affected). The counter is cleared if the center-aligned mode is selected or if DIR=0 (upcounting), else it takes the auto-reload value (ARR) if DIR=1 (downcounting).
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD1</name>
          <displayName>RSVD1</displayName>
          <description></description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>CNT</name>
          <displayName>CNT</displayName>
          <description>Counter</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>CNT</name>
              <description>
              counter value
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PSC</name>
          <displayName>PSC</displayName>
          <description>Prescaler</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>PSC</name>
              <description>
              Prescaler value
              The counter clock frequency is equal to fCLK / (PSC[15:0] + 1).
              PSC contains the value to be loaded in the active prescaler register at each update event (including when the counter is cleared through UG bit of EGR register or through trigger controller when configured in reset mode).
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ARR</name>
          <displayName>ARR</displayName>
          <description>Auto-reload register</description>
          <addressOffset>0x2c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ARR</name>
              <description>
              Auto-reload value
              ARR is the value to be loaded in the actual auto-reload register. The counter is blocked while the auto-reload value is null.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>WDT2</name>
      <description></description>
      <groupName>WDT</groupName>
      <baseAddress>0x4000b000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>WDT_CVR0</name>
          <displayName>WDT_CVR0</displayName>
          <description>WatchDog Counter Value 0</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>COUNT_VALUE_0</name>
              <description>
              Count Value for 1st TimeOut
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_CVR1</name>
          <displayName>WDT_CVR1</displayName>
          <description>WatchDog Counter Value 1</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>COUNT_VALUE_1</name>
              <description>
              Count Value for 2nd TimeOut
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_CR</name>
          <displayName>WDT_CR</displayName>
          <description>WatchDog Control Register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>27</bitWidth>
            </field>
            <field>
              <name>RESPONSE_MODE</name>
              <description>
              0:reset only, 1:interrupt and reset
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RESET_LENGTH</name>
              <description>
              reset pulse length in number of wdt clock cycles
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_CCR</name>
          <displayName>WDT_CCR</displayName>
          <description>WatchDog Counter Control Register</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>COUNTER_CONTROL</name>
              <description>
              SinglePulse /Write 8'h76 to restart, write8'h34 to stop, else do nothing
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_ICR</name>
          <displayName>WDT_ICR</displayName>
          <description>WatchDog Interrupt Clear Register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>31</bitWidth>
            </field>
            <field>
              <name>INT_CLR</name>
              <description>
              SinglePulse /A pulse to clear interrupt
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_SR</name>
          <displayName>WDT_SR</displayName>
          <description>WatchDog Status Register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>30</bitWidth>
            </field>
            <field>
              <name>WDT_ACTIVE</name>
              <description>
              Watchdog runs when 1, else 0
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>INT_ASSERT</name>
              <description>
              Interrupt assert when 1
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_WP</name>
          <displayName>WDT_WP</displayName>
          <description>WatchDog Write Protect Register</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>WRPT_ST</name>
              <description>
              1 indicates write protect is active
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>WRPT</name>
              <description>
              write 0x58ab99fc generate write_protect, write 0x51ff8621 to release
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>31</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_FG</name>
          <displayName>WDT_FG</displayName>
          <description>WatchDog Flag Register</description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>28</bitWidth>
            </field>
            <field>
              <name>SYNC_FG</name>
              <description>
              1 indicates one transition from system clk to wdt clk has complicated
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SYNC_FG_CLR</name>
              <description>
              SinglePulse/A pulse to clear sync flag
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RST_FG</name>
              <description>
              1 indicates wdt has already reset system
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RST_FG_CLR</name>
              <description>
              SinglePulse/A pulse to clear reset flag
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>LPTIM3</name>
      <description></description>
      <groupName>LPTIM</groupName>
      <baseAddress>0x40042000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>ISR</name>
          <displayName>ISR</displayName>
          <description>LPTIM interrupt and status register</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>21</bitWidth>
            </field>
            <field>
              <name>OCWKUP</name>
              <description>
              Indicates output compare wakeup occurred
              The OCWKUP bit is set by hardware when LPTIM_CNT register value reached the LPTIM_CMP registers value. To clear OCWKUP, first  write 0 to the OCWE bit in the LPTIM_IER register to disable, then write 1 to the WKUPCLR bit in the LPTIM_ICR register. 
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OFWKUP</name>
              <description>
              Indicates overflow wakeup occurred
              OFWKUP is set by hardware when LPTIM_CNT registers value reached the LPTIM_ARR registers value and count from zero again. To clear OFWKUP, first  write 0 to the OFWE bit in the LPTIM_IER register to disable, then write 1 to the WKUPCLR bit in the LPTIM_ICR register. 
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UEWKUP</name>
              <description>
              Indicates update event wakeup occurred
              UEWKUP is set by hardware when an update event was generated (overflow occurred while repetition counter reached zero). To clear UEWKUP, first  write 0 to the UEWE bit in the LPTIM_IER register to disable, then write 1 to the WKUPCLR bit in the LPTIM_ICR register. 
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>ET</name>
              <description>
              External trigger edge event
              ET is set by hardware to inform application that a valid edge on the selected external trigger input has occurred. If the trigger is ignored because the timer has already started, then this flag is not set. ET flag can be cleared by writing 1 to the ETCLR bit in the LPTIM_ICR register.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OC</name>
              <description>
              Output compare match
              The OC bit is set by hardware to inform application that LPTIM_CNT register value reached the LPTIM_CMP registers value. OC flag can be cleared by writing 1 to the OCCLR bit in the LPTIM_ICR register.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OF</name>
              <description>
              Overflow occurred
              OF is set by hardware to inform application that LPTIM_CNT registers value reached the LPTIM_ARR registers value and count from zero again. OF flag can be cleared by writing 1 to the OFCLR bit in the LPTIM_ICR register.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UE</name>
              <description>
              LPTIM update event occurred
              UE is set by hardware to inform application that an update event was generated when overflow occurred while repetition counter reached zero. UE flag can be cleared by writing 1 to the UECLR bit in the LPTIM_ICR register. 
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ICR</name>
          <displayName>ICR</displayName>
          <description>LPTIM interrupt and status clear register</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>WKUPCLR</name>
              <description>
              wakeup status clear flag
              Writing 1 to this bit clears all wakeup status flags in the LPTIM_ISR register.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>ETCLR</name>
              <description>
              External trigger valid edge clear flag
              Writing 1 to this bit clears the ET flag in the LPTIM_ISR register
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OCCLR</name>
              <description>
              Output compare clear flag
              Writing 1 to this bit clears the OC flag in the LPTIM_ISR register
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OFCLR</name>
              <description>
              Overflow clear flag
              Writing 1 to this bit clears the OF flag in the LPTIM_ISR register
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UECLR</name>
              <description>
              Update event clear flag
              Writing 1 to this bit clear the UE flag in the LPTIM_ISR register.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IER</name>
          <displayName>IER</displayName>
          <description>LPTIM interrupt and wakeup enable register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>21</bitWidth>
            </field>
            <field>
              <name>OCWE</name>
              <description>
              Output compare Wakeup Enable
              0: Output compare wakeup disabled
              1: Output compare wakeup enabled
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OFWE</name>
              <description>
              Overflow Wakeup Enable
              0: Overflow Wakeup disabled
              1: Overflow Wakeup enabled
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UEWE</name>
              <description>
              Update event Wakeup enable
              0: Update event Wakeup disabled
              1: Update event Wakeup enabled
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>ETIE</name>
              <description>
              External trigger valid edge Interrupt Enable
              0: External trigger interrupt disabled
              1: External trigger interrupt enabled
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OCIE</name>
              <description>
              Output compare Interrupt Enable
              0: Output compare interrupt disabled
              1: Output compare interrupt enabled
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OFIE</name>
              <description>
              Overflow Interrupt Enable
              0: Overflow interrupt disabled
              1: Overflow interrupt enabled
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UEIE</name>
              <description>
              Update event interrupt enable
              0: Update event interrupt disabled
              1: Update event interrupt enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CFGR</name>
          <displayName>CFGR</displayName>
          <description>LPTIM configuration register</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>COUNTMODE</name>
              <description>
              counter mode in internal clock source mode (CKSEL=0). If CKSEL=1, this bit has no effect.
              0: the counter is incremented following each internal clock pulse
              1: the counter is incremented following each valid pulse on the external clock
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>WAVPOL</name>
              <description>
              Waveform shape polarity
              The WAVEPOL bit controls the output polarity
              0: The LPTIM output reflects the compare results between LPTIM_ARR and LPTIM_CMP registers
              1: The LPTIM output reflects the inverse of the compare results between LPTIM_ARR and LPTIM_CMP registers
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>WAVE</name>
              <description>
              Waveform shape
              The WAVE bit controls the output shape
              0: Deactivate Set-once mode
              1: Activate the Set-once mode
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TIMOUT</name>
              <description>
              Timeout enable
              The TIMOUT bit controls the Timeout feature
              0: A trigger event arriving when the timer is already started will be ignored
              1: A trigger event arriving when the timer is already started will reset and restart the LPTIM counter and the repetition counter
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TRIGEN</name>
              <description>
              Trigger enable and polarity
              The TRIGEN bits controls whether the LPTIM counter is started by an external trigger or not. If the external trigger option is selected, three configurations are possible for the trigger active edge:
              00: software trigger (counting start is initiated by software)
              01: rising edge is the active edge
              10: falling edge is the active edge
              11: both edges are active edges
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TRIGSEL</name>
              <description>
              Trigger selector
              The TRIGSEL bits select the trigger source that will serve as a trigger event for the LPTIM among the below 8 available sources:
              000: lptim_ext0
              001: lptim_ext1
              010: lptim_ext2
              011: lptim_ext3
              100: lptim_ext4
              101: lptim_ext5
              110: lptim_ext6
              111: lptim_ext7
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PRESC</name>
              <description>
              Clock prescaler
              The PRESC bits configure the prescaler division factor. It can be one among the following division factors:
              000: /1
              001: /2
              010: /4
              011: /8
              100: /16
              101: /32
              110: /64
              111: /128
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>EXTCKSEL</name>
              <description>
              External clock source selector
              0: external clock source is from lptim_in
              1: external clock source is from LPCOMP (if LPCOMP integrated)
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TRGFLT</name>
              <description>
              Configurable digital filter for trigger
              The TRGFLT value sets the number of consecutive equal samples that should be detected when a level change occurs on an internal trigger before it is considered as a valid level transition. An internal clock source must be present to use this feature
              00: any trigger active level change is considered as a valid trigger
              01: trigger active level change must be stable for at least 2 clock periods before it is considered as valid trigger.
              10: trigger active level change must be stable for at least 4 clock periods before it is considered as valid trigger.
              11: trigger active level change must be stable for at least 8 clock periods before it is considered as valid trigger.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>INTCKSEL</name>
              <description>
              Internal clock source selector
              0: internal clock source is clk_lp
              1: internal clock source is pclk2
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CKFLT</name>
              <description>
              Configurable digital filter for external clock
              The CKFLT value sets the number of consecutive equal samples that should be detected when a level change occurs on an external clock signal before it is considered as a valid level transition. An internal clock source must be present to use this feature
              00: any external clock signal level change is considered as a valid transition
              01: external clock signal level change must be stable for at least 2 clock periods before it is considered as valid transition.
              10: external clock signal level change must be stable for at least 4 clock periods before it is considered as valid transition.
              11: external clock signal level change must be stable for at least 8 clock periods before it is considered as valid transition.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>CKPOL</name>
              <description>
              Clock Polarity
              If LPTIM is clocked by an external clock source, CKPOL bits is used to configure the active edge or edges used by the counter:
              00: the rising edge is the active edge used for counting
              01: the falling edge is the active edge used for counting
              10: both edges are active edges. When both external clock signal edges are considered active ones, the LPTIM must also be clocked by an internal clock source with a frequency equal to at least four time the external clock frequency.
              11: not allowed
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>CKSEL</name>
              <description>
              Clock selector
              The CKSEL bit selects which clock source the LPTIM will use:
              0: LPTIM is clocked by internal clock source, according to INTCKSEL
              1: LPTIM is clocked by external clock source, according to EXTCKSEL
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CR</name>
          <displayName>CR</displayName>
          <description>LPTIM control register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>28</bitWidth>
            </field>
            <field>
              <name>COUNTRST</name>
              <description>
              Counter reset
              This bit is set by software and cleared by hardware. When set to 1 this bit will trigger a synchronous reset of the CNT register. Due to the synchronous nature of this reset, it only takes place after a synchronization delay.
              COUNTRST must never be set to 1 by software before it is already cleared to 0 by hardware. Software should consequently check that COUNTRST bit is already cleared to 0 before attempting to set it to 1.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CNTSTRT</name>
              <description>
              Timer start in Continuous mode
              This bit is set by software and cleared by hardware.
              In case of software start (TRIGEN[1:0] = 00), setting this bit starts the LPTIM in Continuous mode.
              If the software start is disabled (TRIGEN[1:0] different than 00), setting this bit starts the timer in Continuous mode as soon as an external trigger is detected.
              If this bit is set when a single pulse mode counting is ongoing, then the timer will not stop at the next match between ARR and CNT registers and the LPTIM counter keeps counting in Continuous mode.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SNGSTRT</name>
              <description>
              LPTIM start in Single mode
              This bit is set by software and cleared by hardware.
              In case of software start (TRIGEN[1:0] = 00), setting this bit starts the LPTIM in single pulse mode.
              If the software start is disabled (TRIGEN[1:0] different than 00), setting this bit starts the LPTIM in single pulse mode as soon as an external trigger is detected.
              If this bit is set when the LPTIM is in continuous counting mode, then the LPTIM will stop at the following match between ARR and CNT registers.
              If this bit is set simultaneously with CNTSTRT, then LPTIM will be in continuous counting mode.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ENABLE</name>
              <description>
              LPTIM enable
              The ENABLE bit is set and cleared by software. 
              0:LPTIM is disabled
              1:LPTIM is enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CMP</name>
          <displayName>CMP</displayName>
          <description>LPTIM compare register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>CMP</name>
              <description>
              Compare value
              CMP is the compare value used by the LPTIM.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ARR</name>
          <displayName>ARR</displayName>
          <description>LPTIM autoreload register</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>ARR</name>
              <description>
              Auto reload value
              ARR is the autoreload value for the LPTIM. This value must be strictly greater than the CMP[15:0] value.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CNT</name>
          <displayName>CNT</displayName>
          <description>LPTIM counter register</description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>CNT</name>
              <description>
              Counter value
              When the LPTIM is running with an asynchronous clock, reading the CNT register may return unreliable values. So in this case it is necessary to perform two consecutive read accesses and verify that the two returned values are identical.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RCR</name>
          <displayName>RCR</displayName>
          <description>LPTIM repetition register</description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>REP</name>
              <description>
              Repetition register value
              REP is the repetition value for the LPTIM.
              Read REP will return left repetition times. It should be noted that for a reliable REP register read access, two consecutive read accesses must be performed and compared. A read access can be considered reliable when the values of the two consecutive read accesses are equal.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>CRC2</name>
      <description></description>
      <groupName>CRC</groupName>
      <baseAddress>0x40085000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>DR</name>
          <displayName>DR</displayName>
          <description>Data register</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>DR</name>
              <description>
              Data register bits.
              This register is used to write new data to the CRC calculator.
              It holds the previous CRC calculation result when it is read.
              If the data size is less than 32 bits, the least significant bits are used to write/read the correct value.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SR</name>
          <displayName>SR</displayName>
          <description>Status register</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>30</bitWidth>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>
              Overflow when new data arrive while last calculation not done yet
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DONE</name>
              <description>
              Done flag. When DR written, done flag will be cleared automatically. The flag will assert after CRC operation of current DR finished.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CR</name>
          <displayName>CR</displayName>
          <description>Control register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>REV_OUT</name>
              <description>
              Reverse output data
              This bit controls the reversal of the bit order of the output data.
              0: Bit order not affected
              1: Bit-reversed output format
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>REV_IN</name>
              <description>
              Reverse input data
              These bits control the reversal of the bit order of the input data
              00: Bit order not affected
              01: Bit reversal done by byte
              10: Bit reversal done by half-word
              11: Bit reversal done by word
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>POLYSIZE</name>
              <description>
              Polynomial size
              These bits control the size of the polynomial.
              00: 32 bit polynomial
              01: 16 bit polynomial
              10: 8 bit polynomial
              11: 7 bit polynomial
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>DATASIZE</name>
              <description>
              Valid input data size
              These bits control the valid size of the input data.
              00: lower 8-bit
              01: lower 16-bit
              10: lower 24-bit
              11: all 32-bit
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RESET</name>
              <description>
              This bit is set by software to reset the CRC calculation unit and set the data register to the value stored in the CRC_INIT register. This bit can only be set, it is automatically cleared by hardware
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD1</name>
          <displayName>RSVD1</displayName>
          <description></description>
          <addressOffset>0xC</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>INIT</name>
          <displayName>INIT</displayName>
          <description>Initial CRC value</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>INIT</name>
              <description>
              Programmable initial CRC value
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>POL</name>
          <displayName>POL</displayName>
          <description>CRC polynomial</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>POL</name>
              <description>
              Programmable polynomial 
              This register is used to write the coefficients of the polynomial to be used for CRC calculation.
              If the polynomial size is less than 32 bits, the least significant bits have to be used to program the correct value.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
  </peripherals>
</device>
