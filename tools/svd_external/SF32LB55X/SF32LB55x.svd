<?xml version="1.0" encoding="utf-8" standalone="no"?>
<device schemaVersion="1.1"
xmlns:xs="http://www.w3.org/2001/XMLSchema-instance"
xs:noNamespaceSchemaLocation="CMSIS-SVD_Schema_1_1.xsd">
  <name>SF32LB55x</name>
  <version>1.0</version>
  <description>SF32LB55x</description>
  <!-- details about the cpu embedded in the device -->
  <cpu>
    <name>CM33</name>
    <revision>r0p1</revision>
    <endian>little</endian>
    <mpuPresent>true</mpuPresent>
    <fpuPresent>true</fpuPresent>
    <nvicPrioBits>3</nvicPrioBits>
    <vendorSystickConfig>false</vendorSystickConfig>
  </cpu>
  <!--Bus Interface Properties-->
  <addressUnitBits>8</addressUnitBits>
  <!--the maximum data bit width accessible within a single transfer-->
  <width>32</width>
  <!--Register Default Properties-->
  <size>0x20</size>
  <resetValue>0x0</resetValue>
  <resetMask>0xFFFFFFFF</resetMask>
  <peripherals>
    <peripheral>
      <name>HPSYS_RCC</name>
      <description></description>
      <groupName>HPSYS_RCC</groupName>
      <baseAddress>0x40000000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>RSTR1</name>
          <displayName>RSTR1</displayName>
          <description>Reset Register 1</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>PTC1</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DSIPHY</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DSIHOST</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>I2C2</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>I2C1</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PDM2</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PDM1</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>NNACC</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PSRAMC</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EXTDMA</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SPI2</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SPI1</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>WDT1</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BTIM2</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BTIM1</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GPTIM2</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GPTIM1</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TRNG</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CRC</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>AES</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EFUSEC</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SYSCFG1</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>I2S2</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>I2S1</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LCDC1</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EPIC</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EZIP</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>USART2</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>USART1</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PINMUX1</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MAILBOX1</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMAC1</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSTR2</name>
          <displayName>RSTR2</displayName>
          <description>Reset Register 2</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>I2C3</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BUSMON1</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>USBC</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SDMMC2</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SDMMC1</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>QSPI3</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>QSPI2</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>QSPI1</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GPIO1</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ENR1</name>
          <displayName>ENR1</displayName>
          <description>Enable Register 1</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>PTC1</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DSIPHY</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DSIHOST</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>I2C2</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>I2C1</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PDM2</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PDM1</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>NNACC</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PSRAMC</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EXTDMA</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SPI2</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SPI1</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>WDT1</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BTIM2</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BTIM1</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GPTIM2</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GPTIM1</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TRNG</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CRC</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>AES</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EFUSEC</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SYSCFG1</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>I2S2</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>I2S1</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LCDC1</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EPIC</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EZIP</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>USART2</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>USART1</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PINMUX1</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MAILBOX1</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMAC1</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ENR2</name>
          <displayName>ENR2</displayName>
          <description>Enable Register 2</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>I2C3</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BUSMON1</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>USBC</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SDMMC2</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SDMMC1</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>QSPI3</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>QSPI2</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>QSPI1</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GPIO1</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CSR</name>
          <displayName>CSR</displayName>
          <description>Clock Select Register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>FORCE_BUS</name>
              <description>
              for debug only
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>SEL_USBC</name>
              <description>
              select USB source clock
              0 - clk_sys; 1 - dll3
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SEL_PDM2</name>
              <description>
              0 - clk_sys; 1 - dll2
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SEL_PDM1</name>
              <description>
              0 - clk_sys; 1 - dll2
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SEL_USART2</name>
              <description>
              0 - hrc48; 1 - hxt48
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SEL_USART1</name>
              <description>
              0 - hrc48; 1 - hxt48
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SEL_QSPI3</name>
              <description>
              selet QSPI3 function clock
              0 - clk_sys; 1 - reserved; 2 - dll2; 3 - dll3
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>SEL_QSPI2</name>
              <description>
              selet QSPI2 function clock
              0 - clk_sys; 1 - reserved; 2 - dll2; 3 - dll3
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>SEL_QSPI1</name>
              <description>
              selet QSPI1 function clock
              0 - clk_sys; 1 - reserved; 2 - dll2; 3 - dll3
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>SEL_PSRAMC</name>
              <description>
              selet PSRAMC function clock
              0 - clk_sys; 1 - reserved; 2 - dll2; 3 - dll3
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>SEL_SYS</name>
              <description>
              select clk_sys source
              0 - hrc48; 1 - hxt48; 2 - clk_lp; 3 - dll1
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CFGR</name>
          <displayName>CFGR</displayName>
          <description>Clock Configuration Register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
            <field>
              <name>PDIV2</name>
              <description>
              pclk2 = hclk / (2^PDIV2), by default divided by 32
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PDIV1</name>
              <description>
              pclk1 = hclk / (2^PDIV1), by default divided by 2
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>HDIV</name>
              <description>
              hclk = clk_sys / HDIV
              if HDIV=0, hclk = clk_sys
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>I2SR</name>
          <displayName>I2SR</displayName>
          <description>I2S Register</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>27</bitWidth>
            </field>
            <field>
              <name>DIV</name>
              <description>
              I2S clock = pclk1 / DIV. After divider, I2S clock must be 12MHz.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>USBCR</name>
          <displayName>USBCR</displayName>
          <description>USBC Register</description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>29</bitWidth>
            </field>
            <field>
              <name>DIV</name>
              <description>
              USB function clock is USB source clock divided by DIV. After divider, USB function clock must be 60MHz.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DLL1CR</name>
          <displayName>DLL1CR</displayName>
          <description>DLL1 Control Register</description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>READY</name>
              <description>
              0: dll not ready
              1: dll ready
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LOCK_DLY</name>
              <description>
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>PU_DLY</name>
              <description>
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>DTEST_TR</name>
              <description>
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>DTEST_EN</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BYPASS</name>
              <description>
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>VST_SEL</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PRCHG_EXT</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PRCHG_EN</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MCU_PRCHG</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MCU_PRCHG_EN</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OUT_DIV2_EN</name>
              <description>
              0: dll output not divided
              1: dll output divided by 2
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IN_DIV2_EN</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LDO_VREF</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>MODE48M_EN</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>XTALIN_EN</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>STG</name>
              <description>
              DLL lock freqency is decided by STG.
              DLL output frequency is:
              0: 192MHz(if OUT_DIV2_EN=1) or 384MHz(if OUT_DIV2_EN=0)
              1: 168MHz(if OUT_DIV2_EN=1) or 336MHz(if OUT_DIV2_EN=0)
              2: 144MHz(if OUT_DIV2_EN=1) or 288MHz(if OUT_DIV2_EN=0)
              3: 120MHz(if OUT_DIV2_EN=1) or 240MHz(if OUT_DIV2_EN=0)
              4: 96MHz(if OUT_DIV2_EN=1) or 192MHz(if OUT_DIV2_EN=0)
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>SW</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EN</name>
              <description>
              0: dll disabled
              1: dll enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DLL2CR</name>
          <displayName>DLL2CR</displayName>
          <description>DLL2 Control Register</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>READY</name>
              <description>
              0: dll not ready
              1: dll ready
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LOCK_DLY</name>
              <description>
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>PU_DLY</name>
              <description>
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>DTEST_TR</name>
              <description>
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>DTEST_EN</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BYPASS</name>
              <description>
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>VST_SEL</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PRCHG_EXT</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PRCHG_EN</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MCU_PRCHG</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MCU_PRCHG_EN</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OUT_DIV2_EN</name>
              <description>
              0: dll output not divided
              1: dll output divided by 2
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IN_DIV2_EN</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LDO_VREF</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>MODE48M_EN</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>XTALIN_EN</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>STG</name>
              <description>
              DLL lock freqency is decided by STG.
              DLL output frequency is:
              0: 192MHz(if OUT_DIV2_EN=1) or 384MHz(if OUT_DIV2_EN=0)
              1: 168MHz(if OUT_DIV2_EN=1) or 336MHz(if OUT_DIV2_EN=0)
              2: 144MHz(if OUT_DIV2_EN=1) or 288MHz(if OUT_DIV2_EN=0)
              3: 120MHz(if OUT_DIV2_EN=1) or 240MHz(if OUT_DIV2_EN=0)
              4: 96MHz(if OUT_DIV2_EN=1) or 192MHz(if OUT_DIV2_EN=0)
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>SW</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EN</name>
              <description>
              0: dll disabled
              1: dll enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DLL3CR</name>
          <displayName>DLL3CR</displayName>
          <description>DLL3 Control Register</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>READY</name>
              <description>
              0: dll not ready
              1: dll ready
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LOCK_DLY</name>
              <description>
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>PU_DLY</name>
              <description>
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>DTEST_TR</name>
              <description>
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>DTEST_EN</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BYPASS</name>
              <description>
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>VST_SEL</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PRCHG_EXT</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PRCHG_EN</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MCU_PRCHG</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MCU_PRCHG_EN</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OUT_DIV2_EN</name>
              <description>
              0: dll output not divided
              1: dll output divided by 2
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IN_DIV2_EN</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LDO_VREF</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>MODE48M_EN</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>XTALIN_EN</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>STG</name>
              <description>
              DLL lock freqency is decided by STG.
              DLL output frequency is:
              0: 192MHz(if OUT_DIV2_EN=1) or 384MHz(if OUT_DIV2_EN=0)
              1: 168MHz(if OUT_DIV2_EN=1) or 336MHz(if OUT_DIV2_EN=0)
              2: 144MHz(if OUT_DIV2_EN=1) or 288MHz(if OUT_DIV2_EN=0)
              3: 120MHz(if OUT_DIV2_EN=1) or 240MHz(if OUT_DIV2_EN=0)
              4: 96MHz(if OUT_DIV2_EN=1) or 192MHz(if OUT_DIV2_EN=0)
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>SW</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EN</name>
              <description>
              0: dll disabled
              1: dll enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>HRCCAL1</name>
          <displayName>HRCCAL1</displayName>
          <description>HRC Calibration Register 1</description>
          <addressOffset>0x2c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>CAL_DONE</name>
              <description>
              Calibration done.
              After a new calibration started, results should be processed only when cal_done asserted.
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CAL_EN</name>
              <description>
              Calibration enble. 
              Set to 0 to clear result, then set to 1 to start a new calibration
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>14</bitWidth>
            </field>
            <field>
              <name>CAL_LENGTH</name>
              <description>
              Target hxt48 cycles during calibration
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>HRCCAL2</name>
          <displayName>HRCCAL2</displayName>
          <description>HRC Calibration Register 2</description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>HXT_CNT</name>
              <description>
              Total hxt48 cycles during calibration
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>HRC_CNT</name>
              <description>
              Total hrc48 cycles during calibration
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DBGCLKR</name>
          <displayName>DBGCLKR</displayName>
          <description>Debug Clock Register</description>
          <addressOffset>0x34</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>DLL3_OUT_STR</name>
              <description>
              for debug only
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>DLL3_CG_EN</name>
              <description>
              for debug only
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DLL3_OUT_RSTB</name>
              <description>
              for debug only
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DLL3_LOOP_EN</name>
              <description>
              for debug only
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DLL3_OUT_EN</name>
              <description>
              for debug only
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DLL3_LDO_EN</name>
              <description>
              for debug only
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DLL3_DBG</name>
              <description>
              for debug only
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DLL2_OUT_STR</name>
              <description>
              for debug only
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>DLL2_CG_EN</name>
              <description>
              for debug only
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DLL2_OUT_RSTB</name>
              <description>
              for debug only
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DLL2_LOOP_EN</name>
              <description>
              for debug only
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DLL2_OUT_EN</name>
              <description>
              for debug only
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DLL2_LDO_EN</name>
              <description>
              for debug only
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DLL2_DBG</name>
              <description>
              for debug only
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DLL1_OUT_STR</name>
              <description>
              for debug only
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>DLL1_CG_EN</name>
              <description>
              for debug only
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DLL1_OUT_RSTB</name>
              <description>
              for debug only
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DLL1_LOOP_EN</name>
              <description>
              for debug only
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DLL1_OUT_EN</name>
              <description>
              for debug only
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DLL1_LDO_EN</name>
              <description>
              for debug only
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DLL1_DBG</name>
              <description>
              for debug only
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CLK_EN</name>
              <description>
              for debug only
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CLK_SEL</name>
              <description>
              for debug only
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>DMAC1</name>
      <description></description>
      <groupName>DMAC</groupName>
      <baseAddress>0x40001000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>ISR</name>
          <displayName>ISR</displayName>
          <description></description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>TEIF8</name>
              <description>
              channel transfer error flag
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HTIF8</name>
              <description>
              channel half transfer flag
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIF8</name>
              <description>
              channel transfer complete flag
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GIF8</name>
              <description>
              channel global interrupt flag
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIF7</name>
              <description>
              channel transfer error flag
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HTIF7</name>
              <description>
              channel half transfer flag
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIF7</name>
              <description>
              channel transfer complete flag
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GIF7</name>
              <description>
              channel global interrupt flag
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIF6</name>
              <description>
              channel transfer error flag
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HTIF6</name>
              <description>
              channel half transfer flag
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIF6</name>
              <description>
              channel transfer complete flag
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GIF6</name>
              <description>
              channel global interrupt flag
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIF5</name>
              <description>
              channel transfer error flag
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HTIF5</name>
              <description>
              channel half transfer flag
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIF5</name>
              <description>
              channel transfer complete flag
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GIF5</name>
              <description>
              channel global interrupt flag
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIF4</name>
              <description>
              channel transfer error flag
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HTIF4</name>
              <description>
              channel half transfer flag
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIF4</name>
              <description>
              channel transfer complete flag
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GIF4</name>
              <description>
              channel global interrupt flag
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIF3</name>
              <description>
              channel transfer error flag
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HTIF3</name>
              <description>
              channel half transfer flag
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIF3</name>
              <description>
              channel transfer complete flag
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GIF3</name>
              <description>
              channel global interrupt flag
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIF2</name>
              <description>
              channel transfer error flag
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HTIF2</name>
              <description>
              channel half transfer flag
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIF2</name>
              <description>
              channel transfer complete flag
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GIF2</name>
              <description>
              channel global interrupt flag
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIF1</name>
              <description>
              channel transfer error flag. Set when bus error detected. Cleared when write 1 to CTEIF or CGIF.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HTIF1</name>
              <description>
              channel half transfer flag. Set when half NDT are transferred. Cleared when write 1 to CHTIF or CGIF.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIF1</name>
              <description>
              channel transfer complete flag. Set when all NDT are transferred.  Cleared when write 1 to CTCIF or CGIF.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GIF1</name>
              <description>
              channel global interrupt flag. Set when any of TEIF/HTIF/TCIF asserted. Cleared when TEIF/HTIF/TCIF all cleared.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IFCR</name>
          <displayName>IFCR</displayName>
          <description></description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>CTEIF8</name>
              <description>
              CTEIF, transfer error flag clear
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CHTIF8</name>
              <description>
              CHTIF, half transfer flag clear
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTCIF8</name>
              <description>
              CTCIF, transfer complete flag clear
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CGIF8</name>
              <description>
              CGIF,  global interrupt flag clear
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTEIF7</name>
              <description>
              CTEIF, transfer error flag clear
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CHTIF7</name>
              <description>
              CHTIF, half transfer flag clear
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTCIF7</name>
              <description>
              CTCIF, transfer complete flag clear
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CGIF7</name>
              <description>
              CGIF,  global interrupt flag clear
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTEIF6</name>
              <description>
              CTEIF, transfer error flag clear
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CHTIF6</name>
              <description>
              CHTIF, half transfer flag clear
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTCIF6</name>
              <description>
              CTCIF, transfer complete flag clear
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CGIF6</name>
              <description>
              CGIF,  global interrupt flag clear
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTEIF5</name>
              <description>
              CTEIF, transfer error flag clear
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CHTIF5</name>
              <description>
              CHTIF, half transfer flag clear
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTCIF5</name>
              <description>
              CTCIF, transfer complete flag clear
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CGIF5</name>
              <description>
              CGIF,  global interrupt flag clear
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTEIF4</name>
              <description>
              CTEIF, transfer error flag clear
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CHTIF4</name>
              <description>
              CHTIF, half transfer flag clear
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTCIF4</name>
              <description>
              CTCIF, transfer complete flag clear
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CGIF4</name>
              <description>
              CGIF,  global interrupt flag clear
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTEIF3</name>
              <description>
              CTEIF, transfer error flag clear
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CHTIF3</name>
              <description>
              CHTIF, half transfer flag clear
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTCIF3</name>
              <description>
              CTCIF, transfer complete flag clear
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CGIF3</name>
              <description>
              CGIF,  global interrupt flag clear
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTEIF2</name>
              <description>
              CTEIF, transfer error flag clear
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CHTIF2</name>
              <description>
              CHTIF, half transfer flag clear
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTCIF2</name>
              <description>
              CTCIF, transfer complete flag clear
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CGIF2</name>
              <description>
              CGIF,  global interrupt flag clear
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTEIF1</name>
              <description>
              CTEIF, transfer error flag clear. Write 1 to clear TEIF.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CHTIF1</name>
              <description>
              CHTIF, half transfer flag clear. Write 1 to clear HTIF.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTCIF1</name>
              <description>
              CTCIF, transfer complete flag clear. Write 1 to clear TCIF.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CGIF1</name>
              <description>
              CGIF,  global interrupt flag clear. Write 1 to clear all TEIF/HTIF/TCIF.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR1</name>
          <displayName>CCR1</displayName>
          <description></description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
            <field>
              <name>MEM2MEM</name>
              <description>
              memory-to-memory mode
              0: disabled
              1: enabled
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PL</name>
              <description>
              priority level
              00: low
              01: medium
              10: high
              11: very high
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>MSIZE</name>
              <description>
              memory size
              Defines the data size of each DMA transfer to the identified memory.
              In memory-to-memory mode, this field identifies the memory source if DIR = 1 and the memory destination if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.
              00: 8 bits
              01: 16 bits
              10: 32 bits
              11: reserved
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>PSIZE</name>
              <description>
              peripheral size
              Defines the data size of each DMA transfer to the identified peripheral.
              In memory-to-memory mode, this field identifies the memory destination if DIR = 1 and the memory source if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR = 1 and the peripheral source if DIR = 0.
              00: 8 bits
              01: 16 bits
              10: 32 bits
              11: reserved
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>MINC</name>
              <description>
              memory increment mode
              Defines the increment mode for each DMA transfer to the identified memory.
              In memory-to-memory mode, this field identifies the memory source if DIR = 1 and the memory destination if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.
              0: disabled
              1: enabled
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PINC</name>
              <description>
              peripheral increment mode
              Defines the increment mode for each DMA transfer to the identified peripheral.
              n memory-to-memory mode, this field identifies the memory destination if DIR = 1 and the 
              memory source if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR = 1 and 
              the peripheral source if DIR = 0.
              0: disabled
              1: enabled
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CIRC</name>
              <description>
              circular mode
              0: disabled
              1: enabled
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DIR</name>
              <description>
              data transfer direction
              This bit must be set only in memory-to-peripheral and peripheral-to-memory modes.
              0: read from peripheral
                 Source attributes are defined by PSIZE and PINC, plus the CPARx register. This is still valid in a memory-to-memory mode.
                 Destination attributes are defined by MSIZE and MINC, plus the CM0ARx register. This is still valid in a peripheral-to-peripheral mode.
              1: read from memory
                 Destination attributes are defined by PSIZE and PINC, plus the CPARx register. This is still valid in a memory-to-memory mode.
                 Source attributes are defined by MSIZE and MINC, plus the CM0ARx register. This is still valid in a peripheral-to-peripheral mode.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIE</name>
              <description>
              transfer error interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HTIE</name>
              <description>
              half transfer interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIE</name>
              <description>
              transfer complete interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EN</name>
              <description>
              channel enable
              When a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the ISR register is cleared (by setting the CTEIFx bit of the IFCR register).
              0: disabled
              1: enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CNDTR1</name>
          <displayName>CNDTR1</displayName>
          <description></description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>NDT</name>
              <description>
              number of data to transfer (0 to 2^16 - 1)
              This field is updated by hardware when the channel is enabled:
                 It is decremented after each single DMA 'read followed by write' transfer, indicating the remaining amount of data items to transfer.
                 It is kept at zero when the programmed amount of data to transfer is reached, if the channel is not in circular mode (CIRC = 0 in the CCRx register).
                 It is reloaded automatically by the previously programmed value, when the transfer is complete, if the channel is in circular mode (CIRC = 1).
              If this field is zero, no transfer can be served whatever the channel status (enabled or not).
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CPAR1</name>
          <displayName>CPAR1</displayName>
          <description></description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>PA</name>
              <description>
              peripheral address
              It contains the base address of the peripheral data register from/to which the data will be read/written.
              In memory-to-memory mode, this register identifies the memory destination address if DIR = 1 and the memory source address if DIR = 0.
              In peripheral-to-peripheral mode, this register identifies the peripheral destination address DIR = 1 and the peripheral source address if DIR = 0.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0AR1</name>
          <displayName>CM0AR1</displayName>
          <description></description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>MA</name>
              <description>
              memory address
              It contains the base address of the memory from/to which the data will be read/written.
              In memory-to-memory mode, this register identifies the memory source address if DIR = 1 and the memory destination address if DIR = 0.
              In peripheral-to-peripheral mode, this register identifies the peripheral source address DIR = 1 and the peripheral destination address if DIR = 0.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CBSR1</name>
          <displayName>CBSR1</displayName>
          <description></description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>BS</name>
              <description>
              burst size in non-m2m mode
              When BS>1, DMA will transfer for BS times for each request if left NDT is larger than BS, or else transfer for left NDT times.
              When BS=0 or 1, DMA will always do single transfer for each request.
              In memory-to-memory mode, BS is ignored.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR2</name>
          <displayName>CCR2</displayName>
          <description></description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
            <field>
              <name>MEM2MEM</name>
              <description>
              memory-to-memory mode
              0: disabled
              1: enabled
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PL</name>
              <description>
              priority level
              00: low
              01: medium
              10: high
              11: very high
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>MSIZE</name>
              <description>
              memory size
              Defines the data size of each DMA transfer to the identified memory.
              In memory-to-memory mode, this field identifies the memory source if DIR = 1 and the memory destination if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.
              00: 8 bits
              01: 16 bits
              10: 32 bits
              11: reserved
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>PSIZE</name>
              <description>
              peripheral size
              Defines the data size of each DMA transfer to the identified peripheral.
              In memory-to-memory mode, this field identifies the memory destination if DIR = 1 and the memory source if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR = 1 and the peripheral source if DIR = 0.
              00: 8 bits
              01: 16 bits
              10: 32 bits
              11: reserved
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>MINC</name>
              <description>
              memory increment mode
              Defines the increment mode for each DMA transfer to the identified memory.
              In memory-to-memory mode, this field identifies the memory source if DIR = 1 and the memory destination if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.
              0: disabled
              1: enabled
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PINC</name>
              <description>
              peripheral increment mode
              Defines the increment mode for each DMA transfer to the identified peripheral.
              n memory-to-memory mode, this field identifies the memory destination if DIR = 1 and the 
              memory source if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR = 1 and 
              the peripheral source if DIR = 0.
              0: disabled
              1: enabled
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CIRC</name>
              <description>
              circular mode
              0: disabled
              1: enabled
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DIR</name>
              <description>
              data transfer direction
              This bit must be set only in memory-to-peripheral and peripheral-to-memory modes.
              0: read from peripheral
                 Source attributes are defined by PSIZE and PINC, plus the CPARx register. This is still valid in a memory-to-memory mode.
                 Destination attributes are defined by MSIZE and MINC, plus the CM0ARx register. This is still valid in a peripheral-to-peripheral mode.
              1: read from memory
                 Destination attributes are defined by PSIZE and PINC, plus the CPARx register. This is still valid in a memory-to-memory mode.
                 Source attributes are defined by MSIZE and MINC, plus the CM0ARx register. This is still valid in a peripheral-to-peripheral mode.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIE</name>
              <description>
              transfer error interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HTIE</name>
              <description>
              half transfer interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIE</name>
              <description>
              transfer complete interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EN</name>
              <description>
              channel enable
              When a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the ISR register is cleared (by setting the CTEIFx bit of the IFCR register).
              0: disabled
              1: enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CNDTR2</name>
          <displayName>CNDTR2</displayName>
          <description></description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>NDT</name>
              <description>
              number of data to transfer (0 to 2^16 - 1)
              This field is updated by hardware when the channel is enabled:
                 It is decremented after each single DMA 'read followed by write' transfer, indicating the remaining amount of data items to transfer.
                 It is kept at zero when the programmed amount of data to transfer is reached, if the channel is not in circular mode (CIRC = 0 in the CCRx register).
                 It is reloaded automatically by the previously programmed value, when the transfer is complete, if the channel is in circular mode (CIRC = 1).
              If this field is zero, no transfer can be served whatever the channel status (enabled or not).
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CPAR2</name>
          <displayName>CPAR2</displayName>
          <description></description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>PA</name>
              <description>
              peripheral address
              It contains the base address of the peripheral data register from/to which the data will be read/written.
              In memory-to-memory mode, this register identifies the memory destination address if DIR = 1 and the memory source address if DIR = 0.
              In peripheral-to-peripheral mode, this register identifies the peripheral destination address DIR = 1 and the peripheral source address if DIR = 0.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0AR2</name>
          <displayName>CM0AR2</displayName>
          <description></description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>MA</name>
              <description>
              peripheral address
              It contains the base address of the memory from/to which the data will be read/written.
              In memory-to-memory mode, this register identifies the memory source address if DIR = 1 and the memory destination address if DIR = 0.
              In peripheral-to-peripheral mode, this register identifies the peripheral source address DIR = 1 and the peripheral destination address if DIR = 0.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CBSR2</name>
          <displayName>CBSR2</displayName>
          <description></description>
          <addressOffset>0x2c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>BS</name>
              <description>
              burst size in non-m2m mode
              When BS>1, DMA will transfer for BS times for each request if left NDT is larger than BS, or else transfer for left NDT times.
              When BS=0 or 1, DMA will always do single transfer for each request.
              In memory-to-memory mode, BS is ignored.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR3</name>
          <displayName>CCR3</displayName>
          <description></description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
            <field>
              <name>MEM2MEM</name>
              <description>
              memory-to-memory mode
              0: disabled
              1: enabled
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PL</name>
              <description>
              priority level
              00: low
              01: medium
              10: high
              11: very high
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>MSIZE</name>
              <description>
              memory size
              Defines the data size of each DMA transfer to the identified memory.
              In memory-to-memory mode, this field identifies the memory source if DIR = 1 and the memory destination if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.
              00: 8 bits
              01: 16 bits
              10: 32 bits
              11: reserved
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>PSIZE</name>
              <description>
              peripheral size
              Defines the data size of each DMA transfer to the identified peripheral.
              In memory-to-memory mode, this field identifies the memory destination if DIR = 1 and the memory source if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR = 1 and the peripheral source if DIR = 0.
              00: 8 bits
              01: 16 bits
              10: 32 bits
              11: reserved
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>MINC</name>
              <description>
              memory increment mode
              Defines the increment mode for each DMA transfer to the identified memory.
              In memory-to-memory mode, this field identifies the memory source if DIR = 1 and the memory destination if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.
              0: disabled
              1: enabled
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PINC</name>
              <description>
              peripheral increment mode
              Defines the increment mode for each DMA transfer to the identified peripheral.
              n memory-to-memory mode, this field identifies the memory destination if DIR = 1 and the 
              memory source if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR = 1 and 
              the peripheral source if DIR = 0.
              0: disabled
              1: enabled
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CIRC</name>
              <description>
              circular mode
              0: disabled
              1: enabled
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DIR</name>
              <description>
              data transfer direction
              This bit must be set only in memory-to-peripheral and peripheral-to-memory modes.
              0: read from peripheral
                 Source attributes are defined by PSIZE and PINC, plus the CPARx register. This is still valid in a memory-to-memory mode.
                 Destination attributes are defined by MSIZE and MINC, plus the CM0ARx register. This is still valid in a peripheral-to-peripheral mode.
              1: read from memory
                 Destination attributes are defined by PSIZE and PINC, plus the CPARx register. This is still valid in a memory-to-memory mode.
                 Source attributes are defined by MSIZE and MINC, plus the CM0ARx register. This is still valid in a peripheral-to-peripheral mode.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIE</name>
              <description>
              transfer error interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HTIE</name>
              <description>
              half transfer interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIE</name>
              <description>
              transfer complete interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EN</name>
              <description>
              channel enable
              When a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the ISR register is cleared (by setting the CTEIFx bit of the IFCR register).
              0: disabled
              1: enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CNDTR3</name>
          <displayName>CNDTR3</displayName>
          <description></description>
          <addressOffset>0x34</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>NDT</name>
              <description>
              number of data to transfer (0 to 2^16 - 1)
              This field is updated by hardware when the channel is enabled:
                 It is decremented after each single DMA 'read followed by write' transfer, indicating the remaining amount of data items to transfer.
                 It is kept at zero when the programmed amount of data to transfer is reached, if the channel is not in circular mode (CIRC = 0 in the CCRx register).
                 It is reloaded automatically by the previously programmed value, when the transfer is complete, if the channel is in circular mode (CIRC = 1).
              If this field is zero, no transfer can be served whatever the channel status (enabled or not).
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CPAR3</name>
          <displayName>CPAR3</displayName>
          <description></description>
          <addressOffset>0x38</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>PA</name>
              <description>
              peripheral address
              It contains the base address of the peripheral data register from/to which the data will be read/written.
              In memory-to-memory mode, this register identifies the memory destination address if DIR = 1 and the memory source address if DIR = 0.
              In peripheral-to-peripheral mode, this register identifies the peripheral destination address DIR = 1 and the peripheral source address if DIR = 0.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0AR3</name>
          <displayName>CM0AR3</displayName>
          <description></description>
          <addressOffset>0x3c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>MA</name>
              <description>
              peripheral address
              It contains the base address of the memory from/to which the data will be read/written.
              In memory-to-memory mode, this register identifies the memory source address if DIR = 1 and the memory destination address if DIR = 0.
              In peripheral-to-peripheral mode, this register identifies the peripheral source address DIR = 1 and the peripheral destination address if DIR = 0.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CBSR3</name>
          <displayName>CBSR3</displayName>
          <description></description>
          <addressOffset>0x40</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>BS</name>
              <description>
              burst size in non-m2m mode
              When BS>1, DMA will transfer for BS times for each request if left NDT is larger than BS, or else transfer for left NDT times.
              When BS=0 or 1, DMA will always do single transfer for each request.
              In memory-to-memory mode, BS is ignored.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR4</name>
          <displayName>CCR4</displayName>
          <description></description>
          <addressOffset>0x44</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
            <field>
              <name>MEM2MEM</name>
              <description>
              memory-to-memory mode
              0: disabled
              1: enabled
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PL</name>
              <description>
              priority level
              00: low
              01: medium
              10: high
              11: very high
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>MSIZE</name>
              <description>
              memory size
              Defines the data size of each DMA transfer to the identified memory.
              In memory-to-memory mode, this field identifies the memory source if DIR = 1 and the memory destination if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.
              00: 8 bits
              01: 16 bits
              10: 32 bits
              11: reserved
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>PSIZE</name>
              <description>
              peripheral size
              Defines the data size of each DMA transfer to the identified peripheral.
              In memory-to-memory mode, this field identifies the memory destination if DIR = 1 and the memory source if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR = 1 and the peripheral source if DIR = 0.
              00: 8 bits
              01: 16 bits
              10: 32 bits
              11: reserved
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>MINC</name>
              <description>
              memory increment mode
              Defines the increment mode for each DMA transfer to the identified memory.
              In memory-to-memory mode, this field identifies the memory source if DIR = 1 and the memory destination if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.
              0: disabled
              1: enabled
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PINC</name>
              <description>
              peripheral increment mode
              Defines the increment mode for each DMA transfer to the identified peripheral.
              n memory-to-memory mode, this field identifies the memory destination if DIR = 1 and the 
              memory source if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR = 1 and 
              the peripheral source if DIR = 0.
              0: disabled
              1: enabled
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CIRC</name>
              <description>
              circular mode
              0: disabled
              1: enabled
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DIR</name>
              <description>
              data transfer direction
              This bit must be set only in memory-to-peripheral and peripheral-to-memory modes.
              0: read from peripheral
                 Source attributes are defined by PSIZE and PINC, plus the CPARx register. This is still valid in a memory-to-memory mode.
                 Destination attributes are defined by MSIZE and MINC, plus the CM0ARx register. This is still valid in a peripheral-to-peripheral mode.
              1: read from memory
                 Destination attributes are defined by PSIZE and PINC, plus the CPARx register. This is still valid in a memory-to-memory mode.
                 Source attributes are defined by MSIZE and MINC, plus the CM0ARx register. This is still valid in a peripheral-to-peripheral mode.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIE</name>
              <description>
              transfer error interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HTIE</name>
              <description>
              half transfer interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIE</name>
              <description>
              transfer complete interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EN</name>
              <description>
              channel enable
              When a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the ISR register is cleared (by setting the CTEIFx bit of the IFCR register).
              0: disabled
              1: enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CNDTR4</name>
          <displayName>CNDTR4</displayName>
          <description></description>
          <addressOffset>0x48</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>NDT</name>
              <description>
              number of data to transfer (0 to 2^16 - 1)
              This field is updated by hardware when the channel is enabled:
                 It is decremented after each single DMA 'read followed by write' transfer, indicating the remaining amount of data items to transfer.
                 It is kept at zero when the programmed amount of data to transfer is reached, if the channel is not in circular mode (CIRC = 0 in the CCRx register).
                 It is reloaded automatically by the previously programmed value, when the transfer is complete, if the channel is in circular mode (CIRC = 1).
              If this field is zero, no transfer can be served whatever the channel status (enabled or not).
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CPAR4</name>
          <displayName>CPAR4</displayName>
          <description></description>
          <addressOffset>0x4c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>PA</name>
              <description>
              peripheral address
              It contains the base address of the peripheral data register from/to which the data will be read/written.
              In memory-to-memory mode, this register identifies the memory destination address if DIR = 1 and the memory source address if DIR = 0.
              In peripheral-to-peripheral mode, this register identifies the peripheral destination address DIR = 1 and the peripheral source address if DIR = 0.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0AR4</name>
          <displayName>CM0AR4</displayName>
          <description></description>
          <addressOffset>0x50</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>MA</name>
              <description>
              peripheral address
              It contains the base address of the memory from/to which the data will be read/written.
              In memory-to-memory mode, this register identifies the memory source address if DIR = 1 and the memory destination address if DIR = 0.
              In peripheral-to-peripheral mode, this register identifies the peripheral source address DIR = 1 and the peripheral destination address if DIR = 0.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CBSR4</name>
          <displayName>CBSR4</displayName>
          <description></description>
          <addressOffset>0x54</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>BS</name>
              <description>
              burst size in non-m2m mode
              When BS>1, DMA will transfer for BS times for each request if left NDT is larger than BS, or else transfer for left NDT times.
              When BS=0 or 1, DMA will always do single transfer for each request.
              In memory-to-memory mode, BS is ignored.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR5</name>
          <displayName>CCR5</displayName>
          <description></description>
          <addressOffset>0x58</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
            <field>
              <name>MEM2MEM</name>
              <description>
              memory-to-memory mode
              0: disabled
              1: enabled
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PL</name>
              <description>
              priority level
              00: low
              01: medium
              10: high
              11: very high
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>MSIZE</name>
              <description>
              memory size
              Defines the data size of each DMA transfer to the identified memory.
              In memory-to-memory mode, this field identifies the memory source if DIR = 1 and the memory destination if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.
              00: 8 bits
              01: 16 bits
              10: 32 bits
              11: reserved
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>PSIZE</name>
              <description>
              peripheral size
              Defines the data size of each DMA transfer to the identified peripheral.
              In memory-to-memory mode, this field identifies the memory destination if DIR = 1 and the memory source if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR = 1 and the peripheral source if DIR = 0.
              00: 8 bits
              01: 16 bits
              10: 32 bits
              11: reserved
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>MINC</name>
              <description>
              memory increment mode
              Defines the increment mode for each DMA transfer to the identified memory.
              In memory-to-memory mode, this field identifies the memory source if DIR = 1 and the memory destination if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.
              0: disabled
              1: enabled
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PINC</name>
              <description>
              peripheral increment mode
              Defines the increment mode for each DMA transfer to the identified peripheral.
              n memory-to-memory mode, this field identifies the memory destination if DIR = 1 and the 
              memory source if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR = 1 and 
              the peripheral source if DIR = 0.
              0: disabled
              1: enabled
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CIRC</name>
              <description>
              circular mode
              0: disabled
              1: enabled
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DIR</name>
              <description>
              data transfer direction
              This bit must be set only in memory-to-peripheral and peripheral-to-memory modes.
              0: read from peripheral
                 Source attributes are defined by PSIZE and PINC, plus the CPARx register. This is still valid in a memory-to-memory mode.
                 Destination attributes are defined by MSIZE and MINC, plus the CM0ARx register. This is still valid in a peripheral-to-peripheral mode.
              1: read from memory
                 Destination attributes are defined by PSIZE and PINC, plus the CPARx register. This is still valid in a memory-to-memory mode.
                 Source attributes are defined by MSIZE and MINC, plus the CM0ARx register. This is still valid in a peripheral-to-peripheral mode.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIE</name>
              <description>
              transfer error interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HTIE</name>
              <description>
              half transfer interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIE</name>
              <description>
              transfer complete interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EN</name>
              <description>
              channel enable
              When a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the ISR register is cleared (by setting the CTEIFx bit of the IFCR register).
              0: disabled
              1: enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CNDTR5</name>
          <displayName>CNDTR5</displayName>
          <description></description>
          <addressOffset>0x5c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>NDT</name>
              <description>
              number of data to transfer (0 to 2^16 - 1)
              This field is updated by hardware when the channel is enabled:
                 It is decremented after each single DMA 'read followed by write' transfer, indicating the remaining amount of data items to transfer.
                 It is kept at zero when the programmed amount of data to transfer is reached, if the channel is not in circular mode (CIRC = 0 in the CCRx register).
                 It is reloaded automatically by the previously programmed value, when the transfer is complete, if the channel is in circular mode (CIRC = 1).
              If this field is zero, no transfer can be served whatever the channel status (enabled or not).
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CPAR5</name>
          <displayName>CPAR5</displayName>
          <description></description>
          <addressOffset>0x60</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>PA</name>
              <description>
              peripheral address
              It contains the base address of the peripheral data register from/to which the data will be read/written.
              In memory-to-memory mode, this register identifies the memory destination address if DIR = 1 and the memory source address if DIR = 0.
              In peripheral-to-peripheral mode, this register identifies the peripheral destination address DIR = 1 and the peripheral source address if DIR = 0.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0AR5</name>
          <displayName>CM0AR5</displayName>
          <description></description>
          <addressOffset>0x64</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>MA</name>
              <description>
              peripheral address
              It contains the base address of the memory from/to which the data will be read/written.
              In memory-to-memory mode, this register identifies the memory source address if DIR = 1 and the memory destination address if DIR = 0.
              In peripheral-to-peripheral mode, this register identifies the peripheral source address DIR = 1 and the peripheral destination address if DIR = 0.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CBSR5</name>
          <displayName>CBSR5</displayName>
          <description></description>
          <addressOffset>0x68</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>BS</name>
              <description>
              burst size in non-m2m mode
              When BS>1, DMA will transfer for BS times for each request if left NDT is larger than BS, or else transfer for left NDT times.
              When BS=0 or 1, DMA will always do single transfer for each request.
              In memory-to-memory mode, BS is ignored.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR6</name>
          <displayName>CCR6</displayName>
          <description></description>
          <addressOffset>0x6c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
            <field>
              <name>MEM2MEM</name>
              <description>
              memory-to-memory mode
              0: disabled
              1: enabled
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PL</name>
              <description>
              priority level
              00: low
              01: medium
              10: high
              11: very high
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>MSIZE</name>
              <description>
              memory size
              Defines the data size of each DMA transfer to the identified memory.
              In memory-to-memory mode, this field identifies the memory source if DIR = 1 and the memory destination if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.
              00: 8 bits
              01: 16 bits
              10: 32 bits
              11: reserved
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>PSIZE</name>
              <description>
              peripheral size
              Defines the data size of each DMA transfer to the identified peripheral.
              In memory-to-memory mode, this field identifies the memory destination if DIR = 1 and the memory source if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR = 1 and the peripheral source if DIR = 0.
              00: 8 bits
              01: 16 bits
              10: 32 bits
              11: reserved
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>MINC</name>
              <description>
              memory increment mode
              Defines the increment mode for each DMA transfer to the identified memory.
              In memory-to-memory mode, this field identifies the memory source if DIR = 1 and the memory destination if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.
              0: disabled
              1: enabled
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PINC</name>
              <description>
              peripheral increment mode
              Defines the increment mode for each DMA transfer to the identified peripheral.
              n memory-to-memory mode, this field identifies the memory destination if DIR = 1 and the 
              memory source if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR = 1 and 
              the peripheral source if DIR = 0.
              0: disabled
              1: enabled
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CIRC</name>
              <description>
              circular mode
              0: disabled
              1: enabled
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DIR</name>
              <description>
              data transfer direction
              This bit must be set only in memory-to-peripheral and peripheral-to-memory modes.
              0: read from peripheral
                 Source attributes are defined by PSIZE and PINC, plus the CPARx register. This is still valid in a memory-to-memory mode.
                 Destination attributes are defined by MSIZE and MINC, plus the CM0ARx register. This is still valid in a peripheral-to-peripheral mode.
              1: read from memory
                 Destination attributes are defined by PSIZE and PINC, plus the CPARx register. This is still valid in a memory-to-memory mode.
                 Source attributes are defined by MSIZE and MINC, plus the CM0ARx register. This is still valid in a peripheral-to-peripheral mode.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIE</name>
              <description>
              transfer error interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HTIE</name>
              <description>
              half transfer interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIE</name>
              <description>
              transfer complete interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EN</name>
              <description>
              channel enable
              When a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the ISR register is cleared (by setting the CTEIFx bit of the IFCR register).
              0: disabled
              1: enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CNDTR6</name>
          <displayName>CNDTR6</displayName>
          <description></description>
          <addressOffset>0x70</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>NDT</name>
              <description>
              number of data to transfer (0 to 2^16 - 1)
              This field is updated by hardware when the channel is enabled:
                 It is decremented after each single DMA 'read followed by write' transfer, indicating the remaining amount of data items to transfer.
                 It is kept at zero when the programmed amount of data to transfer is reached, if the channel is not in circular mode (CIRC = 0 in the CCRx register).
                 It is reloaded automatically by the previously programmed value, when the transfer is complete, if the channel is in circular mode (CIRC = 1).
              If this field is zero, no transfer can be served whatever the channel status (enabled or not).
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CPAR6</name>
          <displayName>CPAR6</displayName>
          <description></description>
          <addressOffset>0x74</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>PA</name>
              <description>
              peripheral address
              It contains the base address of the peripheral data register from/to which the data will be read/written.
              In memory-to-memory mode, this register identifies the memory destination address if DIR = 1 and the memory source address if DIR = 0.
              In peripheral-to-peripheral mode, this register identifies the peripheral destination address DIR = 1 and the peripheral source address if DIR = 0.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0AR6</name>
          <displayName>CM0AR6</displayName>
          <description></description>
          <addressOffset>0x78</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>MA</name>
              <description>
              peripheral address
              It contains the base address of the memory from/to which the data will be read/written.
              In memory-to-memory mode, this register identifies the memory source address if DIR = 1 and the memory destination address if DIR = 0.
              In peripheral-to-peripheral mode, this register identifies the peripheral source address DIR = 1 and the peripheral destination address if DIR = 0.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CBSR6</name>
          <displayName>CBSR6</displayName>
          <description></description>
          <addressOffset>0x7c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>BS</name>
              <description>
              burst size in non-m2m mode
              When BS>1, DMA will transfer for BS times for each request if left NDT is larger than BS, or else transfer for left NDT times.
              When BS=0 or 1, DMA will always do single transfer for each request.
              In memory-to-memory mode, BS is ignored.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR7</name>
          <displayName>CCR7</displayName>
          <description></description>
          <addressOffset>0x80</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
            <field>
              <name>MEM2MEM</name>
              <description>
              memory-to-memory mode
              0: disabled
              1: enabled
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PL</name>
              <description>
              priority level
              00: low
              01: medium
              10: high
              11: very high
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>MSIZE</name>
              <description>
              memory size
              Defines the data size of each DMA transfer to the identified memory.
              In memory-to-memory mode, this field identifies the memory source if DIR = 1 and the memory destination if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.
              00: 8 bits
              01: 16 bits
              10: 32 bits
              11: reserved
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>PSIZE</name>
              <description>
              peripheral size
              Defines the data size of each DMA transfer to the identified peripheral.
              In memory-to-memory mode, this field identifies the memory destination if DIR = 1 and the memory source if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR = 1 and the peripheral source if DIR = 0.
              00: 8 bits
              01: 16 bits
              10: 32 bits
              11: reserved
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>MINC</name>
              <description>
              memory increment mode
              Defines the increment mode for each DMA transfer to the identified memory.
              In memory-to-memory mode, this field identifies the memory source if DIR = 1 and the memory destination if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.
              0: disabled
              1: enabled
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PINC</name>
              <description>
              peripheral increment mode
              Defines the increment mode for each DMA transfer to the identified peripheral.
              n memory-to-memory mode, this field identifies the memory destination if DIR = 1 and the 
              memory source if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR = 1 and 
              the peripheral source if DIR = 0.
              0: disabled
              1: enabled
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CIRC</name>
              <description>
              circular mode
              0: disabled
              1: enabled
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DIR</name>
              <description>
              data transfer direction
              This bit must be set only in memory-to-peripheral and peripheral-to-memory modes.
              0: read from peripheral
                 Source attributes are defined by PSIZE and PINC, plus the CPARx register. This is still valid in a memory-to-memory mode.
                 Destination attributes are defined by MSIZE and MINC, plus the CM0ARx register. This is still valid in a peripheral-to-peripheral mode.
              1: read from memory
                 Destination attributes are defined by PSIZE and PINC, plus the CPARx register. This is still valid in a memory-to-memory mode.
                 Source attributes are defined by MSIZE and MINC, plus the CM0ARx register. This is still valid in a peripheral-to-peripheral mode.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIE</name>
              <description>
              transfer error interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HTIE</name>
              <description>
              half transfer interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIE</name>
              <description>
              transfer complete interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EN</name>
              <description>
              channel enable
              When a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the ISR register is cleared (by setting the CTEIFx bit of the IFCR register).
              0: disabled
              1: enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CNDTR7</name>
          <displayName>CNDTR7</displayName>
          <description></description>
          <addressOffset>0x84</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>NDT</name>
              <description>
              number of data to transfer (0 to 2^16 - 1)
              This field is updated by hardware when the channel is enabled:
                 It is decremented after each single DMA 'read followed by write' transfer, indicating the remaining amount of data items to transfer.
                 It is kept at zero when the programmed amount of data to transfer is reached, if the channel is not in circular mode (CIRC = 0 in the CCRx register).
                 It is reloaded automatically by the previously programmed value, when the transfer is complete, if the channel is in circular mode (CIRC = 1).
              If this field is zero, no transfer can be served whatever the channel status (enabled or not).
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CPAR7</name>
          <displayName>CPAR7</displayName>
          <description></description>
          <addressOffset>0x88</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>PA</name>
              <description>
              peripheral address
              It contains the base address of the peripheral data register from/to which the data will be read/written.
              In memory-to-memory mode, this register identifies the memory destination address if DIR = 1 and the memory source address if DIR = 0.
              In peripheral-to-peripheral mode, this register identifies the peripheral destination address DIR = 1 and the peripheral source address if DIR = 0.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0AR7</name>
          <displayName>CM0AR7</displayName>
          <description></description>
          <addressOffset>0x8c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>MA</name>
              <description>
              peripheral address
              It contains the base address of the memory from/to which the data will be read/written.
              In memory-to-memory mode, this register identifies the memory source address if DIR = 1 and the memory destination address if DIR = 0.
              In peripheral-to-peripheral mode, this register identifies the peripheral source address DIR = 1 and the peripheral destination address if DIR = 0.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CBSR7</name>
          <displayName>CBSR7</displayName>
          <description></description>
          <addressOffset>0x90</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>BS</name>
              <description>
              burst size in non memory-to-memory mode
              When BS>1, DMA will transfer for BS times for each request if left NDT is larger than BS, or else transfer for left NDT times.
              When BS=0 or 1, DMA will always do single transfer for each request.
              In memory-to-memory mode, BS is ignored.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR8</name>
          <displayName>CCR8</displayName>
          <description></description>
          <addressOffset>0x94</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
            <field>
              <name>MEM2MEM</name>
              <description>
              memory-to-memory mode
              0: disabled
              1: enabled
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PL</name>
              <description>
              priority level
              00: low
              01: medium
              10: high
              11: very high
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>MSIZE</name>
              <description>
              memory size
              Defines the data size of each DMA transfer to the identified memory.
              In memory-to-memory mode, this field identifies the memory source if DIR = 1 and the memory destination if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.
              00: 8 bits
              01: 16 bits
              10: 32 bits
              11: reserved
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>PSIZE</name>
              <description>
              peripheral size
              Defines the data size of each DMA transfer to the identified peripheral.
              In memory-to-memory mode, this field identifies the memory destination if DIR = 1 and the memory source if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR = 1 and the peripheral source if DIR = 0.
              00: 8 bits
              01: 16 bits
              10: 32 bits
              11: reserved
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>MINC</name>
              <description>
              memory increment mode
              Defines the increment mode for each DMA transfer to the identified memory.
              In memory-to-memory mode, this field identifies the memory source if DIR = 1 and the memory destination if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.
              0: disabled
              1: enabled
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PINC</name>
              <description>
              peripheral increment mode
              Defines the increment mode for each DMA transfer to the identified peripheral.
              n memory-to-memory mode, this field identifies the memory destination if DIR = 1 and the 
              memory source if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR = 1 and 
              the peripheral source if DIR = 0.
              0: disabled
              1: enabled
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CIRC</name>
              <description>
              circular mode
              0: disabled
              1: enabled
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DIR</name>
              <description>
              data transfer direction
              This bit must be set only in memory-to-peripheral and peripheral-to-memory modes.
              0: read from peripheral
                 Source attributes are defined by PSIZE and PINC, plus the CPARx register. This is still valid in a memory-to-memory mode.
                 Destination attributes are defined by MSIZE and MINC, plus the CM0ARx register. This is still valid in a peripheral-to-peripheral mode.
              1: read from memory
                 Destination attributes are defined by PSIZE and PINC, plus the CPARx register. This is still valid in a memory-to-memory mode.
                 Source attributes are defined by MSIZE and MINC, plus the CM0ARx register. This is still valid in a peripheral-to-peripheral mode.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIE</name>
              <description>
              transfer error interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HTIE</name>
              <description>
              half transfer interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIE</name>
              <description>
              transfer complete interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EN</name>
              <description>
              channel enable
              When a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the ISR register is cleared (by setting the CTEIFx bit of the IFCR register).
              0: disabled
              1: enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CNDTR8</name>
          <displayName>CNDTR8</displayName>
          <description></description>
          <addressOffset>0x98</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>NDT</name>
              <description>
              number of data to transfer (0 to 2^16 - 1)
              This field is updated by hardware when the channel is enabled:
                 It is decremented after each single DMA 'read followed by write' transfer, indicating the remaining amount of data items to transfer.
                 It is kept at zero when the programmed amount of data to transfer is reached, if the channel is not in circular mode (CIRC = 0 in the CCRx register).
                 It is reloaded automatically by the previously programmed value, when the transfer is complete, if the channel is in circular mode (CIRC = 1).
              If this field is zero, no transfer can be served whatever the channel status (enabled or not).
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CPAR8</name>
          <displayName>CPAR8</displayName>
          <description></description>
          <addressOffset>0x9c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>PA</name>
              <description>
              peripheral address
              It contains the base address of the peripheral data register from/to which the data will be read/written.
              In memory-to-memory mode, this register identifies the memory destination address if DIR = 1 and the memory source address if DIR = 0.
              In peripheral-to-peripheral mode, this register identifies the peripheral destination address DIR = 1 and the peripheral source address if DIR = 0.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0AR8</name>
          <displayName>CM0AR8</displayName>
          <description></description>
          <addressOffset>0xa0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>MA</name>
              <description>
              peripheral address
              It contains the base address of the memory from/to which the data will be read/written.
              In memory-to-memory mode, this register identifies the memory source address if DIR = 1 and the memory destination address if DIR = 0.
              In peripheral-to-peripheral mode, this register identifies the peripheral source address DIR = 1 and the peripheral destination address if DIR = 0.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CBSR8</name>
          <displayName>CBSR8</displayName>
          <description></description>
          <addressOffset>0xa4</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>BS</name>
              <description>
              burst size in non-m2m mode
              When BS>1, DMA will transfer for BS times for each request if left NDT is larger than BS, or else transfer for left NDT times.
              When BS=0 or 1, DMA will always do single transfer for each request.
              In memory-to-memory mode, BS is ignored.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CSELR1</name>
          <displayName>CSELR1</displayName>
          <description></description>
          <addressOffset>0xa8</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>C4S</name>
              <description>
              DMA channel 4 selection
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>C3S</name>
              <description>
              DMA channel 3 selection
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>C2S</name>
              <description>
              DMA channel 2 selection
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>C1S</name>
              <description>
              DMA channel 1 selection
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CSELR2</name>
          <displayName>CSELR2</displayName>
          <description></description>
          <addressOffset>0xac</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>C8S</name>
              <description>
              DMA channel 8 selection
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>C7S</name>
              <description>
              DMA channel 7 selection
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>C6S</name>
              <description>
              DMA channel 6 selection
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>C5S</name>
              <description>
              DMA channel 5 selection
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>HPSYS_PINMUX1</name>
      <description></description>
      <groupName>HPSYS_PINMUX</groupName>
      <baseAddress>0x40003000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>PAD_SIP00</name>
          <displayName>PAD_SIP00</displayName>
          <description></description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_SIP01</name>
          <displayName>PAD_SIP01</displayName>
          <description></description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_SIP02</name>
          <displayName>PAD_SIP02</displayName>
          <description></description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_SIP03</name>
          <displayName>PAD_SIP03</displayName>
          <description></description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_SIP04</name>
          <displayName>PAD_SIP04</displayName>
          <description></description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_SIP05</name>
          <displayName>PAD_SIP05</displayName>
          <description></description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_SIP06</name>
          <displayName>PAD_SIP06</displayName>
          <description></description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_SIP07</name>
          <displayName>PAD_SIP07</displayName>
          <description></description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_SIP08</name>
          <displayName>PAD_SIP08</displayName>
          <description></description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_SIP09</name>
          <displayName>PAD_SIP09</displayName>
          <description></description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_SIP10</name>
          <displayName>PAD_SIP10</displayName>
          <description></description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_SIP11</name>
          <displayName>PAD_SIP11</displayName>
          <description></description>
          <addressOffset>0x2c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_SIP12</name>
          <displayName>PAD_SIP12</displayName>
          <description></description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_SIP13</name>
          <displayName>PAD_SIP13</displayName>
          <description></description>
          <addressOffset>0x34</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_SIP14</name>
          <displayName>PAD_SIP14</displayName>
          <description></description>
          <addressOffset>0x38</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_SIP15</name>
          <displayName>PAD_SIP15</displayName>
          <description></description>
          <addressOffset>0x3c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_SIP16</name>
          <displayName>PAD_SIP16</displayName>
          <description></description>
          <addressOffset>0x40</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_SIP17</name>
          <displayName>PAD_SIP17</displayName>
          <description></description>
          <addressOffset>0x44</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_SIP18</name>
          <displayName>PAD_SIP18</displayName>
          <description></description>
          <addressOffset>0x48</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA00</name>
          <displayName>PAD_PA00</displayName>
          <description></description>
          <addressOffset>0x4c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA01</name>
          <displayName>PAD_PA01</displayName>
          <description></description>
          <addressOffset>0x50</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA02</name>
          <displayName>PAD_PA02</displayName>
          <description></description>
          <addressOffset>0x54</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA03</name>
          <displayName>PAD_PA03</displayName>
          <description></description>
          <addressOffset>0x58</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA04</name>
          <displayName>PAD_PA04</displayName>
          <description></description>
          <addressOffset>0x5c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA05</name>
          <displayName>PAD_PA05</displayName>
          <description></description>
          <addressOffset>0x60</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA06</name>
          <displayName>PAD_PA06</displayName>
          <description></description>
          <addressOffset>0x64</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA07</name>
          <displayName>PAD_PA07</displayName>
          <description></description>
          <addressOffset>0x68</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA08</name>
          <displayName>PAD_PA08</displayName>
          <description></description>
          <addressOffset>0x6c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA09</name>
          <displayName>PAD_PA09</displayName>
          <description></description>
          <addressOffset>0x70</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA10</name>
          <displayName>PAD_PA10</displayName>
          <description></description>
          <addressOffset>0x74</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS</name>
              <description>
              Drive select. Logic LOW selects 4mA drive, logic HIGH selects 20mA drive.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MODE</name>
              <description>
              Mode select. Logic LOW enables GPIO mode, logic HIGH enables I2C mode.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA11</name>
          <displayName>PAD_PA11</displayName>
          <description></description>
          <addressOffset>0x78</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA12</name>
          <displayName>PAD_PA12</displayName>
          <description></description>
          <addressOffset>0x7c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA13</name>
          <displayName>PAD_PA13</displayName>
          <description></description>
          <addressOffset>0x80</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA14</name>
          <displayName>PAD_PA14</displayName>
          <description></description>
          <addressOffset>0x84</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS</name>
              <description>
              Drive select. Logic LOW selects 4mA drive, logic HIGH selects 20mA drive.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MODE</name>
              <description>
              Mode select. Logic LOW enables GPIO mode, logic HIGH enables I2C mode.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA15</name>
          <displayName>PAD_PA15</displayName>
          <description></description>
          <addressOffset>0x88</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA16</name>
          <displayName>PAD_PA16</displayName>
          <description></description>
          <addressOffset>0x8c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA17</name>
          <displayName>PAD_PA17</displayName>
          <description></description>
          <addressOffset>0x90</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA18</name>
          <displayName>PAD_PA18</displayName>
          <description></description>
          <addressOffset>0x94</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA19</name>
          <displayName>PAD_PA19</displayName>
          <description></description>
          <addressOffset>0x98</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA20</name>
          <displayName>PAD_PA20</displayName>
          <description></description>
          <addressOffset>0x9c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA21</name>
          <displayName>PAD_PA21</displayName>
          <description></description>
          <addressOffset>0xa0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA22</name>
          <displayName>PAD_PA22</displayName>
          <description></description>
          <addressOffset>0xa4</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA23</name>
          <displayName>PAD_PA23</displayName>
          <description></description>
          <addressOffset>0xa8</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA24</name>
          <displayName>PAD_PA24</displayName>
          <description></description>
          <addressOffset>0xac</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA25</name>
          <displayName>PAD_PA25</displayName>
          <description></description>
          <addressOffset>0xb0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA26</name>
          <displayName>PAD_PA26</displayName>
          <description></description>
          <addressOffset>0xb4</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA27</name>
          <displayName>PAD_PA27</displayName>
          <description></description>
          <addressOffset>0xb8</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA28</name>
          <displayName>PAD_PA28</displayName>
          <description></description>
          <addressOffset>0xbc</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA29</name>
          <displayName>PAD_PA29</displayName>
          <description></description>
          <addressOffset>0xc0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA30</name>
          <displayName>PAD_PA30</displayName>
          <description></description>
          <addressOffset>0xc4</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA31</name>
          <displayName>PAD_PA31</displayName>
          <description></description>
          <addressOffset>0xc8</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA32</name>
          <displayName>PAD_PA32</displayName>
          <description></description>
          <addressOffset>0xcc</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA33</name>
          <displayName>PAD_PA33</displayName>
          <description></description>
          <addressOffset>0xd0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA34</name>
          <displayName>PAD_PA34</displayName>
          <description></description>
          <addressOffset>0xd4</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA35</name>
          <displayName>PAD_PA35</displayName>
          <description></description>
          <addressOffset>0xd8</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA36</name>
          <displayName>PAD_PA36</displayName>
          <description></description>
          <addressOffset>0xdc</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA37</name>
          <displayName>PAD_PA37</displayName>
          <description></description>
          <addressOffset>0xe0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA38</name>
          <displayName>PAD_PA38</displayName>
          <description></description>
          <addressOffset>0xe4</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA39</name>
          <displayName>PAD_PA39</displayName>
          <description></description>
          <addressOffset>0xe8</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA40</name>
          <displayName>PAD_PA40</displayName>
          <description></description>
          <addressOffset>0xec</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA41</name>
          <displayName>PAD_PA41</displayName>
          <description></description>
          <addressOffset>0xf0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA42</name>
          <displayName>PAD_PA42</displayName>
          <description></description>
          <addressOffset>0xf4</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA43</name>
          <displayName>PAD_PA43</displayName>
          <description></description>
          <addressOffset>0xf8</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA44</name>
          <displayName>PAD_PA44</displayName>
          <description></description>
          <addressOffset>0xfc</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA45</name>
          <displayName>PAD_PA45</displayName>
          <description></description>
          <addressOffset>0x100</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA46</name>
          <displayName>PAD_PA46</displayName>
          <description></description>
          <addressOffset>0x104</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA47</name>
          <displayName>PAD_PA47</displayName>
          <description></description>
          <addressOffset>0x108</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA48</name>
          <displayName>PAD_PA48</displayName>
          <description></description>
          <addressOffset>0x10c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA49</name>
          <displayName>PAD_PA49</displayName>
          <description></description>
          <addressOffset>0x110</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA50</name>
          <displayName>PAD_PA50</displayName>
          <description></description>
          <addressOffset>0x114</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA51</name>
          <displayName>PAD_PA51</displayName>
          <description></description>
          <addressOffset>0x118</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA52</name>
          <displayName>PAD_PA52</displayName>
          <description></description>
          <addressOffset>0x11c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA53</name>
          <displayName>PAD_PA53</displayName>
          <description></description>
          <addressOffset>0x120</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA54</name>
          <displayName>PAD_PA54</displayName>
          <description></description>
          <addressOffset>0x124</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA55</name>
          <displayName>PAD_PA55</displayName>
          <description></description>
          <addressOffset>0x128</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA56</name>
          <displayName>PAD_PA56</displayName>
          <description></description>
          <addressOffset>0x12c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA57</name>
          <displayName>PAD_PA57</displayName>
          <description></description>
          <addressOffset>0x130</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA58</name>
          <displayName>PAD_PA58</displayName>
          <description></description>
          <addressOffset>0x134</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA59</name>
          <displayName>PAD_PA59</displayName>
          <description></description>
          <addressOffset>0x138</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA60</name>
          <displayName>PAD_PA60</displayName>
          <description></description>
          <addressOffset>0x13c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA61</name>
          <displayName>PAD_PA61</displayName>
          <description></description>
          <addressOffset>0x140</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA62</name>
          <displayName>PAD_PA62</displayName>
          <description></description>
          <addressOffset>0x144</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA63</name>
          <displayName>PAD_PA63</displayName>
          <description></description>
          <addressOffset>0x148</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA64</name>
          <displayName>PAD_PA64</displayName>
          <description></description>
          <addressOffset>0x14c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA65</name>
          <displayName>PAD_PA65</displayName>
          <description></description>
          <addressOffset>0x150</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA66</name>
          <displayName>PAD_PA66</displayName>
          <description></description>
          <addressOffset>0x154</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA67</name>
          <displayName>PAD_PA67</displayName>
          <description></description>
          <addressOffset>0x158</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA68</name>
          <displayName>PAD_PA68</displayName>
          <description></description>
          <addressOffset>0x15c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA69</name>
          <displayName>PAD_PA69</displayName>
          <description></description>
          <addressOffset>0x160</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA70</name>
          <displayName>PAD_PA70</displayName>
          <description></description>
          <addressOffset>0x164</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA71</name>
          <displayName>PAD_PA71</displayName>
          <description></description>
          <addressOffset>0x168</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA72</name>
          <displayName>PAD_PA72</displayName>
          <description></description>
          <addressOffset>0x16c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA73</name>
          <displayName>PAD_PA73</displayName>
          <description></description>
          <addressOffset>0x170</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA74</name>
          <displayName>PAD_PA74</displayName>
          <description></description>
          <addressOffset>0x174</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA75</name>
          <displayName>PAD_PA75</displayName>
          <description></description>
          <addressOffset>0x178</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA76</name>
          <displayName>PAD_PA76</displayName>
          <description></description>
          <addressOffset>0x17c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA77</name>
          <displayName>PAD_PA77</displayName>
          <description></description>
          <addressOffset>0x180</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA78</name>
          <displayName>PAD_PA78</displayName>
          <description></description>
          <addressOffset>0x184</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA79</name>
          <displayName>PAD_PA79</displayName>
          <description></description>
          <addressOffset>0x188</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS</name>
              <description>
              Drive select. Logic LOW selects 4mA drive, logic HIGH selects 20mA drive.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MODE</name>
              <description>
              Mode select. Logic LOW enables GPIO mode, logic HIGH enables I2C mode.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA80</name>
          <displayName>PAD_PA80</displayName>
          <description></description>
          <addressOffset>0x18c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS</name>
              <description>
              Drive select. Logic LOW selects 4mA drive, logic HIGH selects 20mA drive.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MODE</name>
              <description>
              Mode select. Logic LOW enables GPIO mode, logic HIGH enables I2C mode.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>USART1</name>
      <description></description>
      <groupName>USART</groupName>
      <baseAddress>0x40004000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CR1</name>
          <displayName>CR1</displayName>
          <description>Control Register 1</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>M</name>
              <description>
              Mode bit indicates the length of the packet, including data bits and parity. Stop bits not included.
              0: 6 bits (e.g. 6 data bits + no parity bit)
              1: 7 bits (e.g. 6 data bits + 1 parity bit)
              2: 8 bits (e.g. 7 data bits + 1 parity bit, or 6 data bits + 2 parity bits)
              3: 9 bits (e.g. 8 data bits + 1 parity bit, or 7 data bits + 2 parity bits)
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>RSVD5</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>OVER8</name>
              <description>
              Oversampling mode
              0: Oversampling by 16
              1: Oversampling by 8
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD6</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD7</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD8</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PCE</name>
              <description>
              Parity check enable. If enabled, parity bit is inserted at the MSB position 
              0: parity check disabled
              1: parity check enabled
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Parity select
              0: even parity
              1: odd parity
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PEIE</name>
              <description>
              Parity error interrupt enable
              0: interrupt disabled
              1: interrupt is generated whenever PE=1 in the ISR register
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TXEIE</name>
              <description>
              Tx empty interrupt enable
              0: interrupt disabled
              1: interrupt is generated whenver TXE=1 in the ISR register
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIE</name>
              <description>
              Transfer compelete interrupt enable
              0: interrupt disabled
              1: interrupt is generated whenever TC=1 in the ISR register
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RXNEIE</name>
              <description>
              Rx not empty interrupt enable
              0: interrupt disabled
              1: interrupt is generated whenever RXNE=1 in the ISR register
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IDLEIE</name>
              <description>
              Idle line interrupt enable
              0: interrupt disabled
              1: interrupt is generated whenever IDLE=1 in the ISR  register
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TE</name>
              <description>
              Transmitter enable
              0: transmitter is disabled
              1: transmitter is enabled
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RE</name>
              <description>
              Receiver enable
              0: receiver is disabled
              1: receiver is enabled
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD9</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UE</name>
              <description>
              USART enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CR2</name>
          <displayName>CR2</displayName>
          <description>Control Register 2</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD5</name>
              <description>
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD6</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD7</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD8</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD9</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD10</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>STOP</name>
              <description>
              Stop bits
              0/1: 1 stop bit
              2/3: 2 stop bits
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD11</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD12</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD13</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD14</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD15</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD16</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD17</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD18</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD19</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CR3</name>
          <displayName>CR3</displayName>
          <description>Control Register 3</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD5</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD6</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD7</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD8</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD9</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD10</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OVRDIS</name>
              <description>
              Overrun disable
              0: overrun error flag (ORE) will be set if new data received but previous data not read. New data will not overwrite the content in RDR register.
              1: overrun disabled. If new data is received before previous data is read, the new data will overwrite the content in RDR register and ORE flag remains unset.
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ONEBIT</name>
              <description>
              One bit sampling mode
              0: 3-bit sampling mode, the sampling value is determined by the voted result out of 3 bits
              1: 1-bit sampling mode
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTSIE</name>
              <description>
              CTS interrupt enable
              0: interrupt disabled
              1: interrupt is generated whenever CTSIF=1 in the ISR register
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTSE</name>
              <description>
              CTS enable
              0: CTS hardware flow control disabled
              1: CTS hardware flow control enabled, data is transmitted only when CTS input is asserted low
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RTSE</name>
              <description>
              RTS enable
              0: RTS hardware flow control disabled
              1: RTS hardware flow control enabled, RTS output is asserted low when new data can be received
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMAT</name>
              <description>
              Transmitter DMA enable
              0: DMA mode disabled for transmission
              1: DMA mode enabled for transmission
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMAR</name>
              <description>
              Receiver DMA enable
              0: DMA mode disabled for reception
              1: DMA mode enabled for reception
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD11</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD12</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD13</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD14</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD15</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EIE</name>
              <description>
              Error interrupt enable
              0: interrupt disabled
              1: interrupt is generated whenever FE=1 or ORE=1 or NF=1 in the ISR register
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BRR</name>
          <displayName>BRR</displayName>
          <description>Baud Rate Register</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>INT</name>
              <description>
              Integer part of baud rate prescaler
              If OVER8 = 0, Baud Rate = 48000000 / (INT + FRAC/16) / 16
              If OVER8 = 1, Baud Rate = 48000000 / (INT + FRAC/16) / 8
              For example:
              OVER=0, INT=3, FRAC=0, Baud Rate = 48000000/(3+0)/16 = 1Mbps
              OVER=0, INT=3, FRAC=4, Baud Rate = 48000000/(3+4/16)/16 = 923077 = 921600 + 1.6
              OVER=1, INT=52, FRAC=1, Baud Rate = 48000000/(52+1/16)/8 = 115246 = 115200 + 0.4
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
            <field>
              <name>FRAC</name>
              <description>
              Fractional part of baud rate prescaler
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD1</name>
          <displayName>RSVD1</displayName>
          <description></description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>RQR</name>
          <displayName>RQR</displayName>
          <description>Request Register</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>27</bitWidth>
            </field>
            <field>
              <name>TXFRQ</name>
              <description>
              Tx data flush request Reserved-Do not modify
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RXFRQ</name>
              <description>
              Rx data flush request. Write 1 to clear the RXNE flag and discard the current data in RDR
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ISR</name>
          <displayName>ISR</displayName>
          <description>Interrupt and Status Register</description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x020000C0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD5</name>
              <description>
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD6</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD7</name>
              <description>
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD8</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD9</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD10</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD11</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD12</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD13</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD14</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD15</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTS</name>
              <description>
              CTS input. Read this bit to get the raw status of the CTS line.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTSIF</name>
              <description>
              CTS interrupt flag. This bit is set by hardware whenever CTS input toggles.
              0: no change on the CTS line
              1: there is a change on the CTS line
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD16</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TXE</name>
              <description>
              Tx data empty
              0: data is ready in TDR
              1: data is already transferred to shift register, i.e. transmission is in progress or complete
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TC</name>
              <description>
              transmission complete. This bit is set by hardware if the transmission is complete
              0: transmission is not complete
              1: transmission is complete
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RXNE</name>
              <description>
              Rx data not empty. This bit is set by hardware when the received data is transferred into RDR register.
              0: data is not received
              1: data is ready in RDR to be read
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IDLE</name>
              <description>
              Idle line detected
              0: no idle line is detected
              1: idle line is detected
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ORE</name>
              <description>
              Overrun error. When new data is received but Rx buffer is not empty (i.e. previous data is not read yet), ORE is asserted and current RDR content is not lost. This feature can be disabled by set CR3_OVRDIS to 1.
              0: no overrun error
              1: overrun error is detected
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>NF</name>
              <description>
              Noise flag. Noise means the samping values in the 3-bit sampling mode are not the same.
              0: no noise is detected
              1: noise is detected
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FE</name>
              <description>
              Framing error. This bit is set by hardware when stop bit is not correctly received
              0: no framing error is detected
              1: framing error is detected
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Parity error. This bit is set when a parity error is detected in the received packet.
              0: no parity error
              1: parity error detected
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ICR</name>
          <displayName>ICR</displayName>
          <description>Interrupt flag Clear Register</description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD5</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>RSVD6</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD7</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD8</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTSCF</name>
              <description>
              CTS clear flag. Writing 1 to this bit clears the CTSIF flag in the ISR register.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD9</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD10</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCCF</name>
              <description>
              Transmission complete clear flag. Writing 1 to this bit clears the TC flag in the ISR register.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD11</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IDLECF</name>
              <description>
              Idle line detected clear flag. Writing 1 to this bit clears the IDLECF flag in the ISR register.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ORECF</name>
              <description>
              Overrun error clear flag. Writing 1 to this bit clears the ORE flag in the ISR register.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>NCF</name>
              <description>
              Noise detected clear flag. Writing 1 to this bit clears the NF flag in the ISR register.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FECF</name>
              <description>
              Framing error clear flag. Writing 1 to this bit clears the FE flag in the ISR register.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PECF</name>
              <description>
              Parity error clear flag. Wriring 1 to this bit clears the PE flag in the ISR register.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RDR</name>
          <displayName>RDR</displayName>
          <description>Receive Data Register</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>RDR</name>
              <description>
              Received data
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TDR</name>
          <displayName>TDR</displayName>
          <description>Transmit Data Register</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>TDR</name>
              <description>
              Transmit data
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>MISCR</name>
          <displayName>MISCR</displayName>
          <description>Miscellaneous Register</description>
          <addressOffset>0x2c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>RTSBIT</name>
              <description>
              assert RTS ahead of the frame completion (in number of bits) Reserved-Do not modify
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>SMPLINI</name>
              <description>
              initial sample count, count down from this value to zero to reach the middle of the start bit in Rx Reserved-Do not modify
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>USART2</name>
      <description></description>
      <groupName>USART</groupName>
      <baseAddress>0x40005000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CR1</name>
          <displayName>CR1</displayName>
          <description>Control Register 1</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>M</name>
              <description>
              Mode bit indicates the length of the packet, including data bits and parity. Stop bits not included.
              0: 6 bits (e.g. 6 data bits + no parity bit)
              1: 7 bits (e.g. 6 data bits + 1 parity bit)
              2: 8 bits (e.g. 7 data bits + 1 parity bit, or 6 data bits + 2 parity bits)
              3: 9 bits (e.g. 8 data bits + 1 parity bit, or 7 data bits + 2 parity bits)
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>RSVD5</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>OVER8</name>
              <description>
              Oversampling mode
              0: Oversampling by 16
              1: Oversampling by 8
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD6</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD7</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD8</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PCE</name>
              <description>
              Parity check enable. If enabled, parity bit is inserted at the MSB position 
              0: parity check disabled
              1: parity check enabled
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Parity select
              0: even parity
              1: odd parity
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PEIE</name>
              <description>
              Parity error interrupt enable
              0: interrupt disabled
              1: interrupt is generated whenever PE=1 in the ISR register
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TXEIE</name>
              <description>
              Tx empty interrupt enable
              0: interrupt disabled
              1: interrupt is generated whenver TXE=1 in the ISR register
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIE</name>
              <description>
              Transfer compelete interrupt enable
              0: interrupt disabled
              1: interrupt is generated whenever TC=1 in the ISR register
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RXNEIE</name>
              <description>
              Rx not empty interrupt enable
              0: interrupt disabled
              1: interrupt is generated whenever RXNE=1 in the ISR register
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IDLEIE</name>
              <description>
              Idle line interrupt enable
              0: interrupt disabled
              1: interrupt is generated whenever IDLE=1 in the ISR  register
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TE</name>
              <description>
              Transmitter enable
              0: transmitter is disabled
              1: transmitter is enabled
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RE</name>
              <description>
              Receiver enable
              0: receiver is disabled
              1: receiver is enabled
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD9</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UE</name>
              <description>
              USART enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CR2</name>
          <displayName>CR2</displayName>
          <description>Control Register 2</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD5</name>
              <description>
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD6</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD7</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD8</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD9</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD10</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>STOP</name>
              <description>
              Stop bits
              0/1: 1 stop bit
              2/3: 2 stop bits
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD11</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD12</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD13</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD14</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD15</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD16</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD17</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD18</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD19</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CR3</name>
          <displayName>CR3</displayName>
          <description>Control Register 3</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD5</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD6</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD7</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD8</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD9</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD10</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OVRDIS</name>
              <description>
              Overrun disable
              0: overrun error flag (ORE) will be set if new data received but previous data not read. New data will not overwrite the content in RDR register.
              1: overrun disabled. If new data is received before previous data is read, the new data will overwrite the content in RDR register and ORE flag remains unset.
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ONEBIT</name>
              <description>
              One bit sampling mode
              0: 3-bit sampling mode, the sampling value is determined by the voted result out of 3 bits
              1: 1-bit sampling mode
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTSIE</name>
              <description>
              CTS interrupt enable
              0: interrupt disabled
              1: interrupt is generated whenever CTSIF=1 in the ISR register
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTSE</name>
              <description>
              CTS enable
              0: CTS hardware flow control disabled
              1: CTS hardware flow control enabled, data is transmitted only when CTS input is asserted low
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RTSE</name>
              <description>
              RTS enable
              0: RTS hardware flow control disabled
              1: RTS hardware flow control enabled, RTS output is asserted low when new data can be received
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMAT</name>
              <description>
              Transmitter DMA enable
              0: DMA mode disabled for transmission
              1: DMA mode enabled for transmission
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMAR</name>
              <description>
              Receiver DMA enable
              0: DMA mode disabled for reception
              1: DMA mode enabled for reception
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD11</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD12</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD13</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD14</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD15</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EIE</name>
              <description>
              Error interrupt enable
              0: interrupt disabled
              1: interrupt is generated whenever FE=1 or ORE=1 or NF=1 in the ISR register
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BRR</name>
          <displayName>BRR</displayName>
          <description>Baud Rate Register</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>INT</name>
              <description>
              Integer part of baud rate prescaler
              If OVER8 = 0, Baud Rate = 48000000 / (INT + FRAC/16) / 16
              If OVER8 = 1, Baud Rate = 48000000 / (INT + FRAC/16) / 8
              For example:
              OVER=0, INT=3, FRAC=0, Baud Rate = 48000000/(3+0)/16 = 1Mbps
              OVER=0, INT=3, FRAC=4, Baud Rate = 48000000/(3+4/16)/16 = 923077 = 921600 + 1.6
              OVER=1, INT=52, FRAC=1, Baud Rate = 48000000/(52+1/16)/8 = 115246 = 115200 + 0.4
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
            <field>
              <name>FRAC</name>
              <description>
              Fractional part of baud rate prescaler
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD1</name>
          <displayName>RSVD1</displayName>
          <description></description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>RQR</name>
          <displayName>RQR</displayName>
          <description>Request Register</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>27</bitWidth>
            </field>
            <field>
              <name>TXFRQ</name>
              <description>
              Tx data flush request Reserved-Do not modify
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RXFRQ</name>
              <description>
              Rx data flush request. Write 1 to clear the RXNE flag and discard the current data in RDR
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ISR</name>
          <displayName>ISR</displayName>
          <description>Interrupt and Status Register</description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x020000C0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD5</name>
              <description>
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD6</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD7</name>
              <description>
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD8</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD9</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD10</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD11</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD12</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD13</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD14</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD15</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTS</name>
              <description>
              CTS input. Read this bit to get the raw status of the CTS line.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTSIF</name>
              <description>
              CTS interrupt flag. This bit is set by hardware whenever CTS input toggles.
              0: no change on the CTS line
              1: there is a change on the CTS line
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD16</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TXE</name>
              <description>
              Tx data empty
              0: data is ready in TDR
              1: data is already transferred to shift register, i.e. transmission is in progress or complete
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TC</name>
              <description>
              transmission complete. This bit is set by hardware if the transmission is complete
              0: transmission is not complete
              1: transmission is complete
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RXNE</name>
              <description>
              Rx data not empty. This bit is set by hardware when the received data is transferred into RDR register.
              0: data is not received
              1: data is ready in RDR to be read
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IDLE</name>
              <description>
              Idle line detected
              0: no idle line is detected
              1: idle line is detected
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ORE</name>
              <description>
              Overrun error. When new data is received but Rx buffer is not empty (i.e. previous data is not read yet), ORE is asserted and current RDR content is not lost. This feature can be disabled by set CR3_OVRDIS to 1.
              0: no overrun error
              1: overrun error is detected
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>NF</name>
              <description>
              Noise flag. Noise means the samping values in the 3-bit sampling mode are not the same.
              0: no noise is detected
              1: noise is detected
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FE</name>
              <description>
              Framing error. This bit is set by hardware when stop bit is not correctly received
              0: no framing error is detected
              1: framing error is detected
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Parity error. This bit is set when a parity error is detected in the received packet.
              0: no parity error
              1: parity error detected
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ICR</name>
          <displayName>ICR</displayName>
          <description>Interrupt flag Clear Register</description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD5</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>RSVD6</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD7</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD8</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTSCF</name>
              <description>
              CTS clear flag. Writing 1 to this bit clears the CTSIF flag in the ISR register.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD9</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD10</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCCF</name>
              <description>
              Transmission complete clear flag. Writing 1 to this bit clears the TC flag in the ISR register.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD11</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IDLECF</name>
              <description>
              Idle line detected clear flag. Writing 1 to this bit clears the IDLECF flag in the ISR register.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ORECF</name>
              <description>
              Overrun error clear flag. Writing 1 to this bit clears the ORE flag in the ISR register.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>NCF</name>
              <description>
              Noise detected clear flag. Writing 1 to this bit clears the NF flag in the ISR register.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FECF</name>
              <description>
              Framing error clear flag. Writing 1 to this bit clears the FE flag in the ISR register.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PECF</name>
              <description>
              Parity error clear flag. Wriring 1 to this bit clears the PE flag in the ISR register.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RDR</name>
          <displayName>RDR</displayName>
          <description>Receive Data Register</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>RDR</name>
              <description>
              Received data
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TDR</name>
          <displayName>TDR</displayName>
          <description>Transmit Data Register</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>TDR</name>
              <description>
              Transmit data
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>MISCR</name>
          <displayName>MISCR</displayName>
          <description>Miscellaneous Register</description>
          <addressOffset>0x2c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>RTSBIT</name>
              <description>
              assert RTS ahead of the frame completion (in number of bits) Reserved-Do not modify
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>SMPLINI</name>
              <description>
              initial sample count, count down from this value to zero to reach the middle of the start bit in Rx Reserved-Do not modify
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>EZIP</name>
      <description></description>
      <groupName>EZIP</groupName>
      <baseAddress>0x40006000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>EZIP_CTRL</name>
          <displayName>EZIP_CTRL</displayName>
          <description>ezip decoder ctrl</description>
          <addressOffset>0x000</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>31</bitWidth>
            </field>
            <field>
              <name>EZIP_CTRL</name>
              <description>
              1:start and run
              0:end
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SRC_ADDR</name>
          <displayName>SRC_ADDR</displayName>
          <description>ezip decoder source address</description>
          <addressOffset>0x004</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>SRC_ADDR</name>
              <description>
              ezip decoder source address
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DST_ADDR</name>
          <displayName>DST_ADDR</displayName>
          <description>ezip decoder destination address</description>
          <addressOffset>0x008</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DST_ADDR</name>
              <description>
              ezip decoder destination address(ahb_out mode)
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>EZIP_PARA</name>
          <displayName>EZIP_PARA</displayName>
          <description>ezip decoder  parameter</description>
          <addressOffset>0x00c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>26</bitWidth>
            </field>
            <field>
              <name>SPI_SEL</name>
              <description>
              0:QSPI3
              1:QSPI2
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IN_SEL</name>
              <description>
              don't support ezip type2\type4. 
              0:ahb
              1:fifo
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CACHE_EN</name>
              <description>
              ezip index cache enable(only support ezip_type=4)
              0:disable
              1:enable
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MOD_SEL</name>
              <description>
              0:ezip
              1:gzip
              2:Lz4
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>OUT_SEL</name>
              <description>
              only used in ezip decoder mode. must select ahb in gzip/lz4 decoder mode.
              0:epic
              1:ahb
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CACHE_CLR</name>
          <displayName>CACHE_CLR</displayName>
          <description>ezd index cache clear</description>
          <addressOffset>0x010</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>31</bitWidth>
            </field>
            <field>
              <name>CACHE_CLR</name>
              <description>
              ezd index cache clear
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>START_POINT</name>
          <displayName>START_POINT</displayName>
          <description>ezip decoder start point</description>
          <addressOffset>0x014</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>START_COL</name>
              <description>
              ezd start col,count from 0
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>START_ROW</name>
              <description>
              ezd start row,count from 0
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>END_POINT</name>
          <displayName>END_POINT</displayName>
          <description>ezip decoder end point</description>
          <addressOffset>0x018</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>END_COL</name>
              <description>
              ezd end col
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>END_ROW</name>
              <description>
              ezd end row
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ROW_SIGN</name>
          <displayName>ROW_SIGN</displayName>
          <description>ezip decoder row sign</description>
          <addressOffset>0x01c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>ROW_SIGN</name>
              <description>
              arrived row sign,ezd can generate a interrupt
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>INT_EN</name>
          <displayName>INT_EN</displayName>
          <description>ezip decoder _int_en</description>
          <addressOffset>0x020</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>27</bitWidth>
            </field>
            <field>
              <name>ETYPE_ERR_EN</name>
              <description>
              ezip_type_err_en
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BTYPE_ERR_EN</name>
              <description>
              btype_err_en
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ROW_ERR_EN</name>
              <description>
              row_err_en
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ROW_INT_EN</name>
              <description>
              row_int_en
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>END_INT_EN</name>
              <description>
              ezd_end _int_en
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>INT_STA</name>
          <displayName>INT_STA</displayName>
          <description>ezip decoder _int_sta</description>
          <addressOffset>0x024</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>27</bitWidth>
            </field>
            <field>
              <name>ETYPE_ERR_STA</name>
              <description>
              ezip_type_err_sta
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BTYPE_ERR_STA</name>
              <description>
              btype_err_sta
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ROW_ERR_STA</name>
              <description>
              overflow height sta
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ROW_INT_STA</name>
              <description>
              arrive row sign sta
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>END_INT_STA</name>
              <description>
              ezd_end _int_sta
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>INT_MASK</name>
          <displayName>INT_MASK</displayName>
          <description>ezip decoder int mask state</description>
          <addressOffset>0x028</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>27</bitWidth>
            </field>
            <field>
              <name>ETYPE_ERR_MASK</name>
              <description>
              ezip_type_err_mask sta
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BTYPE_ERR_MASK</name>
              <description>
              btype_err_mask sta
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ROW_ERR_MASK</name>
              <description>
              overflow height mask sta
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ROW_INT_MASK</name>
              <description>
              arrive row sign mask sta
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>END_INT_MASK</name>
              <description>
              ezd_end _int mask sta
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>NAP_PARA</name>
          <displayName>NAP_PARA</displayName>
          <description>ezip decoder release bus parameter</description>
          <addressOffset>0x02c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>BURST_NUM</name>
              <description>
              ezip decoder burst number
              0000: 16
              0001: 32 
              0010: 64 
              0100: 128 
              1000: 256 
              other: 16
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>NAP_TIM</name>
              <description>
              ezip decoder release bus time
              0000: not nap
              0001: 16 cycle
              0010: 32 cycle
              0100: 64 cycle
              1000: 128 cycle
              other: not nap
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DB_SEL</name>
          <displayName>DB_SEL</displayName>
          <description>ezip decoder debug sel</description>
          <addressOffset>0x030</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>DB_SEL</name>
              <description>
              bit[15] 0:line_first                 1:out_buf_en[1]
              bit[14] 0:rd_head3                1:out_buf_en[0]
              bit[13] 0:rd_head2                1:inbuf_empty
              bit[12] 0:rd_heas1                 1:inbuf_half_empty
              bit[11] 0:blk_restart              1: inbuf_full
              bit[10] 0:ezd_buf_end        1:ezd_pixel_end
              bit[9]   0:ezd_buf_full           1:0
              bit[8]   0:ezd_buf_empty      1:0
              bit[7]   0:dec_buf_empty         1:0
              bit[6]   0:dec_buf_full               1:para_ok
              bit[5]   0:dec_on         1:ezd_fuf_push
              bit[4]   0:ind3_on       1:copy_on
              bit[3]   0:ind2_on       1:bypass_on
              bit[2]   0:ind1_on       1:blk_clr
              bit[1]   0:ezd_on       1:para_val
              bit[0]   0:ezd_int      1:para_req
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DB_DATA0</name>
          <displayName>DB_DATA0</displayName>
          <description>ezip decoder debug data0</description>
          <addressOffset>0x034</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DB_DATA0</name>
              <description>
              bit[31:24]  bit_depth
              bit[23:16] color_type
              bit[15:0] block number
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DB_DATA1</name>
          <displayName>DB_DATA1</displayName>
          <description>ezip decoder debug data1</description>
          <addressOffset>0x038</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DB_DATA1</name>
              <description>
              bit[31:16] width
              bit[15:0] height
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DB_DATA2</name>
          <displayName>DB_DATA2</displayName>
          <description>ezip decoder debug data2</description>
          <addressOffset>0x03c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DB_DATA2</name>
              <description>
              bit[31:0] total_len
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DB_DATA3</name>
          <displayName>DB_DATA3</displayName>
          <description>ezip decoder debug data3</description>
          <addressOffset>0x040</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DB_DATA3</name>
              <description>
              bit[31:24] ezip_type
              bit[23:20] bfinal
              bit[19:16] btype
              bit[11:8] ahb_state
              bit[7:4] ctrl_state
              bir[3:0] build_stste
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DB_DATA4</name>
          <displayName>DB_DATA4</displayName>
          <description>ezip decoder debug data4</description>
          <addressOffset>0x044</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DB_DATA4</name>
              <description>
              bit[9]:ezd_buf_full
              bit[8]:ezd_buf_empty
              bit[7]:dec_buf_full
              bit[6]:dec_buf_empty
              bit[5]:bypass_on
              bit[4]:dec_on
              bit[3]:ind3_on
              bit[2]:ind2_on
              bit[1]:ind1_on
              bit[0]:ezd_on
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DB_DATA5</name>
          <displayName>DB_DATA5</displayName>
          <description>ezip decoder debug data5</description>
          <addressOffset>0x048</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DB_DATA5</name>
              <description>
              bit[31:16] width_cur
              bit[15:0] height_cur
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SRC_LEN</name>
          <displayName>SRC_LEN</displayName>
          <description>ezip source data length</description>
          <addressOffset>0x04c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>SRC_LEN</name>
              <description>
              source data length only in source data fifo mode
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>EPIC</name>
      <description></description>
      <groupName>EPIC</groupName>
      <baseAddress>0x40007000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>COMMAND</name>
          <displayName>COMMAND</displayName>
          <description></description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>30</bitWidth>
            </field>
            <field>
              <name>RESET</name>
              <description>
              1: reset the whole graphics   0: release the reset
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>START</name>
              <description>
              write 1 to trigger the lcd interface block
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS</name>
          <displayName>STATUS</displayName>
          <description></description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>27</bitWidth>
            </field>
            <field>
              <name>LCD_BUSY</name>
              <description>
              LCD controll busy flag
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>IA_BUSY</name>
              <description>
              Graphics accelerator busy flag
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>EOF_IRQ</name>
          <displayName>EOF_IRQ</displayName>
          <description></description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>14</bitWidth>
            </field>
            <field>
              <name>LINE_HIT_STATUS</name>
              <description>
              raw status of line hit interrupt
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IRQ_STATUS</name>
              <description>
              raw status of end of frame interrupt
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>14</bitWidth>
            </field>
            <field>
              <name>LINE_HIT_CAUSE</name>
              <description>
              line hit interrupt, can be masked by LINE_IRQ_MASK
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IRQ_CAUSE</name>
              <description>
              end of frame interrupt, can be masked by EOF_IRQ_MASK
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SETTING</name>
          <displayName>SETTING</displayName>
          <description></description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>LINE_IRQ_NUM</name>
              <description>
              canvas line hit interrupt line number
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>13</bitWidth>
            </field>
            <field>
              <name>AUTO_GATE_EN</name>
              <description>
              auto clock gating enable
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LINE_IRQ_MASK</name>
              <description>
              canvas line hit interrupt mask, 0: mask the interrupt
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EOF_IRQ_MASK</name>
              <description>
              end of frame interrupt mask, 0: mask the interrupt
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CANVAS_TL_POS</name>
          <displayName>CANVAS_TL_POS</displayName>
          <description>Top-Left pixel coordinate</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>Y0</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>X0</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CANVAS_BR_POS</name>
          <displayName>CANVAS_BR_POS</displayName>
          <description>Bottom-Right pixel coordinate</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>Y1</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>X1</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CANVAS_BG</name>
          <displayName>CANVAS_BG</displayName>
          <description>Background color</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
            <field>
              <name>BG_BLENDING_BYPASS</name>
              <description>
              if this bit is set, the layer is not blending with background. The alpha value will be reserved to output.
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RED</name>
              <description>
              Red color
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>GREEN</name>
              <description>
              green color
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>BLUE</name>
              <description>
              blue color
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>VL_CFG</name>
          <displayName>VL_CFG</displayName>
          <description></description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EZIP_EN</name>
              <description>
              enable EZIP. EZIP can only be enable for one layer, the order is VL > L0 > L1 > L2
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ALPHA_BLEND</name>
              <description>
              set 1 to enable alpha blending mode. Use layer alpha as blending factor for ARGB8888 and ARGB8565 image.
              Alpha_out = Layer_alpha * Image_alpha
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ACTIVE</name>
              <description>
              layer active flag
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PREFETCH_EN</name>
              <description>
              preload 64 bytes extra data when reading pixel from memory
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>WIDTH</name>
              <description>
              source image width(including padding), unit is bytes
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>13</bitWidth>
            </field>
            <field>
              <name>FILTER_EN</name>
              <description>
              layer color filter enable
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BLEND_DEPTH</name>
              <description>
              video layer blending depth
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>ALPHA</name>
              <description>
              layer alpha value
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>ALPHA_SEL</name>
              <description>
              alpha selection
              1'b0: select alpha according to image format
              1'b1: select layer alpha
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FORMAT</name>
              <description>
              video layer input format
              2'h0: RGB565
              2'h1: RGB888
              2'h2: ARGB8888
              2'h3: ARGB8565
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>VL_TL_POS</name>
          <displayName>VL_TL_POS</displayName>
          <description></description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>Y0</name>
              <description>
              Coordingate Y-value
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>X0</name>
              <description>
              Coordinate X-value
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>VL_BR_POS</name>
          <displayName>VL_BR_POS</displayName>
          <description></description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>Y1</name>
              <description>
              Coordingate Y-value
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>X1</name>
              <description>
              Coordinate X-value
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>VL_EXTENTS</name>
          <displayName>VL_EXTENTS</displayName>
          <description></description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>MAX_COL</name>
              <description>
              number of pixels of each line of source image(not including padding)
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>MAX_LINE</name>
              <description>
              number of pixels of each column of source image(not including padding)
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>VL_FILTER</name>
          <displayName>VL_FILTER</displayName>
          <description></description>
          <addressOffset>0x2c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>FILTER_MASK</name>
              <description>
              layer color filter mask
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>FILTER_R</name>
              <description>
              filter r color
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>FILTER_G</name>
              <description>
              filter g color
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>FILTER_B</name>
              <description>
              filter b color
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>VL_SRC</name>
          <displayName>VL_SRC</displayName>
          <description></description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ADDR</name>
              <description>
              source image RGB data address[31:0]. For RGB565 format, address should be aligned to halfword. For ARGB8888 format, address should be aligned to word.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>VL_ROT</name>
          <displayName>VL_ROT</displayName>
          <description></description>
          <addressOffset>0x34</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>CALC_REQ</name>
              <description>
              rot_max_col and rot_max_line calculation request. Write 1 to trigger the calculation.
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CALC_CLR</name>
              <description>
              rot_max_col and rot_max_line calculation clear request. Write 1 to clear the result.
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ROT_DEG</name>
              <description>
              rotation degree, rotation is clockwise.
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
            <field>
              <name>CALC_DONE</name>
              <description>
              calculation done indicator
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ROT_MAX_COL</name>
              <description>
              max column of rotated image
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
            <field>
              <name>ROT_MAX_LINE</name>
              <description>
              max line of rotated image
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>VL_SCALE_RATIO</name>
          <displayName>VL_SCALE_RATIO</displayName>
          <description></description>
          <addressOffset>0x38</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>YPITCH</name>
              <description>
              x-axis rescaling ratio, 3.8 fixed point number, YPITCH &lt; MAX_LINE/(Y1-Y0)
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>XPITCH</name>
              <description>
              y-axis rescaling ration, 3.8 fixed point number, XPITCH &lt; MAX_COL/(X1-X0)
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>VL_MISC_CFG</name>
          <displayName>VL_MISC_CFG</displayName>
          <description></description>
          <addressOffset>0x3c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>DEG_FORCE</name>
              <description>
              force epic use external sin and cos value, quadrant is still calculated from ROT_DEG.
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SIN_FORCE_VALUE</name>
              <description>
              external absolute value of sin. U13.12 format.
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>13</bitWidth>
            </field>
            <field>
              <name>COS_FORCE_VALUE</name>
              <description>
              external absolute value of cos. U13.12 format.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>13</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MIRROR</name>
              <description>
              mirror enable
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>L0_CFG</name>
          <displayName>L0_CFG</displayName>
          <description></description>
          <addressOffset>0x40</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EZIP_EN</name>
              <description>
              enable EZIP. EZIP can only be enable for one layer, the order is VL > L0 > L1 > L2
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ALPHA_BLEND</name>
              <description>
              set 1 to enable alpha blending mode. Use layer alpha as blending factor for ARGB8888 and ARGB8565 image.
              Alpha_out = Layer_alpha * Image_alpha
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ACTIVE</name>
              <description>
              layer active flag
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PREFETCH_EN</name>
              <description>
              preload 64 bytes extra data when reading pixel from memory
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>WIDTH</name>
              <description>
              source image width(including padding), unit is bytes
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>13</bitWidth>
            </field>
            <field>
              <name>FILTER_EN</name>
              <description>
              layer color filter enable
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>ALPHA</name>
              <description>
              layer alpha value
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>ALPHA_SEL</name>
              <description>
              alpha selection
              1'b0: select alpha according to image format
              1'b1: select layer alpha
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FORMAT</name>
              <description>
              video layer input format
              2'h0: RGB565
              2'h1: RGB888
              2'h2: ARGB8888
              2'h3: ARGB8565
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>L0_TL_POS</name>
          <displayName>L0_TL_POS</displayName>
          <description></description>
          <addressOffset>0x44</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>Y0</name>
              <description>
              Coordingate Y-value
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>X0</name>
              <description>
              Coordinate X-value
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>L0_BR_POS</name>
          <displayName>L0_BR_POS</displayName>
          <description></description>
          <addressOffset>0x48</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>Y1</name>
              <description>
              Coordingate Y-value
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>X1</name>
              <description>
              Coordinate X-value
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>L0_FILTER</name>
          <displayName>L0_FILTER</displayName>
          <description></description>
          <addressOffset>0x4c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>FILTER_MASK</name>
              <description>
              layer color filter mask
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>FILTER_R</name>
              <description>
              filter r color
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>FILTER_G</name>
              <description>
              filter g color
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>FILTER_B</name>
              <description>
              filter b color
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>L0_SRC</name>
          <displayName>L0_SRC</displayName>
          <description></description>
          <addressOffset>0x50</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ADDR</name>
              <description>
              source image RGB data address[31:0]. For RGB565 format, address should be aligned to halfword. For ARGB8888 format, address should be aligned to word.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>L1_CFG</name>
          <displayName>L1_CFG</displayName>
          <description></description>
          <addressOffset>0x54</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EZIP_EN</name>
              <description>
              enable EZIP. EZIP can only be enable for one layer, the order is VL > L0 > L1 > L2
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ALPHA_BLEND</name>
              <description>
              set 1 to enable alpha blending mode. Use layer alpha as blending factor for ARGB8888 and ARGB8565 image.
              Alpha_out = Layer_alpha * Image_alpha
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ACTIVE</name>
              <description>
              layer active flag
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PREFETCH_EN</name>
              <description>
              preload 64 bytes extra data when reading pixel from memory
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>WIDTH</name>
              <description>
              source image width(including padding), unit is bytes
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>13</bitWidth>
            </field>
            <field>
              <name>FILTER_EN</name>
              <description>
              layer color filter enable
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>ALPHA</name>
              <description>
              layer alpha value
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>ALPHA_SEL</name>
              <description>
              alpha selection
              1'b0: select alpha according to image format
              1'b1: select layer alpha
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FORMAT</name>
              <description>
              video layer input format
              2'h0: RGB565
              2'h1: RGB888
              2'h2: ARGB8888
              2'h3: ARGB8565
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>L1_TL_POS</name>
          <displayName>L1_TL_POS</displayName>
          <description></description>
          <addressOffset>0x58</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>Y0</name>
              <description>
              Coordingate Y-value
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>X0</name>
              <description>
              Coordinate X-value
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>L1_BR_POS</name>
          <displayName>L1_BR_POS</displayName>
          <description></description>
          <addressOffset>0x5c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>Y1</name>
              <description>
              Coordingate Y-value
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>X1</name>
              <description>
              Coordinate X-value
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>L1_FILTER</name>
          <displayName>L1_FILTER</displayName>
          <description></description>
          <addressOffset>0x60</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>FILTER_MASK</name>
              <description>
              layer color filter mask
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>FILTER_R</name>
              <description>
              filter r color
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>FILTER_G</name>
              <description>
              filter g color
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>FILTER_B</name>
              <description>
              filter b color
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>L1_SRC</name>
          <displayName>L1_SRC</displayName>
          <description></description>
          <addressOffset>0x64</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ADDR</name>
              <description>
              source image RGB data address[31:0]. For RGB565 format, address should be aligned to halfword. For ARGB8888 format, address should be aligned to word.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>L2_CFG</name>
          <displayName>L2_CFG</displayName>
          <description></description>
          <addressOffset>0x68</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EZIP_EN</name>
              <description>
              enable EZIP. EZIP can only be enable for one layer, the order is VL > L0 > L1 > L2
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ALPHA_BLEND</name>
              <description>
              set 1 to enable alpha blending mode. Use layer alpha as blending factor for ARGB8888 and ARGB8565 image.
              Alpha_out = Layer_alpha * Image_alpha
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ACTIVE</name>
              <description>
              layer active flag
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PREFETCH_EN</name>
              <description>
              preload 64 bytes extra data when reading pixel from memory
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>WIDTH</name>
              <description>
              source image width(including padding), unit is bytes
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>13</bitWidth>
            </field>
            <field>
              <name>FILTER_EN</name>
              <description>
              layer color filter enable
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>ALPHA</name>
              <description>
              layer alpha value
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>ALPHA_SEL</name>
              <description>
              alpha selection
              1'b0: select alpha according to image format
              1'b1: select layer alpha
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FORMAT</name>
              <description>
              video layer input format
              2'h0: RGB565
              2'h1: RGB888
              2'h2: ARGB8888
              2'h3: ARGB8565
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>L2_TL_POS</name>
          <displayName>L2_TL_POS</displayName>
          <description></description>
          <addressOffset>0x6c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>Y0</name>
              <description>
              Coordingate Y-value
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>X0</name>
              <description>
              Coordinate X-value
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>L2_BR_POS</name>
          <displayName>L2_BR_POS</displayName>
          <description></description>
          <addressOffset>0x70</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>Y1</name>
              <description>
              Coordingate Y-value
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>X1</name>
              <description>
              Coordinate X-value
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>L2_FILTER</name>
          <displayName>L2_FILTER</displayName>
          <description></description>
          <addressOffset>0x74</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>FILTER_MASK</name>
              <description>
              layer color filter mask
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>FILTER_R</name>
              <description>
              filter r color
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>FILTER_G</name>
              <description>
              filter g color
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>FILTER_B</name>
              <description>
              filter b color
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>L2_SRC</name>
          <displayName>L2_SRC</displayName>
          <description></description>
          <addressOffset>0x78</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ADDR</name>
              <description>
              source image RGB data address[31:0]. For RGB565 format, address should be aligned to halfword. For ARGB8888 format, address should be aligned to word.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>AHB_CTRL</name>
          <displayName>AHB_CTRL</displayName>
          <description></description>
          <addressOffset>0x7c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>29</bitWidth>
            </field>
            <field>
              <name>O_FORMAT</name>
              <description>
              AHB output format:
              2'h0: RGB565
              2'h1: RGB888
              2'h2: ARGB8888
              2'h3: ARGB8565
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>DESTINATION</name>
              <description>
              The Data can be sent to two destinations:
              2'b0: AHB RAM
              2'b1: AHB LCD
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>AHB_MEM</name>
          <displayName>AHB_MEM</displayName>
          <description></description>
          <addressOffset>0x80</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ADDR</name>
              <description>
              AHB RAM/AHB LCD target address
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>AHB_STRIDE</name>
          <displayName>AHB_STRIDE</displayName>
          <description></description>
          <addressOffset>0x84</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>OFFSET</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DEBUG</name>
          <displayName>DEBUG</displayName>
          <description></description>
          <addressOffset>0x88</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DEBUG_INT_DATA</name>
              <description>
              4'h0: RSVD
              4'h1: OL0 debug info
              4'h2: OL1 debug info
              4'h3: OL2 debug info
              4'h4: VL debug info1
              4'h5: VL debug info2
              4'h6: ROI debug out
              4'h7: mem intfa debug out
              4'h8: mem intfb debug out
              4'h9: ahb ctrl debug out
              4'ha: ROI XX
              4'hb: ROI YY
              4'hc: EPIC_EZIP debug out
              others: RSVD
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>DEBUG_INT_SEL</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>DEBUG_OUT_SEL</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>VL_ROT_M_CFG1</name>
          <displayName>VL_ROT_M_CFG1</displayName>
          <description></description>
          <addressOffset>0x8c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>M_MODE</name>
              <description>
              1'b0: auto mode
              1'b1: manual mode
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>M_ROT_MAX_COL</name>
              <description>
              manual mode rotation max column, unsigned value
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>M_ROT_MAX_LINE</name>
              <description>
              manual mode rotation max line, unsigned value
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>VL_ROT_M_CFG2</name>
          <displayName>VL_ROT_M_CFG2</displayName>
          <description></description>
          <addressOffset>0x90</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>M_PIVOT_Y</name>
              <description>
              manual mode pivot y, unsigned value
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>M_PIVOT_X</name>
              <description>
              manual mode pivot x, unsigned value
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>VL_ROT_M_CFG3</name>
          <displayName>VL_ROT_M_CFG3</displayName>
          <description></description>
          <addressOffset>0x94</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>M_YTL</name>
              <description>
              manual mode top left y cordinate, signed value
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>M_XTL</name>
              <description>
              manual mode top left x cordinate, signed value
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>LCDC1</name>
      <description></description>
      <groupName>LCDC</groupName>
      <baseAddress>0x40008000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>COMMAND</name>
          <displayName>COMMAND</displayName>
          <description></description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>30</bitWidth>
            </field>
            <field>
              <name>RESET</name>
              <description>
              1: reset the whole graphics   0: release the reset
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>START</name>
              <description>
              write 1 to trigger the lcd interface block
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS</name>
          <displayName>STATUS</displayName>
          <description></description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>29</bitWidth>
            </field>
            <field>
              <name>JDI_PAR_RUN</name>
              <description>
              JDI parallel interface is running
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DPI_RUN</name>
              <description>
              DPI interface is running
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LCD_BUSY</name>
              <description>
              LCS controll busy flag
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IRQ</name>
          <displayName>IRQ</displayName>
          <description></description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
            <field>
              <name>JDI_PAR_UDR_RAW_STAT</name>
              <description>
              raw_status of jdi parallel interface under run interrupt
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>JDI_PARL_INTR_RAW_STAT</name>
              <description>
              raw_status of jdi parallel interface line interrupt
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DPI_UDR_RAW_STAT</name>
              <description>
              raw status of dpi under run interrupt
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DPIL_INTR_RAW_STAT</name>
              <description>
              raw status of dpi line interrupt
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ICB_OF_RAW_STAT</name>
              <description>
              raw status of icb overflow interrupt
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EOF_RAW_STAT</name>
              <description>
              raw status of end of frame interrupt
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
            <field>
              <name>JDI_PAR_UDR_STAT</name>
              <description>
              jdi parallel interface under run interrupt, masked by mask register
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>JDI_PARL_INTR_STAT</name>
              <description>
              jdi parallel interface line interrupt, masked by mask register
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DPI_UDR_STAT</name>
              <description>
              dpi under run interrupt, masked by mask register
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DPIL_INTR_STAT</name>
              <description>
              dpi line interrupt, masked by mask register
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ICB_OF_STAT</name>
              <description>
              icb overflow interrupt, masked by mask register
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EOF_STAT</name>
              <description>
              end of frame interrupt, masked by mask register
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SETTING</name>
          <displayName>SETTING</displayName>
          <description></description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>AUTO_GATE_EN</name>
              <description>
              auto clock gating enable
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>JDI_PAR_UDR_MASK</name>
              <description>
              jdi parallel interface under run interrupt mask, 0: mask the interrupt
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>JDI_PARL_INTR_MASK</name>
              <description>
              jdi parallel interface line interrupt, 0: mask the interrupt
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DPI_UDR_MASK</name>
              <description>
              dpi under run interrupt mask, 0: mask the interrupt
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DPIL_INTR_MASK</name>
              <description>
              dpi line interrupt, 0: mask the interrupt
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ICB_OF_MASK</name>
              <description>
              icb overflow interrupt mask, 0: mask the interrupt
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EOF_MASK</name>
              <description>
              end of frame interrupt mask, 0: mask the interrupt
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CANVAS_TL_POS</name>
          <displayName>CANVAS_TL_POS</displayName>
          <description></description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>Y0</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>X0</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CANVAS_BR_POS</name>
          <displayName>CANVAS_BR_POS</displayName>
          <description></description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>Y1</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>X1</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CANVAS_BG</name>
          <displayName>CANVAS_BG</displayName>
          <description></description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>RED</name>
              <description>
              Red color
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>GREEN</name>
              <description>
              green color
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>BLUE</name>
              <description>
              blue color
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>LAYER0_CONFIG</name>
          <displayName>LAYER0_CONFIG</displayName>
          <description></description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>ACTIVE</name>
              <description>
              layer active flag
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LINE_FETCH_MODE</name>
              <description>
              line fetch mode
              0: address skip every single line
              1: address skip every two line
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PREFETCH_EN</name>
              <description>
              preload 64 bytes extra data when reading pixel from memory
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>WIDTH</name>
              <description>
              source image width(including padding), unit is bytes
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>13</bitWidth>
            </field>
            <field>
              <name>FILTER_EN</name>
              <description>
              layer color filter enable
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ALPHA</name>
              <description>
              layer alpha value
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>ALPHA_SEL</name>
              <description>
              alpha selection
              1'b0: select alpha according to image format
              1'b1: select layer alpha
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FORMAT</name>
              <description>
              overlay layer input format
              3'h0: RGB565
              3'h1: RGB888
              3'h2: ARGB8888
              3'h3: ARGB8565
              3'h4: RGB332
              others: reserved
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>LAYER0_TL_POS</name>
          <displayName>LAYER0_TL_POS</displayName>
          <description></description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>Y0</name>
              <description>
              Coordingate Y-value
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>X0</name>
              <description>
              Coordinate X-value
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>LAYER0_BR_POS</name>
          <displayName>LAYER0_BR_POS</displayName>
          <description></description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>Y1</name>
              <description>
              Coordingate Y-value
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>X1</name>
              <description>
              Coordinate X-value
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>LAYER0_FILTER</name>
          <displayName>LAYER0_FILTER</displayName>
          <description></description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>FILTER_MASK</name>
              <description>
              layer color filter mask
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>FILTER_R</name>
              <description>
              filter r color
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>FILTER_G</name>
              <description>
              filter g color
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>FILTER_B</name>
              <description>
              filter b color
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>LAYER0_SRC</name>
          <displayName>LAYER0_SRC</displayName>
          <description></description>
          <addressOffset>0x2c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ADDR</name>
              <description>
              source image RGB data address[31:0]. For RGB565 format, address should be aligned to halfword. For ARGB8888 format, address should be aligned to word.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>LAYER0_DECOMP</name>
          <displayName>LAYER0_DECOMP</displayName>
          <description></description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
            <field>
              <name>COL_SIZE</name>
              <description>
              number of colums in a line of original image
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
            <field>
              <name>TARGET_WORDS</name>
              <description>
              size of a single channel data before decompression. Unit is half word. Each line has 3 channels. So for each line, the compressed data size is target_words * 3 * 2 bytes.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
            <field>
              <name>ENABLE</name>
              <description>
              decompression enable
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>LAYER0_DECOMP_CFG0</name>
          <displayName>LAYER0_DECOMP_CFG0</displayName>
          <description></description>
          <addressOffset>0x34</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x01055982</resetValue>
          <fields>
            <field>
              <name>CFG0_RESERVED</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
            <field>
              <name>LOSSLESS_QIDX2</name>
              <description>
              condition to decrease qidx
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>LOSSLESS_QIDX1</name>
              <description>
              up level for adjusted qidx value for low quality block
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>USE_LOSSLESS_QIDX</name>
              <description>
              condition to increase qidx
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>EXTRA_THRESHOLD</name>
              <description>
              the threshold to distinguish high/low quality block
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>EXTRA_HIGH</name>
              <description>
              extra bit for high quality bit
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>LAYER0_DECOMP_CFG1</name>
          <displayName>LAYER0_DECOMP_CFG1</displayName>
          <description></description>
          <addressOffset>0x38</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x80023307</resetValue>
          <fields>
            <field>
              <name>EXTRA_LOW</name>
              <description>
              extra bit for low quality block
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>BLOCK_MIN_QIDX</name>
              <description>
              minimum qidx for block mode
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>LINE_MIN_QIDX</name>
              <description>
              minimum qidx for line mode
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>FAILOVER_BITS_B</name>
              <description>
              failover compression mode target bits(Blue)
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>FAILOVER_BITS_G</name>
              <description>
              failover compression mode target bits(Green)
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>FAILOVER_BITS_R</name>
              <description>
              failover compression mode target bits(Red)
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>CFG1_RESERVED</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>DITHER</name>
              <description>
              dithering function
              0: off
              1: on
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BLOCK_WIDTH</name>
              <description>
              block_size in pixel unit.
              0: 16 pixels
              1: 32 pixels
              Small block size will cause more blocks and more bits to store block information.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>LAYER0_DECOMP_STAT</name>
          <displayName>LAYER0_DECOMP_STAT</displayName>
          <description></description>
          <addressOffset>0x3c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>26</bitWidth>
            </field>
            <field>
              <name>BUF_MAX_DEPTH</name>
              <description>
              buf max usage
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>LAYER1_CONFIG</name>
          <displayName>LAYER1_CONFIG</displayName>
          <description></description>
          <addressOffset>0x40</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>ACTIVE</name>
              <description>
              layer active flag
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LINE_FETCH_MODE</name>
              <description>
              line fetch mode
              0: address skip every single line
              1: address skip every two line
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PREFETCH_EN</name>
              <description>
              preload 64 bytes extra data when reading pixel from memory
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>WIDTH</name>
              <description>
              source image width(including padding), unit is bytes
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>13</bitWidth>
            </field>
            <field>
              <name>FILTER_EN</name>
              <description>
              layer color filter enable
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ALPHA</name>
              <description>
              layer alpha value
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>ALPHA_SEL</name>
              <description>
              alpha selection
              1'b0: select alpha according to image format
              1'b1: select layer alpha
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FORMAT</name>
              <description>
              overlay layer input format
              3'h0: RGB565
              3'h1: RGB888
              3'h2: ARGB8888
              3'h3: ARGB8565
              3'h4: RGB332
              others: reserved
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>LAYER1_TL_POS</name>
          <displayName>LAYER1_TL_POS</displayName>
          <description></description>
          <addressOffset>0x44</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>Y0</name>
              <description>
              Coordingate Y-value
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>X0</name>
              <description>
              Coordinate X-value
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>LAYER1_BR_POS</name>
          <displayName>LAYER1_BR_POS</displayName>
          <description></description>
          <addressOffset>0x48</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>Y1</name>
              <description>
              Coordingate Y-value
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>X1</name>
              <description>
              Coordinate X-value
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>LAYER1_FILTER</name>
          <displayName>LAYER1_FILTER</displayName>
          <description></description>
          <addressOffset>0x4c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>FILTER_MASK</name>
              <description>
              layer color filter mask
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>FILTER_R</name>
              <description>
              filter r color
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>FILTER_G</name>
              <description>
              filter g color
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>FILTER_B</name>
              <description>
              filter b color
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>LAYER1_SRC</name>
          <displayName>LAYER1_SRC</displayName>
          <description></description>
          <addressOffset>0x50</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ADDR</name>
              <description>
              source image RGB data address[31:0]. For RGB565 format, address should be aligned to halfword. For ARGB8888 format, address should be aligned to word.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD1</name>
          <displayName>RSVD1</displayName>
          <description></description>
          <addressOffset>0x54</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>LCD_CONF</name>
          <displayName>LCD_CONF</displayName>
          <description></description>
          <addressOffset>0x60</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>15</bitWidth>
            </field>
            <field>
              <name>JDI_SER_FORMAT</name>
              <description>
              JDI serial format
              2'b00: 3-bit mode
              2'b01: 4-bit mode
              2'b10: 1-bit mode
              2'b11: reserved
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>DPI_LCD_FORMAT</name>
              <description>
              DPI LCD format
              3'b000: 16-bit conf1
              3'b001: 16-bit conf2
              3'b010: 16-bit conf3
              3'b011: 18-bit conf1
              3'b100: 18-bit conf2
              3'b101: 24-bit
              others: Reserved
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>SPI_LCD_FORMAT</name>
              <description>
              SPI LCD format
              2'b00: 8-bit RGB 3:3:2
              2'b01: 16-bit RGB 5:6:5
              2'b10: 24-bit RGB 8:8:8
              2'b11: Reserved
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>AHB_FORMAT</name>
              <description>
              AHB LCD/RAM output format:
              0: RGB565
              1: RGB888
              2: ARGB8888
              3: RGB332
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>LCD_FORMAT</name>
              <description>
              LCD output format:
              3'b000: 8-bit RGB 3:3:2
              3'b001: 16-bit RGB 5:6:5 over 8-bit bus, 2 cycles/pixel
              3'b010: 12-bit RGB 4:4:4
              3'b011: 16-bit RGB 5:6:5
              3'b100: 18-bit RGB 6:6:6
              3'b101: 24-bit RGB 8:8:8
              3'b110: 24-bit RGB 8:8:8 over 16-bit bus, 1.5 cycles/pixel
              3'b111: 24-bit RGB 8:8:8 over 8-bit bus, 3cycles/pixel
              others: Reserved
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>LCD_INTF_SEL</name>
              <description>
              3'b000: 8080 DBI Type B
              3'b001: SPI interface
              3'b010: DSI interface
              3'b011: DPI interface
              3'b100: JDI serial interface
              3'b101: JDI parallel interface
              3'b110: 8080 DBI Type A
              others: reserved
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>TARGET_LCD</name>
              <description>
              The Data can be sent to four destinations:
              2'b00: LCD panel 0
              2'b01: LCD panel 1
              2'b10: AHB LCD
              2'b11: AHB RAM
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>LCD_IF_CONF</name>
          <displayName>LCD_IF_CONF</displayName>
          <description></description>
          <addressOffset>0x64</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
            <field>
              <name>DO_DLY_SET</name>
              <description>
              if this bit is set to 1,  LCD data output will be delayed for 1 lcdc clock cycle
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LCD_RSTB</name>
              <description>
              LCD RSTB pin, direct to output
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RD_POL</name>
              <description>
              LCD RD pin polarity. RD is 0 for write operation, 1 for idle if polarity bit is set as 0. RD bit definition is opposite if polarity bit is set as 1.
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>WR_POL</name>
              <description>
              LCD WR pin polarity. WR is 0 for write operation, 1 for idle if polarity bit is set as 0. WR bit definition is opposite if polarity bit is set as 1.
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RS_POL</name>
              <description>
              LCD RS pin polarity. RS is 1 for data access, 0 for command access if polarity bit is set as 0. RS bit definition is opposite if polarity bit is set as 1.
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CS1_POL</name>
              <description>
              LCD0 CS pin polarity. CS is 0 for LCD chip select if polarity bit is set as 0. CS bit definition is opposite if polarity bit is set as 1.
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CS0_POL</name>
              <description>
              LCD1 CS pin polarity. CS is 0 for LCD chip select if polarity bit is set as 0. CS bit definition is opposite if polarity bit is set as 1.
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PWH</name>
              <description>
              inactive cycles of LCD_WR/LCD_RD for consecutive write/read operation
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>PWL</name>
              <description>
              active cycles of LCD_WR/LCD_RD
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>TAH</name>
              <description>
              hold cycles, delay from LCD_WR/LCD_RD inactive to LCD_CS inactive
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>TAS</name>
              <description>
              setup cycles, delay from LCD_CS active to LCD_WR/LCD_RD active
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>LCD_MEM</name>
          <displayName>LCD_MEM</displayName>
          <description></description>
          <addressOffset>0x68</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ADDR</name>
              <description>
              address for AHB LCD/AHB RAM
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>LCD_O_WIDTH</name>
          <displayName>LCD_O_WIDTH</displayName>
          <description></description>
          <addressOffset>0x6c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>22</bitWidth>
            </field>
            <field>
              <name>OFFSET</name>
              <description>
              AHB RAM address offset for each line
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>LCD_SINGLE</name>
          <displayName>LCD_SINGLE</displayName>
          <description></description>
          <addressOffset>0x70</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>28</bitWidth>
            </field>
            <field>
              <name>LCD_BUSY</name>
              <description>
              LCD/SPI LCD interface is busy for single access
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RD_TRIG</name>
              <description>
              Single read operation trigger
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>WR_TRIG</name>
              <description>
              Single write operation trigger
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TYPE</name>
              <description>
              LCD access type, this bit could affect all LCD interface including SPI, parellel and AHB
              1'b0: command
              1'b1: data
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>LCD_WR</name>
          <displayName>LCD_WR</displayName>
          <description></description>
          <addressOffset>0x74</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              LCD write data
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>LCD_RD</name>
          <displayName>LCD_RD</displayName>
          <description></description>
          <addressOffset>0x78</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              LCD read data
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_IF_CONF</name>
          <displayName>SPI_IF_CONF</displayName>
          <description></description>
          <addressOffset>0x7c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SPI_CLK_INIT</name>
              <description>
              SPI CLK idle state value
              1'h0: high
              1'h1: low
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SPI_CLK_POL</name>
              <description>
              SPI CLK polarity
              1'h0: normal
              1'h1: inverted
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SPI_CS_POL</name>
              <description>
              SPI CS polarity
              0: low active
              1: high active
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SPI_CS_AUTO_DIS</name>
              <description>
              1: SPI CS is automatically disabled after data transaction
              0: SPI CS is not disabled after data transaction
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SPI_CS_NO_IDLE</name>
              <description>
              1: SPI CS is always active during data transaction
              0: SPI CS is IDLE in wait state during data transaction
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SPI_CLK_AUTO_DIS</name>
              <description>
              1: SPI clock auto disable in wait state during data transaction
              0: SPI clock is always on in wait state during data transaction
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SPI_RD_MODE</name>
              <description>
              SPI read mode:
              1'b0: normal read. Send write request before read.
              1'b1: direct read. Read data without write request.
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>WR_LEN</name>
              <description>
              SPI write data length(single access)
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RD_LEN</name>
              <description>
              SPI read data length(single access)
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>LINE</name>
              <description>
              SPI line mode
              0: 4-line
              1: 4-line with 2 data line(support RGB565 and RGB888)
              2: 4-line with 4 data line(support RGB565 and RGB888)
              3: reserved
              4: 3-line 
              5: 3-line with 2 data line(support RGB565 and RGB888)
              6: 3-line with 4 data line(support RGB565 and RGB888)
              7: reserved
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>DUMMY_CYCLE</name>
              <description>
              SPI transaction dummy cycle
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>CLK_DIV</name>
              <description>
              SPI clock divider
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>DEV_ID</name>
              <description>
              SPI device ID
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TE_CONF</name>
          <displayName>TE_CONF</displayName>
          <description></description>
          <addressOffset>0x80</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
            <field>
              <name>FMARK_SOURCE</name>
              <description>
              TE signal source
              1: use TE signal from DSI
              0: use TE signal from external pin
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FMARK_MODE</name>
              <description>
              TE signal trigger mode
              1: edge trigger
              0: pulse trigger
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>VSYNC_DET_CNT</name>
              <description>
              vsync signal detect counter, used for mode 1 to detect vsync signal
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>MODE</name>
              <description>
              0: vsync only TE mode 
              1: vsync+hsync TE mode
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FMARK_POL</name>
              <description>
              TE signal polarity
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ENABLE</name>
              <description>
              TE enable
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TE_CONF2</name>
          <displayName>TE_CONF2</displayName>
          <description></description>
          <addressOffset>0x84</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DLY_CNT</name>
              <description>
              TE delay counter
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DPI_IF_CONF1</name>
          <displayName>DPI_IF_CONF1</displayName>
          <description></description>
          <addressOffset>0x88</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>HSW</name>
              <description>
              dpi hsync width
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>VSH</name>
              <description>
              dpi vsync height
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DPI_IF_CONF2</name>
          <displayName>DPI_IF_CONF2</displayName>
          <description></description>
          <addressOffset>0x8c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>HBP</name>
              <description>
              horizontal back porch
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>VBP</name>
              <description>
              vertical back porch
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DPI_IF_CONF3</name>
          <displayName>DPI_IF_CONF3</displayName>
          <description></description>
          <addressOffset>0x90</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>HFP</name>
              <description>
              horizontal front porch
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>VFP</name>
              <description>
              vertical front porch
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DPI_IF_CONF4</name>
          <displayName>DPI_IF_CONF4</displayName>
          <description></description>
          <addressOffset>0x94</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>HAW</name>
              <description>
              horizontal active width
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>VAH</name>
              <description>
              vertical active height
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DPI_IF_CONF5</name>
          <displayName>DPI_IF_CONF5</displayName>
          <description></description>
          <addressOffset>0x98</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
            <field>
              <name>INT_LINE_NUM</name>
              <description>
              DPI interrupt line number
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
            <field>
              <name>HSPOL</name>
              <description>
              hsync polarity
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>VSPOL</name>
              <description>
              vsync polarity
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DEPOL</name>
              <description>
              de polarity
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PCLKPOL</name>
              <description>
              pixel clock polarity
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PCLK_DIV</name>
              <description>
              pixel clock divider
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DPI_CTRL</name>
          <displayName>DPI_CTRL</displayName>
          <description></description>
          <addressOffset>0x9c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>29</bitWidth>
            </field>
            <field>
              <name>DPI_SD</name>
              <description>
              dpi shutdown
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DPI_CM</name>
              <description>
              dpi color mode
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DPI_EN</name>
              <description>
              dpi interface enable
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DPI_STAT</name>
          <displayName>DPI_STAT</displayName>
          <description></description>
          <addressOffset>0xa0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>VPOS</name>
              <description>
              dpi vertical position
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>HSTAT</name>
              <description>
              horizontal status
              0: idle
              1: prep
              2: hsync
              3: hbp
              4: hact
              5: hfp
              6: wait
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>HPOS</name>
              <description>
              dpi horizontal position
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>JDI_SER_CONF1</name>
          <displayName>JDI_SER_CONF1</displayName>
          <description></description>
          <addressOffset>0xa4</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>CLK_DIV</name>
              <description>
              jdi serial clock divider
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>WR_LEN</name>
              <description>
              jdi single write bit length
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>JDI_SER_CONF2</name>
          <displayName>JDI_SER_CONF2</displayName>
          <description></description>
          <addressOffset>0xa8</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>INIT_LINE_CNT</name>
              <description>
              jdi serial init line counter
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>WR_CMD</name>
              <description>
              jdi serial data transfer write command
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>JDI_SER_CTRL</name>
          <displayName>JDI_SER_CTRL</displayName>
          <description></description>
          <addressOffset>0xac</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>30</bitWidth>
            </field>
            <field>
              <name>EXTCOMIN</name>
              <description>
              jdi serial interface extcomin control
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DISP</name>
              <description>
              jdi serial interface disp control
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>JDI_PAR_CONF1</name>
          <displayName>JDI_PAR_CONF1</displayName>
          <description></description>
          <addressOffset>0xb0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>MAX_LINE</name>
              <description>
              jdi parallel interface max line, line number start from 0
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>MAX_COL</name>
              <description>
              jdi parallel interface max column, column number start from 0
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>JDI_PAR_CONF2</name>
          <displayName>JDI_PAR_CONF2</displayName>
          <description></description>
          <addressOffset>0xb4</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ST_LINE</name>
              <description>
              jdi parallel interface start line, line number start from 0
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>END_LINE</name>
              <description>
              jdi parallel interface end line, line number start from 0
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>JDI_PAR_CONF3</name>
          <displayName>JDI_PAR_CONF3</displayName>
          <description></description>
          <addressOffset>0xb8</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ST_COL</name>
              <description>
              jdi parallel interface start column, column number start from 0
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>END_COL</name>
              <description>
              jdi parallel interface end column, column number start from 0
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>JDI_PAR_CONF4</name>
          <displayName>JDI_PAR_CONF4</displayName>
          <description></description>
          <addressOffset>0xbc</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>HCK_WIDTH</name>
              <description>
              jdi parallel interface HCK width, HSK width = lcd_ck_cycle * HCK_WIDTH
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>HST_WIDTH</name>
              <description>
              jdi parallel interface HST width, HST width = lcd_ck_cycle * HST_WIDTH
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>JDI_PAR_CONF5</name>
          <displayName>JDI_PAR_CONF5</displayName>
          <description></description>
          <addressOffset>0xc0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>VCK_WIDTH</name>
              <description>
              jdi parallel interface VCK width, VCK width = lcd_ck_cycle * VCK_WIDTH
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>VST_WIDTH</name>
              <description>
              jdi parallel interface VST width, VST width = lcd_ck_cycle * VST_WIDTH
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>JDI_PAR_CONF6</name>
          <displayName>JDI_PAR_CONF6</displayName>
          <description></description>
          <addressOffset>0xc4</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>VCK_DLY</name>
              <description>
              jdi parallel interface VST to VCK delay, VST2VCK delay = lcd_ck_cycle * VCK_DLY
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>HST_DLY</name>
              <description>
              jdi parallel interface VCK to HST delay, VCK2HST delay = lcd_ck_cycle * HST_DLY
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>JDI_PAR_CONF7</name>
          <displayName>JDI_PAR_CONF7</displayName>
          <description></description>
          <addressOffset>0xc8</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>15</bitWidth>
            </field>
            <field>
              <name>DP_MODE</name>
              <description>
              double pixel mode. Some jdi parallel screens use large pixel+small pixel structure. Set this bit to 1 to support this structure.
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HCK_DLY</name>
              <description>
              jdi parallel interface HST to HCK delay
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>JDI_PAR_CTRL</name>
          <displayName>JDI_PAR_CTRL</displayName>
          <description></description>
          <addressOffset>0xcc</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>INT_LINE_NUM</name>
              <description>
              jdi parallel interface interrupt line number, line number start from 0.
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>VSTPOL</name>
              <description>
              jdi parallel vst polarity
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>VCKPOL</name>
              <description>
              jdi parallel vck polarity
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HSTPOL</name>
              <description>
              jdi parallel hst polarity
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HCKPOL</name>
              <description>
              jdi parallel hck polarity
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ENBPOL</name>
              <description>
              jdi parallel enb polarity
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>XRST</name>
              <description>
              jdi parallel interface XRST
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>ENABLE</name>
              <description>
              jdi parallel interface enable
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>JDI_PAR_STAT</name>
          <displayName>JDI_PAR_STAT</displayName>
          <description></description>
          <addressOffset>0xd0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>VPOS</name>
              <description>
              jdi parallel vertical position
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>HPOS</name>
              <description>
              jdi parallel horizontal position
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>JDI_PAR_EX_CTRL</name>
          <displayName>JDI_PAR_EX_CTRL</displayName>
          <description></description>
          <addressOffset>0xd4</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>VCOM</name>
              <description>
              VCOM value
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FRP</name>
              <description>
              FRP value
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>XFRP</name>
              <description>
              XFRP value
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CNT_EN</name>
              <description>
              VCOM/FRP/XFRP counter enable
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>MAX_CNT</name>
              <description>
              VCOM/FRP/XFRP max counter
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>JDI_PAR_CONF8</name>
          <displayName>JDI_PAR_CONF8</displayName>
          <description></description>
          <addressOffset>0xd8</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ENB_ST_COL</name>
              <description>
              jdi parallel interface enb start column, column number start from 0
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>ENB_END_COL</name>
              <description>
              jdi parallel interface enb end column, column number start from 0
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>JDI_PAR_CONF9</name>
          <displayName>JDI_PAR_CONF9</displayName>
          <description></description>
          <addressOffset>0xdc</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ENB_ST_LINE</name>
              <description>
              jdi parallel interface enb start line, line number start from 0
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>ENB_END_LINE</name>
              <description>
              jdi parallel interface enb end line, line number start from 0
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>I2S1</name>
      <description></description>
      <groupName>I2S</groupName>
      <baseAddress>0x40009000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>RSVD41</name>
          <displayName>RSVD41</displayName>
          <description></description>
          <addressOffset>0x0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>TX_PCM_FORMAT</name>
          <displayName>TX_PCM_FORMAT</displayName>
          <description></description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000010</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>26</bitWidth>
            </field>
            <field>
              <name>TRACK_FLAG</name>
              <description>
              0: stereo
              1: mono
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DW</name>
              <description>
              tx source pcm data width N(N>=8)
              common value is 8,13,14,16,18,20,22,24
              This data width indicate the tx fifo output data width.
              When writing to tx fifo, please refer to following format:
                  Mono 8 bit: fifo_data[31:0] = {L3,L2,L1,L0}, each word contains 4 samples, so four samples need read one word
                  Stereo 8 bit: fifo_data[31:0] = { R1,L1,R0,L0 }, each word contains 2 samples, so two samples need read one word
                  Mono 13/14/16 bit: fifo_data[31:0] = {L1,L0}, each word contains 2 samples, so two samples need read one word
                  Stereo 13/14/16 bit: fifo_data[31:0] = {R0,L0}, each word contains 1 samples, so each sample need read one word
                  Mono 18/20/22/24 bit: fifo_data[31:0] = L0, each word contains 1 samples, so each sample need read one word 
                  Stereo 18/20/22/24 bit: fifo_data[31:0][0] = {L0}, fifo_data[31:0][1]={R0}, each 2 words contain 1 samples, so each sample need read two word
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD40</name>
          <displayName>RSVD40</displayName>
          <description></description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>TX_PCM_SAMPLE_CLK</name>
          <displayName>TX_PCM_SAMPLE_CLK</displayName>
          <description></description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x000000FA</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>19</bitWidth>
            </field>
            <field>
              <name>FS_DUTY</name>
              <description>
              source PCM sample clock duty cycle(with GCLK=12MHz):
              250 for 48K FS
              272 for 44.1K FS
              375 for 32K FS
              500 for 24K FS
              544 for 22.05K FS
              750 for 16K FS
              1000 for 12K FS
              1088 for 11.025K FS
              1500 for 8K FS
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>13</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD39</name>
          <displayName>RSVD39</displayName>
          <description></description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>TX_RS_SMOOTH</name>
          <displayName>TX_RS_SMOOTH</displayName>
          <description></description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>31</bitWidth>
            </field>
            <field>
              <name>EN</name>
              <description>
              0: Disable TX re-sample smooth filter
              1: Enable TX re-sample smooth filter
              This function is not implemented.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD38</name>
          <displayName>RSVD38</displayName>
          <description></description>
          <addressOffset>0x34</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>TX_PCM_CH_SEL</name>
          <displayName>TX_PCM_CH_SEL</displayName>
          <description></description>
          <addressOffset>0x40</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>28</bitWidth>
            </field>
            <field>
              <name>LEFT_CHANNEL_SEL</name>
              <description>
              TX re-sampling module setting:
              00: TX left = source left
              01: TX left = source right
              10,11: TX left = (source left + source right)/2
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RIGHT_CHANNEL_SEL</name>
              <description>
              TX re-sampling module setting:
              00: TX right = source right
              01: TX right = source left
              10,11: TX right = (source left + source right)/2
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD37</name>
          <displayName>RSVD37</displayName>
          <description></description>
          <addressOffset>0x44</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>TX_VOL_CTRL</name>
          <displayName>TX_VOL_CTRL</displayName>
          <description></description>
          <addressOffset>0x50</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0000000F</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>28</bitWidth>
            </field>
            <field>
              <name>VOL</name>
              <description>
              volume control:
              0000: +6dB,    0001: +4.5dB,
              0010: +3dB,    0011: +1.5dB,
              0100: 0dB,     0101: -1.5dB,
              0110: -3.0dB,  0111: -4.5dB,
              1000: -6.0dB,  1001: -7.5dB,
              1010: -9dB,    1011: -10.5dB,
              1100: -12dB,   1101: -13.5dB,
              1110: -15dB,   1111: mute
              Note:
              1) +1.5db = 20log(1+1/4-1/16+1/1024)
              2) -1.5dB = 20log(1-1/8-1/32-1/512-1/2048)
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD36</name>
          <displayName>RSVD36</displayName>
          <description></description>
          <addressOffset>0x54</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>TX_LR_BAL_CTRL</name>
          <displayName>TX_LR_BAL_CTRL</displayName>
          <description></description>
          <addressOffset>0x60</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>26</bitWidth>
            </field>
            <field>
              <name>EN</name>
              <description>
              LR balance enable:
              00: both left and right in full volume
              10: left channel balance volume adjustment enable
              01: right channel balance volume adjustment enable
              11: reserved, still kepp left and right in full volume
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>BAL_VOL</name>
              <description>
              Balance volume control:
              0000: Reserved,  0001: -1.5dB,
              0010: -3.0dB,  0011: -4.5dB,
              0100: -6.0dB,  0101: -7.5dB,
              0110: -9.0dB,  0111: -10.5dB,
              1000: -12dB,   1001: -13.5dB,
              1010: -15dB,   1011: -16.5dB,
              1100: -18dB,   1101: -19.5dB,
              1110: -21dB,   1111: mute
              Note:
                1) bit[5:0] = 101111 for left mute
                2) bit[5:0] = 011111 for right mute
                3) bit[5:4] = 00 or 11, bit[3:0] is don't care
                4) +1.5db = 20log(1+1/4-1/16+1/1024)
                5) -1.5dB = 20log(1-1/8-1/32-1/512-1/2048)
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD35</name>
          <displayName>RSVD35</displayName>
          <description></description>
          <addressOffset>0x64</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>AUDIO_TX_LRCK_DIV</name>
          <displayName>AUDIO_TX_LRCK_DIV</displayName>
          <description></description>
          <addressOffset>0x70</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x007D007D</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>DUTY_HIGH</name>
              <description>
              TX LRCK duty cycle high:
              125 for 48K FS
              136 for 44.1K FS
              185 for 32K FS
              250 for 24K FS
              272 for 22.05K FS
              375 for 16K FS
              500 for 12K FS
              544 for 11.025K FS
              750 for 8K FS      
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>DUTY_LOW</name>
              <description>
              TX LRCK duty cycle low:
              125 for 48K FS
              136 for 44.1K FS
              190 for 32K FS
              250 for 24K FS
              272 for 22.05K FS
              375 for 16K FS
              500 for 12K FS
              544 for 11.025K FS
              750 for 8K FS
              Note:
              1)duty_cycle = 12M/FS
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD34</name>
          <displayName>RSVD34</displayName>
          <description></description>
          <addressOffset>0x74</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>AUDIO_TX_BCLK_DIV</name>
          <displayName>AUDIO_TX_BCLK_DIV</displayName>
          <description></description>
          <addressOffset>0x80</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>26</bitWidth>
            </field>
            <field>
              <name>DUTY</name>
              <description>
              TX serial bit clock duty cycle
              5 for 48K FS
              4 for 44.1K FS
              5 for 32KFS
              10 for 24K FS
              8 for 22.05K FS
              15 for 16K FS
              20 for 12K FS
              16 for 11.025K FS
              30 for 8KFs
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD33</name>
          <displayName>RSVD33</displayName>
          <description></description>
          <addressOffset>0x84</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>AUDIO_TX_FORMAT</name>
          <displayName>AUDIO_TX_FORMAT</displayName>
          <description></description>
          <addressOffset>0x90</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>27</bitWidth>
            </field>
            <field>
              <name>PCM_DATA_WIDTH</name>
              <description>
              I2S out pcm data width
              M >= 16,
              common value: 16, 18, 20, 22, 24
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD32</name>
          <displayName>RSVD32</displayName>
          <description></description>
          <addressOffset>0x94</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>AUDIO_SERIAL_TIMING</name>
          <displayName>AUDIO_SERIAL_TIMING</displayName>
          <description></description>
          <addressOffset>0xa0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>28</bitWidth>
            </field>
            <field>
              <name>LRCK_POL</name>
              <description>
              TX LRCK polarity control.
              0: disable TX_LRCK inventor
              1: enable TX_LRCK inventor
              for standard I2S, set tx_lrck_pol to low
              for Left/Right Justified, set tx_lrck_pol to hgih
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SLAVE_EN</name>
              <description>
              audio code transmit mode select.
              0: master mode, 1: slave mode
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TIMING</name>
              <description>
              00: I2S mode
              01: Left justified
              10: right justified
              11: reserved
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD31</name>
          <displayName>RSVD31</displayName>
          <description></description>
          <addressOffset>0xA4</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>AUDIO_TX_FUNC_EN</name>
          <displayName>AUDIO_TX_FUNC_EN</displayName>
          <description></description>
          <addressOffset>0xb0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>31</bitWidth>
            </field>
            <field>
              <name>TX_EN</name>
              <description>
              1: enable 0:disable
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD30</name>
          <displayName>RSVD30</displayName>
          <description></description>
          <addressOffset>0xB4</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>AUDIO_TX_PAUSE</name>
          <displayName>AUDIO_TX_PAUSE</displayName>
          <description></description>
          <addressOffset>0xc0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>31</bitWidth>
            </field>
            <field>
              <name>TX_PAUSE</name>
              <description>
              TX pause control when tx_enable = 1.
              1: pause
              0: TX work
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD29</name>
          <displayName>RSVD29</displayName>
          <description></description>
          <addressOffset>0xC4</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>AUDIO_I2S_SL_MERGE</name>
          <displayName>AUDIO_I2S_SL_MERGE</displayName>
          <description></description>
          <addressOffset>0xc8</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>31</bitWidth>
            </field>
            <field>
              <name>SLAVE_TIMING_MERGE</name>
              <description>
              when work as an I2S slave, and external I2S master TX/RX share an only BCLK/LRCK, we need set this bit high.
              0: I2S slave use separated timing control port. TX_BCLK_IN/TX_LRCK_IN and RX_BCLK/RX_LRCK_IN are separated.
              1: I2S slave use the same BCLK/LRCK, the TX_BCLK_IN/TX_LRCK also is used for RX controller.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD28</name>
          <displayName>RSVD28</displayName>
          <description></description>
          <addressOffset>0xCC</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>AUDIO_RX_FUNC_EN</name>
          <displayName>AUDIO_RX_FUNC_EN</displayName>
          <description></description>
          <addressOffset>0x100</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>31</bitWidth>
            </field>
            <field>
              <name>RX_EN</name>
              <description>
              1: enable  0: disable
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD27</name>
          <displayName>RSVD27</displayName>
          <description></description>
          <addressOffset>0x104</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>AUDIO_RX_PAUSE</name>
          <displayName>AUDIO_RX_PAUSE</displayName>
          <description></description>
          <addressOffset>0x110</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>31</bitWidth>
            </field>
            <field>
              <name>RX_PAUSE</name>
              <description>
              RX pause control when rx_enable = 1.
              1: pause
              0: RX work
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD26</name>
          <displayName>RSVD26</displayName>
          <description></description>
          <addressOffset>0x114</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>AUDIO_RX_SERIAL_TIMING</name>
          <displayName>AUDIO_RX_SERIAL_TIMING</displayName>
          <description></description>
          <addressOffset>0x120</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00040000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>28</bitWidth>
            </field>
            <field>
              <name>LRCK_POL</name>
              <description>
              RX LRCK polarity control.
              0: disable RX_LRCK inventor
              1: enable RX_LRCK inventor
              for standard I2S, set tx_lrck_pol to low
              for Left/Right Justified, set tx_lrck_pol to hgih
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SLAVE_EN</name>
              <description>
              audio code receiver mode select.
              0: master mode, 1: slave mode
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TIMING</name>
              <description>
              00: I2S
              01: Left justified
              10: right justified
              11: reserved
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD25</name>
          <displayName>RSVD25</displayName>
          <description></description>
          <addressOffset>0x124</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>AUDIO_RX_PCM_DW</name>
          <displayName>AUDIO_RX_PCM_DW</displayName>
          <description></description>
          <addressOffset>0x130</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000010</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>27</bitWidth>
            </field>
            <field>
              <name>PCM_DATA_WIDTH</name>
              <description>
              For I2S and left justified mode, M can be 8,13,14,16
              For right justified mode, M can be 8, 13, 14, 16, 18, 20, 22, 24
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD24</name>
          <displayName>RSVD24</displayName>
          <description></description>
          <addressOffset>0x134</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>AUDIO_RX_LRCK_DIV</name>
          <displayName>AUDIO_RX_LRCK_DIV</displayName>
          <description></description>
          <addressOffset>0x140</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x007D007D</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>DUTY_HIGH</name>
              <description>
              RX LRCK duty cycle high:
              125 for 48K FS
              136 for 44.1K FS
              185 for 32K FS
              250 for 24K FS
              272 for 22.05K FS
              375 for 16K FS
              500 for 12K FS
              544 for 11.025K FS
              750 for 8K FS      
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>DUTY_LOW</name>
              <description>
              RX LRCK duty cycle low:
              125 for 48K FS
              136 for 44.1K FS
              190 for 32K FS
              250 for 24K FS
              272 for 22.05K FS
              375 for 16K FS
              500 for 12K FS
              544 for 11.025K FS
              750 for 8K FS
              Note:
              1)duty_cycle = 12M/FS
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD23</name>
          <displayName>RSVD23</displayName>
          <description></description>
          <addressOffset>0x144</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>AUDIO_RX_BCLK_DIV</name>
          <displayName>AUDIO_RX_BCLK_DIV</displayName>
          <description></description>
          <addressOffset>0x150</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000005</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>22</bitWidth>
            </field>
            <field>
              <name>DUTY</name>
              <description>
              RX serial bit clock duty cycle
              5 for 48K FS
              4 for 44.1K FS
              5 for 32KFS
              10 for 24K FS
              8 for 22.05K FS
              15 for 16K FS
              20 for 12K FS
              16 for 11.025K FS
              30 for 8KFs
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD22</name>
          <displayName>RSVD22</displayName>
          <description></description>
          <addressOffset>0x154</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>RECORD_DATA_SEL</name>
          <displayName>RECORD_DATA_SEL</displayName>
          <description></description>
          <addressOffset>0x160</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>31</bitWidth>
            </field>
            <field>
              <name>RS_DATA_SEL</name>
              <description>
              0: I2S audio recording  1: BT recording
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD21</name>
          <displayName>RSVD21</displayName>
          <description></description>
          <addressOffset>0x164</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>RX_RE_SAMPLE_CLK_DIV</name>
          <displayName>RX_RE_SAMPLE_CLK_DIV</displayName>
          <description></description>
          <addressOffset>0x170</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0000007D</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>19</bitWidth>
            </field>
            <field>
              <name>RS_DUTY</name>
              <description>
              source PCM sample clock duty cycle:
              250 for 48K FS
              272 for 44.1K FS
              375 for 32K FS
              500 for 24K FS
              544 for 22.05K FS
              750 for 16K FS
              1000 for 12K FS
              1088 for 11.025K FS
              1500 for 8K FS
              Note:
              1)duty_cycle = 12M/FS      
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>13</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD20</name>
          <displayName>RSVD20</displayName>
          <description></description>
          <addressOffset>0x174</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>RX_RE_SAMPLE</name>
          <displayName>RX_RE_SAMPLE</displayName>
          <description></description>
          <addressOffset>0x180</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>31</bitWidth>
            </field>
            <field>
              <name>SMOOTH_EN</name>
              <description>
              0: Disable RX re-sample smooth filter
              1: Enable RX re-sample smooth filter
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD19</name>
          <displayName>RSVD19</displayName>
          <description></description>
          <addressOffset>0x184</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>RECORD_FORMAT</name>
          <displayName>RECORD_FORMAT</displayName>
          <description></description>
          <addressOffset>0x190</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>30</bitWidth>
            </field>
            <field>
              <name>TRACK</name>
              <description>
              1: mono recording, 0: stereo recording
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DW</name>
              <description>
              0: 8bit 1: 16bit
              RX fifo data format:
                   Mono 8 bit (unsigned): RX FIFO_DIN[31:0] = {L3,L2,L1,L0}, each four samples need one FIFO write operation
                  Stereo 8 bit (unsigned): RX_FIFO_DIN[31:0] = {R1,L1,R0,L0}, each tow samples need one FIFO write operation
                  Mono 16 bit (Signed 2's complement): RX_FIFO_DIN[31:0] = {L1,L0}, each two samples need one FIFO write operation
                  Stereo 16 bit (Signed 2's complement): RX_FIFO_DIN[31:0] = {R0,L0}, each sample need one FIFO write operation
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD18</name>
          <displayName>RSVD18</displayName>
          <description></description>
          <addressOffset>0x194</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>RX_CH_SEL</name>
          <displayName>RX_CH_SEL</displayName>
          <description></description>
          <addressOffset>0x1a0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>28</bitWidth>
            </field>
            <field>
              <name>LEFT_CHANNEL_SEL</name>
              <description>
              RX re-sampling module setting:
              00: RD left = RX left
              01: RD left = RX right
              10,11: RD left = (RX left + RX right)/2
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RIGHT_CHANNEL_SEL</name>
              <description>
              RX re-sampling module setting:
              00: RD right = RX right
              01: RD right = RX left
              10,11: RD right = (RX left + RX right)/2
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD17</name>
          <displayName>RSVD17</displayName>
          <description></description>
          <addressOffset>0x1A4</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>BT_PHONE_CTRL</name>
          <displayName>BT_PHONE_CTRL</displayName>
          <description></description>
          <addressOffset>0x200</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>26</bitWidth>
            </field>
            <field>
              <name>BB_I2S_BPS_TO_CDC</name>
              <description>
              bypass baseband I2S interface to audio codec i2s interface
              0: no bypass, 1: bypass
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BT_PCM_IF_BPS</name>
              <description>
              bypass baseband PCM signals to BT VCI master:
              0: no bypass, 1: bypass
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BT_PATH_SEL</name>
              <description>
               BT path select
              0: digital path, 1: analog path
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BT_MIX_SMOOTH_FILTER_EN</name>
              <description>
              0: disable the smooth filter for background mixer
              1: enable the smooth filer for background mixer
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BT_BACK_MIX_EN</name>
              <description>
               background mixer enable
              0: disable, 1: enable
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BT_PH_EN</name>
              <description>
              BT phone enable
              0: disable, 1: enable
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD16</name>
          <displayName>RSVD16</displayName>
          <description></description>
          <addressOffset>0x204</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>BB_PCM_FORMAT</name>
          <displayName>BB_PCM_FORMAT</displayName>
          <description></description>
          <addressOffset>0x210</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>21</bitWidth>
            </field>
            <field>
              <name>PCM_CLK_POL</name>
              <description>
              input BB pcm clock polarity:
              0: rising edge for data transmitting, falling edge for data receiving
              1: rising edge for data receiving, falling edge for data transmitting
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>I2S_LRCK_POL</name>
              <description>
              0: no bb_i2s_lrck input inventor
              1: enable bb_i2s_lrck input inventor
              for standard I2S, set tx_lrck_pol to low
              for Left/Right Justified, set tx_lrck_pol to high
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PCM_LSB_FLAG</name>
              <description>
              Serial PCM data bit sequence.
              0: MSB first, 1: LSB first
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PCM_SYNC_FLAG</name>
              <description>
              0: short sync, 1: long sync
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PCM_TIM_SEL</name>
              <description>
              00: I2S timing, 01: Left Justified
              10: Right Justified, 11: PCM timing
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>PCM_DW</name>
              <description>
              Baseband Master PCM data width (>=8)
              Common value: 8, 13,14, 16, 18, 20, 22, 24.
              for I2S/Left Justified/Right Kistified timing, bb_pcm_dw >=16
              For PCM timing, only 8, 13, 14, 16 configure value is available.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD15</name>
          <displayName>RSVD15</displayName>
          <description></description>
          <addressOffset>0x214</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>BT_PCM_DW</name>
          <displayName>BT_PCM_DW</displayName>
          <description></description>
          <addressOffset>0x220</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000010</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>27</bitWidth>
            </field>
            <field>
              <name>DW</name>
              <description>
              BT PCM master data width (>= 8),
              common value: 8, 13,14, 16
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD14</name>
          <displayName>RSVD14</displayName>
          <description></description>
          <addressOffset>0x224</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>BT_PCM_TIMING</name>
          <displayName>BT_PCM_TIMING</displayName>
          <description></description>
          <addressOffset>0x230</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>29</bitWidth>
            </field>
            <field>
              <name>CLK_POL</name>
              <description>
              BT PCM master output pcm clock polarity:
              0: rising edge for data transmitting, falling edge for data receiving
              1: rising edge for data receiving, falling edge for data transmitting
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SYNC_FLAG</name>
              <description>
              0: short sync, 1: long sync
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LSB_FLAG</name>
              <description>
              Serial PCM data bit sequence.
              0: MSB first, 1: LSB first
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD13</name>
          <displayName>RSVD13</displayName>
          <description></description>
          <addressOffset>0x234</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>BT_PCM_CLK_DUTY</name>
          <displayName>BT_PCM_CLK_DUTY</displayName>
          <description></description>
          <addressOffset>0x240</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>22</bitWidth>
            </field>
            <field>
              <name>CLK_DUTY</name>
              <description>
              BT_PCM_CLK duty cycle
              &lt;= (GCLK/(bt_pcm_sync*bt_pcm_dw))
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD12</name>
          <displayName>RSVD12</displayName>
          <description></description>
          <addressOffset>0x244</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>BT_PCM_SYNC_DUTY</name>
          <displayName>BT_PCM_SYNC_DUTY</displayName>
          <description></description>
          <addressOffset>0x250</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>26</bitWidth>
            </field>
            <field>
              <name>SYNC_DUTY</name>
              <description>
              PCM_SYNC duty cycle  (bt_pcm_sync frequency =  bt_pclk_clk/bt_pcm_sync_duty)
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD11</name>
          <displayName>RSVD11</displayName>
          <description></description>
          <addressOffset>0x254</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>BT_VOL_CTRL</name>
          <displayName>BT_VOL_CTRL</displayName>
          <description></description>
          <addressOffset>0x260</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>28</bitWidth>
            </field>
            <field>
              <name>VOL_ADJ_EN</name>
              <description>
              BT volume adjust enable
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>VOL</name>
              <description>
              BT master volume
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD10</name>
          <displayName>RSVD10</displayName>
          <description></description>
          <addressOffset>0x264</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>INT_MASK</name>
          <displayName>INT_MASK</displayName>
          <description></description>
          <addressOffset>0x300</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000003</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>30</bitWidth>
            </field>
            <field>
              <name>TX_FIFO_INT_MASK</name>
              <description>
              Interrupt mask for TX FIFO pop underflow, high active
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RX_FIFO_INT_MASK</name>
              <description>
              Interrupt mask for RX FIFO push overflow, high active
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD9</name>
          <displayName>RSVD9</displayName>
          <description></description>
          <addressOffset>0x304</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>INT_STATUS</name>
          <displayName>INT_STATUS</displayName>
          <description></description>
          <addressOffset>0x310</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>30</bitWidth>
            </field>
            <field>
              <name>TX_FIFO_UNDERFLOW</name>
              <description>
              TX FIFO pop underflow
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RX_FIFO_OVERFLOW</name>
              <description>
              RX FIFO push overflow
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD8</name>
          <displayName>RSVD8</displayName>
          <description></description>
          <addressOffset>0x314</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>TX_DMA_ENTRY</name>
          <displayName>TX_DMA_ENTRY</displayName>
          <description></description>
          <addressOffset>0x400</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>TX_DMA_ENTRY</name>
              <description>
              TX DMA entry
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD7</name>
          <displayName>RSVD7</displayName>
          <description></description>
          <addressOffset>0x404</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>RX_DMA_ENTRY</name>
          <displayName>RX_DMA_ENTRY</displayName>
          <description></description>
          <addressOffset>0x440</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RX_DMA_ENTRY</name>
              <description>
              RX DMA entry
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD6</name>
          <displayName>RSVD6</displayName>
          <description></description>
          <addressOffset>0x444</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>DMA_MASK</name>
          <displayName>DMA_MASK</displayName>
          <description></description>
          <addressOffset>0x480</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000003</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>30</bitWidth>
            </field>
            <field>
              <name>TX_DMA_MASK</name>
              <description>
              TX DMA mask enable:1: mask0: do not mask
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RX_DMA_MASK</name>
              <description>
              RX DMA mask enable:1: mask0: do not mask
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD5</name>
          <displayName>RSVD5</displayName>
          <description></description>
          <addressOffset>0x484</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>DEBUG_LOOP</name>
          <displayName>DEBUG_LOOP</displayName>
          <description></description>
          <addressOffset>0x500</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>30</bitWidth>
            </field>
            <field>
              <name>AD2DA_LOOP_BACK</name>
              <description>
              RX-->TX Loop debug control:
              0: disable
              1: enable, internally connect RX Resampled PCM to TX Resample PCM input
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DA2AD_LOOP_BACK</name>
              <description>
              TX-->RX Loop debug control:
              0: disable
              1: enable, internally connect TX SDTO to RX SDTI
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD4</name>
          <displayName>RSVD4</displayName>
          <description></description>
          <addressOffset>0x504</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>FIFO_STATUS</name>
          <displayName>FIFO_STATUS</displayName>
          <description></description>
          <addressOffset>0x600</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>FIFO_STATUS_OUT</name>
              <description>
              FIFO Status output:
               Bit [7:0] = {tx_full,tx_empty,tx_almost_full,tx_almost_empty,rx_full,rx_empty,rx_almost_full,rx_almost_empty}
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD3</name>
          <displayName>RSVD3</displayName>
          <description></description>
          <addressOffset>0x604</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>TX_EQUALIZER_EN</name>
          <displayName>TX_EQUALIZER_EN</displayName>
          <description></description>
          <addressOffset>0x700</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>31</bitWidth>
            </field>
            <field>
              <name>TX_EQUALIZER_EN</name>
              <description>
              0: Disable TX equalizer
              1: Enable TX equalizer
              equalizer is not implemented
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD2</name>
          <displayName>RSVD2</displayName>
          <description></description>
          <addressOffset>0x704</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>TX_EQUALIZER_GAIN1</name>
          <displayName>TX_EQUALIZER_GAIN1</displayName>
          <description></description>
          <addressOffset>0x710</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>BAND6_GAIN</name>
              <description>
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>BAND5_GAIN</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>BAND4_GAIN</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>BAND3_GAIN</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>BAND2_GAIN</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>BAND1_GAIN</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD1</name>
          <displayName>RSVD1</displayName>
          <description></description>
          <addressOffset>0x714</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>TX_EQUALIZER_GAIN2</name>
          <displayName>TX_EQUALIZER_GAIN2</displayName>
          <description></description>
          <addressOffset>0x720</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
            <field>
              <name>BAND10_GAIN</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>BAND9_GAIN</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>BAND8_GAIN</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>BAND7_GAIN</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>I2S2</name>
      <description></description>
      <groupName>I2S</groupName>
      <baseAddress>0x4000a000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>RSVD41</name>
          <displayName>RSVD41</displayName>
          <description></description>
          <addressOffset>0x0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>TX_PCM_FORMAT</name>
          <displayName>TX_PCM_FORMAT</displayName>
          <description></description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000010</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>26</bitWidth>
            </field>
            <field>
              <name>TRACK_FLAG</name>
              <description>
              0: stereo
              1: mono
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DW</name>
              <description>
              tx source pcm data width N(N>=8)
              common value is 8,13,14,16,18,20,22,24
              This data width indicate the tx fifo output data width.
              When writing to tx fifo, please refer to following format:
                  Mono 8 bit: fifo_data[31:0] = {L3,L2,L1,L0}, each word contains 4 samples, so four samples need read one word
                  Stereo 8 bit: fifo_data[31:0] = { R1,L1,R0,L0 }, each word contains 2 samples, so two samples need read one word
                  Mono 13/14/16 bit: fifo_data[31:0] = {L1,L0}, each word contains 2 samples, so two samples need read one word
                  Stereo 13/14/16 bit: fifo_data[31:0] = {R0,L0}, each word contains 1 samples, so each sample need read one word
                  Mono 18/20/22/24 bit: fifo_data[31:0] = L0, each word contains 1 samples, so each sample need read one word 
                  Stereo 18/20/22/24 bit: fifo_data[31:0][0] = {L0}, fifo_data[31:0][1]={R0}, each 2 words contain 1 samples, so each sample need read two word
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD40</name>
          <displayName>RSVD40</displayName>
          <description></description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>TX_PCM_SAMPLE_CLK</name>
          <displayName>TX_PCM_SAMPLE_CLK</displayName>
          <description></description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x000000FA</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>19</bitWidth>
            </field>
            <field>
              <name>FS_DUTY</name>
              <description>
              source PCM sample clock duty cycle(with GCLK=12MHz):
              250 for 48K FS
              272 for 44.1K FS
              375 for 32K FS
              500 for 24K FS
              544 for 22.05K FS
              750 for 16K FS
              1000 for 12K FS
              1088 for 11.025K FS
              1500 for 8K FS
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>13</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD39</name>
          <displayName>RSVD39</displayName>
          <description></description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>TX_RS_SMOOTH</name>
          <displayName>TX_RS_SMOOTH</displayName>
          <description></description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>31</bitWidth>
            </field>
            <field>
              <name>EN</name>
              <description>
              0: Disable TX re-sample smooth filter
              1: Enable TX re-sample smooth filter
              This function is not implemented.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD38</name>
          <displayName>RSVD38</displayName>
          <description></description>
          <addressOffset>0x34</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>TX_PCM_CH_SEL</name>
          <displayName>TX_PCM_CH_SEL</displayName>
          <description></description>
          <addressOffset>0x40</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>28</bitWidth>
            </field>
            <field>
              <name>LEFT_CHANNEL_SEL</name>
              <description>
              TX re-sampling module setting:
              00: TX left = source left
              01: TX left = source right
              10,11: TX left = (source left + source right)/2
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RIGHT_CHANNEL_SEL</name>
              <description>
              TX re-sampling module setting:
              00: TX right = source right
              01: TX right = source left
              10,11: TX right = (source left + source right)/2
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD37</name>
          <displayName>RSVD37</displayName>
          <description></description>
          <addressOffset>0x44</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>TX_VOL_CTRL</name>
          <displayName>TX_VOL_CTRL</displayName>
          <description></description>
          <addressOffset>0x50</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0000000F</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>28</bitWidth>
            </field>
            <field>
              <name>VOL</name>
              <description>
              volume control:
              0000: +6dB,    0001: +4.5dB,
              0010: +3dB,    0011: +1.5dB,
              0100: 0dB,     0101: -1.5dB,
              0110: -3.0dB,  0111: -4.5dB,
              1000: -6.0dB,  1001: -7.5dB,
              1010: -9dB,    1011: -10.5dB,
              1100: -12dB,   1101: -13.5dB,
              1110: -15dB,   1111: mute
              Note:
              1) +1.5db = 20log(1+1/4-1/16+1/1024)
              2) -1.5dB = 20log(1-1/8-1/32-1/512-1/2048)
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD36</name>
          <displayName>RSVD36</displayName>
          <description></description>
          <addressOffset>0x54</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>TX_LR_BAL_CTRL</name>
          <displayName>TX_LR_BAL_CTRL</displayName>
          <description></description>
          <addressOffset>0x60</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>26</bitWidth>
            </field>
            <field>
              <name>EN</name>
              <description>
              LR balance enable:
              00: both left and right in full volume
              10: left channel balance volume adjustment enable
              01: right channel balance volume adjustment enable
              11: reserved, still kepp left and right in full volume
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>BAL_VOL</name>
              <description>
              Balance volume control:
              0000: Reserved,  0001: -1.5dB,
              0010: -3.0dB,  0011: -4.5dB,
              0100: -6.0dB,  0101: -7.5dB,
              0110: -9.0dB,  0111: -10.5dB,
              1000: -12dB,   1001: -13.5dB,
              1010: -15dB,   1011: -16.5dB,
              1100: -18dB,   1101: -19.5dB,
              1110: -21dB,   1111: mute
              Note:
                1) bit[5:0] = 101111 for left mute
                2) bit[5:0] = 011111 for right mute
                3) bit[5:4] = 00 or 11, bit[3:0] is don't care
                4) +1.5db = 20log(1+1/4-1/16+1/1024)
                5) -1.5dB = 20log(1-1/8-1/32-1/512-1/2048)
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD35</name>
          <displayName>RSVD35</displayName>
          <description></description>
          <addressOffset>0x64</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>AUDIO_TX_LRCK_DIV</name>
          <displayName>AUDIO_TX_LRCK_DIV</displayName>
          <description></description>
          <addressOffset>0x70</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x007D007D</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>DUTY_HIGH</name>
              <description>
              TX LRCK duty cycle high:
              125 for 48K FS
              136 for 44.1K FS
              185 for 32K FS
              250 for 24K FS
              272 for 22.05K FS
              375 for 16K FS
              500 for 12K FS
              544 for 11.025K FS
              750 for 8K FS      
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>DUTY_LOW</name>
              <description>
              TX LRCK duty cycle low:
              125 for 48K FS
              136 for 44.1K FS
              190 for 32K FS
              250 for 24K FS
              272 for 22.05K FS
              375 for 16K FS
              500 for 12K FS
              544 for 11.025K FS
              750 for 8K FS
              Note:
              1)duty_cycle = 12M/FS
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD34</name>
          <displayName>RSVD34</displayName>
          <description></description>
          <addressOffset>0x74</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>AUDIO_TX_BCLK_DIV</name>
          <displayName>AUDIO_TX_BCLK_DIV</displayName>
          <description></description>
          <addressOffset>0x80</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>26</bitWidth>
            </field>
            <field>
              <name>DUTY</name>
              <description>
              TX serial bit clock duty cycle
              5 for 48K FS
              4 for 44.1K FS
              5 for 32KFS
              10 for 24K FS
              8 for 22.05K FS
              15 for 16K FS
              20 for 12K FS
              16 for 11.025K FS
              30 for 8KFs
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD33</name>
          <displayName>RSVD33</displayName>
          <description></description>
          <addressOffset>0x84</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>AUDIO_TX_FORMAT</name>
          <displayName>AUDIO_TX_FORMAT</displayName>
          <description></description>
          <addressOffset>0x90</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>27</bitWidth>
            </field>
            <field>
              <name>PCM_DATA_WIDTH</name>
              <description>
              I2S out pcm data width
              M >= 16,
              common value: 16, 18, 20, 22, 24
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD32</name>
          <displayName>RSVD32</displayName>
          <description></description>
          <addressOffset>0x94</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>AUDIO_SERIAL_TIMING</name>
          <displayName>AUDIO_SERIAL_TIMING</displayName>
          <description></description>
          <addressOffset>0xa0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>28</bitWidth>
            </field>
            <field>
              <name>LRCK_POL</name>
              <description>
              TX LRCK polarity control.
              0: disable TX_LRCK inventor
              1: enable TX_LRCK inventor
              for standard I2S, set tx_lrck_pol to low
              for Left/Right Justified, set tx_lrck_pol to hgih
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SLAVE_EN</name>
              <description>
              audio code transmit mode select.
              0: master mode, 1: slave mode
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TIMING</name>
              <description>
              00: I2S mode
              01: Left justified
              10: right justified
              11: reserved
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD31</name>
          <displayName>RSVD31</displayName>
          <description></description>
          <addressOffset>0xA4</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>AUDIO_TX_FUNC_EN</name>
          <displayName>AUDIO_TX_FUNC_EN</displayName>
          <description></description>
          <addressOffset>0xb0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>31</bitWidth>
            </field>
            <field>
              <name>TX_EN</name>
              <description>
              1: enable 0:disable
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD30</name>
          <displayName>RSVD30</displayName>
          <description></description>
          <addressOffset>0xB4</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>AUDIO_TX_PAUSE</name>
          <displayName>AUDIO_TX_PAUSE</displayName>
          <description></description>
          <addressOffset>0xc0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>31</bitWidth>
            </field>
            <field>
              <name>TX_PAUSE</name>
              <description>
              TX pause control when tx_enable = 1.
              1: pause
              0: TX work
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD29</name>
          <displayName>RSVD29</displayName>
          <description></description>
          <addressOffset>0xC4</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>AUDIO_I2S_SL_MERGE</name>
          <displayName>AUDIO_I2S_SL_MERGE</displayName>
          <description></description>
          <addressOffset>0xc8</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>31</bitWidth>
            </field>
            <field>
              <name>SLAVE_TIMING_MERGE</name>
              <description>
              when work as an I2S slave, and external I2S master TX/RX share an only BCLK/LRCK, we need set this bit high.
              0: I2S slave use separated timing control port. TX_BCLK_IN/TX_LRCK_IN and RX_BCLK/RX_LRCK_IN are separated.
              1: I2S slave use the same BCLK/LRCK, the TX_BCLK_IN/TX_LRCK also is used for RX controller.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD28</name>
          <displayName>RSVD28</displayName>
          <description></description>
          <addressOffset>0xCC</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>AUDIO_RX_FUNC_EN</name>
          <displayName>AUDIO_RX_FUNC_EN</displayName>
          <description></description>
          <addressOffset>0x100</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>31</bitWidth>
            </field>
            <field>
              <name>RX_EN</name>
              <description>
              1: enable  0: disable
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD27</name>
          <displayName>RSVD27</displayName>
          <description></description>
          <addressOffset>0x104</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>AUDIO_RX_PAUSE</name>
          <displayName>AUDIO_RX_PAUSE</displayName>
          <description></description>
          <addressOffset>0x110</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>31</bitWidth>
            </field>
            <field>
              <name>RX_PAUSE</name>
              <description>
              RX pause control when rx_enable = 1.
              1: pause
              0: RX work
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD26</name>
          <displayName>RSVD26</displayName>
          <description></description>
          <addressOffset>0x114</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>AUDIO_RX_SERIAL_TIMING</name>
          <displayName>AUDIO_RX_SERIAL_TIMING</displayName>
          <description></description>
          <addressOffset>0x120</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00040000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>28</bitWidth>
            </field>
            <field>
              <name>LRCK_POL</name>
              <description>
              RX LRCK polarity control.
              0: disable RX_LRCK inventor
              1: enable RX_LRCK inventor
              for standard I2S, set tx_lrck_pol to low
              for Left/Right Justified, set tx_lrck_pol to hgih
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SLAVE_EN</name>
              <description>
              audio code receiver mode select.
              0: master mode, 1: slave mode
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TIMING</name>
              <description>
              00: I2S
              01: Left justified
              10: right justified
              11: reserved
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD25</name>
          <displayName>RSVD25</displayName>
          <description></description>
          <addressOffset>0x124</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>AUDIO_RX_PCM_DW</name>
          <displayName>AUDIO_RX_PCM_DW</displayName>
          <description></description>
          <addressOffset>0x130</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000010</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>27</bitWidth>
            </field>
            <field>
              <name>PCM_DATA_WIDTH</name>
              <description>
              For I2S and left justified mode, M can be 8,13,14,16
              For right justified mode, M can be 8, 13, 14, 16, 18, 20, 22, 24
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD24</name>
          <displayName>RSVD24</displayName>
          <description></description>
          <addressOffset>0x134</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>AUDIO_RX_LRCK_DIV</name>
          <displayName>AUDIO_RX_LRCK_DIV</displayName>
          <description></description>
          <addressOffset>0x140</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x007D007D</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>DUTY_HIGH</name>
              <description>
              RX LRCK duty cycle high:
              125 for 48K FS
              136 for 44.1K FS
              185 for 32K FS
              250 for 24K FS
              272 for 22.05K FS
              375 for 16K FS
              500 for 12K FS
              544 for 11.025K FS
              750 for 8K FS      
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>DUTY_LOW</name>
              <description>
              RX LRCK duty cycle low:
              125 for 48K FS
              136 for 44.1K FS
              190 for 32K FS
              250 for 24K FS
              272 for 22.05K FS
              375 for 16K FS
              500 for 12K FS
              544 for 11.025K FS
              750 for 8K FS
              Note:
              1)duty_cycle = 12M/FS
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD23</name>
          <displayName>RSVD23</displayName>
          <description></description>
          <addressOffset>0x144</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>AUDIO_RX_BCLK_DIV</name>
          <displayName>AUDIO_RX_BCLK_DIV</displayName>
          <description></description>
          <addressOffset>0x150</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000005</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>22</bitWidth>
            </field>
            <field>
              <name>DUTY</name>
              <description>
              RX serial bit clock duty cycle
              5 for 48K FS
              4 for 44.1K FS
              5 for 32KFS
              10 for 24K FS
              8 for 22.05K FS
              15 for 16K FS
              20 for 12K FS
              16 for 11.025K FS
              30 for 8KFs
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD22</name>
          <displayName>RSVD22</displayName>
          <description></description>
          <addressOffset>0x154</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>RECORD_DATA_SEL</name>
          <displayName>RECORD_DATA_SEL</displayName>
          <description></description>
          <addressOffset>0x160</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>31</bitWidth>
            </field>
            <field>
              <name>RS_DATA_SEL</name>
              <description>
              0: I2S audio recording  1: BT recording
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD21</name>
          <displayName>RSVD21</displayName>
          <description></description>
          <addressOffset>0x164</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>RX_RE_SAMPLE_CLK_DIV</name>
          <displayName>RX_RE_SAMPLE_CLK_DIV</displayName>
          <description></description>
          <addressOffset>0x170</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0000007D</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>19</bitWidth>
            </field>
            <field>
              <name>RS_DUTY</name>
              <description>
              source PCM sample clock duty cycle:
              250 for 48K FS
              272 for 44.1K FS
              375 for 32K FS
              500 for 24K FS
              544 for 22.05K FS
              750 for 16K FS
              1000 for 12K FS
              1088 for 11.025K FS
              1500 for 8K FS
              Note:
              1)duty_cycle = 12M/FS      
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>13</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD20</name>
          <displayName>RSVD20</displayName>
          <description></description>
          <addressOffset>0x174</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>RX_RE_SAMPLE</name>
          <displayName>RX_RE_SAMPLE</displayName>
          <description></description>
          <addressOffset>0x180</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>31</bitWidth>
            </field>
            <field>
              <name>SMOOTH_EN</name>
              <description>
              0: Disable RX re-sample smooth filter
              1: Enable RX re-sample smooth filter
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD19</name>
          <displayName>RSVD19</displayName>
          <description></description>
          <addressOffset>0x184</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>RECORD_FORMAT</name>
          <displayName>RECORD_FORMAT</displayName>
          <description></description>
          <addressOffset>0x190</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>30</bitWidth>
            </field>
            <field>
              <name>TRACK</name>
              <description>
              1: mono recording, 0: stereo recording
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DW</name>
              <description>
              0: 8bit 1: 16bit
              RX fifo data format:
                   Mono 8 bit (unsigned): RX FIFO_DIN[31:0] = {L3,L2,L1,L0}, each four samples need one FIFO write operation
                  Stereo 8 bit (unsigned): RX_FIFO_DIN[31:0] = {R1,L1,R0,L0}, each tow samples need one FIFO write operation
                  Mono 16 bit (Signed 2's complement): RX_FIFO_DIN[31:0] = {L1,L0}, each two samples need one FIFO write operation
                  Stereo 16 bit (Signed 2's complement): RX_FIFO_DIN[31:0] = {R0,L0}, each sample need one FIFO write operation
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD18</name>
          <displayName>RSVD18</displayName>
          <description></description>
          <addressOffset>0x194</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>RX_CH_SEL</name>
          <displayName>RX_CH_SEL</displayName>
          <description></description>
          <addressOffset>0x1a0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>28</bitWidth>
            </field>
            <field>
              <name>LEFT_CHANNEL_SEL</name>
              <description>
              RX re-sampling module setting:
              00: RD left = RX left
              01: RD left = RX right
              10,11: RD left = (RX left + RX right)/2
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RIGHT_CHANNEL_SEL</name>
              <description>
              RX re-sampling module setting:
              00: RD right = RX right
              01: RD right = RX left
              10,11: RD right = (RX left + RX right)/2
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD17</name>
          <displayName>RSVD17</displayName>
          <description></description>
          <addressOffset>0x1A4</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>BT_PHONE_CTRL</name>
          <displayName>BT_PHONE_CTRL</displayName>
          <description></description>
          <addressOffset>0x200</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>26</bitWidth>
            </field>
            <field>
              <name>BB_I2S_BPS_TO_CDC</name>
              <description>
              bypass baseband I2S interface to audio codec i2s interface
              0: no bypass, 1: bypass
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BT_PCM_IF_BPS</name>
              <description>
              bypass baseband PCM signals to BT VCI master:
              0: no bypass, 1: bypass
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BT_PATH_SEL</name>
              <description>
               BT path select
              0: digital path, 1: analog path
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BT_MIX_SMOOTH_FILTER_EN</name>
              <description>
              0: disable the smooth filter for background mixer
              1: enable the smooth filer for background mixer
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BT_BACK_MIX_EN</name>
              <description>
               background mixer enable
              0: disable, 1: enable
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BT_PH_EN</name>
              <description>
              BT phone enable
              0: disable, 1: enable
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD16</name>
          <displayName>RSVD16</displayName>
          <description></description>
          <addressOffset>0x204</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>BB_PCM_FORMAT</name>
          <displayName>BB_PCM_FORMAT</displayName>
          <description></description>
          <addressOffset>0x210</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>21</bitWidth>
            </field>
            <field>
              <name>PCM_CLK_POL</name>
              <description>
              input BB pcm clock polarity:
              0: rising edge for data transmitting, falling edge for data receiving
              1: rising edge for data receiving, falling edge for data transmitting
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>I2S_LRCK_POL</name>
              <description>
              0: no bb_i2s_lrck input inventor
              1: enable bb_i2s_lrck input inventor
              for standard I2S, set tx_lrck_pol to low
              for Left/Right Justified, set tx_lrck_pol to high
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PCM_LSB_FLAG</name>
              <description>
              Serial PCM data bit sequence.
              0: MSB first, 1: LSB first
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PCM_SYNC_FLAG</name>
              <description>
              0: short sync, 1: long sync
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PCM_TIM_SEL</name>
              <description>
              00: I2S timing, 01: Left Justified
              10: Right Justified, 11: PCM timing
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>PCM_DW</name>
              <description>
              Baseband Master PCM data width (>=8)
              Common value: 8, 13,14, 16, 18, 20, 22, 24.
              for I2S/Left Justified/Right Kistified timing, bb_pcm_dw >=16
              For PCM timing, only 8, 13, 14, 16 configure value is available.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD15</name>
          <displayName>RSVD15</displayName>
          <description></description>
          <addressOffset>0x214</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>BT_PCM_DW</name>
          <displayName>BT_PCM_DW</displayName>
          <description></description>
          <addressOffset>0x220</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000010</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>27</bitWidth>
            </field>
            <field>
              <name>DW</name>
              <description>
              BT PCM master data width (>= 8),
              common value: 8, 13,14, 16
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD14</name>
          <displayName>RSVD14</displayName>
          <description></description>
          <addressOffset>0x224</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>BT_PCM_TIMING</name>
          <displayName>BT_PCM_TIMING</displayName>
          <description></description>
          <addressOffset>0x230</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>29</bitWidth>
            </field>
            <field>
              <name>CLK_POL</name>
              <description>
              BT PCM master output pcm clock polarity:
              0: rising edge for data transmitting, falling edge for data receiving
              1: rising edge for data receiving, falling edge for data transmitting
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SYNC_FLAG</name>
              <description>
              0: short sync, 1: long sync
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LSB_FLAG</name>
              <description>
              Serial PCM data bit sequence.
              0: MSB first, 1: LSB first
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD13</name>
          <displayName>RSVD13</displayName>
          <description></description>
          <addressOffset>0x234</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>BT_PCM_CLK_DUTY</name>
          <displayName>BT_PCM_CLK_DUTY</displayName>
          <description></description>
          <addressOffset>0x240</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>22</bitWidth>
            </field>
            <field>
              <name>CLK_DUTY</name>
              <description>
              BT_PCM_CLK duty cycle
              &lt;= (GCLK/(bt_pcm_sync*bt_pcm_dw))
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD12</name>
          <displayName>RSVD12</displayName>
          <description></description>
          <addressOffset>0x244</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>BT_PCM_SYNC_DUTY</name>
          <displayName>BT_PCM_SYNC_DUTY</displayName>
          <description></description>
          <addressOffset>0x250</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>26</bitWidth>
            </field>
            <field>
              <name>SYNC_DUTY</name>
              <description>
              PCM_SYNC duty cycle  (bt_pcm_sync frequency =  bt_pclk_clk/bt_pcm_sync_duty)
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD11</name>
          <displayName>RSVD11</displayName>
          <description></description>
          <addressOffset>0x254</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>BT_VOL_CTRL</name>
          <displayName>BT_VOL_CTRL</displayName>
          <description></description>
          <addressOffset>0x260</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>28</bitWidth>
            </field>
            <field>
              <name>VOL_ADJ_EN</name>
              <description>
              BT volume adjust enable
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>VOL</name>
              <description>
              BT master volume
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD10</name>
          <displayName>RSVD10</displayName>
          <description></description>
          <addressOffset>0x264</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>INT_MASK</name>
          <displayName>INT_MASK</displayName>
          <description></description>
          <addressOffset>0x300</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000003</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>30</bitWidth>
            </field>
            <field>
              <name>TX_FIFO_INT_MASK</name>
              <description>
              Interrupt mask for TX FIFO pop underflow, high active
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RX_FIFO_INT_MASK</name>
              <description>
              Interrupt mask for RX FIFO push overflow, high active
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD9</name>
          <displayName>RSVD9</displayName>
          <description></description>
          <addressOffset>0x304</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>INT_STATUS</name>
          <displayName>INT_STATUS</displayName>
          <description></description>
          <addressOffset>0x310</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>30</bitWidth>
            </field>
            <field>
              <name>TX_FIFO_UNDERFLOW</name>
              <description>
              TX FIFO pop underflow
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RX_FIFO_OVERFLOW</name>
              <description>
              RX FIFO push overflow
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD8</name>
          <displayName>RSVD8</displayName>
          <description></description>
          <addressOffset>0x314</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>TX_DMA_ENTRY</name>
          <displayName>TX_DMA_ENTRY</displayName>
          <description></description>
          <addressOffset>0x400</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>TX_DMA_ENTRY</name>
              <description>
              TX DMA entry
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD7</name>
          <displayName>RSVD7</displayName>
          <description></description>
          <addressOffset>0x404</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>RX_DMA_ENTRY</name>
          <displayName>RX_DMA_ENTRY</displayName>
          <description></description>
          <addressOffset>0x440</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RX_DMA_ENTRY</name>
              <description>
              RX DMA entry
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD6</name>
          <displayName>RSVD6</displayName>
          <description></description>
          <addressOffset>0x444</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>DMA_MASK</name>
          <displayName>DMA_MASK</displayName>
          <description></description>
          <addressOffset>0x480</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000003</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>30</bitWidth>
            </field>
            <field>
              <name>TX_DMA_MASK</name>
              <description>
              TX DMA mask enable:1: mask0: do not mask
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RX_DMA_MASK</name>
              <description>
              RX DMA mask enable:1: mask0: do not mask
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD5</name>
          <displayName>RSVD5</displayName>
          <description></description>
          <addressOffset>0x484</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>DEBUG_LOOP</name>
          <displayName>DEBUG_LOOP</displayName>
          <description></description>
          <addressOffset>0x500</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>30</bitWidth>
            </field>
            <field>
              <name>AD2DA_LOOP_BACK</name>
              <description>
              RX-->TX Loop debug control:
              0: disable
              1: enable, internally connect RX Resampled PCM to TX Resample PCM input
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DA2AD_LOOP_BACK</name>
              <description>
              TX-->RX Loop debug control:
              0: disable
              1: enable, internally connect TX SDTO to RX SDTI
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD4</name>
          <displayName>RSVD4</displayName>
          <description></description>
          <addressOffset>0x504</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>FIFO_STATUS</name>
          <displayName>FIFO_STATUS</displayName>
          <description></description>
          <addressOffset>0x600</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>FIFO_STATUS_OUT</name>
              <description>
              FIFO Status output:
               Bit [7:0] = {tx_full,tx_empty,tx_almost_full,tx_almost_empty,rx_full,rx_empty,rx_almost_full,rx_almost_empty}
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD3</name>
          <displayName>RSVD3</displayName>
          <description></description>
          <addressOffset>0x604</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>TX_EQUALIZER_EN</name>
          <displayName>TX_EQUALIZER_EN</displayName>
          <description></description>
          <addressOffset>0x700</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>31</bitWidth>
            </field>
            <field>
              <name>TX_EQUALIZER_EN</name>
              <description>
              0: Disable TX equalizer
              1: Enable TX equalizer
              equalizer is not implemented
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD2</name>
          <displayName>RSVD2</displayName>
          <description></description>
          <addressOffset>0x704</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>TX_EQUALIZER_GAIN1</name>
          <displayName>TX_EQUALIZER_GAIN1</displayName>
          <description></description>
          <addressOffset>0x710</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>BAND6_GAIN</name>
              <description>
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>BAND5_GAIN</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>BAND4_GAIN</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>BAND3_GAIN</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>BAND2_GAIN</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>BAND1_GAIN</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD1</name>
          <displayName>RSVD1</displayName>
          <description></description>
          <addressOffset>0x714</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>TX_EQUALIZER_GAIN2</name>
          <displayName>TX_EQUALIZER_GAIN2</displayName>
          <description></description>
          <addressOffset>0x720</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
            <field>
              <name>BAND10_GAIN</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>BAND9_GAIN</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>BAND8_GAIN</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>BAND7_GAIN</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>HPSYS_CFG</name>
      <description></description>
      <groupName>HPSYS_CFG</groupName>
      <baseAddress>0x4000b000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>BMR</name>
          <displayName>BMR</displayName>
          <description>Boot Mode Register</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>31</bitWidth>
            </field>
            <field>
              <name>BOOT_MODE</name>
              <description>
              0 - normal, 1 - download mode
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IDR</name>
          <displayName>IDR</displayName>
          <description>ID Register</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>SID</name>
              <description>
              Series ID
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>CID</name>
              <description>
              Chip ID
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>PID</name>
              <description>
              Package ID
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>REVID</name>
              <description>
              ECO Revision ID
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SCR</name>
          <displayName>SCR</displayName>
          <description>Security Control Register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>31</bitWidth>
            </field>
            <field>
              <name>FKEY_MODE</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>USBCR</name>
          <displayName>USBCR</displayName>
          <description>USB Control register</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD1</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>RSVD0</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>DC_TR</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>DC_TE</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TX_RTUNE</name>
              <description>
              TX outp impedance tuning
              0 = 50 Ohm, 1 = 46 Ohm, 2 = 43 Ohm, 3 = 40 Ohm, 4 = 37.5 Ohm, 5 = 35 Ohm, 6 = 33 Ohm, 7 = 31.5 Ohm
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>DM_PD</name>
              <description>
              enable DM 15k Ohm pull down resistor 
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LDO_LP_EN</name>
              <description>
              2.5V LDO low power mode enable. 0 = 240 uA, 1 = 50 uA
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LDO_VSEL</name>
              <description>
              2.5V LDO output voltage setting
              0 = 2.40 V, 1 = 2.47 V, 2 = 2.53 V, 3 = 2.60 V, 4 = 2.60 V, 5 = 2.67 V, 6 = 2.73 V, 7 = 2.8 V
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>USB_EN</name>
              <description>
              USB PHY enable, turn on power swith, power up LDO and bias 
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>MCR</name>
          <displayName>MCR</displayName>
          <description>Memory Control register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>FORCE_ON</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>21</bitWidth>
            </field>
            <field>
              <name>PD_OTHER</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PD_RAM5</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PD_RAM4</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PD_RAM3</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PD_RAM2</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PD_RAM1</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PD_RAM0</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PD_CACHE</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PD_ITCM</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PD_ROM</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ULPMCR</name>
          <displayName>ULPMCR</displayName>
          <description>ULP Memory Control register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>FORCE_ON</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>18</bitWidth>
            </field>
            <field>
              <name>WPULSE</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>WA</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RA</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RME</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RM</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RTC_TR</name>
          <displayName>RTC_TR</displayName>
          <description>Mirrored RTC Time Register</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>PM</name>
              <description>
              AM/PM notation
              0: AM
              1: PM
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HT</name>
              <description>
              Hour tens in BCD format
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>HU</name>
              <description>
              Hour units in BCD format
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>MNT</name>
              <description>
              Minute tens in BCD format
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>MNU</name>
              <description>
              Minute units in BCD format
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>ST</name>
              <description>
              Second tens in BCD format
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>SU</name>
              <description>
              Second units in BCD format
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SS</name>
              <description>
              Sub-second counter
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RTC_DR</name>
          <displayName>RTC_DR</displayName>
          <description>Mirrored RTC Date Register</description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>ERR</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>CB</name>
              <description>
              Century flag
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>YT</name>
              <description>
              Year tens in BCD format
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>YU</name>
              <description>
              Year units in BCD format
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>WD</name>
              <description>
              Week day units
              000: forbidden
              001: Monday
              ...
              111: Sunday
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>MT</name>
              <description>
              Month tens in BCD format
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MU</name>
              <description>
              Month units in BCD format
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>DT</name>
              <description>
              Date tens in BCD format
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>DU</name>
              <description>
              Date units in BCD format
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DBGR</name>
          <displayName>DBGR</displayName>
          <description>Debug Select Register</description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>BITEN_H</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>SEL_H</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>BITEN_L</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>SEL_L</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CAU2_ATEST</name>
          <displayName>CAU2_ATEST</displayName>
          <description>CAU2 ATEST Register</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>DC_MR</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>DC_BR</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>DC_TR</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CAU2_RSVD1</name>
          <displayName>CAU2_RSVD1</displayName>
          <description>CAU2 RSVD Register1</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>RESERVE2</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>RESERVE1</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>RESERVE0</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CAU2_RSVD2</name>
          <displayName>CAU2_RSVD2</displayName>
          <description>CAU2 RSVD Register2</description>
          <addressOffset>0x2c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>RESERVE5</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>RESERVE4</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>RESERVE3</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD1</name>
          <displayName>RSVD1</displayName>
          <description></description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>SYS_RSVD</name>
          <displayName>SYS_RSVD</displayName>
          <description>HPSYS RSVD Register</description>
          <addressOffset>0x34</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RESERVE3</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>RESERVE2</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>RESERVE1</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>RESERVE0</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>EFUSEC</name>
      <description></description>
      <groupName>EFUSEC</groupName>
      <baseAddress>0x4000c000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CR</name>
          <displayName>CR</displayName>
          <description>Control Register</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>27</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Interrupt enable
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BANKSEL</name>
              <description>
              Bank select
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>MODE</name>
              <description>
              0 - READ, 1 - PGM
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EN</name>
              <description>
              Write 1 to enable PGM/READ. Self clear
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TIMR</name>
          <displayName>TIMR</displayName>
          <description>Timer Register</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
            <field>
              <name>TCKHP</name>
              <description>
              SCLK high period for PGM. Recommended value  ~10us
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
            <field>
              <name>THPCK</name>
              <description>
              SCLK to CSB hold time into PGM mode. Recommended value > 20ns
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>THRCK</name>
              <description>
              SCLK to CSB hold time into READ mode. Recmmended value > 500ns
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SR</name>
          <displayName>SR</displayName>
          <description>Status Register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>31</bitWidth>
            </field>
            <field>
              <name>DONE</name>
              <description>
              Indicates PGM/READ done. Write 1 to clear
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVDR</name>
          <displayName>RSVDR</displayName>
          <description>Reserved Register</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PGM_DATA0</name>
          <displayName>PGM_DATA0</displayName>
          <description>Program Data0</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PGM_DATA1</name>
          <displayName>PGM_DATA1</displayName>
          <description>Program Data1</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PGM_DATA2</name>
          <displayName>PGM_DATA2</displayName>
          <description>Program Data2</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PGM_DATA3</name>
          <displayName>PGM_DATA3</displayName>
          <description>Program Data3</description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PGM_DATA4</name>
          <displayName>PGM_DATA4</displayName>
          <description>Program Data4</description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PGM_DATA5</name>
          <displayName>PGM_DATA5</displayName>
          <description>Program Data5</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PGM_DATA6</name>
          <displayName>PGM_DATA6</displayName>
          <description>Program Data6</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PGM_DATA7</name>
          <displayName>PGM_DATA7</displayName>
          <description>Program Data7</description>
          <addressOffset>0x2c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BANK0_DATA0</name>
          <displayName>BANK0_DATA0</displayName>
          <description>Bank0 Data0</description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BANK0_DATA1</name>
          <displayName>BANK0_DATA1</displayName>
          <description>Bank0 Data1</description>
          <addressOffset>0x34</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BANK0_DATA2</name>
          <displayName>BANK0_DATA2</displayName>
          <description>Bank0 Data2</description>
          <addressOffset>0x38</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BANK0_DATA3</name>
          <displayName>BANK0_DATA3</displayName>
          <description>Bank0 Data3</description>
          <addressOffset>0x3c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BANK0_DATA4</name>
          <displayName>BANK0_DATA4</displayName>
          <description>Bank0 Data4</description>
          <addressOffset>0x40</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BANK0_DATA5</name>
          <displayName>BANK0_DATA5</displayName>
          <description>Bank0 Data5</description>
          <addressOffset>0x44</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BANK0_DATA6</name>
          <displayName>BANK0_DATA6</displayName>
          <description>Bank0 Data6</description>
          <addressOffset>0x48</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BANK0_DATA7</name>
          <displayName>BANK0_DATA7</displayName>
          <description>Bank0 Data7</description>
          <addressOffset>0x4c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BANK1_DATA0</name>
          <displayName>BANK1_DATA0</displayName>
          <description>Bank1 Data0</description>
          <addressOffset>0x50</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BANK1_DATA1</name>
          <displayName>BANK1_DATA1</displayName>
          <description>Bank1 Data1</description>
          <addressOffset>0x54</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BANK1_DATA2</name>
          <displayName>BANK1_DATA2</displayName>
          <description>Bank1 Data2</description>
          <addressOffset>0x58</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BANK1_DATA3</name>
          <displayName>BANK1_DATA3</displayName>
          <description>Bank1 Data3</description>
          <addressOffset>0x5c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BANK1_DATA4</name>
          <displayName>BANK1_DATA4</displayName>
          <description>Bank1 Data4</description>
          <addressOffset>0x60</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BANK1_DATA5</name>
          <displayName>BANK1_DATA5</displayName>
          <description>Bank1 Data5</description>
          <addressOffset>0x64</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BANK1_DATA6</name>
          <displayName>BANK1_DATA6</displayName>
          <description>Bank1 Data6</description>
          <addressOffset>0x68</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BANK1_DATA7</name>
          <displayName>BANK1_DATA7</displayName>
          <description>Bank1 Data7</description>
          <addressOffset>0x6c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BANK2_DATA0</name>
          <displayName>BANK2_DATA0</displayName>
          <description>Bank2 Data0</description>
          <addressOffset>0x70</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BANK2_DATA1</name>
          <displayName>BANK2_DATA1</displayName>
          <description>Bank2 Data1</description>
          <addressOffset>0x74</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BANK2_DATA2</name>
          <displayName>BANK2_DATA2</displayName>
          <description>Bank2 Data2</description>
          <addressOffset>0x78</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BANK2_DATA3</name>
          <displayName>BANK2_DATA3</displayName>
          <description>Bank2 Data3</description>
          <addressOffset>0x7c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BANK2_DATA4</name>
          <displayName>BANK2_DATA4</displayName>
          <description>Bank2 Data4</description>
          <addressOffset>0x80</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BANK2_DATA5</name>
          <displayName>BANK2_DATA5</displayName>
          <description>Bank2 Data5</description>
          <addressOffset>0x84</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BANK2_DATA6</name>
          <displayName>BANK2_DATA6</displayName>
          <description>Bank2 Data6</description>
          <addressOffset>0x88</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BANK2_DATA7</name>
          <displayName>BANK2_DATA7</displayName>
          <description>Bank2 Data7</description>
          <addressOffset>0x8c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BANK3_DATA0</name>
          <displayName>BANK3_DATA0</displayName>
          <description>Bank3 Data0</description>
          <addressOffset>0x90</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BANK3_DATA1</name>
          <displayName>BANK3_DATA1</displayName>
          <description>Bank3 Data1</description>
          <addressOffset>0x94</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BANK3_DATA2</name>
          <displayName>BANK3_DATA2</displayName>
          <description>Bank3 Data2</description>
          <addressOffset>0x98</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BANK3_DATA3</name>
          <displayName>BANK3_DATA3</displayName>
          <description>Bank3 Data3</description>
          <addressOffset>0x9c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BANK3_DATA4</name>
          <displayName>BANK3_DATA4</displayName>
          <description>Bank3 Data4</description>
          <addressOffset>0xa0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BANK3_DATA5</name>
          <displayName>BANK3_DATA5</displayName>
          <description>Bank3 Data5</description>
          <addressOffset>0xa4</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BANK3_DATA6</name>
          <displayName>BANK3_DATA6</displayName>
          <description>Bank3 Data6</description>
          <addressOffset>0xa8</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BANK3_DATA7</name>
          <displayName>BANK3_DATA7</displayName>
          <description>Bank3 Data7</description>
          <addressOffset>0xac</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ANACR</name>
          <displayName>ANACR</displayName>
          <description>Bank3 Data7</description>
          <addressOffset>0xb0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RESERVE1</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>RESERVE0</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>LDO_DC_TR</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>LDO_MODE</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LDO_VREF_SEL</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>LDO_EN</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>AES</name>
      <description></description>
      <groupName>AES</groupName>
      <baseAddress>0x4000d000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>COMMAND</name>
          <displayName>COMMAND</displayName>
          <description></description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>29</bitWidth>
            </field>
            <field>
              <name>AUTO_GATE</name>
              <description>
              auto clock gating
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>AES_ACC_RESET</name>
              <description>
              AES_ACC soft reset, 1'h1: reset the AES_ACC block
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>START</name>
              <description>
              write 1 to trigger the AES_ACC block
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS</name>
          <displayName>STATUS</displayName>
          <description></description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>30</bitWidth>
            </field>
            <field>
              <name>FLASH_KEY_VALID</name>
              <description>
              flash key valid indicator
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BUSY</name>
              <description>
              AES_ACC block is busy
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IRQ</name>
          <displayName>IRQ</displayName>
          <description></description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>13</bitWidth>
            </field>
            <field>
              <name>SETUP_ERR_RAW_STAT</name>
              <description>
              setup error raw status
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BUS_ERR_RAW_STAT</name>
              <description>
              bus error raw status
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DONE_RAW_STAT</name>
              <description>
              done raw status
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>13</bitWidth>
            </field>
            <field>
              <name>SETUP_ERR_STAT</name>
              <description>
              setup error status
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BUS_ERR_STAT</name>
              <description>
              bus error status
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DONE_STAT</name>
              <description>
              done status
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SETTING</name>
          <displayName>SETTING</displayName>
          <description></description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>29</bitWidth>
            </field>
            <field>
              <name>SETUP_ERR_IRQ_MASK</name>
              <description>
              setup error interrupt mask, 0: mask the interrupt
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BUS_ERR_IRQ_MASK</name>
              <description>
              bus error interrupt mask, 0: mask the interrupt
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DONE_IRQ_MASK</name>
              <description>
              done interrupt mask, 0: mask the interrupt
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>AES_SETTING</name>
          <displayName>AES_SETTING</displayName>
          <description></description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>AES_BYPASS</name>
              <description>
              1'h0: normal operation
              1'h1: bypass
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>AES_OP_MODE</name>
              <description>
              1'h0: decryption
              1'h1: encryption
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ALGO_STANDARD</name>
              <description>
              1'h0: AES
              1'h1: SM4
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>KEY_SEL</name>
              <description>
              1'h0: select key from AES_ACC key registers
              1'h1: use internal root key
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>AES_LENGTH</name>
              <description>
              AES Length:
              2'h0: 128-bit
              2'h1: 192-bit
              2'h2: 256-bit
              2'h3: Reserved
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>AES_MODE</name>
              <description>
              AES Mode:
              3'h0: ECB
              3'h1: CTR
              3'h2: CBC
              Others: Reserved
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DMA_IN</name>
          <displayName>DMA_IN</displayName>
          <description></description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ADDR</name>
              <description>
              input data address
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DMA_OUT</name>
          <displayName>DMA_OUT</displayName>
          <description></description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ADDR</name>
              <description>
              output data address
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DMA_DATA</name>
          <displayName>DMA_DATA</displayName>
          <description></description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>SIZE</name>
              <description>
              data block size, AES_ACC only support block aligned transaction. Each block contains 16 bytes.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>28</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IV_W0</name>
          <displayName>IV_W0</displayName>
          <description></description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              Initial Vector Word0
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IV_W1</name>
          <displayName>IV_W1</displayName>
          <description></description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              Initial Vector Word1
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IV_W2</name>
          <displayName>IV_W2</displayName>
          <description></description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              Initial Vector Word2
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IV_W3</name>
          <displayName>IV_W3</displayName>
          <description></description>
          <addressOffset>0x2c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              Initial Vector Word3
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>EXT_KEY_W0</name>
          <displayName>EXT_KEY_W0</displayName>
          <description></description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              External Key Word0
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>EXT_KEY_W1</name>
          <displayName>EXT_KEY_W1</displayName>
          <description></description>
          <addressOffset>0x34</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              External Key Word1
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>EXT_KEY_W2</name>
          <displayName>EXT_KEY_W2</displayName>
          <description></description>
          <addressOffset>0x38</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              External Key Word2
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>EXT_KEY_W3</name>
          <displayName>EXT_KEY_W3</displayName>
          <description></description>
          <addressOffset>0x3c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              External Key Word3
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>EXT_KEY_W4</name>
          <displayName>EXT_KEY_W4</displayName>
          <description></description>
          <addressOffset>0x40</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              External Key Word4
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>EXT_KEY_W5</name>
          <displayName>EXT_KEY_W5</displayName>
          <description></description>
          <addressOffset>0x44</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              External Key Word5
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>EXT_KEY_W6</name>
          <displayName>EXT_KEY_W6</displayName>
          <description></description>
          <addressOffset>0x48</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              External Key Word6
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>EXT_KEY_W7</name>
          <displayName>EXT_KEY_W7</displayName>
          <description></description>
          <addressOffset>0x4c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              External Key Word7
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>CRC</name>
      <description></description>
      <groupName>CRC</groupName>
      <baseAddress>0x4000e000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>DR</name>
          <displayName>DR</displayName>
          <description>Data register</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>DR</name>
              <description>
              Data register bits.
              This register is used to write new data to the CRC calculator.
              It holds the previous CRC calculation result when it is read.
              If the data size is less than 32 bits, the least significant bits are used to write/read the correct value.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SR</name>
          <displayName>SR</displayName>
          <description>Status register</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>30</bitWidth>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>
              Overflow when new data arrive while last calculation not done yet
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DONE</name>
              <description>
              Done flag. When DR written, done flag will be cleared automatically. The flag will assert after CRC operation of current DR finished.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CR</name>
          <displayName>CR</displayName>
          <description>Control register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>REV_OUT</name>
              <description>
              Reverse output data
              This bit controls the reversal of the bit order of the output data.
              0: Bit order not affected
              1: Bit-reversed output format
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>REV_IN</name>
              <description>
              Reverse input data
              These bits control the reversal of the bit order of the input data
              00: Bit order not affected
              01: Bit reversal done by byte
              10: Bit reversal done by half-word
              11: Bit reversal done by word
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>POLYSIZE</name>
              <description>
              Polynomial size
              These bits control the size of the polynomial.
              00: 32 bit polynomial
              01: 16 bit polynomial
              10: 8 bit polynomial
              11: 7 bit polynomial
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>DATASIZE</name>
              <description>
              Valid input data size
              These bits control the valid size of the input data.
              00: lower 8-bit
              01: lower 16-bit
              10: lower 24-bit
              11: all 32-bit
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RESET</name>
              <description>
              This bit is set by software to reset the CRC calculation unit and set the data register to the value stored in the CRC_INIT register. This bit can only be set, it is automatically cleared by hardware
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD1</name>
          <displayName>RSVD1</displayName>
          <description></description>
          <addressOffset>0xC</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>INIT</name>
          <displayName>INIT</displayName>
          <description>Initial CRC value</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>INIT</name>
              <description>
              Programmable initial CRC value
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>POL</name>
          <displayName>POL</displayName>
          <description>CRC polynomial</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>POL</name>
              <description>
              Programmable polynomial 
              This register is used to write the coefficients of the polynomial to be used for CRC calculation.
              If the polynomial size is less than 32 bits, the least significant bits have to be used to program the correct value.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>TRNG</name>
      <description></description>
      <groupName>TRNG</groupName>
      <baseAddress>0x4000f000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTRL</name>
          <displayName>CTRL</displayName>
          <description></description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>27</bitWidth>
            </field>
            <field>
              <name>GEN_RAND_NUM_SUSPEND</name>
              <description>
              Set 1 to suspend random number generation and update. Set 0 to recover the process.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GEN_RAND_NUM_STOP</name>
              <description>
              Set 1 to stop random number generation and update. This will reset the random number generation engine. After release the stop bit, user should write 1 to gen_rand_num_start to trigger the random number engine.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GEN_SEED_STOP</name>
              <description>
              Set 1 to stop random seed generation. This will reset the random seed generation engine. After release the stop bit, user should write 1 to gen_seed_start to trigger the random seed engine.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GEN_RAND_NUM_START</name>
              <description>
              write 1 to trigger the random number generation engine
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GEN_SEED_START</name>
              <description>
              write 1 to trigger the random seed generation engine
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>STAT</name>
          <displayName>STAT</displayName>
          <description></description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>28</bitWidth>
            </field>
            <field>
              <name>RAND_NUM_VALID</name>
              <description>
              random number valid flag
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RAND_NUM_GEN_BUSY</name>
              <description>
              random number engine busy flag
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SEED_VALID</name>
              <description>
              random seed valid flag
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SEED_GEN_BUSY</name>
              <description>
              random seed engine busy flag
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CFG</name>
          <displayName>CFG</displayName>
          <description></description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>REJECT_THRESHOLD</name>
              <description>
              random seed internal VN corrector check threshold
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>USE_EXT_SEED</name>
              <description>
              set 1 to use external seed to generate random number
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>AUTO_CLOCK_ENABLE</name>
              <description>
              auto clock gating enable
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IRQ</name>
          <displayName>IRQ</displayName>
          <description></description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00070000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>13</bitWidth>
            </field>
            <field>
              <name>PRNG_LOCKUP_MSK</name>
              <description>
              prng lockup interrupt mask
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RAND_NUM_AVAIL_MSK</name>
              <description>
              random number available interrupt mask
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SEED_GEN_DONE_MSK</name>
              <description>
              random seed generation done interrupt mask
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>13</bitWidth>
            </field>
            <field>
              <name>PRNG_LOCKUP</name>
              <description>
              prng lockup raw interrupt
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RAND_NUM_AVAIL</name>
              <description>
              random number available raw interrupt
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SEED_GEN_DONE</name>
              <description>
              random seed generation done raw interrupt
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RAND_SEED0</name>
          <displayName>RAND_SEED0</displayName>
          <description></description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>VAL</name>
              <description>
              random seed value0. If using external random seed, write value to this register will update the random seed in use.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RAND_SEED1</name>
          <displayName>RAND_SEED1</displayName>
          <description></description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>VAL</name>
              <description>
              random seed value1. If using external random seed, write value to this register will update the random seed in use.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RAND_SEED2</name>
          <displayName>RAND_SEED2</displayName>
          <description></description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>VAL</name>
              <description>
              random seed value2. If using external random seed, write value to this register will update the random seed in use.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RAND_SEED3</name>
          <displayName>RAND_SEED3</displayName>
          <description></description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>VAL</name>
              <description>
              random seed value3. If using external random seed, write value to this register will update the random seed in use.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RAND_SEED4</name>
          <displayName>RAND_SEED4</displayName>
          <description></description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>VAL</name>
              <description>
              random seed value4. If using external random seed, write value to this register will update the random seed in use.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RAND_SEED5</name>
          <displayName>RAND_SEED5</displayName>
          <description></description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>VAL</name>
              <description>
              random seed value5. If using external random seed, write value to this register will update the random seed in use.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RAND_SEED6</name>
          <displayName>RAND_SEED6</displayName>
          <description></description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>VAL</name>
              <description>
              random seed value6. If using external random seed, write value to this register will update the random seed in use.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RAND_SEED7</name>
          <displayName>RAND_SEED7</displayName>
          <description></description>
          <addressOffset>0x2c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>VAL</name>
              <description>
              random seed value7. If using external random seed, write value to this register will update the random seed in use.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RAND_NUM0</name>
          <displayName>RAND_NUM0</displayName>
          <description></description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>VAL</name>
              <description>
              random number value0
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RAND_NUM1</name>
          <displayName>RAND_NUM1</displayName>
          <description></description>
          <addressOffset>0x34</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>VAL</name>
              <description>
              random number value1
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RAND_NUM2</name>
          <displayName>RAND_NUM2</displayName>
          <description></description>
          <addressOffset>0x38</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>VAL</name>
              <description>
              random number value2
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RAND_NUM3</name>
          <displayName>RAND_NUM3</displayName>
          <description></description>
          <addressOffset>0x3c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>VAL</name>
              <description>
              random number value3
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RAND_NUM4</name>
          <displayName>RAND_NUM4</displayName>
          <description></description>
          <addressOffset>0x40</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>VAL</name>
              <description>
              random number value4
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RAND_NUM5</name>
          <displayName>RAND_NUM5</displayName>
          <description></description>
          <addressOffset>0x44</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>VAL</name>
              <description>
              random number value5
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RAND_NUM6</name>
          <displayName>RAND_NUM6</displayName>
          <description></description>
          <addressOffset>0x48</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>VAL</name>
              <description>
              random number value6
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RAND_NUM7</name>
          <displayName>RAND_NUM7</displayName>
          <description></description>
          <addressOffset>0x4c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>VAL</name>
              <description>
              random number value7
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>GPTIM1</name>
      <description></description>
      <groupName>GPTIM</groupName>
      <baseAddress>0x40010000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CR1</name>
          <displayName>CR1</displayName>
          <description>TIM control register 1</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>UIFREMAP</name>
              <description>
              UIF status bit remapping
              0: No remapping. UIF status bit is not copied to CNT register bit 31
              1: Remapping enabled. UIF status bit is copied to CNT register bit 31
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>ARPE</name>
              <description>
              Auto-reload preload enable
              0: ARR register is not buffered
              1: ARR register is buffered
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CMS</name>
              <description>
              Center-aligned mode selection
              00: Edge-aligned mode. The counter counts up or down depending on the direction bit (DIR).
              01: Center-aligned mode 1. The counter counts up and down alternatively. Output compare interrupt flags of channels configured in output (CCxS=00 in CCMRx register) are set only when the counter is counting down.
              10: Center-aligned mode 2. The counter counts up and down alternatively. Output compare interrupt flags of channels configured in output (CCxS=00 in CCMRx register) are set only when the counter is counting up.
              11: Center-aligned mode 3. The counter counts up and down alternatively. Output compare interrupt flags of channels configured in output (CCxS=00 in CCMRx register) are set both when the counter is counting up or down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>DIR</name>
              <description>
              Direction
              0: Counter used as upcounter
              1: Counter used as downcounter
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OPM</name>
              <description>
              One-pulse mode
              0: Counter is not stopped at update event
              1: Counter stops counting at the next update event (clearing the bit CEN)
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>URS</name>
              <description>
              Update request source
              This bit is set and cleared by software to select the UEV event sources.
              0: Any of the following events generate an update interrupt or DMA request if enabled. 
              These events can be: 
                 Counter overflow/underflow
                 Setting the UG bit
                 Update generation through the slave mode controller
              1: Only counter overflow/underflow generates an update interrupt or DMA request if enabled.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UDIS</name>
              <description>
              Update disable
              This bit is set and cleared by software to enable/disable UEV event generation.
              0: UEV enabled. The Update (UEV) event is generated by one of the following events:
                 Counter overflow/underflow
                 Setting the UG bit
                 Update generation through the slave mode controller
              Buffered registers are then loaded with their preload values.
              1: UEV disabled. The Update event is not generated, shadow registers keep their value (ARR, PSC, CCRx). However the counter and the prescaler are reinitialized if the UG bit is set or if a hardware reset is received from the slave mode controller.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CEN</name>
              <description>
              Counter enable
              0: Counter disabled
              1: Counter enabled
              Note: External clock, gated mode and encoder mode can work only if the CEN bit has been previously set by software. However trigger mode can set the CEN bit automatically by hardware. 
              CEN is cleared automatically in one-pulse mode, when an update event occurs.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CR2</name>
          <displayName>CR2</displayName>
          <description>TIM control register 2</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>TI1S</name>
              <description>
              TI1 selection
              0: The CH1 pin is connected to TI1 input
              1: The CH1, CH2 and CH3 pins are connected to the TI1 input (XOR combination) 
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MMS</name>
              <description>
              Master mode selection
              These bits allow to select the information to be sent in master mode to slave timers for synchronization (TRGO). The combination is as follows:
              000: Reset - the UG bit from the EGR register is used as trigger output (TRGO). If the reset is generated by the trigger input (slave mode controller configured in reset mode) then the signal on TRGO is delayed compared to the actual reset.
              001: Enable - the Counter enable signal is used as trigger output (TRGO). It is useful to start several timers at the same time or to control a window in which a slave timer is enabled. The Counter Enable signal is generated by a logic OR between CEN control bit and the trigger input when configured in gated mode. 
              When the Counter Enable signal is controlled by the trigger input, there is a delay on TRGO, except if the master/slave mode is selected.
              010: Update - The update event is selected as trigger output (TRGO). For instance a master timer can then be used as a prescaler for a slave timer.
              011: Compare Pulse - The trigger output send a positive pulse when the CC1IF flag is to be set (even if it was already high), as soon as a capture or a compare match occurred. (TRGO)
              100: Compare - OC1REF signal is used as trigger output (TRGO)
              101: Compare - OC2REF signal is used as trigger output (TRGO)
              110: Compare - OC3REF signal is used as trigger output (TRGO)
              111: Compare - OC4REF signal is used as trigger output (TRGO)
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>CCDS</name>
              <description>
              Capture/compare DMA selection
              0: CCx DMA request sent when CCx event occurs
              1: CCx DMA requests sent when update event occurs
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SMCR</name>
          <displayName>SMCR</displayName>
          <description>TIM slave mode control register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
            <field>
              <name>SMS</name>
              <description>
              Slave mode selection
              When external signals are selected the active edge of the trigger signal (TRGI) is linked to the polarity selected on the external input.
              0000: Slave mode disabled.
              0001: Encoder mode 1 - Counter counts up/down on TI1FP1 edge depending on TI2FP2 level.
              0010: Encoder mode 2 - Counter counts up/down on TI2FP2 edge depending on TI1FP1 level.
              0011: Encoder mode 3 - Counter counts up/down on both TI1FP1 and TI2FP2 edges depending on the level of the other input.
              0100: Reset Mode - Rising edge of the selected trigger input (TRGI) reinitializes the counter and generates an update of the registers.
              0101: Gated Mode - The counter clock is enabled when the trigger input (TRGI) is high. The counter stops (but is not reset) as soon as the trigger becomes low. Both start and stop of the counter are controlled.
              0110: Trigger Mode - The counter starts at a rising edge of the trigger TRGI (but it is not reset). Only the start of the counter is controlled.
              0111: External Clock Mode 1 - Rising edges of the selected trigger (TRGI) clock the counter.
              1000: Combined reset + trigger mode - Rising edge of the selected trigger input (TRGI) reinitializes the counter, generates an update of the registers and starts the counter.
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>ETP</name>
              <description>
              External trigger polarity
              0: ETR is non-inverted, active at high level or rising edge
              1: ETR is inverted, active at low level or falling edge
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ECE</name>
              <description>
              External clock enable
              This bit enables External clock mode 2.
              0: External clock mode 2 disabled
              1: External clock mode 2 enabled. The counter is clocked by any active edge on the ETRF signal.
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ETPS</name>
              <description>
              External trigger prescaler
              External trigger signal ETRP frequency must be at most 1/4 of CK_INT frequency. A prescaler can be enabled to reduce ETRP frequency. It is useful when inputting fast external clocks.
              00: Prescaler OFF
              01: ETRP frequency divided by 2
              10: ETRP frequency divided by 4
              11: ETRP frequency divided by 8
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>ETF</name>
              <description>
              External trigger filter
              This bit-field then defines the frequency used to sample ETRP signal and the length of the digital filter applied to ETRP. The digital filter is made of an event counter in which N 
              consecutive events are needed to validate a transition on the output:
              0000: No filter
              0001:   fSAMPLING=fCLK, N=2
              0010:   fSAMPLING=fCLK, N=4
              0011:   fSAMPLING=fCLK, N=8
              0100:   fSAMPLING=fCLK/2, N=6
              0101:   fSAMPLING=fCLK/2, N=8
              0110:   fSAMPLING=fCLK/4, N=6
              0111:   fSAMPLING=fCLK/4, N=8
              1000:   fSAMPLING=fCLK/8, N=6
              1001:   fSAMPLING=fCLK/8, N=8
              1010:   fSAMPLING=fCLK/16, N=5
              1011:   fSAMPLING=fCLK/16, N=6
              1100:   fSAMPLING=fCLK/16, N=8
              1101:   fSAMPLING=fCLK/32, N=5
              1110:   fSAMPLING=fCLK/32, N=6
              1111:   fSAMPLING=fCLK/32, N=8
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>MSM</name>
              <description>
              Master/Slave mode
              0: No action
              1: The effect of an event on the trigger input (TRGI) is delayed to allow a perfect synchronization between the current timer and its slaves (through TRGO). It is useful if we want to synchronize several timers on a single external event.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TS</name>
              <description>
              Trigger selection
              This bit-field selects the trigger input to be used to synchronize the counter.
              000: Internal Trigger 0 (ITR0)
              001: Internal Trigger 1 (ITR1) 
              010: Internal Trigger 2 (ITR2)
              011: Internal Trigger 3 (ITR3)
              100: TI1 Edge Detector (TI1F_ED)
              101: Filtered Timer Input 1 (TI1FP1)
              110: Filtered Timer Input 2 (TI2FP2)
              111: External Trigger input (ETRF)
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DIER</name>
          <displayName>DIER</displayName>
          <description>TIM DMA/Interrupt enable register</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
            <field>
              <name>TDE</name>
              <description>
              Trigger DMA request enable
              0: Trigger DMA request disabled.
              1: Trigger DMA request enabled.
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC4DE</name>
              <description>
              Capture/Compare 4 DMA request enable
              0: CC4 DMA request disabled.
              1: CC4 DMA request enabled
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC3DE</name>
              <description>
              Capture/Compare 3 DMA request enable
              0: CC3 DMA request disabled.
              1: CC3 DMA request enabled.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC2DE</name>
              <description>
              Capture/Compare 2 DMA request enable
              0: CC2 DMA request disabled.
              1: CC2 DMA request enabled.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC1DE</name>
              <description>
              Capture/Compare 1 DMA request enable
              0: CC1 DMA request disabled.
              1: CC1 DMA request enabled.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UDE</name>
              <description>
              Update DMA request enable
              0: Update DMA request disabled.
              1: Update DMA request enabled
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TIE</name>
              <description>
              Trigger interrupt enable
              0: Trigger interrupt disabled.
              1: Trigger interrupt enabled
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC4IE</name>
              <description>
              Capture/Compare 4 interrupt enable
              0: CC4 interrupt disabled.
              1: CC4 interrupt enabled
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC3IE</name>
              <description>
              Capture/Compare 3 interrupt enable
              0: CC3 interrupt disabled.
              1: CC3 interrupt enabled
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC2IE</name>
              <description>
              Capture/Compare 2 interrupt enable
              0: CC2 interrupt disabled.
              1: CC2 interrupt enabled.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC1IE</name>
              <description>
              Capture/Compare 1 interrupt enable
              0: CC1 interrupt disabled.
              1: CC1 interrupt enabled
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UIE</name>
              <description>
              Update interrupt enable
              0: Update interrupt disabled.
              1: Update interrupt enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SR</name>
          <displayName>SR</displayName>
          <description>TIM status register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>19</bitWidth>
            </field>
            <field>
              <name>CC4OF</name>
              <description>
              Capture/Compare 4 overcapture flag
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC3OF</name>
              <description>
              Capture/Compare 3 overcapture flag
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC2OF</name>
              <description>
              Capture/Compare 2 overcapture flag
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC1OF</name>
              <description>
              Capture/Compare 1 overcapture flag
              This flag is set by hardware only when the corresponding channel is configured in input capture mode. It is cleared by software by writing it to '0'.
              0: No overcapture has been detected.
              1: The counter value has been captured in CCR1 register while CC1IF flag was already set
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>TIF</name>
              <description>
              Trigger interrupt flag
              This flag is set by hardware on trigger event (active edge detected on TRGI input when the slave mode controller is enabled in all modes but gated mode). It is set when the counter starts or stops when gated mode is selected. It is cleared by software.
              0: No trigger event occurred.
              1: Trigger interrupt pending.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC4IF</name>
              <description>
              Capture/Compare 4 interrupt flag
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC3IF</name>
              <description>
              Capture/Compare 3 interrupt flag
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC2IF</name>
              <description>
              Capture/Compare 2 interrupt flag
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC1IF</name>
              <description>
              Capture/Compare 1 interrupt flag
              If channel CC1 is configured as output: This flag is set by hardware when the counter matches the compare value. It is cleared by software.
              0: No match.
              1: The content of the counter CNT has matched the content of the CCR1 register.
              If channel CC1 is configured as input: This bit is set by hardware on a capture. It is cleared by software or by reading the CCR1 register.
              0: No input capture occurred.
              1: The counter value has been captured in CCR1 register (An edge has been detected on IC1 which matches the selected polarity).
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UIF</name>
              <description>
              Update interrupt flag
              This bit is set by hardware on an update event. It is cleared by software.
              0: No update occurred
              1: Update interrupt pending. This bit is set by hardware when the registers are updated:
              At overflow or underflow and if UDIS=0 in the CR1 register.
              When CNT is reinitialized by software using the UG bit in EGR register, if URS=0 and UDIS=0 in the CR1 register.
              When CNT is reinitialized by a trigger event, if URS=0 and UDIS=0 in the CR1 register.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>EGR</name>
          <displayName>EGR</displayName>
          <description>Event generation register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>25</bitWidth>
            </field>
            <field>
              <name>TG</name>
              <description>
              Trigger generation
              This bit is set by software in order to generate an event, it is automatically cleared by hardware.
              0: No action
              1: The TIF flag is set in SR register. Related interrupt or DMA transfer can occur if enabled.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC4G</name>
              <description>
              Capture/compare 4 generation
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC3G</name>
              <description>
              Capture/compare 3 generation
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC2G</name>
              <description>
              Capture/compare 2 generation
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC1G</name>
              <description>
              Capture/compare 1 generation
              This bit is set by software in order to generate an event, it is automatically cleared by hardware.
              0: No action
              1: A capture/compare event is generated on channel 1:
              If channel CC1 is configured as output:
              CC1IF flag is set, Corresponding interrupt or DMA request is sent if enabled.
              If channel CC1 is configured as input:
              The current value of the counter is captured in CCR1 register. The CC1IF flag is set, the corresponding interrupt or DMA request is sent if enabled. The CC1OF flag is set if the CC1IF flag was already high.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UG</name>
              <description>
              Update generation
              This bit can be set by software, it is automatically cleared by hardware.
              0: No action
              1: Re-initialize the counter and generates an update of the registers. Note that the prescaler counter is cleared too (anyway the prescaler ratio is not affected). The counter is cleared if the center-aligned mode is selected or if DIR=0 (upcounting), else it takes the auto-reload value (ARR) if DIR=1 (downcounting).
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCMR1</name>
          <displayName>CCMR1</displayName>
          <description>TIM capture/compare mode register 1</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>OC2M</name>
              <description>
              Output compare 2 mode
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>OC2PE</name>
              <description>
              Output compare 2 preload enable
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>OC2CE</name>
              <description>
              Output compare 2 clear enable
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OC1M</name>
              <description>
              Output compare 1 mode
              These bits define the behavior of the output reference signal OC1REF from which OC1 and OC1N are derived. OC1REF is active high whereas OC1 and OC1N active level depends on CC1P and CC1NP bits.
              0000: Frozen - The comparison between the output compare register CCR1 and the counter CNT has no effect on the outputs.(this mode is used to generate a timing base).
              0001: Set channel 1 to active level on match. OC1REF signal is forced high when the counter CNT matches the capture/compare register 1 (CCR1).
              0010: Set channel 1 to inactive level on match. OC1REF signal is forced low when the counter CNT matches the capture/compare register 1 (CCR1).
              0011: Toggle - OC1REF toggles when CNT=CCR1.
              0100: Force inactive level - OC1REF is forced low.
              0101: Force active level - OC1REF is forced high.
              0110: PWM mode 1 - In upcounting, channel 1 is active as long as CNT&lt;CCR1 else inactive. In downcounting, channel 1 is inactive (OC1REF='0) as long as CNT>CCR1 else active (OC1REF=1).
              0111: PWM mode 2 - In upcounting, channel 1 is inactive as long as CNT&lt;CCR1 else active. In downcounting, channel 1 is active as long as CNT>CCR1 else inactive.
              1000: Retriggerable OPM mode 1 - In up-counting mode, the channel is active until a trigger event is detected (on TRGI signal). Then, a comparison is performed as in PWM mode 1 and the channels becomes inactive again at the next update. In down-counting mode, the channel is inactive until a trigger event is detected (on TRGI signal). Then, a comparison is performed as in PWM mode 1 and the channels becomes inactive again at the next update.
              1001: Retriggerable OPM mode 2 - In up-counting mode, the channel is inactive until a trigger event is detected (on TRGI signal). Then, a comparison is performed as in PWM mode 2 and the channels becomes inactive again at the next update. In down-counting mode, the channel is active until a trigger event is detected (on TRGI signal). Then, a comparison is performed as in PWM mode 1 and the channels becomes active again at the next update.
              1010: Reserved,
              1011: Reserved,
              1100: Combined PWM mode 1 - OC1REF has the same behavior as in PWM mode 1. OC1REFC is the logical OR between OC1REF and OC2REF.
              1101: Combined PWM mode 2 - OC1REF has the same behavior as in PWM mode 2. OC1REFC is the logical AND between OC1REF and OC2REF.
              1110: Asymmetric PWM mode 1 - OC1REF has the same behavior as in PWM mode 1. OC1REFC outputs OC1REF when the counter is counting up, OC2REF when it is counting down.
              1111: Asymmetric PWM mode 2 - OC1REF has the same behavior as in PWM mode 2. OC1REFC outputs OC1REF when the counter is counting up, OC2REF when it is counting down.
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>OC1PE</name>
              <description>
              Output compare 1 preload enable
              0: Preload register on CCR1 disabled. CCR1 can be written at anytime, the new value is taken in account immediately.
              1: Preload register on CCR1 enabled. Read/Write operations access the preload register. CCR1 preload value is loaded in the active register at each update event.
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>OC1CE</name>
              <description>
              Output compare 1 clear enable
              0: OC1Ref is not affected by the ETRF input
              1: OC1Ref is cleared as soon as a High level is detected on ETRF input
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IC2F</name>
              <description>
              Input capture 2 filter
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>IC2PSC</name>
              <description>
              Input capture 2 prescaler
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>CC2S</name>
              <description>
              Capture/Compare 2 selection
              This bit-field defines the direction of the channel (input/output) as well as the used input. 
              00: CC2 channel is configured as output
              01: CC2 channel is configured as input, IC2 is mapped on TI2
              10: CC2 channel is configured as input, IC2 is mapped on TI1
              11: CC2 channel is configured as input, IC2 is mapped on TRC. This mode is working only if an internal trigger input is selected through the TS bit (SMCR register)
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>IC1F</name>
              <description>
              Input capture 1 filter
              This bit-field defines the frequency used to sample TI1 input and the length of the digital filter applied to TI1. The digital filter is made of an event counter in which N consecutive events are needed to validate a transition on the output:
              0000: No filter, sampling is done at fCLK
              0001: fSAMPLING=fCLK, N=2
              0010: fSAMPLING=fCLK, N=4
              0011: fSAMPLING=fCLK, N=8
              0100: fSAMPLING=fCLK/2, N=6
              0101: fSAMPLING=fCLK/2, N=8
              0110: fSAMPLING=fCLK/4, N=6
              0111: fSAMPLING=fCLK/4, N=8
              1000: fSAMPLING=fCLK/8, N=6
              1001: fSAMPLING=fCLK/8, N=8
              1010: fSAMPLING=fCLK/16, N=5
              1011: fSAMPLING=fCLK/16, N=6
              1100: fSAMPLING=fCLK/16, N=8
              1101: fSAMPLING=fCLK/32, N=5
              1110: fSAMPLING=fCLK/32, N=6
              1111: fSAMPLING=fCLK/32, N=8
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>IC1PSC</name>
              <description>
              Input capture 1 prescaler
              This bit-field defines the ratio of the prescaler acting on CC1 input (IC1). The prescaler is reset as soon as CC1E=0.
              00: no prescaler, capture is done each time an edge is detected on the capture input
              01: capture is done once every 2 events
              10: capture is done once every 4 events
              11: capture is done once every 8 events
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>CC1S</name>
              <description>
              Capture/Compare 1 selection
              This bit-field defines the direction of the channel (input/output) as well as the used input. 
              00: CC1 channel is configured as output
              01: CC1 channel is configured as input, IC1 is mapped on TI1
              10: CC1 channel is configured as input, IC1 is mapped on TI2
              11: CC1 channel is configured as input, IC1 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (SMCR register)
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCMR2</name>
          <displayName>CCMR2</displayName>
          <description>TIM capture/compare mode register 2</description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>OC4M</name>
              <description>
              Output compare 4 mode
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>OC4PE</name>
              <description>
              Output compare 4 preload enable
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>OC4CE</name>
              <description>
              Output compare 4 clear enable
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OC3M</name>
              <description>
              Output compare 3 mode
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>OC3PE</name>
              <description>
              Output compare 3 preload enable
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>OC3CE</name>
              <description>
              Output compare 3 clear enable
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IC4F</name>
              <description>
              Input capture 4 filter
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>IC4PSC</name>
              <description>
              Input capture 4 prescaler
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>CC4S</name>
              <description>
              Capture/Compare 4 selection
              This bit-field defines the direction of the channel (input/output) as well as the used input. 
              00: CC4 channel is configured as output
              01: CC4 channel is configured as input, IC4 is mapped on TI4
              10: CC4 channel is configured as input, IC4 is mapped on TI3
              11: CC4 channel is configured as input, IC4 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (SMCR register)
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>IC3F</name>
              <description>
              Input capture 3 filter
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>IC3PSC</name>
              <description>
              Input capture 3 prescaler
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>CC3S</name>
              <description>
              Capture/Compare 3 selection
              This bit-field defines the direction of the channel (input/output) as well as the used input. 
              00: CC3 channel is configured as output
              01: CC3 channel is configured as input, IC3 is mapped on TI3
              10: CC3 channel is configured as input, IC3 is mapped on TI4
              11: CC3 channel is configured as input, IC3 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (SMCR register)
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCER</name>
          <displayName>CCER</displayName>
          <description>Capture/Compare enable register</description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>CC4NP</name>
              <description>
              Capture/Compare 4 output Polarity.
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC4P</name>
              <description>
              Capture/Compare 4 output Polarity.
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC4E</name>
              <description>
              Capture/Compare 4 output enable.
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC3NP</name>
              <description>
              Capture/Compare 3 output Polarity.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC3P</name>
              <description>
              Capture/Compare 3 output Polarity.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC3E</name>
              <description>
              Capture/Compare 3 output enable.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC2NP</name>
              <description>
              Capture/Compare 2 output Polarity.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC2P</name>
              <description>
              Capture/Compare 2 output Polarity.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC2E</name>
              <description>
              Capture/Compare 2 output enable.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC1NP</name>
              <description>
              Capture/Compare 1 output Polarity.
              CC1 channel configured as output: CC1NP must be kept cleared in this case.
              CC1 channel configured as input: This bit is used in conjunction with CC1P to define TI1FP1/TI2FP1 polarity. refer to CC1P description.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD5</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC1P</name>
              <description>
              Capture/Compare 1 output Polarity.
              CC1 channel configured as output:
              0: OC1 active high
              1: OC1 active low
              CC1 channel configured as input: CC1NP/CC1P bits select TI1FP1 and TI2FP1 polarity for trigger or capture operations.
              00: noninverted/rising edge
              Circuit is sensitive to TIxFP1 rising edge (capture, trigger in reset, external clock or trigger mode), TIxFP1 is not inverted (trigger in gated mode, encoder mode).
              01: inverted/falling edge
              Circuit is sensitive to TIxFP1 falling edge (capture, trigger in reset, external clock or trigger mode), TIxFP1 is inverted (trigger in gated mode, encoder mode).
              10: reserved, do not use this configuration.
              11: noninverted/both edges
              Circuit is sensitive to both TIxFP1 rising and falling edges (capture, trigger in reset, external clock or trigger mode), TIxFP1 is not inverted (trigger in gated mode). This configuration must not be used for encoder mode.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC1E</name>
              <description>
              Capture/Compare 1 output enable.
              CC1 channel configured as output:
              0: Off - OC1 is not active
              1: On - OC1 signal is output on the corresponding output pin
              CC1 channel configured as input: This bit determines if a capture of the counter value can actually be done into the input capture/compare register 1 (CCR1) or not.
              0: Capture disabled
              1: Capture enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CNT</name>
          <displayName>CNT</displayName>
          <description>Counter</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>UIFCPY</name>
              <description>
              Value depends on IUFREMAP in CR1.
              If UIFREMAP = 1
              UIFCPY: UIF Copy
              This bit is a read-only copy of the UIF bit of the ISR register
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>15</bitWidth>
            </field>
            <field>
              <name>CNT</name>
              <description>
              counter value
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PSC</name>
          <displayName>PSC</displayName>
          <description>Prescaler</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>PSC</name>
              <description>
              Prescaler value
              The counter clock frequency is equal to fCLK / (PSC[15:0] + 1).
              PSC contains the value to be loaded in the active prescaler register at each update event (including when the counter is cleared through UG bit of EGR register or through trigger controller when configured in 'reset mode').
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ARR</name>
          <displayName>ARR</displayName>
          <description>Auto-reload register</description>
          <addressOffset>0x2c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>ARR</name>
              <description>
              Auto-reload value
              ARR is the value to be loaded in the actual auto-reload register.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RCR</name>
          <displayName>RCR</displayName>
          <description>Repetition counter register</description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>REP</name>
              <description>
              Repetition counter value
              These bits allow the user to set-up the update rate of the compare registers (i.e. periodic transfers from preload to active registers) when preload registers are enable, as well as the update interrupt generation rate, if this interrupt is enable.
              Each time the REP_CNT related downcounter reaches zero, an update event is generated and it restarts counting from REP value. As REP_CNT is reloaded with REP value only at the repetition update event, any write to the RCR register is not taken in account until the next repetition update event.
              It means in PWM mode (REP+1) corresponds to the number of PWM periods in edge-aligned mode.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR1</name>
          <displayName>CCR1</displayName>
          <description>Capture/Compare register 1</description>
          <addressOffset>0x34</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>CCR1</name>
              <description>
              Capture/Compare 1 value
              If channel CC1 is configured as output:
              CCR1 is the value to be loaded in the actual capture/compare 1 register (preload value).It is loaded permanently if the preload feature is not selected in the CCMR1 register (bit OC1PE). Else the preload value is copied in the active capture/compare 1 register when an update event occurs.
              The active capture/compare register contains the value to be compared to the counter CNT and signaled on OC1 output.
              If channel CC1is configured as input:
              CCR1 is the counter value transferred by the last input capture 1 event (IC1). The CCR1 register is read-only and cannot be programmed.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR2</name>
          <displayName>CCR2</displayName>
          <description>Capture/Compare register 2</description>
          <addressOffset>0x38</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>CCR2</name>
              <description>
              Capture/Compare 2 value
              If channel CC2 is configured as output:
              CCR2 is the value to be loaded in the actual capture/compare 2 register (preload value).It is loaded permanently if the preload feature is not selected in the CCMR1 register (bit OC2PE). Else the preload value is copied in the active capture/compare 2 register when an update event occurs.
              The active capture/compare register contains the value to be compared to the counter CNT and signalled on OC2 output.
              If channel CC2 is configured as input:
              CCR2 is the counter value transferred by the last input capture 2 event (IC2). The CCR2 register is read-only and cannot be programmed.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR3</name>
          <displayName>CCR3</displayName>
          <description>Capture/Compare register 3</description>
          <addressOffset>0x3c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>CCR3</name>
              <description>
              Capture/Compare value
              If channel CC3 is configured as output:
              CCR3 is the value to be loaded in the actual capture/compare 3 register (preload value).It is loaded permanently if the preload feature is not selected in the CCMR2 register (bit OC3PE). Else the preload value is copied in the active capture/compare 3 register when an update event occurs.
              The active capture/compare register contains the value to be compared to the counter CNT and signalled on OC3 output.
              If channel CC3is configured as input:
              CCR3 is the counter value transferred by the last input capture 3 event (IC3). The CCR3 register is read-only and cannot be programmed.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR4</name>
          <displayName>CCR4</displayName>
          <description>Capture/Compare register 4</description>
          <addressOffset>0x40</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>CCR4</name>
              <description>
              Capture/Compare value
              1. if CC4 channel is configured as output:
              CCR4 is the value to be loaded in the actual capture/compare 4 register (preload value).It is loaded permanently if the preload feature is not selected in the CCMR2 register (bit OC4PE). Else the preload value is copied in the active capture/compare 4 register when an update event occurs.
              The active capture/compare register contains the value to be compared to the counter CNT and signalled on OC4 output.
              2.  if CC4 channel is configured as input:
              CCR4 is the counter value transferred by the last input capture 4 event (IC4). The CCR4 register is read-only and cannot be programmed.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>GPTIM2</name>
      <description></description>
      <groupName>GPTIM</groupName>
      <baseAddress>0x40011000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CR1</name>
          <displayName>CR1</displayName>
          <description>TIM control register 1</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>UIFREMAP</name>
              <description>
              UIF status bit remapping
              0: No remapping. UIF status bit is not copied to CNT register bit 31
              1: Remapping enabled. UIF status bit is copied to CNT register bit 31
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>ARPE</name>
              <description>
              Auto-reload preload enable
              0: ARR register is not buffered
              1: ARR register is buffered
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CMS</name>
              <description>
              Center-aligned mode selection
              00: Edge-aligned mode. The counter counts up or down depending on the direction bit (DIR).
              01: Center-aligned mode 1. The counter counts up and down alternatively. Output compare interrupt flags of channels configured in output (CCxS=00 in CCMRx register) are set only when the counter is counting down.
              10: Center-aligned mode 2. The counter counts up and down alternatively. Output compare interrupt flags of channels configured in output (CCxS=00 in CCMRx register) are set only when the counter is counting up.
              11: Center-aligned mode 3. The counter counts up and down alternatively. Output compare interrupt flags of channels configured in output (CCxS=00 in CCMRx register) are set both when the counter is counting up or down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>DIR</name>
              <description>
              Direction
              0: Counter used as upcounter
              1: Counter used as downcounter
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OPM</name>
              <description>
              One-pulse mode
              0: Counter is not stopped at update event
              1: Counter stops counting at the next update event (clearing the bit CEN)
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>URS</name>
              <description>
              Update request source
              This bit is set and cleared by software to select the UEV event sources.
              0: Any of the following events generate an update interrupt or DMA request if enabled. 
              These events can be: 
                 Counter overflow/underflow
                 Setting the UG bit
                 Update generation through the slave mode controller
              1: Only counter overflow/underflow generates an update interrupt or DMA request if enabled.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UDIS</name>
              <description>
              Update disable
              This bit is set and cleared by software to enable/disable UEV event generation.
              0: UEV enabled. The Update (UEV) event is generated by one of the following events:
                 Counter overflow/underflow
                 Setting the UG bit
                 Update generation through the slave mode controller
              Buffered registers are then loaded with their preload values.
              1: UEV disabled. The Update event is not generated, shadow registers keep their value (ARR, PSC, CCRx). However the counter and the prescaler are reinitialized if the UG bit is set or if a hardware reset is received from the slave mode controller.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CEN</name>
              <description>
              Counter enable
              0: Counter disabled
              1: Counter enabled
              Note: External clock, gated mode and encoder mode can work only if the CEN bit has been previously set by software. However trigger mode can set the CEN bit automatically by hardware. 
              CEN is cleared automatically in one-pulse mode, when an update event occurs.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CR2</name>
          <displayName>CR2</displayName>
          <description>TIM control register 2</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>TI1S</name>
              <description>
              TI1 selection
              0: The CH1 pin is connected to TI1 input
              1: The CH1, CH2 and CH3 pins are connected to the TI1 input (XOR combination) 
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MMS</name>
              <description>
              Master mode selection
              These bits allow to select the information to be sent in master mode to slave timers for synchronization (TRGO). The combination is as follows:
              000: Reset - the UG bit from the EGR register is used as trigger output (TRGO). If the reset is generated by the trigger input (slave mode controller configured in reset mode) then the signal on TRGO is delayed compared to the actual reset.
              001: Enable - the Counter enable signal is used as trigger output (TRGO). It is useful to start several timers at the same time or to control a window in which a slave timer is enabled. The Counter Enable signal is generated by a logic OR between CEN control bit and the trigger input when configured in gated mode. 
              When the Counter Enable signal is controlled by the trigger input, there is a delay on TRGO, except if the master/slave mode is selected.
              010: Update - The update event is selected as trigger output (TRGO). For instance a master timer can then be used as a prescaler for a slave timer.
              011: Compare Pulse - The trigger output send a positive pulse when the CC1IF flag is to be set (even if it was already high), as soon as a capture or a compare match occurred. (TRGO)
              100: Compare - OC1REF signal is used as trigger output (TRGO)
              101: Compare - OC2REF signal is used as trigger output (TRGO)
              110: Compare - OC3REF signal is used as trigger output (TRGO)
              111: Compare - OC4REF signal is used as trigger output (TRGO)
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>CCDS</name>
              <description>
              Capture/compare DMA selection
              0: CCx DMA request sent when CCx event occurs
              1: CCx DMA requests sent when update event occurs
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SMCR</name>
          <displayName>SMCR</displayName>
          <description>TIM slave mode control register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
            <field>
              <name>SMS</name>
              <description>
              Slave mode selection
              When external signals are selected the active edge of the trigger signal (TRGI) is linked to the polarity selected on the external input.
              0000: Slave mode disabled.
              0001: Encoder mode 1 - Counter counts up/down on TI1FP1 edge depending on TI2FP2 level.
              0010: Encoder mode 2 - Counter counts up/down on TI2FP2 edge depending on TI1FP1 level.
              0011: Encoder mode 3 - Counter counts up/down on both TI1FP1 and TI2FP2 edges depending on the level of the other input.
              0100: Reset Mode - Rising edge of the selected trigger input (TRGI) reinitializes the counter and generates an update of the registers.
              0101: Gated Mode - The counter clock is enabled when the trigger input (TRGI) is high. The counter stops (but is not reset) as soon as the trigger becomes low. Both start and stop of the counter are controlled.
              0110: Trigger Mode - The counter starts at a rising edge of the trigger TRGI (but it is not reset). Only the start of the counter is controlled.
              0111: External Clock Mode 1 - Rising edges of the selected trigger (TRGI) clock the counter.
              1000: Combined reset + trigger mode - Rising edge of the selected trigger input (TRGI) reinitializes the counter, generates an update of the registers and starts the counter.
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>ETP</name>
              <description>
              External trigger polarity
              0: ETR is non-inverted, active at high level or rising edge
              1: ETR is inverted, active at low level or falling edge
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ECE</name>
              <description>
              External clock enable
              This bit enables External clock mode 2.
              0: External clock mode 2 disabled
              1: External clock mode 2 enabled. The counter is clocked by any active edge on the ETRF signal.
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ETPS</name>
              <description>
              External trigger prescaler
              External trigger signal ETRP frequency must be at most 1/4 of CK_INT frequency. A prescaler can be enabled to reduce ETRP frequency. It is useful when inputting fast external clocks.
              00: Prescaler OFF
              01: ETRP frequency divided by 2
              10: ETRP frequency divided by 4
              11: ETRP frequency divided by 8
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>ETF</name>
              <description>
              External trigger filter
              This bit-field then defines the frequency used to sample ETRP signal and the length of the digital filter applied to ETRP. The digital filter is made of an event counter in which N 
              consecutive events are needed to validate a transition on the output:
              0000: No filter
              0001:   fSAMPLING=fCLK, N=2
              0010:   fSAMPLING=fCLK, N=4
              0011:   fSAMPLING=fCLK, N=8
              0100:   fSAMPLING=fCLK/2, N=6
              0101:   fSAMPLING=fCLK/2, N=8
              0110:   fSAMPLING=fCLK/4, N=6
              0111:   fSAMPLING=fCLK/4, N=8
              1000:   fSAMPLING=fCLK/8, N=6
              1001:   fSAMPLING=fCLK/8, N=8
              1010:   fSAMPLING=fCLK/16, N=5
              1011:   fSAMPLING=fCLK/16, N=6
              1100:   fSAMPLING=fCLK/16, N=8
              1101:   fSAMPLING=fCLK/32, N=5
              1110:   fSAMPLING=fCLK/32, N=6
              1111:   fSAMPLING=fCLK/32, N=8
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>MSM</name>
              <description>
              Master/Slave mode
              0: No action
              1: The effect of an event on the trigger input (TRGI) is delayed to allow a perfect synchronization between the current timer and its slaves (through TRGO). It is useful if we want to synchronize several timers on a single external event.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TS</name>
              <description>
              Trigger selection
              This bit-field selects the trigger input to be used to synchronize the counter.
              000: Internal Trigger 0 (ITR0)
              001: Internal Trigger 1 (ITR1) 
              010: Internal Trigger 2 (ITR2)
              011: Internal Trigger 3 (ITR3)
              100: TI1 Edge Detector (TI1F_ED)
              101: Filtered Timer Input 1 (TI1FP1)
              110: Filtered Timer Input 2 (TI2FP2)
              111: External Trigger input (ETRF)
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DIER</name>
          <displayName>DIER</displayName>
          <description>TIM DMA/Interrupt enable register</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
            <field>
              <name>TDE</name>
              <description>
              Trigger DMA request enable
              0: Trigger DMA request disabled.
              1: Trigger DMA request enabled.
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC4DE</name>
              <description>
              Capture/Compare 4 DMA request enable
              0: CC4 DMA request disabled.
              1: CC4 DMA request enabled
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC3DE</name>
              <description>
              Capture/Compare 3 DMA request enable
              0: CC3 DMA request disabled.
              1: CC3 DMA request enabled.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC2DE</name>
              <description>
              Capture/Compare 2 DMA request enable
              0: CC2 DMA request disabled.
              1: CC2 DMA request enabled.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC1DE</name>
              <description>
              Capture/Compare 1 DMA request enable
              0: CC1 DMA request disabled.
              1: CC1 DMA request enabled.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UDE</name>
              <description>
              Update DMA request enable
              0: Update DMA request disabled.
              1: Update DMA request enabled
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TIE</name>
              <description>
              Trigger interrupt enable
              0: Trigger interrupt disabled.
              1: Trigger interrupt enabled
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC4IE</name>
              <description>
              Capture/Compare 4 interrupt enable
              0: CC4 interrupt disabled.
              1: CC4 interrupt enabled
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC3IE</name>
              <description>
              Capture/Compare 3 interrupt enable
              0: CC3 interrupt disabled.
              1: CC3 interrupt enabled
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC2IE</name>
              <description>
              Capture/Compare 2 interrupt enable
              0: CC2 interrupt disabled.
              1: CC2 interrupt enabled.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC1IE</name>
              <description>
              Capture/Compare 1 interrupt enable
              0: CC1 interrupt disabled.
              1: CC1 interrupt enabled
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UIE</name>
              <description>
              Update interrupt enable
              0: Update interrupt disabled.
              1: Update interrupt enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SR</name>
          <displayName>SR</displayName>
          <description>TIM status register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>19</bitWidth>
            </field>
            <field>
              <name>CC4OF</name>
              <description>
              Capture/Compare 4 overcapture flag
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC3OF</name>
              <description>
              Capture/Compare 3 overcapture flag
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC2OF</name>
              <description>
              Capture/Compare 2 overcapture flag
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC1OF</name>
              <description>
              Capture/Compare 1 overcapture flag
              This flag is set by hardware only when the corresponding channel is configured in input capture mode. It is cleared by software by writing it to '0'.
              0: No overcapture has been detected.
              1: The counter value has been captured in CCR1 register while CC1IF flag was already set
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>TIF</name>
              <description>
              Trigger interrupt flag
              This flag is set by hardware on trigger event (active edge detected on TRGI input when the slave mode controller is enabled in all modes but gated mode). It is set when the counter starts or stops when gated mode is selected. It is cleared by software.
              0: No trigger event occurred.
              1: Trigger interrupt pending.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC4IF</name>
              <description>
              Capture/Compare 4 interrupt flag
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC3IF</name>
              <description>
              Capture/Compare 3 interrupt flag
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC2IF</name>
              <description>
              Capture/Compare 2 interrupt flag
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC1IF</name>
              <description>
              Capture/Compare 1 interrupt flag
              If channel CC1 is configured as output: This flag is set by hardware when the counter matches the compare value. It is cleared by software.
              0: No match.
              1: The content of the counter CNT has matched the content of the CCR1 register.
              If channel CC1 is configured as input: This bit is set by hardware on a capture. It is cleared by software or by reading the CCR1 register.
              0: No input capture occurred.
              1: The counter value has been captured in CCR1 register (An edge has been detected on IC1 which matches the selected polarity).
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UIF</name>
              <description>
              Update interrupt flag
              This bit is set by hardware on an update event. It is cleared by software.
              0: No update occurred
              1: Update interrupt pending. This bit is set by hardware when the registers are updated:
              At overflow or underflow and if UDIS=0 in the CR1 register.
              When CNT is reinitialized by software using the UG bit in EGR register, if URS=0 and UDIS=0 in the CR1 register.
              When CNT is reinitialized by a trigger event, if URS=0 and UDIS=0 in the CR1 register.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>EGR</name>
          <displayName>EGR</displayName>
          <description>Event generation register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>25</bitWidth>
            </field>
            <field>
              <name>TG</name>
              <description>
              Trigger generation
              This bit is set by software in order to generate an event, it is automatically cleared by hardware.
              0: No action
              1: The TIF flag is set in SR register. Related interrupt or DMA transfer can occur if enabled.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC4G</name>
              <description>
              Capture/compare 4 generation
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC3G</name>
              <description>
              Capture/compare 3 generation
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC2G</name>
              <description>
              Capture/compare 2 generation
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC1G</name>
              <description>
              Capture/compare 1 generation
              This bit is set by software in order to generate an event, it is automatically cleared by hardware.
              0: No action
              1: A capture/compare event is generated on channel 1:
              If channel CC1 is configured as output:
              CC1IF flag is set, Corresponding interrupt or DMA request is sent if enabled.
              If channel CC1 is configured as input:
              The current value of the counter is captured in CCR1 register. The CC1IF flag is set, the corresponding interrupt or DMA request is sent if enabled. The CC1OF flag is set if the CC1IF flag was already high.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UG</name>
              <description>
              Update generation
              This bit can be set by software, it is automatically cleared by hardware.
              0: No action
              1: Re-initialize the counter and generates an update of the registers. Note that the prescaler counter is cleared too (anyway the prescaler ratio is not affected). The counter is cleared if the center-aligned mode is selected or if DIR=0 (upcounting), else it takes the auto-reload value (ARR) if DIR=1 (downcounting).
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCMR1</name>
          <displayName>CCMR1</displayName>
          <description>TIM capture/compare mode register 1</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>OC2M</name>
              <description>
              Output compare 2 mode
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>OC2PE</name>
              <description>
              Output compare 2 preload enable
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>OC2CE</name>
              <description>
              Output compare 2 clear enable
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OC1M</name>
              <description>
              Output compare 1 mode
              These bits define the behavior of the output reference signal OC1REF from which OC1 and OC1N are derived. OC1REF is active high whereas OC1 and OC1N active level depends on CC1P and CC1NP bits.
              0000: Frozen - The comparison between the output compare register CCR1 and the counter CNT has no effect on the outputs.(this mode is used to generate a timing base).
              0001: Set channel 1 to active level on match. OC1REF signal is forced high when the counter CNT matches the capture/compare register 1 (CCR1).
              0010: Set channel 1 to inactive level on match. OC1REF signal is forced low when the counter CNT matches the capture/compare register 1 (CCR1).
              0011: Toggle - OC1REF toggles when CNT=CCR1.
              0100: Force inactive level - OC1REF is forced low.
              0101: Force active level - OC1REF is forced high.
              0110: PWM mode 1 - In upcounting, channel 1 is active as long as CNT&lt;CCR1 else inactive. In downcounting, channel 1 is inactive (OC1REF='0) as long as CNT>CCR1 else active (OC1REF=1).
              0111: PWM mode 2 - In upcounting, channel 1 is inactive as long as CNT&lt;CCR1 else active. In downcounting, channel 1 is active as long as CNT>CCR1 else inactive.
              1000: Retriggerable OPM mode 1 - In up-counting mode, the channel is active until a trigger event is detected (on TRGI signal). Then, a comparison is performed as in PWM mode 1 and the channels becomes inactive again at the next update. In down-counting mode, the channel is inactive until a trigger event is detected (on TRGI signal). Then, a comparison is performed as in PWM mode 1 and the channels becomes inactive again at the next update.
              1001: Retriggerable OPM mode 2 - In up-counting mode, the channel is inactive until a trigger event is detected (on TRGI signal). Then, a comparison is performed as in PWM mode 2 and the channels becomes inactive again at the next update. In down-counting mode, the channel is active until a trigger event is detected (on TRGI signal). Then, a comparison is performed as in PWM mode 1 and the channels becomes active again at the next update.
              1010: Reserved,
              1011: Reserved,
              1100: Combined PWM mode 1 - OC1REF has the same behavior as in PWM mode 1. OC1REFC is the logical OR between OC1REF and OC2REF.
              1101: Combined PWM mode 2 - OC1REF has the same behavior as in PWM mode 2. OC1REFC is the logical AND between OC1REF and OC2REF.
              1110: Asymmetric PWM mode 1 - OC1REF has the same behavior as in PWM mode 1. OC1REFC outputs OC1REF when the counter is counting up, OC2REF when it is counting down.
              1111: Asymmetric PWM mode 2 - OC1REF has the same behavior as in PWM mode 2. OC1REFC outputs OC1REF when the counter is counting up, OC2REF when it is counting down.
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>OC1PE</name>
              <description>
              Output compare 1 preload enable
              0: Preload register on CCR1 disabled. CCR1 can be written at anytime, the new value is taken in account immediately.
              1: Preload register on CCR1 enabled. Read/Write operations access the preload register. CCR1 preload value is loaded in the active register at each update event.
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>OC1CE</name>
              <description>
              Output compare 1 clear enable
              0: OC1Ref is not affected by the ETRF input
              1: OC1Ref is cleared as soon as a High level is detected on ETRF input
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IC2F</name>
              <description>
              Input capture 2 filter
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>IC2PSC</name>
              <description>
              Input capture 2 prescaler
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>CC2S</name>
              <description>
              Capture/Compare 2 selection
              This bit-field defines the direction of the channel (input/output) as well as the used input. 
              00: CC2 channel is configured as output
              01: CC2 channel is configured as input, IC2 is mapped on TI2
              10: CC2 channel is configured as input, IC2 is mapped on TI1
              11: CC2 channel is configured as input, IC2 is mapped on TRC. This mode is working only if an internal trigger input is selected through the TS bit (SMCR register)
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>IC1F</name>
              <description>
              Input capture 1 filter
              This bit-field defines the frequency used to sample TI1 input and the length of the digital filter applied to TI1. The digital filter is made of an event counter in which N consecutive events are needed to validate a transition on the output:
              0000: No filter, sampling is done at fCLK
              0001: fSAMPLING=fCLK, N=2
              0010: fSAMPLING=fCLK, N=4
              0011: fSAMPLING=fCLK, N=8
              0100: fSAMPLING=fCLK/2, N=6
              0101: fSAMPLING=fCLK/2, N=8
              0110: fSAMPLING=fCLK/4, N=6
              0111: fSAMPLING=fCLK/4, N=8
              1000: fSAMPLING=fCLK/8, N=6
              1001: fSAMPLING=fCLK/8, N=8
              1010: fSAMPLING=fCLK/16, N=5
              1011: fSAMPLING=fCLK/16, N=6
              1100: fSAMPLING=fCLK/16, N=8
              1101: fSAMPLING=fCLK/32, N=5
              1110: fSAMPLING=fCLK/32, N=6
              1111: fSAMPLING=fCLK/32, N=8
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>IC1PSC</name>
              <description>
              Input capture 1 prescaler
              This bit-field defines the ratio of the prescaler acting on CC1 input (IC1). The prescaler is reset as soon as CC1E=0.
              00: no prescaler, capture is done each time an edge is detected on the capture input
              01: capture is done once every 2 events
              10: capture is done once every 4 events
              11: capture is done once every 8 events
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>CC1S</name>
              <description>
              Capture/Compare 1 selection
              This bit-field defines the direction of the channel (input/output) as well as the used input. 
              00: CC1 channel is configured as output
              01: CC1 channel is configured as input, IC1 is mapped on TI1
              10: CC1 channel is configured as input, IC1 is mapped on TI2
              11: CC1 channel is configured as input, IC1 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (SMCR register)
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCMR2</name>
          <displayName>CCMR2</displayName>
          <description>TIM capture/compare mode register 2</description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>OC4M</name>
              <description>
              Output compare 4 mode
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>OC4PE</name>
              <description>
              Output compare 4 preload enable
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>OC4CE</name>
              <description>
              Output compare 4 clear enable
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OC3M</name>
              <description>
              Output compare 3 mode
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>OC3PE</name>
              <description>
              Output compare 3 preload enable
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>OC3CE</name>
              <description>
              Output compare 3 clear enable
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IC4F</name>
              <description>
              Input capture 4 filter
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>IC4PSC</name>
              <description>
              Input capture 4 prescaler
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>CC4S</name>
              <description>
              Capture/Compare 4 selection
              This bit-field defines the direction of the channel (input/output) as well as the used input. 
              00: CC4 channel is configured as output
              01: CC4 channel is configured as input, IC4 is mapped on TI4
              10: CC4 channel is configured as input, IC4 is mapped on TI3
              11: CC4 channel is configured as input, IC4 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (SMCR register)
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>IC3F</name>
              <description>
              Input capture 3 filter
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>IC3PSC</name>
              <description>
              Input capture 3 prescaler
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>CC3S</name>
              <description>
              Capture/Compare 3 selection
              This bit-field defines the direction of the channel (input/output) as well as the used input. 
              00: CC3 channel is configured as output
              01: CC3 channel is configured as input, IC3 is mapped on TI3
              10: CC3 channel is configured as input, IC3 is mapped on TI4
              11: CC3 channel is configured as input, IC3 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (SMCR register)
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCER</name>
          <displayName>CCER</displayName>
          <description>Capture/Compare enable register</description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>CC4NP</name>
              <description>
              Capture/Compare 4 output Polarity.
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC4P</name>
              <description>
              Capture/Compare 4 output Polarity.
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC4E</name>
              <description>
              Capture/Compare 4 output enable.
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC3NP</name>
              <description>
              Capture/Compare 3 output Polarity.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC3P</name>
              <description>
              Capture/Compare 3 output Polarity.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC3E</name>
              <description>
              Capture/Compare 3 output enable.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC2NP</name>
              <description>
              Capture/Compare 2 output Polarity.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC2P</name>
              <description>
              Capture/Compare 2 output Polarity.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC2E</name>
              <description>
              Capture/Compare 2 output enable.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC1NP</name>
              <description>
              Capture/Compare 1 output Polarity.
              CC1 channel configured as output: CC1NP must be kept cleared in this case.
              CC1 channel configured as input: This bit is used in conjunction with CC1P to define TI1FP1/TI2FP1 polarity. refer to CC1P description.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD5</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC1P</name>
              <description>
              Capture/Compare 1 output Polarity.
              CC1 channel configured as output:
              0: OC1 active high
              1: OC1 active low
              CC1 channel configured as input: CC1NP/CC1P bits select TI1FP1 and TI2FP1 polarity for trigger or capture operations.
              00: noninverted/rising edge
              Circuit is sensitive to TIxFP1 rising edge (capture, trigger in reset, external clock or trigger mode), TIxFP1 is not inverted (trigger in gated mode, encoder mode).
              01: inverted/falling edge
              Circuit is sensitive to TIxFP1 falling edge (capture, trigger in reset, external clock or trigger mode), TIxFP1 is inverted (trigger in gated mode, encoder mode).
              10: reserved, do not use this configuration.
              11: noninverted/both edges
              Circuit is sensitive to both TIxFP1 rising and falling edges (capture, trigger in reset, external clock or trigger mode), TIxFP1 is not inverted (trigger in gated mode). This configuration must not be used for encoder mode.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC1E</name>
              <description>
              Capture/Compare 1 output enable.
              CC1 channel configured as output:
              0: Off - OC1 is not active
              1: On - OC1 signal is output on the corresponding output pin
              CC1 channel configured as input: This bit determines if a capture of the counter value can actually be done into the input capture/compare register 1 (CCR1) or not.
              0: Capture disabled
              1: Capture enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CNT</name>
          <displayName>CNT</displayName>
          <description>Counter</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>UIFCPY</name>
              <description>
              Value depends on IUFREMAP in CR1.
              If UIFREMAP = 1
              UIFCPY: UIF Copy
              This bit is a read-only copy of the UIF bit of the ISR register
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>15</bitWidth>
            </field>
            <field>
              <name>CNT</name>
              <description>
              counter value
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PSC</name>
          <displayName>PSC</displayName>
          <description>Prescaler</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>PSC</name>
              <description>
              Prescaler value
              The counter clock frequency is equal to fCLK / (PSC[15:0] + 1).
              PSC contains the value to be loaded in the active prescaler register at each update event (including when the counter is cleared through UG bit of EGR register or through trigger controller when configured in 'reset mode').
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ARR</name>
          <displayName>ARR</displayName>
          <description>Auto-reload register</description>
          <addressOffset>0x2c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>ARR</name>
              <description>
              Auto-reload value
              ARR is the value to be loaded in the actual auto-reload register.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RCR</name>
          <displayName>RCR</displayName>
          <description>Repetition counter register</description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>REP</name>
              <description>
              Repetition counter value
              These bits allow the user to set-up the update rate of the compare registers (i.e. periodic transfers from preload to active registers) when preload registers are enable, as well as the update interrupt generation rate, if this interrupt is enable.
              Each time the REP_CNT related downcounter reaches zero, an update event is generated and it restarts counting from REP value. As REP_CNT is reloaded with REP value only at the repetition update event, any write to the RCR register is not taken in account until the next repetition update event.
              It means in PWM mode (REP+1) corresponds to the number of PWM periods in edge-aligned mode.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR1</name>
          <displayName>CCR1</displayName>
          <description>Capture/Compare register 1</description>
          <addressOffset>0x34</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>CCR1</name>
              <description>
              Capture/Compare 1 value
              If channel CC1 is configured as output:
              CCR1 is the value to be loaded in the actual capture/compare 1 register (preload value).It is loaded permanently if the preload feature is not selected in the CCMR1 register (bit OC1PE). Else the preload value is copied in the active capture/compare 1 register when an update event occurs.
              The active capture/compare register contains the value to be compared to the counter CNT and signaled on OC1 output.
              If channel CC1is configured as input:
              CCR1 is the counter value transferred by the last input capture 1 event (IC1). The CCR1 register is read-only and cannot be programmed.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR2</name>
          <displayName>CCR2</displayName>
          <description>Capture/Compare register 2</description>
          <addressOffset>0x38</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>CCR2</name>
              <description>
              Capture/Compare 2 value
              If channel CC2 is configured as output:
              CCR2 is the value to be loaded in the actual capture/compare 2 register (preload value).It is loaded permanently if the preload feature is not selected in the CCMR1 register (bit OC2PE). Else the preload value is copied in the active capture/compare 2 register when an update event occurs.
              The active capture/compare register contains the value to be compared to the counter CNT and signalled on OC2 output.
              If channel CC2 is configured as input:
              CCR2 is the counter value transferred by the last input capture 2 event (IC2). The CCR2 register is read-only and cannot be programmed.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR3</name>
          <displayName>CCR3</displayName>
          <description>Capture/Compare register 3</description>
          <addressOffset>0x3c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>CCR3</name>
              <description>
              Capture/Compare value
              If channel CC3 is configured as output:
              CCR3 is the value to be loaded in the actual capture/compare 3 register (preload value).It is loaded permanently if the preload feature is not selected in the CCMR2 register (bit OC3PE). Else the preload value is copied in the active capture/compare 3 register when an update event occurs.
              The active capture/compare register contains the value to be compared to the counter CNT and signalled on OC3 output.
              If channel CC3is configured as input:
              CCR3 is the counter value transferred by the last input capture 3 event (IC3). The CCR3 register is read-only and cannot be programmed.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR4</name>
          <displayName>CCR4</displayName>
          <description>Capture/Compare register 4</description>
          <addressOffset>0x40</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>CCR4</name>
              <description>
              Capture/Compare value
              1. if CC4 channel is configured as output:
              CCR4 is the value to be loaded in the actual capture/compare 4 register (preload value).It is loaded permanently if the preload feature is not selected in the CCMR2 register (bit OC4PE). Else the preload value is copied in the active capture/compare 4 register when an update event occurs.
              The active capture/compare register contains the value to be compared to the counter CNT and signalled on OC4 output.
              2.  if CC4 channel is configured as input:
              CCR4 is the counter value transferred by the last input capture 4 event (IC4). The CCR4 register is read-only and cannot be programmed.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>BTIM1</name>
      <description></description>
      <groupName>BTIM</groupName>
      <baseAddress>0x40012000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CR1</name>
          <displayName>CR1</displayName>
          <description>TIM control register 1</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>ARPE</name>
              <description>
              Auto-reload preload enable
              0: ARR register is not buffered
              1: ARR register is buffered
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>OPM</name>
              <description>
              One-pulse mode
              0: Counter is not stopped at update event
              1: Counter stops counting at the next update event (clearing the bit CEN)
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>URS</name>
              <description>
              Update request source
              This bit is set and cleared by software to select the UEV event sources.
              0: Any of the following events generate an update interrupt or DMA request if enabled. 
              These events can be: 
                 Counter overflow
                 Setting the UG bit
                 Update generation through the slave mode controller
              1: Only counter overflow generates an update interrupt or DMA request if enabled.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UDIS</name>
              <description>
              Update disable
              This bit is set and cleared by software to enable/disable UEV event generation.
              0: UEV enabled. The Update (UEV) event is generated by one of the following events:
                 Counter overflow
                 Setting the UG bit
                 Update generation through the slave mode controller
              Buffered registers are then loaded with their preload values.
              1: UEV disabled. The Update event is not generated, shadow registers keep their value (ARR, PSC). However the counter and the prescaler are reinitialized if the UG bit is set or if a hardware reset is received from the slave mode controller.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CEN</name>
              <description>
              Counter enable
              0: Counter disabled
              1: Counter enabled
              Note: Gated mode can work only if the CEN bit has been previously set by software. However trigger mode can set the CEN bit automatically by hardware. 
              CEN is cleared automatically in one-pulse mode, when an update event occurs.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CR2</name>
          <displayName>CR2</displayName>
          <description>TIM control register 2</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>26</bitWidth>
            </field>
            <field>
              <name>MMS</name>
              <description>
              Master mode selection
              These bits allow to select the information to be sent in master mode to slave timers for synchronization (TRGO). The combination is as follows:
              00: Reset:the UG bit from the EGR register is used as trigger output (TRGO). If the reset is generated by the trigger input (slave mode controller configured in reset mode) then the signal on TRGO is delayed compared to the actual reset.
              01: Enable :the Counter enable signal, CNT_EN, is used as trigger output (TRGO). It is useful to start several timers at the same time or to control a window in which a slave timer is enabled. The Counter Enable signal is generated by a logic OR between CEN control bit and the trigger input when configured in gated mode. 
              When the Counter Enable signal is controlled by the trigger input, there is a delay on TRGO, except if the master/slave mode is selected (see the MSM bit description in SMCR register).
              10: Update:The update event is selected as trigger output (TRGO). For instance a master timer can then be used as a prescaler for a slave timer.
              11: Gating:The delayed gating trigger is selected as trigger output (TRGO). 
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SMCR</name>
          <displayName>SMCR</displayName>
          <description>TIM slave mode control register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>GM</name>
              <description>
              Gated Mode. The counter clock is enabled when the selected trigger input (TRGI) is active (according to gating trigger polarity). The counter stops (but is not reset) as soon as the trigger becomes inactive. Both start and stop of the counter are controlled. Gated mode and slave mode can be enabled simutanuously with different trigger selection.
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GTP</name>
              <description>
              Gating trigger polarity invert
              0: active at high level
              1: active at low level
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GTS</name>
              <description>
              Gating trigger selection in gated mode
              This bit-field selects the trigger input to be used to enable the counter gating.
              00: Internal Trigger 0 (ITR0)
              01: Internal Trigger 1 (ITR1) 
              10: Internal Trigger 2 (ITR2)
              11: Internal Trigger 3 (ITR3)
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SMS</name>
              <description>
              Slave mode selection
              When external signals are selected the active edge of the trigger signal (TRGI) is linked to the polarity selected on the external input.
              000: Slave mode disabled.
              001: Reset Mode - Rising edge of the selected trigger input (TRGI) reinitializes the counter and generates an update of the registers.
              010: Trigger Mode - The counter starts at a rising edge of the trigger TRGI (but it is not reset). Only the start of the counter is controlled.
              011: Combined reset + trigger mode - Rising edge of the selected trigger input (TRGI) reinitializes the counter, generates an update of the registers and starts the counter.
              100: External Clock Mode - Rising edges of the selected trigger (TRGI) clock the counter.
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>MSM</name>
              <description>
              Master/Slave mode. This bit should be asserted on master timer if synchronization if needed.
              0: No action
              1: The effect of an event on the trigger input (TRGI) is delayed to allow a perfect synchronization between the current timer and its slaves (through TRGO). It is useful if we want to synchronize several timers on a single external event.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TS</name>
              <description>
              Trigger selection
              This bit-field selects the trigger input to be used to synchronize the counter.
              00: Internal Trigger 0 (ITR0)
              01: Internal Trigger 1 (ITR1) 
              10: Internal Trigger 2 (ITR2)
              11: Internal Trigger 3 (ITR3)
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD5</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DIER</name>
          <displayName>DIER</displayName>
          <description>TIM DMA/Interrupt enable register</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>UDE</name>
              <description>
              Update DMA request enable
              0: Update DMA request disabled.
              1: Update DMA request enabled
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
            <field>
              <name>UIE</name>
              <description>
              Update interrupt enable
              0: Update interrupt disabled.
              1: Update interrupt enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SR</name>
          <displayName>SR</displayName>
          <description>TIM status register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>31</bitWidth>
            </field>
            <field>
              <name>UIF</name>
              <description>
              Update interrupt flag
              This bit is set by hardware on an update event. It is cleared by software.
              0: No update occurred
              1: Update interrupt pending. This bit is set by hardware when the registers are updated:
              At overflow and if UDIS=0 in the CR1 register.
              When CNT is reinitialized by software using the UG bit in EGR register, if URS=0 and UDIS=0 in the CR1 register.
              When CNT is reinitialized by a trigger event (refer to the synchro control register description), if URS=0 and UDIS=0 in the CR1 register.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>EGR</name>
          <displayName>EGR</displayName>
          <description>Event generation register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>31</bitWidth>
            </field>
            <field>
              <name>UG</name>
              <description>
              Update generation
              This bit can be set by software, it is automatically cleared by hardware.
              0: No action
              1: Re-initialize the counter and generates an update of the registers. Note that the prescaler counter is cleared too (anyway the prescaler ratio is not affected). The counter is cleared if the center-aligned mode is selected or if DIR=0 (upcounting), else it takes the auto-reload value (ARR) if DIR=1 (downcounting).
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD1</name>
          <displayName>RSVD1</displayName>
          <description></description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>CNT</name>
          <displayName>CNT</displayName>
          <description>Counter</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>CNT</name>
              <description>
              counter value
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PSC</name>
          <displayName>PSC</displayName>
          <description>Prescaler</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>PSC</name>
              <description>
              Prescaler value
              The counter clock frequency is equal to fCLK / (PSC[15:0] + 1).
              PSC contains the value to be loaded in the active prescaler register at each update event (including when the counter is cleared through UG bit of EGR register or through trigger controller when configured in "reset mode").
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ARR</name>
          <displayName>ARR</displayName>
          <description>Auto-reload register</description>
          <addressOffset>0x2c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ARR</name>
              <description>
              Auto-reload value
              ARR is the value to be loaded in the actual auto-reload register. The counter is blocked while the auto-reload value is null.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>BTIM2</name>
      <description></description>
      <groupName>BTIM</groupName>
      <baseAddress>0x40013000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CR1</name>
          <displayName>CR1</displayName>
          <description>TIM control register 1</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>ARPE</name>
              <description>
              Auto-reload preload enable
              0: ARR register is not buffered
              1: ARR register is buffered
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>OPM</name>
              <description>
              One-pulse mode
              0: Counter is not stopped at update event
              1: Counter stops counting at the next update event (clearing the bit CEN)
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>URS</name>
              <description>
              Update request source
              This bit is set and cleared by software to select the UEV event sources.
              0: Any of the following events generate an update interrupt or DMA request if enabled. 
              These events can be: 
                 Counter overflow
                 Setting the UG bit
                 Update generation through the slave mode controller
              1: Only counter overflow generates an update interrupt or DMA request if enabled.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UDIS</name>
              <description>
              Update disable
              This bit is set and cleared by software to enable/disable UEV event generation.
              0: UEV enabled. The Update (UEV) event is generated by one of the following events:
                 Counter overflow
                 Setting the UG bit
                 Update generation through the slave mode controller
              Buffered registers are then loaded with their preload values.
              1: UEV disabled. The Update event is not generated, shadow registers keep their value (ARR, PSC). However the counter and the prescaler are reinitialized if the UG bit is set or if a hardware reset is received from the slave mode controller.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CEN</name>
              <description>
              Counter enable
              0: Counter disabled
              1: Counter enabled
              Note: Gated mode can work only if the CEN bit has been previously set by software. However trigger mode can set the CEN bit automatically by hardware. 
              CEN is cleared automatically in one-pulse mode, when an update event occurs.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CR2</name>
          <displayName>CR2</displayName>
          <description>TIM control register 2</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>26</bitWidth>
            </field>
            <field>
              <name>MMS</name>
              <description>
              Master mode selection
              These bits allow to select the information to be sent in master mode to slave timers for synchronization (TRGO). The combination is as follows:
              00: Reset:the UG bit from the EGR register is used as trigger output (TRGO). If the reset is generated by the trigger input (slave mode controller configured in reset mode) then the signal on TRGO is delayed compared to the actual reset.
              01: Enable :the Counter enable signal, CNT_EN, is used as trigger output (TRGO). It is useful to start several timers at the same time or to control a window in which a slave timer is enabled. The Counter Enable signal is generated by a logic OR between CEN control bit and the trigger input when configured in gated mode. 
              When the Counter Enable signal is controlled by the trigger input, there is a delay on TRGO, except if the master/slave mode is selected (see the MSM bit description in SMCR register).
              10: Update:The update event is selected as trigger output (TRGO). For instance a master timer can then be used as a prescaler for a slave timer.
              11: Gating:The delayed gating trigger is selected as trigger output (TRGO). 
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SMCR</name>
          <displayName>SMCR</displayName>
          <description>TIM slave mode control register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>GM</name>
              <description>
              Gated Mode. The counter clock is enabled when the selected trigger input (TRGI) is active (according to gating trigger polarity). The counter stops (but is not reset) as soon as the trigger becomes inactive. Both start and stop of the counter are controlled. Gated mode and slave mode can be enabled simutanuously with different trigger selection.
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GTP</name>
              <description>
              Gating trigger polarity invert
              0: active at high level
              1: active at low level
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GTS</name>
              <description>
              Gating trigger selection in gated mode
              This bit-field selects the trigger input to be used to enable the counter gating.
              00: Internal Trigger 0 (ITR0)
              01: Internal Trigger 1 (ITR1) 
              10: Internal Trigger 2 (ITR2)
              11: Internal Trigger 3 (ITR3)
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SMS</name>
              <description>
              Slave mode selection
              When external signals are selected the active edge of the trigger signal (TRGI) is linked to the polarity selected on the external input.
              000: Slave mode disabled.
              001: Reset Mode - Rising edge of the selected trigger input (TRGI) reinitializes the counter and generates an update of the registers.
              010: Trigger Mode - The counter starts at a rising edge of the trigger TRGI (but it is not reset). Only the start of the counter is controlled.
              011: Combined reset + trigger mode - Rising edge of the selected trigger input (TRGI) reinitializes the counter, generates an update of the registers and starts the counter.
              100: External Clock Mode - Rising edges of the selected trigger (TRGI) clock the counter.
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>MSM</name>
              <description>
              Master/Slave mode. This bit should be asserted on master timer if synchronization if needed.
              0: No action
              1: The effect of an event on the trigger input (TRGI) is delayed to allow a perfect synchronization between the current timer and its slaves (through TRGO). It is useful if we want to synchronize several timers on a single external event.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TS</name>
              <description>
              Trigger selection
              This bit-field selects the trigger input to be used to synchronize the counter.
              00: Internal Trigger 0 (ITR0)
              01: Internal Trigger 1 (ITR1) 
              10: Internal Trigger 2 (ITR2)
              11: Internal Trigger 3 (ITR3)
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD5</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DIER</name>
          <displayName>DIER</displayName>
          <description>TIM DMA/Interrupt enable register</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>UDE</name>
              <description>
              Update DMA request enable
              0: Update DMA request disabled.
              1: Update DMA request enabled
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
            <field>
              <name>UIE</name>
              <description>
              Update interrupt enable
              0: Update interrupt disabled.
              1: Update interrupt enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SR</name>
          <displayName>SR</displayName>
          <description>TIM status register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>31</bitWidth>
            </field>
            <field>
              <name>UIF</name>
              <description>
              Update interrupt flag
              This bit is set by hardware on an update event. It is cleared by software.
              0: No update occurred
              1: Update interrupt pending. This bit is set by hardware when the registers are updated:
              At overflow and if UDIS=0 in the CR1 register.
              When CNT is reinitialized by software using the UG bit in EGR register, if URS=0 and UDIS=0 in the CR1 register.
              When CNT is reinitialized by a trigger event (refer to the synchro control register description), if URS=0 and UDIS=0 in the CR1 register.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>EGR</name>
          <displayName>EGR</displayName>
          <description>Event generation register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>31</bitWidth>
            </field>
            <field>
              <name>UG</name>
              <description>
              Update generation
              This bit can be set by software, it is automatically cleared by hardware.
              0: No action
              1: Re-initialize the counter and generates an update of the registers. Note that the prescaler counter is cleared too (anyway the prescaler ratio is not affected). The counter is cleared if the center-aligned mode is selected or if DIR=0 (upcounting), else it takes the auto-reload value (ARR) if DIR=1 (downcounting).
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD1</name>
          <displayName>RSVD1</displayName>
          <description></description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>CNT</name>
          <displayName>CNT</displayName>
          <description>Counter</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>CNT</name>
              <description>
              counter value
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PSC</name>
          <displayName>PSC</displayName>
          <description>Prescaler</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>PSC</name>
              <description>
              Prescaler value
              The counter clock frequency is equal to fCLK / (PSC[15:0] + 1).
              PSC contains the value to be loaded in the active prescaler register at each update event (including when the counter is cleared through UG bit of EGR register or through trigger controller when configured in "reset mode").
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ARR</name>
          <displayName>ARR</displayName>
          <description>Auto-reload register</description>
          <addressOffset>0x2c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ARR</name>
              <description>
              Auto-reload value
              ARR is the value to be loaded in the actual auto-reload register. The counter is blocked while the auto-reload value is null.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>WDT1</name>
      <description></description>
      <groupName>WDT</groupName>
      <baseAddress>0x40014000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>WDT_CVR0</name>
          <displayName>WDT_CVR0</displayName>
          <description>WatchDog Counter Value 0</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>COUNT_VALUE_0</name>
              <description>
              Count Value for 1st TimeOut
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_CVR1</name>
          <displayName>WDT_CVR1</displayName>
          <description>WatchDog Counter Value 1</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>COUNT_VALUE_1</name>
              <description>
              Count Value for 2nd TimeOut
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_CR</name>
          <displayName>WDT_CR</displayName>
          <description>WatchDog Control Register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>27</bitWidth>
            </field>
            <field>
              <name>RESPONSE_MODE</name>
              <description>
              0:reset only, 1:interrupt and reset
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RESET_LENGTH</name>
              <description>
              reset pulse length in number of wdt clock cycles
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_CCR</name>
          <displayName>WDT_CCR</displayName>
          <description>WatchDog Counter Control Register</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>COUNTER_CONTROL</name>
              <description>
              SinglePulse /Write 8'h76 to restart, write8'h34 to stop, else do nothing
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_ICR</name>
          <displayName>WDT_ICR</displayName>
          <description>WatchDog Interrupt Clear Register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>31</bitWidth>
            </field>
            <field>
              <name>INT_CLR</name>
              <description>
              SinglePulse /A pulse to clear interrupt
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_SR</name>
          <displayName>WDT_SR</displayName>
          <description>WatchDog Status Register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>30</bitWidth>
            </field>
            <field>
              <name>WDT_ACTIVE</name>
              <description>
              Watchdog runs when 1, else 0
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>INT_ASSERT</name>
              <description>
              Interrupt assert when 1
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_WP</name>
          <displayName>WDT_WP</displayName>
          <description>WatchDog Write Protect Register</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>WRPT_ST</name>
              <description>
              1 indicates write protect is active
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>WRPT</name>
              <description>
              write 0x58ab99fc generate write_protect, write 0x51ff8621 to release
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>31</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>SPI1</name>
      <description></description>
      <groupName>SPI</groupName>
      <baseAddress>0x40015000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>TOP_CTRL</name>
          <displayName>TOP_CTRL</displayName>
          <description>Top Control Register</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>13</bitWidth>
            </field>
            <field>
              <name>TTELP</name>
              <description>
              TXD Three-state Enable On Last Phase 0 = TXDx is three-stated 1/2 clock cycle after the beginning of the LSB 1 = TXDx output signal is three-stated on the clock edge that ends the LSB
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TTE</name>
              <description>
              TXD Three-State Enable 0 = TXDx output signal is not three-stated 1 = TXD is three-stated when not transmitting data
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SCFR</name>
              <description>
              Slave Clock Free Running 0 = Clock input to SSPSCLKx is continuously running 1 = Clock input to SSPSCLKx is only active during data transfers. 
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IFS</name>
              <description>
              Invert Frame Signal 0 = SSPSFRMx polarity is determined by the PSP polarity bits 1 = SSPSFRMx will be inverted from normal-SSPSFRMx (as defined by the PSP polarity bits). (Works in all frame formats: SPI, SSP, and PSP)
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HOLD_FRAME_LOW</name>
              <description>
              Hold Frame Low Control 1=After this field is set to 1 and the SSP is operating in master mode, the output frame clock ssp_sfrm_gpio will hold low. Used for SPI and NMW Format Rx FIFO Auto Full Control, which makes the frame clock is still low during there's no bit clock, or the data transfers before the stop clock will be discarded.  
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TRAIL</name>
              <description>
              Trailing Byte 0 = Trailing bytes are handled by CPU 1 = Trailing bytes are handled by DMA bursts
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SPH</name>
              <description>
              Motorola SPI SSPSCLK phase setting 0 = SSPSCLKx is inactive until one cycle after the start of a frame and active until 1/2 cycle before the end of a frame 1 = SSPSCLKx is inactive until 1/2 cycle after the start of a frame and active until one cycle before the end of a frame
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SPO</name>
              <description>
              Motorola SPI SSPSCLK Polarity Setting 0 = The inactive or idle state of SSPSCLKx is low 1 = The inactive or idle state of SSPSCLKx is high
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DSS</name>
              <description>
              SSP Work data size,  register bits value 0~31 indicated data size 1~32 bits,  usually use data size 8bits, 16bits, 24bits, 32bits
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>SFRMDIR</name>
              <description>
              SSP Frame (SSPSFRMx) Direction 0 = Master mode, SSPx port drives SSPSFRMx 1 = Slave mode, SSPx port receives SSPSFRMx
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SCLKDIR</name>
              <description>
              SSP Serial Bit Rate Clock (SSPSCLKx) Direction 0 = Master mode, SSPx port drives SSPSCLKx 1 = Slave mode, SSPx port receives SSPSCLKx
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FRF</name>
              <description>
              Frame Format 0x0 = Motorola* Serial Peripheral Interface (SPI)  0x1 = Texas Instruments* Synchronous Serial Protocol (SSP) 0x2 = National Semiconductor Microwire* 0x3 = Programmable Serial Protocol (PSP) 
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>SSE</name>
              <description>
              Synchronous Serial Port Enable 0 = SSPx port is disabled  1 = SSPx port is enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>FIFO_CTRL</name>
          <displayName>FIFO_CTRL</displayName>
          <description>FIFO Control Register</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>14</bitWidth>
            </field>
            <field>
              <name>RXFIFO_AUTO_FULL_CTRL</name>
              <description>
              Rx FIFO Auto Full Control =1After this field is set to 1 and the SSP is operating in master mode, the SSP FSM returns to IDLE state and stops the ssp_sclk_gpio. When Rx FIFO is full, the SSP FSM continues transferring data after the Rx FIFO is not full. This field is used to avoid an Rx FIFO overrun issue. 1= Enable Rx FIFO auto full control
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FPCKE</name>
              <description>
              FIFO Packing Enable 0 = FIFO packing mode disabled 1 = FIFO packing mode enabled
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TXFIFO_WR_ENDIAN</name>
              <description>
              apb_pwdata Write to Tx FIFO Endian 0x0 = txfifo_wdata[31:0] = apb_pwdata[31:0] 0x1 = fifo_wdata[31:0] = {apb_pwdata[15:0], apb_pwdata[31:16]} 0x2 = txfifo_wdata[31:0] = {apb_pwdata[7:0], apb_pwdata[15:8], apb_pwdata[23:16], apb_pwdata[31:24]} 0x3 = txfifo_wdata[31:0] = {apb_pwdata[23:16], apb_pwdata[31:24], apb_pwdata[7:0], apb_pwdata[15:8]}
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RXFIFO_RD_ENDIAN</name>
              <description>
              apb_prdata Read from Rx FIFO Endian 0x0 = apb_prdata[31:0] = rxfifo_wdata[31:0] 0x1 = apb_prdata[31:0] = {rxfifo_wdata[15:0], rxfifo_wdata[31:16]} 0x2 = apb_prdata[31:0]= {rxfifo_wdata[7:0], rxfifo_wdata[15:8], rxfifo_wdata[23:16], rxfifo_wdata[31:24]} 0x3 = apb_prdata[31:0]= {rxfifo_wdata[23:16], rxfifo_wdata[31:24], rxfifo_wdata[7:0], rxfifo_wdata[15:8]}
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSRE</name>
              <description>
              Receive Service Request Enable 0 = DMA service request is disabled 1 = DMA service request is enabled
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TSRE</name>
              <description>
              Transmit Service Request Enable 0 = DMA service request is disabled 1 = DMA service request is enabled
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RFT</name>
              <description>
              RXFIFO Trigger Threshold This field sets the threshold level at which RXFIFO asserts interrupt. The level should be set to the preferred threshold value minus 1.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>TFT</name>
              <description>
              TXFIFO Trigger Threshold This field sets the threshold level at which TXFIFO asserts interrupt. The level should be set to the preferred threshold value minus 1. 
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>INTE</name>
          <displayName>INTE</displayName>
          <description>Interrupt Enable Register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>26</bitWidth>
            </field>
            <field>
              <name>TIM</name>
              <description>
              Transmit FIFO Underrun Interrupt Mask 0 = TUR events generate an SSP interrupt 1 = TUR events do NOT generate an SSP interrupt 
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RIM</name>
              <description>
              Receive FIFO Overrun Interrupt Mask 0 = ROR events generate an SSP interrupt 1 = ROR events do NOT generate an SSP interrupt 
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TIE</name>
              <description>
              Transmit FIFO Interrupt Enable 0 = TXFIFO threshold-level-reached interrupt is disabled 1 = TXFIFO threshold-level-reached interrupt is enabled
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RIE</name>
              <description>
              Receive FIFO Interrupt Enable 0 = RXFIFO threshold-level-reached interrupt is disabled 1 = RXFIFO threshold-level-reached interrupt is enabled
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TINTE</name>
              <description>
              Receiver Time-out Interrupt Enable 0 = Receiver time-out interrupt is disabled 1 = Receiver time-out interrupt is enabled
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TO</name>
          <displayName>TO</displayName>
          <description>SPI Time Out Register</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>TIMEOUT</name>
              <description>
              Timeout Value TIMEOUT value is the value (0 to 2&lt;super 24>-1) that defines the time-out interval. The time-out interval is given by the equation shown in the TIMEOUT Interval Equation.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DATA</name>
          <displayName>DATA</displayName>
          <description>SPI DATA Register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              DATA This field is used for data to be written to the TXFIFO read from the RXFIFO.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS</name>
          <displayName>STATUS</displayName>
          <description>Status Register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>OSS</name>
              <description>
              Odd Sample Status 0 = RxFIFO entry has two samples 1 = RxFIFO entry has one sample  Note that this bit needs to be looked at only when FIFO Packing is enabled (&lt;FIFO Packing Enable> field in SSP FIFO Control Register is set). Otherwise, this bit is zero. When SSPx port is in Packed mode and the CPU is used instead of DMA to read the RxFIFO, the CPU should make sure that &lt;Receive FIFO Not Empty> = 1 AND this field = 0 before it attempts to read the RxFIFO.
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TX_OSS</name>
              <description>
              TX FIFO Odd Sample Status When SSPx port is in packed mode, the number of samples in the TX FIFO is:  (&lt;Transmit FIFO Level>*2 + this field), when &lt;Transmit FIFO Not Full> = 1 32, when &lt;Transmit FIFO Not Full> = 0. The TX FIFO cannot accept new data when &lt;Transmit FIFO Not Full> = 1 and &lt;Transmit FIFO Level> = 15 and this field = 1. (The TX FIFO has 31 samples).  0 = TxFIFO entry has an even number of samples 1 = TxFIFO entry has an odd number of samples Note that this bit needs to be read only when FIFO Packing is enabled (&lt;FIFO Packing Enable> in the SSP FIFO Control Register is set). Otherwise, this bit is zero.
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BCE</name>
              <description>
              Bit Count Error 0 = The SSPx port has not experienced a bit count error 1 = The SSPSFRMx signal was asserted when the bit counter was not zero
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ROR</name>
              <description>
              Receive FIFO Overrun 0 = RXFIFO has not experienced an overrun 1 = Attempted data write to full RXFIFO, causes an interrupt request
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RFL</name>
              <description>
              Receive FIFO Level This field is the number of entries minus one in RXFIFO. When the value 0x1F is read, the RXFIFO is either empty or full, and software should read the &lt;Receive FIFO Not Empty> field.
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>RNE</name>
              <description>
              Receive FIFO Not Empty 0 = RXFIFO is empty 1 = RXFIFO is not empty
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RFS</name>
              <description>
              Receive FIFO Service Request 0 = RXFIFO level is at or below RFT threshold (RFT) or SSPx port is disabled 1 = RXFIFO level exceeds RFT threshold (RFT), causes an interrupt request
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TUR</name>
              <description>
              Transmit FIFO Underrun 0 = The TXFIFO has not experienced an underrun 1 = A read from the TXFIFO was attempted when the TXFIFO was empty, causes an interrupt if it is enabled (&lt;Transmit FIFO Underrun Interrupt Mask> in the SSP INT EN Register  is 0)
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TFL</name>
              <description>
              Transmit FIFO Level This field is the number of entries in TXFIFO.When the value 0x0 is read, the TXFIFO is either empty or full, and software should read the &lt;Transmit FIFO Not Full> field.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>TNF</name>
              <description>
              Transmit FIFO Not Full 0 = TXFIFO is full 1 = TXFIFO is not full
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TFS</name>
              <description>
              Transmit FIFO Service Request 0 = TX FIFO level exceeds the TFT threshold (TFT + 1) or SSPx port disabled 1 = TXFIFO level is at or below TFT threshold (TFT + 1), causes an interrupt request
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EOC</name>
              <description>
              End Of Chain 0 = DMA has not signaled an end of chain condition 1 = DMA has signaled an end of chain condition
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TINT</name>
              <description>
              Receiver Time-out Interrupt 0 = No receiver time-out is pending 1 = Receiver time-out pending, causes an interrupt request
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PINT</name>
              <description>
              Peripheral Trailing Byte Interrupt 0 = No peripheral trailing byte interrupt is pending 1 = Peripheral trailing byte interrupt is pending
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CSS</name>
              <description>
              Clock Synchronization Status 0 = The SSPx port is ready for slave clock operations 1 = The SSPx port is currently busy synchronizing slave mode signals
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BSY</name>
              <description>
              SSP Busy 0 = SSPx port is idle or disabled 1 = SSPx port is currently transmitting or receiving framed data
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD3</name>
          <displayName>RSVD3</displayName>
          <description></description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>RWOT_CTRL</name>
          <displayName>RWOT_CTRL</displayName>
          <description>SSP RWOT Control Register</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>27</bitWidth>
            </field>
            <field>
              <name>MASK_RWOT_LAST_SAMPLE</name>
              <description>
              Mask last_sample_flag in RWOT Mode 1= Mask 0 = Unmask
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CLR_RWOT_CYCLE</name>
              <description>
              Clear SSP Internal rwot_counter This field clears the rwot_counter to 0. This field is self cleared by SSP after SSE = 1. 1 = Clear rwot_counter
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SET_RWOT_CYCLE</name>
              <description>
              Set RWOT Cycle This field is used to set the value of the SSP_RWOT_CCM register to the SSP internal rwot_counter. This field is self-cleared by SSP after SSE = 1. 1 = Set rwot_counter
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CYCLE_RWOT_EN</name>
              <description>
              Enable SSP RWOT Cycle Counter Mode 1 = Enable
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RWOT</name>
              <description>
              Receive Without Transmit 0 = Transmit/receive mode 1 = Receive without transmit mode
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RWOT_CCM</name>
          <displayName>RWOT_CCM</displayName>
          <description>SSP RWOT Counter Cycles Match Register</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>SSPRWOTCCM</name>
              <description>
              It's just total ssp_sclk_gpio Cycles The value of this register defines the total number of ssp_sclk_gpio cycles when SSP works in master and RWOT mode. When the rwot_counter matches this value, SSP returns to IDLE state and does not output ssp_sclk_gpio anymore.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RWOT_CVWRN</name>
          <displayName>RWOT_CVWRN</displayName>
          <description>SSP RWOT Counter Value Write for Red Request Register</description>
          <addressOffset>0x2c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>SSPRWOTCVWR</name>
              <description>
              SSPRWOTCVWR This register prevents the risk of instability on rwot_counter value reading, it's only valid after SSP has been enabled Write 0 = No effect Write 1 = Capture value of rwot_counter Read: Returns the captured value of rwot_counter
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD2</name>
          <displayName>RSVD2</displayName>
          <description></description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>CLK_CTRL</name>
          <displayName>CLK_CTRL</displayName>
          <description>SSP CLK  Control Register</description>
          <addressOffset>0x3c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>CLK_SEL</name>
              <description>
              0: select clk_div as clk_ssp 1: select clk_sys as clk_ssp
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CLK_DIV</name>
              <description>
              div ratio from clk_sys
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD1</name>
          <displayName>RSVD1</displayName>
          <description></description>
          <addressOffset>0x40</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>TRIWIRE_CTRL</name>
          <displayName>TRIWIRE_CTRL</displayName>
          <description>SSP Three Wire Mode  Control Register</description>
          <addressOffset>0x54</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>29</bitWidth>
            </field>
            <field>
              <name>SSP_WORK_WIDTH_DYN_CHANGE</name>
              <description>
              SSP_WORK_WIDTH_DYN_CHNAGE 1=SP can dynamicly change SSP_TOP_CTRL[9:5] without disabling SSP_TOP_CTRL[0] and re-enabling SSP_TOP_CTRL[0]   
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TXD_OEN</name>
              <description>
              TXD_OEN 1=TXD is input  0=TXD is output
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SPI_TRI_WIRE_EN</name>
              <description>
              SPI_THREE_WIRE_MODE_EN 1=enable
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>SPI2</name>
      <description></description>
      <groupName>SPI</groupName>
      <baseAddress>0x40016000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>TOP_CTRL</name>
          <displayName>TOP_CTRL</displayName>
          <description>Top Control Register</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>13</bitWidth>
            </field>
            <field>
              <name>TTELP</name>
              <description>
              TXD Three-state Enable On Last Phase 0 = TXDx is three-stated 1/2 clock cycle after the beginning of the LSB 1 = TXDx output signal is three-stated on the clock edge that ends the LSB
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TTE</name>
              <description>
              TXD Three-State Enable 0 = TXDx output signal is not three-stated 1 = TXD is three-stated when not transmitting data
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SCFR</name>
              <description>
              Slave Clock Free Running 0 = Clock input to SSPSCLKx is continuously running 1 = Clock input to SSPSCLKx is only active during data transfers. 
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IFS</name>
              <description>
              Invert Frame Signal 0 = SSPSFRMx polarity is determined by the PSP polarity bits 1 = SSPSFRMx will be inverted from normal-SSPSFRMx (as defined by the PSP polarity bits). (Works in all frame formats: SPI, SSP, and PSP)
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HOLD_FRAME_LOW</name>
              <description>
              Hold Frame Low Control 1=After this field is set to 1 and the SSP is operating in master mode, the output frame clock ssp_sfrm_gpio will hold low. Used for SPI and NMW Format Rx FIFO Auto Full Control, which makes the frame clock is still low during there's no bit clock, or the data transfers before the stop clock will be discarded.  
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TRAIL</name>
              <description>
              Trailing Byte 0 = Trailing bytes are handled by CPU 1 = Trailing bytes are handled by DMA bursts
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SPH</name>
              <description>
              Motorola SPI SSPSCLK phase setting 0 = SSPSCLKx is inactive until one cycle after the start of a frame and active until 1/2 cycle before the end of a frame 1 = SSPSCLKx is inactive until 1/2 cycle after the start of a frame and active until one cycle before the end of a frame
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SPO</name>
              <description>
              Motorola SPI SSPSCLK Polarity Setting 0 = The inactive or idle state of SSPSCLKx is low 1 = The inactive or idle state of SSPSCLKx is high
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DSS</name>
              <description>
              SSP Work data size,  register bits value 0~31 indicated data size 1~32 bits,  usually use data size 8bits, 16bits, 24bits, 32bits
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>SFRMDIR</name>
              <description>
              SSP Frame (SSPSFRMx) Direction 0 = Master mode, SSPx port drives SSPSFRMx 1 = Slave mode, SSPx port receives SSPSFRMx
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SCLKDIR</name>
              <description>
              SSP Serial Bit Rate Clock (SSPSCLKx) Direction 0 = Master mode, SSPx port drives SSPSCLKx 1 = Slave mode, SSPx port receives SSPSCLKx
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FRF</name>
              <description>
              Frame Format 0x0 = Motorola* Serial Peripheral Interface (SPI)  0x1 = Texas Instruments* Synchronous Serial Protocol (SSP) 0x2 = National Semiconductor Microwire* 0x3 = Programmable Serial Protocol (PSP) 
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>SSE</name>
              <description>
              Synchronous Serial Port Enable 0 = SSPx port is disabled  1 = SSPx port is enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>FIFO_CTRL</name>
          <displayName>FIFO_CTRL</displayName>
          <description>FIFO Control Register</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>14</bitWidth>
            </field>
            <field>
              <name>RXFIFO_AUTO_FULL_CTRL</name>
              <description>
              Rx FIFO Auto Full Control =1After this field is set to 1 and the SSP is operating in master mode, the SSP FSM returns to IDLE state and stops the ssp_sclk_gpio. When Rx FIFO is full, the SSP FSM continues transferring data after the Rx FIFO is not full. This field is used to avoid an Rx FIFO overrun issue. 1= Enable Rx FIFO auto full control
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FPCKE</name>
              <description>
              FIFO Packing Enable 0 = FIFO packing mode disabled 1 = FIFO packing mode enabled
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TXFIFO_WR_ENDIAN</name>
              <description>
              apb_pwdata Write to Tx FIFO Endian 0x0 = txfifo_wdata[31:0] = apb_pwdata[31:0] 0x1 = fifo_wdata[31:0] = {apb_pwdata[15:0], apb_pwdata[31:16]} 0x2 = txfifo_wdata[31:0] = {apb_pwdata[7:0], apb_pwdata[15:8], apb_pwdata[23:16], apb_pwdata[31:24]} 0x3 = txfifo_wdata[31:0] = {apb_pwdata[23:16], apb_pwdata[31:24], apb_pwdata[7:0], apb_pwdata[15:8]}
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RXFIFO_RD_ENDIAN</name>
              <description>
              apb_prdata Read from Rx FIFO Endian 0x0 = apb_prdata[31:0] = rxfifo_wdata[31:0] 0x1 = apb_prdata[31:0] = {rxfifo_wdata[15:0], rxfifo_wdata[31:16]} 0x2 = apb_prdata[31:0]= {rxfifo_wdata[7:0], rxfifo_wdata[15:8], rxfifo_wdata[23:16], rxfifo_wdata[31:24]} 0x3 = apb_prdata[31:0]= {rxfifo_wdata[23:16], rxfifo_wdata[31:24], rxfifo_wdata[7:0], rxfifo_wdata[15:8]}
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSRE</name>
              <description>
              Receive Service Request Enable 0 = DMA service request is disabled 1 = DMA service request is enabled
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TSRE</name>
              <description>
              Transmit Service Request Enable 0 = DMA service request is disabled 1 = DMA service request is enabled
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RFT</name>
              <description>
              RXFIFO Trigger Threshold This field sets the threshold level at which RXFIFO asserts interrupt. The level should be set to the preferred threshold value minus 1.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>TFT</name>
              <description>
              TXFIFO Trigger Threshold This field sets the threshold level at which TXFIFO asserts interrupt. The level should be set to the preferred threshold value minus 1. 
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>INTE</name>
          <displayName>INTE</displayName>
          <description>Interrupt Enable Register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>26</bitWidth>
            </field>
            <field>
              <name>TIM</name>
              <description>
              Transmit FIFO Underrun Interrupt Mask 0 = TUR events generate an SSP interrupt 1 = TUR events do NOT generate an SSP interrupt 
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RIM</name>
              <description>
              Receive FIFO Overrun Interrupt Mask 0 = ROR events generate an SSP interrupt 1 = ROR events do NOT generate an SSP interrupt 
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TIE</name>
              <description>
              Transmit FIFO Interrupt Enable 0 = TXFIFO threshold-level-reached interrupt is disabled 1 = TXFIFO threshold-level-reached interrupt is enabled
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RIE</name>
              <description>
              Receive FIFO Interrupt Enable 0 = RXFIFO threshold-level-reached interrupt is disabled 1 = RXFIFO threshold-level-reached interrupt is enabled
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TINTE</name>
              <description>
              Receiver Time-out Interrupt Enable 0 = Receiver time-out interrupt is disabled 1 = Receiver time-out interrupt is enabled
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TO</name>
          <displayName>TO</displayName>
          <description>SPI Time Out Register</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>TIMEOUT</name>
              <description>
              Timeout Value TIMEOUT value is the value (0 to 2&lt;super 24>-1) that defines the time-out interval. The time-out interval is given by the equation shown in the TIMEOUT Interval Equation.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DATA</name>
          <displayName>DATA</displayName>
          <description>SPI DATA Register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              DATA This field is used for data to be written to the TXFIFO read from the RXFIFO.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS</name>
          <displayName>STATUS</displayName>
          <description>Status Register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>OSS</name>
              <description>
              Odd Sample Status 0 = RxFIFO entry has two samples 1 = RxFIFO entry has one sample  Note that this bit needs to be looked at only when FIFO Packing is enabled (&lt;FIFO Packing Enable> field in SSP FIFO Control Register is set). Otherwise, this bit is zero. When SSPx port is in Packed mode and the CPU is used instead of DMA to read the RxFIFO, the CPU should make sure that &lt;Receive FIFO Not Empty> = 1 AND this field = 0 before it attempts to read the RxFIFO.
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TX_OSS</name>
              <description>
              TX FIFO Odd Sample Status When SSPx port is in packed mode, the number of samples in the TX FIFO is:  (&lt;Transmit FIFO Level>*2 + this field), when &lt;Transmit FIFO Not Full> = 1 32, when &lt;Transmit FIFO Not Full> = 0. The TX FIFO cannot accept new data when &lt;Transmit FIFO Not Full> = 1 and &lt;Transmit FIFO Level> = 15 and this field = 1. (The TX FIFO has 31 samples).  0 = TxFIFO entry has an even number of samples 1 = TxFIFO entry has an odd number of samples Note that this bit needs to be read only when FIFO Packing is enabled (&lt;FIFO Packing Enable> in the SSP FIFO Control Register is set). Otherwise, this bit is zero.
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BCE</name>
              <description>
              Bit Count Error 0 = The SSPx port has not experienced a bit count error 1 = The SSPSFRMx signal was asserted when the bit counter was not zero
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ROR</name>
              <description>
              Receive FIFO Overrun 0 = RXFIFO has not experienced an overrun 1 = Attempted data write to full RXFIFO, causes an interrupt request
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RFL</name>
              <description>
              Receive FIFO Level This field is the number of entries minus one in RXFIFO. When the value 0x1F is read, the RXFIFO is either empty or full, and software should read the &lt;Receive FIFO Not Empty> field.
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>RNE</name>
              <description>
              Receive FIFO Not Empty 0 = RXFIFO is empty 1 = RXFIFO is not empty
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RFS</name>
              <description>
              Receive FIFO Service Request 0 = RXFIFO level is at or below RFT threshold (RFT) or SSPx port is disabled 1 = RXFIFO level exceeds RFT threshold (RFT), causes an interrupt request
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TUR</name>
              <description>
              Transmit FIFO Underrun 0 = The TXFIFO has not experienced an underrun 1 = A read from the TXFIFO was attempted when the TXFIFO was empty, causes an interrupt if it is enabled (&lt;Transmit FIFO Underrun Interrupt Mask> in the SSP INT EN Register  is 0)
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TFL</name>
              <description>
              Transmit FIFO Level This field is the number of entries in TXFIFO.When the value 0x0 is read, the TXFIFO is either empty or full, and software should read the &lt;Transmit FIFO Not Full> field.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>TNF</name>
              <description>
              Transmit FIFO Not Full 0 = TXFIFO is full 1 = TXFIFO is not full
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TFS</name>
              <description>
              Transmit FIFO Service Request 0 = TX FIFO level exceeds the TFT threshold (TFT + 1) or SSPx port disabled 1 = TXFIFO level is at or below TFT threshold (TFT + 1), causes an interrupt request
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EOC</name>
              <description>
              End Of Chain 0 = DMA has not signaled an end of chain condition 1 = DMA has signaled an end of chain condition
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TINT</name>
              <description>
              Receiver Time-out Interrupt 0 = No receiver time-out is pending 1 = Receiver time-out pending, causes an interrupt request
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PINT</name>
              <description>
              Peripheral Trailing Byte Interrupt 0 = No peripheral trailing byte interrupt is pending 1 = Peripheral trailing byte interrupt is pending
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CSS</name>
              <description>
              Clock Synchronization Status 0 = The SSPx port is ready for slave clock operations 1 = The SSPx port is currently busy synchronizing slave mode signals
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BSY</name>
              <description>
              SSP Busy 0 = SSPx port is idle or disabled 1 = SSPx port is currently transmitting or receiving framed data
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD3</name>
          <displayName>RSVD3</displayName>
          <description></description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>RWOT_CTRL</name>
          <displayName>RWOT_CTRL</displayName>
          <description>SSP RWOT Control Register</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>27</bitWidth>
            </field>
            <field>
              <name>MASK_RWOT_LAST_SAMPLE</name>
              <description>
              Mask last_sample_flag in RWOT Mode 1= Mask 0 = Unmask
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CLR_RWOT_CYCLE</name>
              <description>
              Clear SSP Internal rwot_counter This field clears the rwot_counter to 0. This field is self cleared by SSP after SSE = 1. 1 = Clear rwot_counter
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SET_RWOT_CYCLE</name>
              <description>
              Set RWOT Cycle This field is used to set the value of the SSP_RWOT_CCM register to the SSP internal rwot_counter. This field is self-cleared by SSP after SSE = 1. 1 = Set rwot_counter
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CYCLE_RWOT_EN</name>
              <description>
              Enable SSP RWOT Cycle Counter Mode 1 = Enable
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RWOT</name>
              <description>
              Receive Without Transmit 0 = Transmit/receive mode 1 = Receive without transmit mode
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RWOT_CCM</name>
          <displayName>RWOT_CCM</displayName>
          <description>SSP RWOT Counter Cycles Match Register</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>SSPRWOTCCM</name>
              <description>
              It's just total ssp_sclk_gpio Cycles The value of this register defines the total number of ssp_sclk_gpio cycles when SSP works in master and RWOT mode. When the rwot_counter matches this value, SSP returns to IDLE state and does not output ssp_sclk_gpio anymore.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RWOT_CVWRN</name>
          <displayName>RWOT_CVWRN</displayName>
          <description>SSP RWOT Counter Value Write for Red Request Register</description>
          <addressOffset>0x2c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>SSPRWOTCVWR</name>
              <description>
              SSPRWOTCVWR This register prevents the risk of instability on rwot_counter value reading, it's only valid after SSP has been enabled Write 0 = No effect Write 1 = Capture value of rwot_counter Read: Returns the captured value of rwot_counter
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD2</name>
          <displayName>RSVD2</displayName>
          <description></description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>CLK_CTRL</name>
          <displayName>CLK_CTRL</displayName>
          <description>SSP CLK  Control Register</description>
          <addressOffset>0x3c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>CLK_SEL</name>
              <description>
              0: select clk_div as clk_ssp 1: select clk_sys as clk_ssp
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CLK_DIV</name>
              <description>
              div ratio from clk_sys
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD1</name>
          <displayName>RSVD1</displayName>
          <description></description>
          <addressOffset>0x40</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>TRIWIRE_CTRL</name>
          <displayName>TRIWIRE_CTRL</displayName>
          <description>SSP Three Wire Mode  Control Register</description>
          <addressOffset>0x54</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>29</bitWidth>
            </field>
            <field>
              <name>SSP_WORK_WIDTH_DYN_CHANGE</name>
              <description>
              SSP_WORK_WIDTH_DYN_CHNAGE 1=SP can dynamicly change SSP_TOP_CTRL[9:5] without disabling SSP_TOP_CTRL[0] and re-enabling SSP_TOP_CTRL[0]   
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TXD_OEN</name>
              <description>
              TXD_OEN 1=TXD is input  0=TXD is output
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SPI_TRI_WIRE_EN</name>
              <description>
              SPI_THREE_WIRE_MODE_EN 1=enable
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>EXTDMA</name>
      <description></description>
      <groupName>EXTDMA</groupName>
      <baseAddress>0x40017000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>ISR</name>
          <displayName>ISR</displayName>
          <description>interrupt status register </description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>27</bitWidth>
            </field>
            <field>
              <name>OFIF</name>
              <description>
              OFIF, overflow flag
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIF</name>
              <description>
              TEIF, transfer error flag
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HTIF</name>
              <description>
              HTIF, half transfer flag
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIF</name>
              <description>
              TCIF, transfer complete flag
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GIF</name>
              <description>
              GIF,  global interrupt flag
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IFCR</name>
          <displayName>IFCR</displayName>
          <description>interrupt clear register </description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>27</bitWidth>
            </field>
            <field>
              <name>COFIF</name>
              <description>
              COFIF, overflow flag clear
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTEIF</name>
              <description>
              CTEIF, transfer error flag clear
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CHTIF</name>
              <description>
              CHTIF, half transfer flag clear
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTCIF</name>
              <description>
              CTCIF, transfer complete flag clear
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CGIF</name>
              <description>
              CGIF,  global interrupt flag clear
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR</name>
          <displayName>CCR</displayName>
          <description>channel control register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x000F0AC0</resetValue>
          <fields>
            <field>
              <name>RESET</name>
              <description>
              Software reset, will clear extdma status. Active high. Will be cleared by HW automatically
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
            <field>
              <name>SRCBURST</name>
              <description>
              source burst transfer configuration
              00: single transfer
              01: INCR4 (incremental burst of 4 beats)
              10: INCR8 (incremental burst of 8 beats)
              11: INCR16 (incremental burst of 16 beats)
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>DSTBURST</name>
              <description>
              destination burst transfer configuration
              00: single transfer
              01: INCR4 (incremental burst of 4 beats)
              10: INCR8 (incremental burst of 8 beats)
              11: INCR16 (incremental burst of 16 beats)
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>SRCSIZE</name>
              <description>
              source size
              Defines the data size of each DMA transfer to the source memory.
              Should be fixed to 10 (32 bits), word access allowed only.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>DSTSIZE</name>
              <description>
              destination size
              Defines the data size of each DMA transfer to the destination memory.
              Should be fixed to 10 (32 bits), word access allowed only.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>SRCINC</name>
              <description>
              source increment mode
              Defines the increment mode for each DMA transfer to the source memory.
              0: disabled
              1: enabled
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DSTINC</name>
              <description>
              destination increment mode
              Defines the increment mode for each DMA transfer to the destination memory.
              0: disabled
              1: enabled
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OFIE</name>
              <description>
              overflow interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIE</name>
              <description>
              transfer error interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HTIE</name>
              <description>
              half transfer interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIE</name>
              <description>
              transfer complete interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EN</name>
              <description>
              extdma enable. Will be cleared if ccr_reset is written
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CNDTR</name>
          <displayName>CNDTR</displayName>
          <description>number of data register</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
            <field>
              <name>NDT</name>
              <description>
              number of data to transfer (0 to 2^20 - 1)
              This field is updated by hardware when the channel is enabled:
                 It is decremented after each transfer, indicating the remaining amount of data items to transfer.
                 It is kept at zero when the programmed amount of data to transfer is reached.
              If this field is zero, no transfer can be served whatever the channel enabled or not
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SRCAR</name>
          <displayName>SRCAR</displayName>
          <description>source address register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>SRCADDR</name>
              <description>
              source address
              It contains the base address of the source data to be read. Should be word aligned
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DSTAR</name>
          <displayName>DSTAR</displayName>
          <description>destination 0 address register </description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DSTADDR</name>
              <description>
              destination address
              It contains the base address of the destination data to be written. Should be word aligned
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD1</name>
          <displayName>RSVD1</displayName>
          <description></description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>CMPRCR</name>
          <displayName>CMPRCR</displayName>
          <description>Image Compression control register</description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>SRCPOS</name>
              <description>
              Starting byte position in the first word of the source frame
              Valid starting positon includes: 
              RGB565: 0x0,0x2
              RGB888: 0x0, 0x1, 0x2, 0x3
              ARGB8888: 0x0
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>SRCFMT</name>
              <description>
              Source frame format
              00: 16-bit RGB 5:6:5
              01: 24-bit RGB 8:8:8
              10: 32-bit ARGB 8:8:8:8
              11: Reserved
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>CMPREN</name>
              <description>
              Compression enable
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CMPRSR</name>
          <displayName>CMPRSR</displayName>
          <description>Compression size register</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>TGTSIZE</name>
              <description>
              output target size of each line after compression. output data size of each line is tgtsize*3*2 bytes
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>LINESIZE</name>
              <description>
              column number (pixel number) of each line. Input data size of each line is linesize*(size per pixel)
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CMPRNDTR</name>
          <displayName>CMPRNDTR</displayName>
          <description>number of compression output data register</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
            <field>
              <name>CMPRNDT</name>
              <description>
              If compression enabled, cmprndt is the number of data to transfer after compression (0 to 2^20 - 1) and have to be written by software before compression. The value should be TGTSIZE*6*line_number/4 in compression mode.
              If compression disabled, it reads the number of data that extdma has written into destination address. Software do not need to write this field.
              This field is updated by hardware when extdma enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CMPRCFG0</name>
          <displayName>CMPRCFG0</displayName>
          <description>Compression configuration 0</description>
          <addressOffset>0x2c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x80023307</resetValue>
          <fields>
            <field>
              <name>CFG</name>
              <description>
              Compression configuration
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CMPRCFG1</name>
          <displayName>CMPRCFG1</displayName>
          <description>Compression configuration 1</description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x01055982</resetValue>
          <fields>
            <field>
              <name>CFG</name>
              <description>
              Compression configuration
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CMPRQR</name>
          <displayName>CMPRQR</displayName>
          <description>Compression quality register</description>
          <addressOffset>0x34</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>DUMMY</name>
              <description>
              line least dummy word in one frame, update every frame.
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>13</bitWidth>
            </field>
            <field>
              <name>LQB</name>
              <description>
              low quality block number. the bigger of this number, the worse compressed image quality
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>LQR</name>
              <description>
              quality sum to low qulity block number ratio. the bigger of this number, the worse compressed image quality.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CMPRDR</name>
          <displayName>CMPRDR</displayName>
          <description>Compression debug register</description>
          <addressOffset>0x38</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>25</bitWidth>
            </field>
            <field>
              <name>MAXBUF</name>
              <description>
              record of max used buffer during compression output
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PDM1</name>
      <description></description>
      <groupName>PDM</groupName>
      <baseAddress>0x4001a000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CFG0</name>
          <displayName>CFG0</displayName>
          <description></description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>22</bitWidth>
            </field>
            <field>
              <name>SWAP_EN</name>
              <description>
              1: Swap right channel and left channel pdm data; 0: Not swap  right channel and left channel pdm data
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>STEREO_EN</name>
              <description>
              1:Enable double channels pdm data sampling; 0: Disable double channels pdm data sampling
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RIGHT_EN</name>
              <description>
              1: Enable right channel pdm data sampling; 0: Disable right channel pdm data sampling
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LEFT_EN</name>
              <description>
              1: Enable left channel  pdm data sampling; 0: Disable left channel  pdm data sampling
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CLK_DIV</name>
              <description>
              Clock frequency division ratio of 3.072MHz or 9.6MHz according to register clk_sel
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>CLK_SEL</name>
              <description>
              1:Clk select dll 3.072MHz; 0: Clk selct xtal 9.6MHz
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PDMCOREEN</name>
              <description>
              1:Enable pdm module; 0: Disable pdm module
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CFG1</name>
          <displayName>CFG1</displayName>
          <description></description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>21</bitWidth>
            </field>
            <field>
              <name>SAMPLE_DLY_R</name>
              <description>
              The number of delay dff before the right data stream in processing
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>SAMPLE_DLY_L</name>
              <description>
              The number of delay dff before the left data stream in processing
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SINC_CFG</name>
          <displayName>SINC_CFG</displayName>
          <description></description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>SINC_ORDER_SEL</name>
              <description>
              1:select four differentiators in sinc filter; 0:select three differentiators in sinc filter
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SINC_RATE</name>
              <description>
              dowmsampling rate of  sinc filter
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD3</name>
          <displayName>RSVD3</displayName>
          <description></description>
          <addressOffset>0xC</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>HPF_CFG</name>
          <displayName>HPF_CFG</displayName>
          <description></description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>26</bitWidth>
            </field>
            <field>
              <name>HPF_RST</name>
              <description>
              1:high-pass filter normal operation ; 0:reset high-pass filter 
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HPF_BYPASS</name>
              <description>
              1:bypass high-pass filter ; 0: enable high-pass filter
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HPF_COEFF</name>
              <description>
              coefficient of high-pass filter
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PGA_CFG</name>
          <displayName>PGA_CFG</displayName>
          <description></description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>18</bitWidth>
            </field>
            <field>
              <name>PGA_GAIN_R</name>
              <description>
              right channel gain control , the range is -15dB~45dB. Resolution is 0.5dB/LSB
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
            <field>
              <name>PGA_GAIN_L</name>
              <description>
              left channel gain control , the range is -15dB~45dB. Resolution is 0.5dB/LSB
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD2</name>
          <displayName>RSVD2</displayName>
          <description></description>
          <addressOffset>0x1C</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>LPF_CFG6</name>
          <displayName>LPF_CFG6</displayName>
          <description></description>
          <addressOffset>0x34</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>18</bitWidth>
            </field>
            <field>
              <name>LPF_BYPASS</name>
              <description>
              1:bypass low-pass filter ; 0: enable low-pass filter
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LPF_DS</name>
              <description>
              1:downsampling rate of low pass filter is two;0:No downsampling of low pass filter
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>FIFO_CFG</name>
          <displayName>FIFO_CFG</displayName>
          <description></description>
          <addressOffset>0x38</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>RX_DMA_MSK_L</name>
              <description>
              1:disable left channel dma request; 0: enable left channel dma request
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RX_DMA_MSK_R</name>
              <description>
              1:disable right channel dma request; 0: enable right channel dma request
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PDM_SHIFT</name>
              <description>
              the number of data left shift for higher data accuracy 
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>BYTE_TRUNC</name>
              <description>
              1: trunc 24bits to 16bit ; 0: maintain 24bits ;
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>BYTE_CON</name>
              <description>
              1: combine left channel and right channel; 0: not combine left channel and right channel
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD1</name>
          <displayName>RSVD1</displayName>
          <description></description>
          <addressOffset>0x3C</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>FIFO_ST</name>
          <displayName>FIFO_ST</displayName>
          <description></description>
          <addressOffset>0x44</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>FULL_L</name>
              <description>
              1 indicates left channel fifo is full
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EMPTY_L</name>
              <description>
              1 indicates left channel fifo is empty
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ALMOST_FULL_L</name>
              <description>
              1 indicates left channel fifo is less than two full
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ALMOST_EMPTY_L</name>
              <description>
              1 indicates left channel fifo is less than two datas left
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FULL_R</name>
              <description>
              1 indicates right channel fifo is full
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EMPTY_R</name>
              <description>
              1 indicates right channel fifo is empty
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ALMOST_FULL_R</name>
              <description>
              1 indicates right channel fifo is less than two full
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ALMOST_EMPTY_R</name>
              <description>
              1 indicates right channel fifo is less than two datas left
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>INT_ST</name>
          <displayName>INT_ST</displayName>
          <description></description>
          <addressOffset>0x48</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>30</bitWidth>
            </field>
            <field>
              <name>OVERFLOW_L</name>
              <description>
              1 indicates left channel fifo has already overflowed and as irq at same time 
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OVERFLOW_R</name>
              <description>
              1 indicates right channel fifo has already overflowed  and as irq at same time
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>INT_MSK</name>
          <displayName>INT_MSK</displayName>
          <description></description>
          <addressOffset>0x4c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>30</bitWidth>
            </field>
            <field>
              <name>INT_MASK_L</name>
              <description>
              1:disable left channel irq to system; 0: enable left channel irq to system
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>INT_MASK_R</name>
              <description>
              1:disable right channel irq to system; 0: enable right channel irq to system
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>INT_CLR</name>
          <displayName>INT_CLR</displayName>
          <description></description>
          <addressOffset>0x50</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>30</bitWidth>
            </field>
            <field>
              <name>INT_CLR_L</name>
              <description>
              clear left channel irq
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>INT_CLR_R</name>
              <description>
              clear right channel irq
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PDM2</name>
      <description></description>
      <groupName>PDM</groupName>
      <baseAddress>0x4001b000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CFG0</name>
          <displayName>CFG0</displayName>
          <description></description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>22</bitWidth>
            </field>
            <field>
              <name>SWAP_EN</name>
              <description>
              1: Swap right channel and left channel pdm data; 0: Not swap  right channel and left channel pdm data
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>STEREO_EN</name>
              <description>
              1:Enable double channels pdm data sampling; 0: Disable double channels pdm data sampling
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RIGHT_EN</name>
              <description>
              1: Enable right channel pdm data sampling; 0: Disable right channel pdm data sampling
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LEFT_EN</name>
              <description>
              1: Enable left channel  pdm data sampling; 0: Disable left channel  pdm data sampling
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CLK_DIV</name>
              <description>
              Clock frequency division ratio of 3.072MHz or 9.6MHz according to register clk_sel
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>CLK_SEL</name>
              <description>
              1:Clk select dll 3.072MHz; 0: Clk selct xtal 9.6MHz
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PDMCOREEN</name>
              <description>
              1:Enable pdm module; 0: Disable pdm module
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CFG1</name>
          <displayName>CFG1</displayName>
          <description></description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>21</bitWidth>
            </field>
            <field>
              <name>SAMPLE_DLY_R</name>
              <description>
              The number of delay dff before the right data stream in processing
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>SAMPLE_DLY_L</name>
              <description>
              The number of delay dff before the left data stream in processing
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SINC_CFG</name>
          <displayName>SINC_CFG</displayName>
          <description></description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>SINC_ORDER_SEL</name>
              <description>
              1:select four differentiators in sinc filter; 0:select three differentiators in sinc filter
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SINC_RATE</name>
              <description>
              dowmsampling rate of  sinc filter
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD3</name>
          <displayName>RSVD3</displayName>
          <description></description>
          <addressOffset>0xC</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>HPF_CFG</name>
          <displayName>HPF_CFG</displayName>
          <description></description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>26</bitWidth>
            </field>
            <field>
              <name>HPF_RST</name>
              <description>
              1:high-pass filter normal operation ; 0:reset high-pass filter 
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HPF_BYPASS</name>
              <description>
              1:bypass high-pass filter ; 0: enable high-pass filter
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HPF_COEFF</name>
              <description>
              coefficient of high-pass filter
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PGA_CFG</name>
          <displayName>PGA_CFG</displayName>
          <description></description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>18</bitWidth>
            </field>
            <field>
              <name>PGA_GAIN_R</name>
              <description>
              right channel gain control , the range is -15dB~45dB. Resolution is 0.5dB/LSB
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
            <field>
              <name>PGA_GAIN_L</name>
              <description>
              left channel gain control , the range is -15dB~45dB. Resolution is 0.5dB/LSB
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD2</name>
          <displayName>RSVD2</displayName>
          <description></description>
          <addressOffset>0x1C</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>LPF_CFG6</name>
          <displayName>LPF_CFG6</displayName>
          <description></description>
          <addressOffset>0x34</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>18</bitWidth>
            </field>
            <field>
              <name>LPF_BYPASS</name>
              <description>
              1:bypass low-pass filter ; 0: enable low-pass filter
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LPF_DS</name>
              <description>
              1:downsampling rate of low pass filter is two;0:No downsampling of low pass filter
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>FIFO_CFG</name>
          <displayName>FIFO_CFG</displayName>
          <description></description>
          <addressOffset>0x38</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>RX_DMA_MSK_L</name>
              <description>
              1:disable left channel dma request; 0: enable left channel dma request
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RX_DMA_MSK_R</name>
              <description>
              1:disable right channel dma request; 0: enable right channel dma request
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PDM_SHIFT</name>
              <description>
              the number of data left shift for higher data accuracy 
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>BYTE_TRUNC</name>
              <description>
              1: trunc 24bits to 16bit ; 0: maintain 24bits ;
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>BYTE_CON</name>
              <description>
              1: combine left channel and right channel; 0: not combine left channel and right channel
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD1</name>
          <displayName>RSVD1</displayName>
          <description></description>
          <addressOffset>0x3C</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>FIFO_ST</name>
          <displayName>FIFO_ST</displayName>
          <description></description>
          <addressOffset>0x44</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>FULL_L</name>
              <description>
              1 indicates left channel fifo is full
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EMPTY_L</name>
              <description>
              1 indicates left channel fifo is empty
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ALMOST_FULL_L</name>
              <description>
              1 indicates left channel fifo is less than two full
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ALMOST_EMPTY_L</name>
              <description>
              1 indicates left channel fifo is less than two datas left
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FULL_R</name>
              <description>
              1 indicates right channel fifo is full
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EMPTY_R</name>
              <description>
              1 indicates right channel fifo is empty
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ALMOST_FULL_R</name>
              <description>
              1 indicates right channel fifo is less than two full
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ALMOST_EMPTY_R</name>
              <description>
              1 indicates right channel fifo is less than two datas left
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>INT_ST</name>
          <displayName>INT_ST</displayName>
          <description></description>
          <addressOffset>0x48</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>30</bitWidth>
            </field>
            <field>
              <name>OVERFLOW_L</name>
              <description>
              1 indicates left channel fifo has already overflowed and as irq at same time 
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OVERFLOW_R</name>
              <description>
              1 indicates right channel fifo has already overflowed  and as irq at same time
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>INT_MSK</name>
          <displayName>INT_MSK</displayName>
          <description></description>
          <addressOffset>0x4c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>30</bitWidth>
            </field>
            <field>
              <name>INT_MASK_L</name>
              <description>
              1:disable left channel irq to system; 0: enable left channel irq to system
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>INT_MASK_R</name>
              <description>
              1:disable right channel irq to system; 0: enable right channel irq to system
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>INT_CLR</name>
          <displayName>INT_CLR</displayName>
          <description></description>
          <addressOffset>0x50</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>30</bitWidth>
            </field>
            <field>
              <name>INT_CLR_L</name>
              <description>
              clear left channel irq
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>INT_CLR_R</name>
              <description>
              clear right channel irq
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>I2C1</name>
      <description></description>
      <groupName>I2C</groupName>
      <baseAddress>0x4001c000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CR</name>
          <displayName>CR</displayName>
          <description>Control register</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>UR</name>
              <description>
              Unit Reset. Software need first assert to reset then deassert to release.
              0 = No reset.
              1 = Reset I2C module.
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSTREQ</name>
              <description>
              I2C will do bus reset upon this bit set. Will be cleared by HW automatically after RSTCYC cycles of SCL generated.
              1 = request for i2c bus reset
              0 = bus reset finished
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BRGRST</name>
              <description>
              Reset bus related state machine and signals. Will be cleared by HW automatically
              1 = request for reset
              0 = reset finished
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>14</bitWidth>
            </field>
            <field>
              <name>DNF</name>
              <description>
              Digital noise filter
              These bits are used to configure the digital noise filter on SDA and SCL input. The digital filter will filter spikes with a length of up to DNF*Tfclk.
              0: Digital filter disabled 
              1: Digital filter enabled and filtering capability up to 1 Tfclk
              ...
              7: digital filter enabled and filtering capability up to 7 Tfclk
              Note: Digital filter is added to analog filter. Digital filter will introduce delay on SCL and SDA processing, which is essential in hs-mode. 
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>SCLPP</name>
              <description>
              Push-pull mode Enable for SCL.
              0 = open drain output for SCL.
              1 = Push-pull output for SCL
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MSDE</name>
              <description>
              Master Stop Detected Enable:
              0 = Master Stop Detect (MSD) status is not enabled.
              1 = Master Stop Detect (MSD) status is enabled.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LASTSTOP</name>
              <description>
              Generate STOP for last DMA transfer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LASTNACK</name>
              <description>
              Generate NACK for last DMA Read transfer
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMAEN</name>
              <description>
              DMA Enable for both TX and RX
              0 = DMA mode is NOT enabled
              1 = DMA mode enabled
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SCLE</name>
              <description>
              SCL Enable:
              0 = Disables the I2C from driving the SCL line.
              1 = Enables the I2C clock output for master-mode operation.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IUE</name>
              <description>
              I2C Unit Enable:
              0 = Disables the unit and does not master any transactions or respond to any slave transactions.
              1 = Enables the I2C (defaults to slave-receive mode).
              Software must guarantee the I2C bus is idle before setting this bit.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MODE</name>
              <description>
              Bus Mode (Master operation):
              2'b00: standard-mode
              2'b01: fast-mode and fast-mode plus
              2'b10: HS-mode (standard mode when not doing a high speed transfer)
              2'b11: HS-mode (fast mode when not doing a high speed transfer)
              Bus Mode (Slave operation):
              2'b0x: HS-mode is disabled. I2C unit uses Standard/Fast mode timing on the SDA pin.
              2'b1x: HS-mode is enabled. I2C unit uses HS-mode timing on the SDA pin when a master code is received.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TCR</name>
          <displayName>TCR</displayName>
          <description>Transfer Control register</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>ABORTDMA</name>
              <description>
              Abort DMA operation. Will be cleared by HW automatically
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RXREQ</name>
              <description>
              Request DMA RX. Will be cleared by HW automatically
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TXREQ</name>
              <description>
              Request DMA TX. Will be cleared by HW automatically
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MA</name>
              <description>
              Master Abort:
              Used by the I2C in master mode to generate a Stop without transmitting another data byte:
              0 = The I2C transmits Stop on if TCR[STOP] is set.
              1 = The I2C sends Stop without data transmission.
              When in master-transmit mode, after transmitting a data byte, the TCR[TB] bit is cleared. When no more data bytes need to be sent, setting master abort bit sends the Stop. The TCR[TB] bit must remain clear.
              In master-receive mode, when a NAK is sent without a Stop (TCR[STOP] bit was not set) and CPU does not send a repeated Start, setting this bit sends the Stop. Once again, the TCR[TB] bit must remain clear. Master Abort can be done immediately after the address phase (Master Transmit mode only).
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>NACK</name>
              <description>
              The positive/negative acknowledge control bit, defines the type of acknowledge pulse sent by the I2C when in master receive mode:
              0 = Send a positive acknowledge (ACK) pulse after receiving a data byte.
              1 = Send a negative acknowledge (NACK) pulse after receiving a data byte.
              The I2C automatically sends an ACK pulse when responding to its slave address or when responding in slave-receive mode, regardless of the NACK control-bit setting.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>STOP</name>
              <description>
              Stop:
              Used to initiate a Stop condition after transferring the next data byte on the I2C bus when in master mode. In master-receive mode, the NACK control bit must be set in conjunction with the STOP bit. 
              0 = Do not send a Stop.
              1 = Send a Stop.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>START</name>
              <description>
              Start:
              Used to initiate a Start condition to the I2C unit when in master mode. 
              0 = Do not send a Start pulse.
              1 = Send a Start pulse.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TB</name>
              <description>
              Transfer Byte:
              Used to send or receive a byte on the I2C bus:
              0 = Cleared by I2C when the byte is sent/received.
              1 = Send/receive a byte. 
              CPU can monitor this bit to determine when the byte transfer has completed. In master or slave mode, after each byte transfer including acknowledge pulse, the I2C holds the SCL line low (inserting wait states) until TB is set.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IER</name>
          <displayName>IER</displayName>
          <description>Interrupt Enable register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>UFIE</name>
              <description>
              FIFO Underflow Interrupt Enable
              0 = FIFO Underflow interrupt is not enabled
              1 = FIFO Underflow interrupt is enabled
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OFIE</name>
              <description>
              FIFO Overflow Interrupt Enable
              0 = FIFO Overflow interrupt is not enabled
              1 = FIFO Overflow interrupt is enabled
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMADONEIE</name>
              <description>
              DMA Transaction Done Interrupt Enable
              0 = DMA Transaction done interrupt is not enabled.
              1 = DMA Transaction done interrupt is enabled.
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MSDIE</name>
              <description>
              Master Stop Detected Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C unit to interrupt upon detecting a Master Stop sent by the I2C unit.
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BEDIE</name>
              <description>
              Bus Error Detected Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C to interrupt for the following I2C bus errors:
              As a master transmitter, no ACK was detected after a byte was sent.
              As a slave receiver, the I2C generated a NACK pulse.
              Software is responsible for guaranteeing that misplaced Start and Stop conditions do not occur.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SADIE</name>
              <description>
              Slave Address Detected Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C to interrupt upon detecting a slave address match or a general call address.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RFIE</name>
              <description>
              DBR Receive Full Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C to interrupt when the DBR has received a data byte from the I2C bus.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIE</name>
              <description>
              DBR Transmit Empty Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C to interrupt after transmitting a byte onto the I2C bus.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ALDIE</name>
              <description>
              Arbitration Loss Detected Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C to interrupt upon losing arbitration while in master mode.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SSDIE</name>
              <description>
              Slave Stop Detected Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C to interrupt when it detects a Stop condition while in slave mode.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SR</name>
          <displayName>SR</displayName>
          <description>Status register</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>UF</name>
              <description>
              FIFO Underflow Flag. Asserted when FIFO is empty and a POP request generated without a PUSH. Cleared if write 1
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OF</name>
              <description>
              FIFO Overflow Flag. Asserted when FIFO is full and a PUSH request generated without a POP. Cleared if write 1
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMADONE</name>
              <description>
              DMA Transaction Done. Asserted when both APB and I2C bus have finished transfer. Cleared if write 1
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MSD</name>
              <description>
              Master Stop Detected:
              0 = No Master Stop Detected.
              1 = This bit is set by the I2C unit when all of the following are true:
              This bit is enabled (CR[MSDE] = 1);
              I2C unit is configured as a master;
              I2C transmits a STOP signal
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EBB</name>
              <description>
              Early Bus Busy
              0 = I2C bus is idle or the I2C is using the bus (that is, unit busy).
              1 = Set when the unit detects that the SCL or SDA line is low without a START condition. Bit will remain set until the I2C unit detects the bus is idle by detecting a STOP condition. Bit will also be set whenever the IBB bit is set.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BED</name>
              <description>
              Bus Error Detected:
              0 = No error detected.
              1 = The I2C sets this bit when it detects one of the following error conditions:
              As a master transmitter, no ACK was detected on the interface after a byte was sent.
              As a slave receiver, the I2C generates a NACK pulse.
              When an error occurs, I2C bus transactions continue. Software must guarantee that misplaced Start and Stop conditions do not occur. 
              Cleared if write 1
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SAD</name>
              <description>
              Slave Address Detected:
              0 = No slave address was detected.
              1 = The I2C detected a seven-bit address that matches the general call address or SAR. An interrupt is signalled when enabled in the CR. 
              Cleared if write 1
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RF</name>
              <description>
              DBR Receive Full:
              0 = The DBR has not received a new data byte or the I2C is idle.
              1 = The DBR register received a new data byte from the I2C bus. An interrupt is signalled when enabled in the CR. 
              Cleared if write 1
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TE</name>
              <description>
              DBR Transmit Empty:
              0 = The data byte is still being transmitted.
              1 = The I2C has finished transmitting a data byte on the I2C bus. An interrupt is signalled when enabled in the CR.
              Cleared if write 1
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ALD</name>
              <description>
              Arbitration Loss Detected:
              Used during multi-master operation:
              0 = Cleared when arbitration is won or never took place.
              1 = Set when the I2C loses arbitration. 
              Cleared if write 1
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SSD</name>
              <description>
              Slave Stop Detected:
              0 = No Stop detected.
              1 = Set when the I2C detects a Stop while in slave-receive or slave-transmit mode. 
              Cleared if write 1
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IBB</name>
              <description>
              I2C Bus Busy:
              0 = I2C bus is idle or the I2C is using the bus (that is, unit busy).
              1 = Set when the I2C bus is busy but local I2C is not involved in the transaction.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UB</name>
              <description>
              Unit Busy:
              0 = I2C not busy.
              1 = Set when local I2C is busy. This is defined as the time between the first Start and Stop. 
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>NACK</name>
              <description>
              ACK/NACK Status:
              0 = The I2C received or sent an ACK on the bus. 
              1 = The I2C received or sent a NACK.on the bus.
              This bit is used in slave-transmit mode to determine when the byte transferred is the last one. This bit is updated after each byte and ACK/NACK information is received.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RWM</name>
              <description>
              Read/write Mode:
              0 = The I2C is in master-transmit or slave-receive mode. 
              1 = The I2C is in master-receive or slave-transmit mode. 
              This is the R/nW bit of the slave address. It is cleared automatically by hardware after a Stop state.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DBR</name>
          <displayName>DBR</displayName>
          <description>Data Buffer register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>DATA</name>
              <description>
              use the I2C Data Buffer register to transmit and receive data from the I2C bus. The DBR is accessed by software on one Side and by the I2C Shift register on the other. The DBR receives data coming into the I2C unit after a full byte is received and acknowledged. CPU writes data going out of the I2C to the DBR and sends it to the serial bus. 
              When the I2C is in transmit mode (master or slave), CPU writes data to the DBR over the internal bus. CPU write data to the DBR when a master transaction is initiated or when the DBR transmit-empty interrupt is signalled. Data moves from the DBR to the Shift register when the transfer byte bit is set. The DBR transmit-empty interrupt is signalled (if enabled) when a byte is transferred on the I2C bus and the acknowledge cycle is complete. If the DBR is not written, and a Stop condition is not in place before the I2C bus is ready to transfer the next byte packet, the I2C unit inserts wait states until CPU writes the DBR and sets the transfer byte bit.
              When the I2C is in receive mode (master or slave), CPU reads DBR data over the internal bus. CPU reads data from the DBR when the DBR receive-full interrupt is signalled. The data moves from the Shift register to the DBR when the acknowledge cycle is complete. The I2C inserts wait states until the DBR is read. After the software reads the DBR, CR[NACK] are written by the software, allowing the next byte transfer to proceed to the I2C bus.
              In DMA mode, DBR is automatically filled from FIFO in master transmit mode, or fetched and stored in FIFO in master receive mode until DMA done or aborted.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SAR</name>
          <displayName>SAR</displayName>
          <description>Slave Address Register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000047</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>25</bitWidth>
            </field>
            <field>
              <name>ADDR</name>
              <description>
              The seven-bit address to which the I2C responds when in slave-receive mode
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>LCR</name>
          <displayName>LCR</displayName>
          <description>Load Count Register</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x081C3675</resetValue>
          <fields>
            <field>
              <name>HLVH</name>
              <description>
              Decrementer Load value for High Speed Mode SCL (master mode) for high phase. 
              Thigh=Tfclk*(HLVH+4+DNF)
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>HLVL</name>
              <description>
              Decrementer Load value for High Speed Mode SCL (master mode) for low phase. 
              Tlow=Tfclk*(HLVL+3+DNF). Data rate is generated as 1/(Thigh+Tlow), or Ffclk/(HLVH+HLVL+7+2*DNF). 
              3.2Mbps data rate is generated by default if fclk is 48MHz.
              HLVL also controls setup time and hold time for START and STOP condition in High Speed Mode(master mode). 
              Thdsta=Tsusta=Tsusto=Tfclk*(HLVL+1)
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
            <field>
              <name>FLV</name>
              <description>
              Decrementer Load value for Fast Mode (or Fast Mode Plus) SCL (master mode) for both high and low phase. 
              Data rate is generated as Ffclk/(FLV+max(FLV,CNT*2+6)+7+DNF) approximately. 
              FLV also controls setup time and hold time for START and STOP condition in Fast Mode(master mode). 
              Thdsta=Tsusta=Tsusto=Tfclk*FLV
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
            <field>
              <name>SLV</name>
              <description>
              Decrementer Load value for Standard Mode SCL (master mode) for both high and low phase. 
              Data rate is generated as Ffclk/(SLV+max(SLV,CNT*2+6)+7+DNF) approximately. 
              SLV also controls setup time and hold time for START and STOP condition in Standard Mode(master mode). 
              Thdsta=Tsusta=Tsusto=Tfclk*SLV
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>WCR</name>
          <displayName>WCR</displayName>
          <description>Wait Count Register</description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0000000A</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>27</bitWidth>
            </field>
            <field>
              <name>CNT</name>
              <description>
              Controls the counter values defining the setup and hold times in standard and fast mode
              Tvddat=Thddat=Tfclk*(CNT+2)
              Tsudat=max(Tlow-Thddat,Thddat)
              Lower counter values may violate setup and hold times.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RCCR</name>
          <displayName>RCCR</displayName>
          <description>Bus Reset Cycle Counter Register</description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000009</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>28</bitWidth>
            </field>
            <field>
              <name>RSTCYC</name>
              <description>
              The cycles of SCL during bus reset
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BMR</name>
          <displayName>BMR</displayName>
          <description>Bus Monitor Register</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000003</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>30</bitWidth>
            </field>
            <field>
              <name>SCL</name>
              <description>
              value of the SCL pin. Software can check bus level when the I2C bus is hung and the I2C unit must be reset.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SDA</name>
              <description>
              value of the SDA pin.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DNR</name>
          <displayName>DNR</displayName>
          <description>DMA number register</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>NDT</name>
              <description>
              Write as number of data to transfer in byte. Read as left data number to transfer
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD1</name>
          <displayName>RSVD1</displayName>
          <description></description>
          <addressOffset>0x2C</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>FIFO</name>
          <displayName>FIFO</displayName>
          <description>FIFO Register</description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>DATA</name>
              <description>
              Write to push send data into FIFO. Read to pop received data from FIFO
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>I2C2</name>
      <description></description>
      <groupName>I2C</groupName>
      <baseAddress>0x4001d000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CR</name>
          <displayName>CR</displayName>
          <description>Control register</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>UR</name>
              <description>
              Unit Reset. Software need first assert to reset then deassert to release.
              0 = No reset.
              1 = Reset I2C module.
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSTREQ</name>
              <description>
              I2C will do bus reset upon this bit set. Will be cleared by HW automatically after RSTCYC cycles of SCL generated.
              1 = request for i2c bus reset
              0 = bus reset finished
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BRGRST</name>
              <description>
              Reset bus related state machine and signals. Will be cleared by HW automatically
              1 = request for reset
              0 = reset finished
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>14</bitWidth>
            </field>
            <field>
              <name>DNF</name>
              <description>
              Digital noise filter
              These bits are used to configure the digital noise filter on SDA and SCL input. The digital filter will filter spikes with a length of up to DNF*Tfclk.
              0: Digital filter disabled 
              1: Digital filter enabled and filtering capability up to 1 Tfclk
              ...
              7: digital filter enabled and filtering capability up to 7 Tfclk
              Note: Digital filter is added to analog filter. Digital filter will introduce delay on SCL and SDA processing, which is essential in hs-mode. 
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>SCLPP</name>
              <description>
              Push-pull mode Enable for SCL.
              0 = open drain output for SCL.
              1 = Push-pull output for SCL
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MSDE</name>
              <description>
              Master Stop Detected Enable:
              0 = Master Stop Detect (MSD) status is not enabled.
              1 = Master Stop Detect (MSD) status is enabled.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LASTSTOP</name>
              <description>
              Generate STOP for last DMA transfer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LASTNACK</name>
              <description>
              Generate NACK for last DMA Read transfer
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMAEN</name>
              <description>
              DMA Enable for both TX and RX
              0 = DMA mode is NOT enabled
              1 = DMA mode enabled
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SCLE</name>
              <description>
              SCL Enable:
              0 = Disables the I2C from driving the SCL line.
              1 = Enables the I2C clock output for master-mode operation.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IUE</name>
              <description>
              I2C Unit Enable:
              0 = Disables the unit and does not master any transactions or respond to any slave transactions.
              1 = Enables the I2C (defaults to slave-receive mode).
              Software must guarantee the I2C bus is idle before setting this bit.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MODE</name>
              <description>
              Bus Mode (Master operation):
              2'b00: standard-mode
              2'b01: fast-mode and fast-mode plus
              2'b10: HS-mode (standard mode when not doing a high speed transfer)
              2'b11: HS-mode (fast mode when not doing a high speed transfer)
              Bus Mode (Slave operation):
              2'b0x: HS-mode is disabled. I2C unit uses Standard/Fast mode timing on the SDA pin.
              2'b1x: HS-mode is enabled. I2C unit uses HS-mode timing on the SDA pin when a master code is received.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TCR</name>
          <displayName>TCR</displayName>
          <description>Transfer Control register</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>ABORTDMA</name>
              <description>
              Abort DMA operation. Will be cleared by HW automatically
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RXREQ</name>
              <description>
              Request DMA RX. Will be cleared by HW automatically
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TXREQ</name>
              <description>
              Request DMA TX. Will be cleared by HW automatically
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MA</name>
              <description>
              Master Abort:
              Used by the I2C in master mode to generate a Stop without transmitting another data byte:
              0 = The I2C transmits Stop on if TCR[STOP] is set.
              1 = The I2C sends Stop without data transmission.
              When in master-transmit mode, after transmitting a data byte, the TCR[TB] bit is cleared. When no more data bytes need to be sent, setting master abort bit sends the Stop. The TCR[TB] bit must remain clear.
              In master-receive mode, when a NAK is sent without a Stop (TCR[STOP] bit was not set) and CPU does not send a repeated Start, setting this bit sends the Stop. Once again, the TCR[TB] bit must remain clear. Master Abort can be done immediately after the address phase (Master Transmit mode only).
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>NACK</name>
              <description>
              The positive/negative acknowledge control bit, defines the type of acknowledge pulse sent by the I2C when in master receive mode:
              0 = Send a positive acknowledge (ACK) pulse after receiving a data byte.
              1 = Send a negative acknowledge (NACK) pulse after receiving a data byte.
              The I2C automatically sends an ACK pulse when responding to its slave address or when responding in slave-receive mode, regardless of the NACK control-bit setting.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>STOP</name>
              <description>
              Stop:
              Used to initiate a Stop condition after transferring the next data byte on the I2C bus when in master mode. In master-receive mode, the NACK control bit must be set in conjunction with the STOP bit. 
              0 = Do not send a Stop.
              1 = Send a Stop.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>START</name>
              <description>
              Start:
              Used to initiate a Start condition to the I2C unit when in master mode. 
              0 = Do not send a Start pulse.
              1 = Send a Start pulse.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TB</name>
              <description>
              Transfer Byte:
              Used to send or receive a byte on the I2C bus:
              0 = Cleared by I2C when the byte is sent/received.
              1 = Send/receive a byte. 
              CPU can monitor this bit to determine when the byte transfer has completed. In master or slave mode, after each byte transfer including acknowledge pulse, the I2C holds the SCL line low (inserting wait states) until TB is set.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IER</name>
          <displayName>IER</displayName>
          <description>Interrupt Enable register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>UFIE</name>
              <description>
              FIFO Underflow Interrupt Enable
              0 = FIFO Underflow interrupt is not enabled
              1 = FIFO Underflow interrupt is enabled
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OFIE</name>
              <description>
              FIFO Overflow Interrupt Enable
              0 = FIFO Overflow interrupt is not enabled
              1 = FIFO Overflow interrupt is enabled
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMADONEIE</name>
              <description>
              DMA Transaction Done Interrupt Enable
              0 = DMA Transaction done interrupt is not enabled.
              1 = DMA Transaction done interrupt is enabled.
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MSDIE</name>
              <description>
              Master Stop Detected Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C unit to interrupt upon detecting a Master Stop sent by the I2C unit.
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BEDIE</name>
              <description>
              Bus Error Detected Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C to interrupt for the following I2C bus errors:
              As a master transmitter, no ACK was detected after a byte was sent.
              As a slave receiver, the I2C generated a NACK pulse.
              Software is responsible for guaranteeing that misplaced Start and Stop conditions do not occur.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SADIE</name>
              <description>
              Slave Address Detected Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C to interrupt upon detecting a slave address match or a general call address.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RFIE</name>
              <description>
              DBR Receive Full Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C to interrupt when the DBR has received a data byte from the I2C bus.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIE</name>
              <description>
              DBR Transmit Empty Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C to interrupt after transmitting a byte onto the I2C bus.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ALDIE</name>
              <description>
              Arbitration Loss Detected Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C to interrupt upon losing arbitration while in master mode.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SSDIE</name>
              <description>
              Slave Stop Detected Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C to interrupt when it detects a Stop condition while in slave mode.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SR</name>
          <displayName>SR</displayName>
          <description>Status register</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>UF</name>
              <description>
              FIFO Underflow Flag. Asserted when FIFO is empty and a POP request generated without a PUSH. Cleared if write 1
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OF</name>
              <description>
              FIFO Overflow Flag. Asserted when FIFO is full and a PUSH request generated without a POP. Cleared if write 1
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMADONE</name>
              <description>
              DMA Transaction Done. Asserted when both APB and I2C bus have finished transfer. Cleared if write 1
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MSD</name>
              <description>
              Master Stop Detected:
              0 = No Master Stop Detected.
              1 = This bit is set by the I2C unit when all of the following are true:
              This bit is enabled (CR[MSDE] = 1);
              I2C unit is configured as a master;
              I2C transmits a STOP signal
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EBB</name>
              <description>
              Early Bus Busy
              0 = I2C bus is idle or the I2C is using the bus (that is, unit busy).
              1 = Set when the unit detects that the SCL or SDA line is low without a START condition. Bit will remain set until the I2C unit detects the bus is idle by detecting a STOP condition. Bit will also be set whenever the IBB bit is set.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BED</name>
              <description>
              Bus Error Detected:
              0 = No error detected.
              1 = The I2C sets this bit when it detects one of the following error conditions:
              As a master transmitter, no ACK was detected on the interface after a byte was sent.
              As a slave receiver, the I2C generates a NACK pulse.
              When an error occurs, I2C bus transactions continue. Software must guarantee that misplaced Start and Stop conditions do not occur. 
              Cleared if write 1
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SAD</name>
              <description>
              Slave Address Detected:
              0 = No slave address was detected.
              1 = The I2C detected a seven-bit address that matches the general call address or SAR. An interrupt is signalled when enabled in the CR. 
              Cleared if write 1
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RF</name>
              <description>
              DBR Receive Full:
              0 = The DBR has not received a new data byte or the I2C is idle.
              1 = The DBR register received a new data byte from the I2C bus. An interrupt is signalled when enabled in the CR. 
              Cleared if write 1
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TE</name>
              <description>
              DBR Transmit Empty:
              0 = The data byte is still being transmitted.
              1 = The I2C has finished transmitting a data byte on the I2C bus. An interrupt is signalled when enabled in the CR.
              Cleared if write 1
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ALD</name>
              <description>
              Arbitration Loss Detected:
              Used during multi-master operation:
              0 = Cleared when arbitration is won or never took place.
              1 = Set when the I2C loses arbitration. 
              Cleared if write 1
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SSD</name>
              <description>
              Slave Stop Detected:
              0 = No Stop detected.
              1 = Set when the I2C detects a Stop while in slave-receive or slave-transmit mode. 
              Cleared if write 1
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IBB</name>
              <description>
              I2C Bus Busy:
              0 = I2C bus is idle or the I2C is using the bus (that is, unit busy).
              1 = Set when the I2C bus is busy but local I2C is not involved in the transaction.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UB</name>
              <description>
              Unit Busy:
              0 = I2C not busy.
              1 = Set when local I2C is busy. This is defined as the time between the first Start and Stop. 
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>NACK</name>
              <description>
              ACK/NACK Status:
              0 = The I2C received or sent an ACK on the bus. 
              1 = The I2C received or sent a NACK.on the bus.
              This bit is used in slave-transmit mode to determine when the byte transferred is the last one. This bit is updated after each byte and ACK/NACK information is received.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RWM</name>
              <description>
              Read/write Mode:
              0 = The I2C is in master-transmit or slave-receive mode. 
              1 = The I2C is in master-receive or slave-transmit mode. 
              This is the R/nW bit of the slave address. It is cleared automatically by hardware after a Stop state.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DBR</name>
          <displayName>DBR</displayName>
          <description>Data Buffer register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>DATA</name>
              <description>
              use the I2C Data Buffer register to transmit and receive data from the I2C bus. The DBR is accessed by software on one Side and by the I2C Shift register on the other. The DBR receives data coming into the I2C unit after a full byte is received and acknowledged. CPU writes data going out of the I2C to the DBR and sends it to the serial bus. 
              When the I2C is in transmit mode (master or slave), CPU writes data to the DBR over the internal bus. CPU write data to the DBR when a master transaction is initiated or when the DBR transmit-empty interrupt is signalled. Data moves from the DBR to the Shift register when the transfer byte bit is set. The DBR transmit-empty interrupt is signalled (if enabled) when a byte is transferred on the I2C bus and the acknowledge cycle is complete. If the DBR is not written, and a Stop condition is not in place before the I2C bus is ready to transfer the next byte packet, the I2C unit inserts wait states until CPU writes the DBR and sets the transfer byte bit.
              When the I2C is in receive mode (master or slave), CPU reads DBR data over the internal bus. CPU reads data from the DBR when the DBR receive-full interrupt is signalled. The data moves from the Shift register to the DBR when the acknowledge cycle is complete. The I2C inserts wait states until the DBR is read. After the software reads the DBR, CR[NACK] are written by the software, allowing the next byte transfer to proceed to the I2C bus.
              In DMA mode, DBR is automatically filled from FIFO in master transmit mode, or fetched and stored in FIFO in master receive mode until DMA done or aborted.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SAR</name>
          <displayName>SAR</displayName>
          <description>Slave Address Register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000047</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>25</bitWidth>
            </field>
            <field>
              <name>ADDR</name>
              <description>
              The seven-bit address to which the I2C responds when in slave-receive mode
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>LCR</name>
          <displayName>LCR</displayName>
          <description>Load Count Register</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x081C3675</resetValue>
          <fields>
            <field>
              <name>HLVH</name>
              <description>
              Decrementer Load value for High Speed Mode SCL (master mode) for high phase. 
              Thigh=Tfclk*(HLVH+4+DNF)
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>HLVL</name>
              <description>
              Decrementer Load value for High Speed Mode SCL (master mode) for low phase. 
              Tlow=Tfclk*(HLVL+3+DNF). Data rate is generated as 1/(Thigh+Tlow), or Ffclk/(HLVH+HLVL+7+2*DNF). 
              3.2Mbps data rate is generated by default if fclk is 48MHz.
              HLVL also controls setup time and hold time for START and STOP condition in High Speed Mode(master mode). 
              Thdsta=Tsusta=Tsusto=Tfclk*(HLVL+1)
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
            <field>
              <name>FLV</name>
              <description>
              Decrementer Load value for Fast Mode (or Fast Mode Plus) SCL (master mode) for both high and low phase. 
              Data rate is generated as Ffclk/(FLV+max(FLV,CNT*2+6)+7+DNF) approximately. 
              FLV also controls setup time and hold time for START and STOP condition in Fast Mode(master mode). 
              Thdsta=Tsusta=Tsusto=Tfclk*FLV
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
            <field>
              <name>SLV</name>
              <description>
              Decrementer Load value for Standard Mode SCL (master mode) for both high and low phase. 
              Data rate is generated as Ffclk/(SLV+max(SLV,CNT*2+6)+7+DNF) approximately. 
              SLV also controls setup time and hold time for START and STOP condition in Standard Mode(master mode). 
              Thdsta=Tsusta=Tsusto=Tfclk*SLV
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>WCR</name>
          <displayName>WCR</displayName>
          <description>Wait Count Register</description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0000000A</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>27</bitWidth>
            </field>
            <field>
              <name>CNT</name>
              <description>
              Controls the counter values defining the setup and hold times in standard and fast mode
              Tvddat=Thddat=Tfclk*(CNT+2)
              Tsudat=max(Tlow-Thddat,Thddat)
              Lower counter values may violate setup and hold times.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RCCR</name>
          <displayName>RCCR</displayName>
          <description>Bus Reset Cycle Counter Register</description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000009</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>28</bitWidth>
            </field>
            <field>
              <name>RSTCYC</name>
              <description>
              The cycles of SCL during bus reset
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BMR</name>
          <displayName>BMR</displayName>
          <description>Bus Monitor Register</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000003</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>30</bitWidth>
            </field>
            <field>
              <name>SCL</name>
              <description>
              value of the SCL pin. Software can check bus level when the I2C bus is hung and the I2C unit must be reset.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SDA</name>
              <description>
              value of the SDA pin.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DNR</name>
          <displayName>DNR</displayName>
          <description>DMA number register</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>NDT</name>
              <description>
              Write as number of data to transfer in byte. Read as left data number to transfer
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD1</name>
          <displayName>RSVD1</displayName>
          <description></description>
          <addressOffset>0x2C</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>FIFO</name>
          <displayName>FIFO</displayName>
          <description>FIFO Register</description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>DATA</name>
              <description>
              Write to push send data into FIFO. Read to pop received data from FIFO
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>DSI_HOST</name>
      <description></description>
      <groupName>DSI_HOST</groupName>
      <baseAddress>0x4001e000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>VER</name>
          <displayName>VER</displayName>
          <description></description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>VALUE</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CTRL</name>
          <displayName>CTRL</displayName>
          <description></description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>15</bitWidth>
            </field>
            <field>
              <name>TIMEOUT_DIV</name>
              <description>
              Time out clock divider
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>ESC_DIV</name>
              <description>
              tx escape clock divider
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>PU</name>
              <description>
              0: Reset
              1: Power-up
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DPI_CFG1</name>
          <displayName>DPI_CFG1</displayName>
          <description></description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>COLORM_POL</name>
              <description>
              color mode polarity
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SHUTDOWN_POL</name>
              <description>
              shutdown polarity
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HSYNC_POL</name>
              <description>
              hsync polarity
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>VSYNC_POL</name>
              <description>
              vsync polarity
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>D_EN_POL</name>
              <description>
              data enable polarity
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LOOSE_EN</name>
              <description>
              enable loosely packed variant to 18-bit mode
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FORMAT</name>
              <description>
              dpi color format
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>VID</name>
              <description>
              dpi channel id
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DPI_CFG2</name>
          <displayName>DPI_CFG2</displayName>
          <description></description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>OUTVACT</name>
              <description>
              command packet size in a line during VSA/VBP/VFP region
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>INVACT</name>
              <description>
              command packet size in a line during VACT region
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DBI_CFG1</name>
          <displayName>DBI_CFG1</displayName>
          <description></description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>WR_CONT_MODE</name>
              <description>
              dbi write memory continuous mode when internal auto partioning enable.
              1: write memory continue command(0x3c) can initial data transfer.
              0: write memory continue command(0x3c) cannot initial data transfer.
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>INTF_DLY_SEL</name>
              <description>
              dbi interface data delay select
              00: no delay
              01: delay by half cycle
              10,11: delay by one cycle
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>PARTITIONING_EN</name>
              <description>
              external partitioning enable
              1: external partitioning enable
              0: internal auto partitioning enable
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LUT_SIZE</name>
              <description>
              LUT commands size
              00,11: 16-bit color display
              01: 18-bit color display
              10: 24-bit color display
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>OFORMAT</name>
              <description>
              DBI output pixel format
              0000: 8-bit 8 bpp
              0001: 8-bit 12 bpp
              0010: 8-bit 16 bpp
              0011: 8-bit 18 bpp
              0100: 8-bit 24 bpp
              0101: 9-bit 18 bpp
              0110: 16-bit 8 bpp
              0111: 16-bit 12 bpp
              1000: 16-bit 16 bpp
              1001: 16-bit 18 bpp, option 1
              1010: 16-bit 18 bpp, option 2
              1011: 16-bit 24 bpp, option 1
              1100: 16-bit 24 bpp, option 2
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>IFORMAT</name>
              <description>
              DBI input pixel format
              0000: 8-bit 8 bpp
              0001: 8-bit 12 bpp
              0010: 8-bit 16 bpp
              0011: 8-bit 18 bpp
              0100: 8-bit 24 bpp
              0101: 9-bit 18 bpp
              0110: 16-bit 8 bpp
              0111: 16-bit 12 bpp
              1000: 16-bit 16 bpp
              1001: 16-bit 18 bpp, option 1
              1010: 16-bit 18 bpp, option 2
              1011: 16-bit 24 bpp, option 1
              1100: 16-bit 24 bpp, option 2
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>VID</name>
              <description>
              DBI virtual channel id
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DBI_CFG2</name>
          <displayName>DBI_CFG2</displayName>
          <description></description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ALLOWED_SIZE</name>
              <description>
              maximum allowed write memory data size. Used when partioning is enable.
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>WR_SIZE</name>
              <description>
              write memory data size. DSI packet payload is the actual payload size minus 1
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>COM_CFG</name>
          <displayName>COM_CFG</displayName>
          <description></description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>30</bitWidth>
            </field>
            <field>
              <name>VID</name>
              <description>
              common interface virtual channel id
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PKT_CFG</name>
          <displayName>PKT_CFG</displayName>
          <description></description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>27</bitWidth>
            </field>
            <field>
              <name>CRC_RX_EN</name>
              <description>
              CRC reception enable
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ECC_RX_EN</name>
              <description>
              ECC reception enable
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BTA_EN</name>
              <description>
              bus turn around request
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EOTP_RX_EN</name>
              <description>
              EoTp reception
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EOTP_TX_EN</name>
              <description>
              EoTp transmission
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>MODE_CFG</name>
          <displayName>MODE_CFG</displayName>
          <description></description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>31</bitWidth>
            </field>
            <field>
              <name>CMD_VIDEO_SEL</name>
              <description>
              0: video mode
              1: command mode
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CMODE_CFG</name>
          <displayName>CMODE_CFG</displayName>
          <description></description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>18</bitWidth>
            </field>
            <field>
              <name>MAX_RD_SIZE</name>
              <description>
              maximum read packet size command transmission type
              0: high-speed
              1: low-power
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LONG_WR</name>
              <description>
              DCS long write packet command transmission type
              0: high-speed
              1: low-power
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SHORT_RD0</name>
              <description>
              DCS short read packet with 0 parameter command transmission type
              0: high-speed
              1: low-power
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SHORT_WR1</name>
              <description>
              DCS short write packet with 1 parameter command transmission type
              0: high-speed
              1: low-power
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SHORT_WR0</name>
              <description>
              DCS short write packet with 0 parameter command transmission type
              0: high-speed
              1: low-power
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>COM_LONG_WR</name>
              <description>
              generic long write packet command transmission type
              0: high-speed
              1: low-power
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>COM_SHORT_RD2</name>
              <description>
              common short read with 2 paramters command transmission type
              0: high-speed
              1: low-power
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>COM_SHORT_RD1</name>
              <description>
              common short read with 1 paramters command transmission type
              0: high-speed
              1: low-power
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>COM_SHORT_RD0</name>
              <description>
              common short read with 0 paramters command transmission type
              0: high-speed
              1: low-power
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>COM_SHORT_WR2</name>
              <description>
              common short write with 2 paramters command transmission type
              0: high-speed
              1: low-power
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>COM_SHORT_WR1</name>
              <description>
              common short write with 1 paramters command transmission type
              0: high-speed
              1: low-power
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>COM_SHORT_WR0</name>
              <description>
              common short write with 0 paramters command transmission type
              0: high-speed
              1: low-power
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ACK_REQ_EN</name>
              <description>
              acknowledge request enable
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FMARK_EN</name>
              <description>
              fmark enable
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>COM_INTF</name>
          <displayName>COM_INTF</displayName>
          <description></description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>HIGH_DATA</name>
              <description>
              common interface MSB of header packet's word count of long packet or data 1 for short packets
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>LOW_DATA</name>
              <description>
              common interface LSB of header packet's word count of long packet or data 0 for short packets
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>VID</name>
              <description>
              common interface virtual channel id
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>DATA_TYPE</name>
              <description>
              common interface packet data type
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>COM_PLD</name>
          <displayName>COM_PLD</displayName>
          <description></description>
          <addressOffset>0x2c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>PDATA</name>
              <description>
              common interface payload data
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CMD_PKT_STAT</name>
          <displayName>CMD_PKT_STAT</displayName>
          <description></description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>18</bitWidth>
            </field>
            <field>
              <name>DBI_RDCMD_BUSY</name>
              <description>
              DBI read command busy
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DBI_RDPLD_FULL</name>
              <description>
              DBI read payload FIFO full
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DBI_RDPLD_EMPTY</name>
              <description>
              DBI read payload FIFO empty
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DBI_WRPLD_FULL</name>
              <description>
              DBI write payload FIFO full
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DBI_WRPLD_EMPTY</name>
              <description>
              DBI write payload FIFO empty
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DBI_CMD_FULL</name>
              <description>
              DBI command FIFO full
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DBI_CMD_EMPTY</name>
              <description>
              DBI command FIFO empty
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>COM_RDCMD_BUSY</name>
              <description>
              common read command busy
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>COM_RDPLD_FULL</name>
              <description>
              common read payload FIFO full
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>COM_RDPLD_EMPTY</name>
              <description>
              common read payload FIFO empty
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>COM_WRPLD_FULL</name>
              <description>
              common write payload FIFO full
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>COM_WRPLD_EMPTY</name>
              <description>
              common write payload FIFO empty
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>COM_CMD_FULL</name>
              <description>
              common command FIFO full
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>COM_CMD_EMPTY</name>
              <description>
              common command FIFO empty
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ST_CNT_CFG1</name>
          <displayName>ST_CNT_CFG1</displayName>
          <description></description>
          <addressOffset>0x34</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>LPRX_TIMEOUT</name>
              <description>
              LPRX timeout counter
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>HSTX_TIMEOUT</name>
              <description>
              HSTX timeout counter
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ST_CNT_CFG2</name>
          <displayName>ST_CNT_CFG2</displayName>
          <description></description>
          <addressOffset>0x38</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>LPRD_TIMEOUT</name>
              <description>
              LP read timeout counter
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>HSRD_TIMEOUT</name>
              <description>
              HS read timeout counter
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ST_CNT_CFG3</name>
          <displayName>ST_CNT_CFG3</displayName>
          <description></description>
          <addressOffset>0x3c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>LPWR_TIMEOUT</name>
              <description>
              LP write timeout counter
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>HSWR_TIMEOUT</name>
              <description>
              HS write timeout counter
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ST_CNT_CFG4</name>
          <displayName>ST_CNT_CFG4</displayName>
          <description></description>
          <addressOffset>0x40</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>BTA_TIMEOUT</name>
              <description>
              BTA timeout counter
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>VMODE_CFG1</name>
          <displayName>VMODE_CFG1</displayName>
          <description></description>
          <addressOffset>0x44</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>PKT_SIZE</name>
              <description>
              Number of pixels in a single video packet
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>14</bitWidth>
            </field>
            <field>
              <name>VPG_ORIENTATION</name>
              <description>
              color bar orientation
              0: vertical mode
              1: horizontal mode
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>VPG_MODE</name>
              <description>
              pattern
              0: color bar
              1: ber pattern
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>VPG_EN</name>
              <description>
              video mode pattern generator enable
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LPCMD_EN</name>
              <description>
              enable command transmission only in lp mode
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BTA_ACK_EN</name>
              <description>
              enable request for an ack response
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LPHFP_EN</name>
              <description>
              enable return to lp inside HFP
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LPHBP_EN</name>
              <description>
              enable return to lp inside HBP
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LPVACT_EN</name>
              <description>
              enable return to lp inside VACT
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LPVFP_EN</name>
              <description>
              enable return to lp inside VFP
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LPVBP_EN</name>
              <description>
              enable return to lp inside VBP
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LPVSA_EN</name>
              <description>
              enable return to lp inside VSA
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>VMODE_TYPE</name>
              <description>
              indicates video mode transmission type
              00: Non-burst with sync pulses
              01: Non-burst with sync events
              10,11: Burst mode
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>VMODE_CFG2</name>
          <displayName>VMODE_CFG2</displayName>
          <description></description>
          <addressOffset>0x48</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>NULL_SIZE</name>
              <description>
              number of bytes inside a null packet
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>13</bitWidth>
            </field>
            <field>
              <name>NUM_CHUNKS</name>
              <description>
              number of chunks during a Line period
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>13</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>VTIMER1</name>
          <displayName>VTIMER1</displayName>
          <description></description>
          <addressOffset>0x4c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>HBP</name>
              <description>
              HBP period
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
            <field>
              <name>HSA</name>
              <description>
              HSA period
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>VTIMER2</name>
          <displayName>VTIMER2</displayName>
          <description></description>
          <addressOffset>0x50</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
            <field>
              <name>VSA</name>
              <description>
              VSA lines
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
            <field>
              <name>HLINE</name>
              <description>
              HLINE period
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>15</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>VTIMER3</name>
          <displayName>VTIMER3</displayName>
          <description></description>
          <addressOffset>0x54</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
            <field>
              <name>VFP</name>
              <description>
              VFP lines
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
            <field>
              <name>VBP</name>
              <description>
              VBP lines
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>VTIMER4</name>
          <displayName>VTIMER4</displayName>
          <description></description>
          <addressOffset>0x58</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>18</bitWidth>
            </field>
            <field>
              <name>VACT</name>
              <description>
              VACTIVE lines
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>14</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SDF3D</name>
          <displayName>SDF3D</displayName>
          <description></description>
          <addressOffset>0x5c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>25</bitWidth>
            </field>
            <field>
              <name>CFG_EN</name>
              <description>
              transfer packet with 3D control payload
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DATA_ORDER</name>
              <description>
              data order
              0: left eye data first
              1: right eye data first
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>VSYNC_2ND</name>
              <description>
              set sync between left and right image
              0: no vsync pulse
              1: add sync pulse
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FORMAT</name>
              <description>
              3D image format
              00: Line
              01: Frame
              10: Pixel
              11: Reserved
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>MODE</name>
              <description>
              3D mode
              00: 3D mode off
              01: 3D mode on, portrait orientation
              10: 3D mode on, landscape orientation
              11: Reserved
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PHY_CFG1</name>
          <displayName>PHY_CFG1</displayName>
          <description></description>
          <addressOffset>0x60</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>CKHS2LP_TIMER</name>
              <description>
              CK lane HS to LP transition time
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
            <field>
              <name>CKLP2HS_TIMER</name>
              <description>
              CK lane LP to HS transition time
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
            <field>
              <name>WAIT_TIMER</name>
              <description>
              wait period between Stop State and HS
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>NUM_ACT_LANE</name>
              <description>
              Number of active lanes
              00: 1 data lane
              01: 2 data lane
              10,11: Reserved
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PHY_CFG2</name>
          <displayName>PHY_CFG2</displayName>
          <description></description>
          <addressOffset>0x64</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MAX_RD_TIMER</name>
              <description>
              max read time
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>15</bitWidth>
            </field>
            <field>
              <name>DATAHS2LP_TIMER</name>
              <description>
              Data lane HS to LP transition time
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>DATALP2HS_TIMER</name>
              <description>
              Data lane LP to HS transition time
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PHY_CTRL</name>
          <displayName>PHY_CTRL</displayName>
          <description></description>
          <addressOffset>0x68</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>18</bitWidth>
            </field>
            <field>
              <name>TX_TRIGGERS</name>
              <description>
              tx trigger transmission
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>DLANE_EXITULPS</name>
              <description>
              ULPS exit for all data lane
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DLANE_REQULPS</name>
              <description>
              ULPS request for all data lane
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CKLANE_EXITULPS</name>
              <description>
              ULPS exit for ck lane
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CKLANE_REQULPS</name>
              <description>
              ULPS request for ck lane
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CKLANE_HSTXREQ</name>
              <description>
              hstx request for ck lane
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CKLANE_AUTO_CTRL</name>
              <description>
              ck lane auto on/off control
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CKLANE_ENABLE</name>
              <description>
              ck lane enable
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PLL_EN</name>
              <description>
              pll enable
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PHY_RSTN</name>
              <description>
              D_PHY reset, active low
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PHY_PD_N</name>
              <description>
              D_PHY power down, active low
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PHY_STAT</name>
          <displayName>PHY_STAT</displayName>
          <description></description>
          <addressOffset>0x6c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00001528</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>19</bitWidth>
            </field>
            <field>
              <name>UNDEF</name>
              <description>
              TBD
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>DLANE1_ULPS_N</name>
              <description>
              Data lane 1 ulps active not signal
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DLANE1_STOP</name>
              <description>
              Data lane 1 stop state signal
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DLANE0_RXULPS_ESC</name>
              <description>
              Data lane 0 rx ulps esc signal
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DLANE0_ULPS_N</name>
              <description>
              Data lane 0 ulps active not signal
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DLANE0_STOP</name>
              <description>
              Data lane 0 stop state signal
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CKLANE_ULPS_N</name>
              <description>
              CK lane ulps active not signal
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CKLANE_STOP</name>
              <description>
              CK lane stop state signal
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DIR</name>
              <description>
              phy direction
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LOCK</name>
              <description>
              phy lock
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>GP</name>
          <displayName>GP</displayName>
          <description></description>
          <addressOffset>0x70</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>13</bitWidth>
            </field>
            <field>
              <name>GP_RD</name>
              <description>
              TBD
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>GP_L</name>
              <description>
              TBD
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
            <field>
              <name>GP_H</name>
              <description>
              TBD
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>INT_STAT1</name>
          <displayName>INT_STAT1</displayName>
          <description></description>
          <addressOffset>0x74</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
            <field>
              <name>D0_LP1_CONT</name>
              <description>
              dlane0 LP1 contention error
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>D0_LP0_CONT</name>
              <description>
              dlane0 LP0 contention error
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>D0_ERRCTRL</name>
              <description>
              dlane0 ErrControl error
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>D0_ERRSYNCESC</name>
              <description>
              dlane0 ErrSyncEsc lpdt synchronization error
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>D0_ERRESC</name>
              <description>
              dlane0 ErrEsc escape entry error
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DSI_PROTOCOL_VIO</name>
              <description>
              DSI protocol violation
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD_INFO1</name>
              <description>
              reserved information
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>INVALID_TRANS_LEN</name>
              <description>
              invalid transmission length
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>INVALID_VCID</name>
              <description>
              invalid DSI VC ID
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UNDEF_DTYPE</name>
              <description>
              undefined DSI data type error
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LONG_PKT_CHKSUM</name>
              <description>
              long packet checksum error
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MULTI_ECC</name>
              <description>
              multi-bit ECC error for ack report
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SINGLE_ECC</name>
              <description>
              single-bit ECC error for ack report
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD_INFO0</name>
              <description>
              reserved information
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FALSE_CTRL</name>
              <description>
              False Control error
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PERI_TIMEOUT</name>
              <description>
              Peripheral Timeout error
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LPTX_SYNC</name>
              <description>
              LP Transmit Sync error
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ESC_ENTRY_CMD</name>
              <description>
              ESC Mode Entry Command error
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EOT_SYNC</name>
              <description>
              EoT Sync error
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SOT_SYNC</name>
              <description>
              SoT Sync error
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SOT</name>
              <description>
              SoT error
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>INT_STAT2</name>
          <displayName>INT_STAT2</displayName>
          <description></description>
          <addressOffset>0x78</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>14</bitWidth>
            </field>
            <field>
              <name>DBI_INVALID_CMD</name>
              <description>
              dbi invalid command error
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DBI_PAYLOAD_RCV</name>
              <description>
              dbi payload FIFO overflow during packet read back
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DBI_PAYLOAD_RD</name>
              <description>
              dbi payload FIFO underflow during DCS read data
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DBI_PAYLOAD_WR</name>
              <description>
              dbi payload FIFO overflow during data write
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DBI_CMD_WR</name>
              <description>
              dbi command FIFO overflow during command write
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>COM_PAYLOAD_RCV</name>
              <description>
              common interface payload FIFO overflow during packet read back
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>COM_PAYLOAD_RD</name>
              <description>
              common interface payload FIFO underflow during DCS read data
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>COM_PAYLOAD_SEND</name>
              <description>
              common interface payload FIFO underflow during packet build
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>COM_PAYLOAD_WR</name>
              <description>
              common interface payload FIFO overflow during data write
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>COM_CMD_WR</name>
              <description>
              common interface command FIFO overflow during command write
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DPI_PAYLOAD_WR</name>
              <description>
              dpi payload FIFO overflow
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EOTP</name>
              <description>
              EoTp packet is not received
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PACKET_SIZE</name>
              <description>
              packet size error
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CRC</name>
              <description>
              CRC error in received packet
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ECC_MULTI</name>
              <description>
              ECC multiple error in received packet
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ECC_SINGLE</name>
              <description>
              ECC single error in received packet
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LPRX_TIMEOUT</name>
              <description>
              lprx timeout
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HSTX_TIMEOUT</name>
              <description>
              hstx timeout
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>INT_MASK1</name>
          <displayName>INT_MASK1</displayName>
          <description></description>
          <addressOffset>0x7c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
            <field>
              <name>D0_LP1_CONT</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>D0_LP0_CONT</name>
              <description>
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>D0_ERRCTRL</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>D0_ERRSYNCESC</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>D0_ERRESC</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DSI_PROTOCOL_VIO</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD_INFO1</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>INVALID_TRANS_LEN</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>INVALID_VCID</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UNDEF_DTYPE</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LONG_PKT_CHKSUM</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MULTI_ECC</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SINGLE_ECC</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD_INFO0</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FALSE_CTRL</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PERI_TIMEOUT</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LPTX_SYNC</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ESC_ENTRY_CMD</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EOT_SYNC</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SOT_SYNC</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SOT</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>INT_MASK2</name>
          <displayName>INT_MASK2</displayName>
          <description></description>
          <addressOffset>0x80</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>14</bitWidth>
            </field>
            <field>
              <name>DBI_INVALID_CMD</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DBI_PAYLOAD_RCV</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DBI_PAYLOAD_RD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DBI_PAYLOAD_WR</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DBI_CMD_WR</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>COM_PAYLOAD_RCV</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>COM_PAYLOAD_RD</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>COM_PAYLOAD_SEND</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>COM_PAYLOAD_WR</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>COM_CMD_WR</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DPI_PAYLOAD_WR</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EOTP</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PACKET_SIZE</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CRC</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ECC_MULTI</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ECC_SINGLE</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LPRX_TIMEOUT</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HSTX_TIMEOUT</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>INT_FORCE1</name>
          <displayName>INT_FORCE1</displayName>
          <description></description>
          <addressOffset>0x84</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
            <field>
              <name>D0_LP1_CONT</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>D0_LP0_CONT</name>
              <description>
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>D0_ERRCTRL</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>D0_ERRSYNCESC</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>D0_ERRESC</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DSI_PROTOCOL_VIO</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD_INFO1</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>INVALID_TRANS_LEN</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>INVALID_VCID</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UNDEF_DTYPE</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LONG_PKT_CHKSUM</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MULTI_ECC</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SINGLE_ECC</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD_INFO0</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FALSE_CTRL</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PERI_TIMEOUT</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LPTX_SYNC</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ESC_ENTRY_CMD</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EOT_SYNC</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SOT_SYNC</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SOT</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>INT_FORCE2</name>
          <displayName>INT_FORCE2</displayName>
          <description></description>
          <addressOffset>0x88</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>14</bitWidth>
            </field>
            <field>
              <name>DBI_INVALID_CMD</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DBI_PAYLOAD_RCV</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DBI_PAYLOAD_RD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DBI_PAYLOAD_WR</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DBI_CMD_WR</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>COM_PAYLOAD_RCV</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>COM_PAYLOAD_RD</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>COM_PAYLOAD_SEND</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>COM_PAYLOAD_WR</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>COM_CMD_WR</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DPI_PAYLOAD_WR</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EOTP</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PACKET_SIZE</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CRC</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ECC_MULTI</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ECC_SINGLE</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LPRX_TIMEOUT</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HSTX_TIMEOUT</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>VAUX_CTRL</name>
          <displayName>VAUX_CTRL</displayName>
          <description></description>
          <addressOffset>0x8c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>29</bitWidth>
            </field>
            <field>
              <name>EXT_REQ</name>
              <description>
              When set to 1, the video request is done by external pin. In this mode,
              aux_req is ignored.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>AUX_REQ</name>
              <description>
              When set to 1, the DPI registers are copied to the auxiliary registers.
              After copying, this bit is auto cleared.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>AUX_LOAD</name>
              <description>
              When set to 1, DPI receives the active configuration from the auxiliary
              registers. When this bit is set along with the aux_req bit, the
              auxiliary registers are automatically updated.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DPI_CFG1_R</name>
          <displayName>DPI_CFG1_R</displayName>
          <description></description>
          <addressOffset>0x90</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>25</bitWidth>
            </field>
            <field>
              <name>LOOSE_EN</name>
              <description>
              enable loosely packed variant to 18-bit mode
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FORMAT</name>
              <description>
              dpi color format
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>VID</name>
              <description>
              dpi channel id
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DPI_CFG2_R</name>
          <displayName>DPI_CFG2_R</displayName>
          <description></description>
          <addressOffset>0x94</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>OUTVACT</name>
              <description>
              command packet size in a line during VSA/VBP/VFP region
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>INVACT</name>
              <description>
              command packet size in a line during VACT region
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>VMODE_CFG1_R</name>
          <displayName>VMODE_CFG1_R</displayName>
          <description></description>
          <addressOffset>0x98</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>PKT_SIZE</name>
              <description>
              Number of pixels in a single video packet
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>14</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>LPCMD_EN</name>
              <description>
              enable command transmission only in lp mode
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BTA_ACK_EN</name>
              <description>
              enable request for an ack response
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LPHFP_EN</name>
              <description>
              enable return to lp inside HFP
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LPHBP_EN</name>
              <description>
              enable return to lp inside HBP
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LPVACT_EN</name>
              <description>
              enable return to lp inside VACT
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LPVFP_EN</name>
              <description>
              enable return to lp inside VFP
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LPVBP_EN</name>
              <description>
              enable return to lp inside VBP
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LPVSA_EN</name>
              <description>
              enable return to lp inside VSA
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>VMODE_TYPE</name>
              <description>
              indicates video mode transmission type
              00: Non-burst with sync pulses
              01: Non-burst with sync events
              10,11: Burst mode
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>VMODE_CFG2_R</name>
          <displayName>VMODE_CFG2_R</displayName>
          <description></description>
          <addressOffset>0x9c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>NULL_SIZE</name>
              <description>
              number of bytes inside a null packet
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>13</bitWidth>
            </field>
            <field>
              <name>NUM_CHUNKS</name>
              <description>
              number of chunks during a Line period
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>13</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>VTIMER1_R</name>
          <displayName>VTIMER1_R</displayName>
          <description></description>
          <addressOffset>0xa0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>HBP</name>
              <description>
              HBP period
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
            <field>
              <name>HSA</name>
              <description>
              HSA period
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>VTIMER2_R</name>
          <displayName>VTIMER2_R</displayName>
          <description></description>
          <addressOffset>0xa4</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
            <field>
              <name>VSA</name>
              <description>
              VSA lines
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
            <field>
              <name>HLINE</name>
              <description>
              HLINE period
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>15</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>VTIMER3_R</name>
          <displayName>VTIMER3_R</displayName>
          <description></description>
          <addressOffset>0xa8</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
            <field>
              <name>VFP</name>
              <description>
              VFP lines
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
            <field>
              <name>VBP</name>
              <description>
              VBP lines
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>VTIMER4_R</name>
          <displayName>VTIMER4_R</displayName>
          <description></description>
          <addressOffset>0xac</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>18</bitWidth>
            </field>
            <field>
              <name>VACT</name>
              <description>
              VACTIVE lines
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>14</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SDF3D_R</name>
          <displayName>SDF3D_R</displayName>
          <description></description>
          <addressOffset>0xb0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>25</bitWidth>
            </field>
            <field>
              <name>CFG_EN</name>
              <description>
              transfer packet with 3D control payload
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DATA_ORDER</name>
              <description>
              data order
              0: left eye data first
              1: right eye data first
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>VSYNC_2ND</name>
              <description>
              set sync between left and right image
              0: no vsync pulse
              1: add sync pulse
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FORMAT</name>
              <description>
              3D image format
              00: Line
              01: Frame
              10: Pixel
              11: Reserved
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>MODE</name>
              <description>
              3D mode
              00: 3D mode off
              01: 3D mode on, portrait orientation
              10: 3D mode on, landscape orientation
              11: Reserved
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>DSI_PHY</name>
      <description></description>
      <groupName>DSI_PHY</groupName>
      <baseAddress>0x4001f000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>PHY_CFG</name>
          <displayName>PHY_CFG</displayName>
          <description></description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>14</bitWidth>
            </field>
            <field>
              <name>INIT_CNT</name>
              <description>
              lane initialization counter, based on TxByteClkHS
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>ENABLE</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RESETN</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CK_LANE_CFG0</name>
          <displayName>CK_LANE_CFG0</displayName>
          <description></description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <fields>
            <field>
              <name>TCLKZERO_CNT</name>
              <description>
              tclkzero counter value, based on dsi_phy_clk
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>TCLKPREP_CNT</name>
              <description>
              tclkprep counter value, based on dsi_phy_clk
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>TLPX_CNT</name>
              <description>
              tlpx counter value, based on dsi_phy_clk
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>PHASE_SEL</name>
              <description>
              clock lane output phase sel
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CK_LANE_CFG1</name>
          <displayName>CK_LANE_CFG1</displayName>
          <description></description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>THSEXIT_CNT</name>
              <description>
              thsexit counter value, based on dsi_phy_clk
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>TCLKTRAIL_CNT</name>
              <description>
              tclktrail counter value, based on dsi_phy_clk
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>TCLKPOST_CNT</name>
              <description>
              tclkpost counter value, based on dsi_phy_clk
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>TCLKPRE_CNT</name>
              <description>
              tclkpre counter value, based on dsi_phy_clk
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CK_LANE_CFG2</name>
          <displayName>CK_LANE_CFG2</displayName>
          <description></description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>TWAKEUP_CNT</name>
              <description>
              twakeup counter value, based on dsi_phy_clk(Usually twakeup requires 1ms, which is over this counter range. Use TxClkExit to enter twakeup state instead of this counter.)
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CK_LANE_CTRL</name>
          <displayName>CK_LANE_CTRL</displayName>
          <description></description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>PN_SWAP</name>
              <description>
              swap dp and dn value
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CDDOUT</name>
              <description>
              contention detect data out
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>LPRXLPDOUT</name>
              <description>
              lprx lp mode data out
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>LPRXULPDOUT</name>
              <description>
              lprx ulp mode data out
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>LPTXENA_BYPASS</name>
              <description>
              bypass lptxena control from hardware logic
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LPTXENA_SET</name>
              <description>
              lptxena bypass value
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LPTXPU_BYPASS</name>
              <description>
              bypass lptx pull up control from hardware logic
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LPTXPU_SET</name>
              <description>
              lptxpu bypass value
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LPTXPD_BYPASS</name>
              <description>
              bypass lptx pull down control from hardware logic
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LPTXPD_SET</name>
              <description>
              lptxpd bypass value
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LPTXDIN_BYPASS</name>
              <description>
              bypass lptxdin control from hardware logic
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LPTXDIN_SET</name>
              <description>
              lptxdin bypass value
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>HSTXENA_BYPASS</name>
              <description>
              bypass hstxena control from hardware logic
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HSTXENA_SET</name>
              <description>
              hstxena bypass value
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HSTXDIN_BYPASS</name>
              <description>
              bypass hstxdin control from hardware logic
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HSTXDIN_SET</name>
              <description>
              hstxdin bypass value
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BIASPON</name>
              <description>
              BIAS power on
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LPRXPONCD</name>
              <description>
              LP RX module CD power on
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LPRXPONULP</name>
              <description>
              LP RX module ULP power on
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LPRXPONLP</name>
              <description>
              LP RX module LP power on
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LPTXPON</name>
              <description>
              LP TX module power on
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HSTXPON</name>
              <description>
              HS TX module power on
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CK_LANE_TEST_CTRL</name>
          <displayName>CK_LANE_TEST_CTRL</displayName>
          <description></description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RUN_LB_TEST</name>
              <description>
              run loopback test
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LPRX_MODE_SEL</name>
              <description>
              1: lprxulp mode
              0: lprxlp mode
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HS_DLY_SEL</name>
              <description>
              hs loopback data delay select
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>LP_DLY_SEL</name>
              <description>
              lp loopback data delay select
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>HS_RX_CLK_POL</name>
              <description>
              hs rx loopback latch clock polarity
              1: inveter
              0: normal
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LP_RX_CLK_POL</name>
              <description>
              lp rx loopback latch clock polarity
              1: inveter
              0: normal
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LB_BUSY</name>
              <description>
              loopback busy status
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LB_DONE</name>
              <description>
              loopback done status
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LB_LP_TEST_PASS</name>
              <description>
              loopback lp test pass
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LB_HS_TEST_PASS</name>
              <description>
              loopback hs test pass
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HSRXPON</name>
              <description>
              HS RX module power on
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LBMODE_EN</name>
              <description>
              loopback mode enable
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>INMATCH_EN</name>
              <description>
              clock lane hsrx input 50ohm match enable
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CAL_EN</name>
              <description>
              hsrx calibration enable
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OS_SET</name>
              <description>
              hsrx offset set
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>SYN_OUT_ENB</name>
              <description>
              synchronized output enable, low active. When disabled, asy_clkout is active.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ASY_CLKOUT</name>
              <description>
              asynchronized clock output
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>ASY_DOUT</name>
              <description>
              asynchronized data output
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>D_LANE0_CFG0</name>
          <displayName>D_LANE0_CFG0</displayName>
          <description></description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>THSTRAIL_CNT</name>
              <description>
              thstrail counter value, based on TxByteClkHS
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>THSZERO_CNT</name>
              <description>
              thszero counter value, based on TxByteClkHS
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>THSPREP_CNT</name>
              <description>
              thsprep counter value, based on TxByteClkHS
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>TLPX_CNT</name>
              <description>
              tlpx counter value, based on TxByteClkHS
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>D_LANE0_CFG1</name>
          <displayName>D_LANE0_CFG1</displayName>
          <description></description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>TWAKEUP_CNT</name>
              <description>
              twakeup counter value, based on TxClkEsc
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>TTAGO_CNT</name>
              <description>
              ttago counter value, based on TxClkEsc
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>TTAGET_CNT</name>
              <description>
              ttaget counter value, based on TxClkEsc
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>TTASURE_CNT</name>
              <description>
              ttasure counter value, based on TxClkEsc
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>D_LANE0_CTRL</name>
          <displayName>D_LANE0_CTRL</displayName>
          <description></description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>LPTX_FIFO_TH</name>
              <description>
              LPTX mode FIFO threshold. The txready is held low if the data in FIFO exceeds the threshold.
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>CONTENTION_DET_EN</name>
              <description>
              contention detect enable
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PN_SWAP</name>
              <description>
              swap dp and dn value
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CDDOUT</name>
              <description>
              contention detect data out
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>LPRXLPDOUT</name>
              <description>
              lprx lp mode data out
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>LPRXULPDOUT</name>
              <description>
              lprx ulp mode data out
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>LPTXENA_BYPASS</name>
              <description>
              bypass lptxena control from hardware logic
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LPTXENA_SET</name>
              <description>
              lptxena bypass value
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LPTXPU_BYPASS</name>
              <description>
              bypass lptx pull up control from hardware logic
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LPTXPU_SET</name>
              <description>
              lptxpu bypass value
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LPTXPD_BYPASS</name>
              <description>
              bypass lptx pull down control from hardware logic
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LPTXPD_SET</name>
              <description>
              lptxpd bypass value
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LPTXDIN_BYPASS</name>
              <description>
              bypass lptxdin control from hardware logic
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LPTXDIN_SET</name>
              <description>
              lptxdin bypass value
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>HSTXENA_BYPASS</name>
              <description>
              bypass hstxena control from hardware logic
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HSTXENA_SET</name>
              <description>
              hstxena bypass value
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HSTXDIN_BYPASS</name>
              <description>
              bypass hstxdin control from hardware logic
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HSTXDIN_SET</name>
              <description>
              hstxdin bypass value
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BIASPON</name>
              <description>
              BIAS power on
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LPRXPONCD</name>
              <description>
              LP RX module CD power on
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LPRXPONULP</name>
              <description>
              LP RX module ULP power on
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LPRXPONLP</name>
              <description>
              LP RX module LP power on
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LPTXPON</name>
              <description>
              LP TX module power on
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HSTXPON</name>
              <description>
              HS TX module power on
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>D_LANE0_TEST_CTRL</name>
          <displayName>D_LANE0_TEST_CTRL</displayName>
          <description></description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RUN_LB_TEST</name>
              <description>
              run loopback test
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LPRX_MODE_SEL</name>
              <description>
              1: lprxulp mode
              0: lprxlp mode
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HS_DLY_SEL</name>
              <description>
              hs loopback data delay select
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>LP_DLY_SEL</name>
              <description>
              lp loopback data delay select
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>HS_RX_CLK_POL</name>
              <description>
              hs rx loopback latch clock polarity
              1: inveter
              0: normal
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LP_RX_CLK_POL</name>
              <description>
              lp rx loopback latch clock polarity
              1: inveter
              0: normal
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LB_BUSY</name>
              <description>
              loopback busy status
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LB_DONE</name>
              <description>
              loopback done status
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LB_LP_TEST_PASS</name>
              <description>
              loopback lp test pass
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LB_HS_TEST_PASS</name>
              <description>
              loopback hs test pass
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HSRXPON</name>
              <description>
              HS RX module power on
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LBMODE_EN</name>
              <description>
              loopback mode enable
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>INMATCH_EN</name>
              <description>
              clock lane hsrx input 50ohm match enable
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CAL_EN</name>
              <description>
              hsrx calibration enable
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OS_SET</name>
              <description>
              hsrx offset set
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>SYN_OUT_ENB</name>
              <description>
              synchronized output enable, low active. When disabled, asy_clkout is active.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ASY_CLKOUT</name>
              <description>
              asynchronized clock output
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>ASY_DOUT</name>
              <description>
              asynchronized data output
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>D_LANE1_CFG0</name>
          <displayName>D_LANE1_CFG0</displayName>
          <description></description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>THSTRAIL_CNT</name>
              <description>
              thstrail counter value, based on TxByteClkHS
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>THSZERO_CNT</name>
              <description>
              thszero counter value, based on TxByteClkHS
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>THSPREP_CNT</name>
              <description>
              thsprep counter value, based on TxByteClkHS
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>TLPX_CNT</name>
              <description>
              twakeup counter value, based on TxByteClkHS
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>D_LANE1_CFG1</name>
          <displayName>D_LANE1_CFG1</displayName>
          <description></description>
          <addressOffset>0x2c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>TWAKEUP_CNT</name>
              <description>
              twakeup counter value, based on TxClkEsc
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>D_LANE1_CTRL</name>
          <displayName>D_LANE1_CTRL</displayName>
          <description></description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>PN_SWAP</name>
              <description>
              swap dp and dn value
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CDDOUT</name>
              <description>
              contention detect data out
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>LPRXLPDOUT</name>
              <description>
              lprx lp mode data out
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>LPRXULPDOUT</name>
              <description>
              lprx ulp mode data out
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>LPTXENA_BYPASS</name>
              <description>
              bypass lptxena control from hardware logic
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LPTXENA_SET</name>
              <description>
              lptxena bypass value
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LPTXPU_BYPASS</name>
              <description>
              bypass lptx pull up control from hardware logic
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LPTXPU_SET</name>
              <description>
              lptxpu bypass value
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LPTXPD_BYPASS</name>
              <description>
              bypass lptx pull down control from hardware logic
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LPTXPD_SET</name>
              <description>
              lptxpd bypass value
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LPTXDIN_BYPASS</name>
              <description>
              bypass lptxdin control from hardware logic
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LPTXDIN_SET</name>
              <description>
              lptxdin bypass value
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>HSTXENA_BYPASS</name>
              <description>
              bypass hstxena control from hardware logic
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HSTXENA_SET</name>
              <description>
              hstxena bypass value
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HSTXDIN_BYPASS</name>
              <description>
              bypass hstxdin control from hardware logic
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HSTXDIN_SET</name>
              <description>
              hstxdin bypass value
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BIASPON</name>
              <description>
              BIAS power on
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LPRXPONCD</name>
              <description>
              LP RX module CD power on
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LPRXPONULP</name>
              <description>
              LP RX module ULP power on
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LPRXPONLP</name>
              <description>
              LP RX module LP power on
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LPTXPON</name>
              <description>
              LP TX module power on
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HSTXPON</name>
              <description>
              HS TX module power on
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>D_LANE1_TEST_CTRL</name>
          <displayName>D_LANE1_TEST_CTRL</displayName>
          <description></description>
          <addressOffset>0x34</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RUN_LB_TEST</name>
              <description>
              run loopback test
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LPRX_MODE_SEL</name>
              <description>
              1: lprxulp mode
              0: lprxlp mode
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HS_DLY_SEL</name>
              <description>
              hs loopback data delay select
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>LP_DLY_SEL</name>
              <description>
              lp loopback data delay select
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>HS_RX_CLK_POL</name>
              <description>
              hs rx loopback latch clock polarity
              1: inveter
              0: normal
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LP_RX_CLK_POL</name>
              <description>
              lp rx loopback latch clock polarity
              1: inveter
              0: normal
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LB_BUSY</name>
              <description>
              loopback busy status
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LB_DONE</name>
              <description>
              loopback done status
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LB_LP_TEST_PASS</name>
              <description>
              loopback lp test pass
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LB_HS_TEST_PASS</name>
              <description>
              loopback hs test pass
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HSRXPON</name>
              <description>
              HS RX module power on
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LBMODE_EN</name>
              <description>
              loopback mode enable
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>INMATCH_EN</name>
              <description>
              clock lane hsrx input 50ohm match enable
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CAL_EN</name>
              <description>
              hsrx calibration enable
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OS_SET</name>
              <description>
              hsrx offset set
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>SYN_OUT_ENB</name>
              <description>
              synchronized output enable, low active. When disabled, asy_clkout is active.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ASY_CLKOUT</name>
              <description>
              asynchronized clock output
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>ASY_DOUT</name>
              <description>
              asynchronized data output
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD1</name>
          <displayName>RSVD1</displayName>
          <description></description>
          <addressOffset>0x38</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>DLL_CFG</name>
          <displayName>DLL_CFG</displayName>
          <description></description>
          <addressOffset>0x40</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
            <field>
              <name>DLL0_OUT_STR</name>
              <description>
              dll0 output strength control
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>DLL0_BYPASS</name>
              <description>
              bypass dll0 core, output input clock
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DLL0_OUT_DIV2_EN</name>
              <description>
              enable output div2
              1: output clock is divided by 2
              0: output clock is not divided by 2
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DLL0_IN_DIV2_EN</name>
              <description>
              enable input div2
              1: input reference clock is divided by 2
              0: input reference clock is not divided by 2
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DLL0_XTALIN_EN</name>
              <description>
              select xtal48M clock as input clock
              1: use xtal 48M
              0: use rc 48M
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DLL0_PRCHG_EXT</name>
              <description>
              external precharge DLL0 vctrl
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DLL0_PRCHG_EN</name>
              <description>
              enable precharge DLL0 vctrl to avoid false lock
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DLL0_MCU_PRCHG_EN</name>
              <description>
              enable MCU/FIRMWARE control DLL0 precharge
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DLL0_MCU_PRCHG</name>
              <description>
              MCU/FIRMWARE control DLL0 precharge
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DLL0_VST_SEL</name>
              <description>
              pre-charge time select
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DLL0_STG</name>
              <description>
              DLL0 output clock frequency select
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>DLL0_48M_EN</name>
              <description>
              enable 48MHz input DLL0 delay chain. Enable the delay chain when the clock to dll core is 48M.(consider input clock clock divider)
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DLL0_LDO_VREF</name>
              <description>
              DLL0 LDO output select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DLL_CTRL</name>
          <displayName>DLL_CTRL</displayName>
          <description></description>
          <addressOffset>0x44</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>28</bitWidth>
            </field>
            <field>
              <name>DLL0_LDO_EN</name>
              <description>
              DLL0 LDO enable
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DLL0_LOOP_EN</name>
              <description>
              enable DLL0 loop, reset delay chain to min delay by rising triggle
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DLL0_OUT_RSTB</name>
              <description>
              reset DLL0 output to 0
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DLL0_OUT_EN</name>
              <description>
              DLL0 output gate enable
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DLL_TEST</name>
          <displayName>DLL_TEST</displayName>
          <description></description>
          <addressOffset>0x48</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>27</bitWidth>
            </field>
            <field>
              <name>DLL0_DTEST_EN</name>
              <description>
              DLL0 dtest enable
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DLL0_DTEST_TR</name>
              <description>
              DLL0 dtest select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DSI_ANA_CTRL</name>
          <displayName>DSI_ANA_CTRL</displayName>
          <description></description>
          <addressOffset>0x4c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>25</bitWidth>
            </field>
            <field>
              <name>DC_TE</name>
              <description>
              Master switch to enable DC test
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DC_BR</name>
              <description>
              DC tst Block select
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>DC_TR</name>
              <description>
              DC testpoint select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BIAS_CTRL</name>
          <displayName>BIAS_CTRL</displayName>
          <description></description>
          <addressOffset>0x50</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
            <field>
              <name>RSET_EN</name>
              <description>
              set Res enable
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BIAS_EN</name>
              <description>
              BIAS enable
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PSW_EN</name>
              <description>
              Power switch for AVDD18 enable
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BIAS_MASTER</name>
              <description>
              not used
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BIAS_PROG_EN</name>
              <description>
              BIAS program enable
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BIAS_PROG</name>
              <description>
              [15] reserved
              [14:11] 1.2v control
              [10] HSRX 1.5G enable
              [9:7] 0.4v control
              [6] LPRX half bias enable
              [5:3] LPTX bias control
              [2:0] lane bias control
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BIAS_CAL</name>
          <displayName>BIAS_CAL</displayName>
          <description></description>
          <addressOffset>0x54</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>MODE</name>
              <description>
              calibration mode
              1'b0: auto mode
              1'b1: manual mode
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>AUTO_CLK_DIV</name>
              <description>
              auto mode calibration clock divider
              divider ratio is 2^AUTO_CLK_DIV
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>START</name>
              <description>
              start automatic calibration
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DONE</name>
              <description>
              auto calibration done indicator
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RCAL_POL</name>
              <description>
              auto calibration rcal_up polarity
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RESULT</name>
              <description>
              auto calibration res result
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RCAL_EN_MANUAL</name>
              <description>
              manual mode RCAL enable
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSET_MANUAL</name>
              <description>
              manual mode RSET control
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RCAL_UP</name>
              <description>
              RCAL flag output, 1 require RSET increase
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>LOOPBACK_CFG</name>
          <displayName>LOOPBACK_CFG</displayName>
          <description></description>
          <addressOffset>0x58</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>LB_CLK_DIV</name>
              <description>
              loopback lpmode clock divider
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>LFSR_SEED</name>
              <description>
              loopback lfsr seed
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>MISC_CFG</name>
          <displayName>MISC_CFG</displayName>
          <description></description>
          <addressOffset>0x5c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>TPULLUP_CNT</name>
              <description>
              data lane lptxpu delay time
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RESERVED_IN</name>
          <displayName>RESERVED_IN</displayName>
          <description></description>
          <addressOffset>0x60</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>CTRL_2</name>
              <description>
              reserved control 2
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>CTRL_1</name>
              <description>
              reserved control 1
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>CTRL_0</name>
              <description>
              reserved control 0
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RESERVED_OUT</name>
          <displayName>RESERVED_OUT</displayName>
          <description></description>
          <addressOffset>0x64</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>STAT</name>
              <description>
              reserved status
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PTC1</name>
      <description></description>
      <groupName>PTC</groupName>
      <baseAddress>0x40020000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>ISR</name>
          <displayName>ISR</displayName>
          <description>interrupt status register</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>TEIF8</name>
              <description>
              transfer error flag for task 8
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIF7</name>
              <description>
              transfer error flag for task 7
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIF6</name>
              <description>
              transfer error flag for task 6
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIF5</name>
              <description>
              transfer error flag for task 5
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIF4</name>
              <description>
              transfer error flag for task 4
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIF3</name>
              <description>
              transfer error flag for task 3
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIF2</name>
              <description>
              transfer error flag for task 2
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIF1</name>
              <description>
              transfer error flag for task 1
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>TCIF8</name>
              <description>
              task complete interrupt flag for task 8
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIF7</name>
              <description>
              task complete interrupt flag for task 7
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIF6</name>
              <description>
              task complete interrupt flag for task 6
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIF5</name>
              <description>
              task complete interrupt flag for task 5
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIF4</name>
              <description>
              task complete interrupt flag for task 4
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIF3</name>
              <description>
              task complete interrupt flag for task 3
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIF2</name>
              <description>
              task complete interrupt flag for task 2
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIF1</name>
              <description>
              task complete interrupt flag for task 1
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ICR</name>
          <displayName>ICR</displayName>
          <description>interrupt clear register</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>15</bitWidth>
            </field>
            <field>
              <name>CTEIF</name>
              <description>
              clear transfer error flag
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>CTCIF8</name>
              <description>
              clear task complete interrupt flag for task 8
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTCIF7</name>
              <description>
              clear task complete interrupt flag for task 7
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTCIF6</name>
              <description>
              clear task complete interrupt flag for task 6
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTCIF5</name>
              <description>
              clear task complete interrupt flag for task 5
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTCIF4</name>
              <description>
              clear task complete interrupt flag for task 4
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTCIF3</name>
              <description>
              clear task complete interrupt flag for task 3
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTCIF2</name>
              <description>
              clear task complete interrupt flag for task 2
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTCIF1</name>
              <description>
              clear task complete interrupt flag for task 1
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IER</name>
          <displayName>IER</displayName>
          <description>interrupt enable register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>15</bitWidth>
            </field>
            <field>
              <name>TEIE</name>
              <description>
              enable transfer error flag
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>TCIE8</name>
              <description>
              enable task complete interrupt for task 8
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIE7</name>
              <description>
              enable task complete interrupt for task 7
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIE6</name>
              <description>
              enable task complete interrupt for task 6
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIE5</name>
              <description>
              enable task complete interrupt for task 5
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIE4</name>
              <description>
              enable task complete interrupt for task 4
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIE3</name>
              <description>
              enable task complete interrupt for task 3
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIE2</name>
              <description>
              enable task complete interrupt for task 2
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIE1</name>
              <description>
              enable task complete interrupt for task 1
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TCR1</name>
          <displayName>TCR1</displayName>
          <description>task 1 control register</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>13</bitWidth>
            </field>
            <field>
              <name>OP</name>
              <description>
              task operation
              3'b000: direct write data
              3'b100: read then XOR with data and write back
              3'b101: read then OR with data and write back
              3'b110: read then AND with data and write back
              3'b111: read then add with data and write back
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>TRIGSEL</name>
              <description>
              select trigger source
              0: task will not be triggered
              others: task will be triggered by selected source
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TAR1</name>
          <displayName>TAR1</displayName>
          <description>task 1 address register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ADDR</name>
              <description>
              peripheral address to access to
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TDR1</name>
          <displayName>TDR1</displayName>
          <description>task 1 data register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              data value for task operation
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TCR2</name>
          <displayName>TCR2</displayName>
          <description></description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>13</bitWidth>
            </field>
            <field>
              <name>OP</name>
              <description>
              task operation
              3'b000: direct write data
              3'b100: read then XOR with data and write back
              3'b101: read then OR with data and write back
              3'b110: read then AND with data and write back
              3'b111: read then add with data and write back
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>TRIGSEL</name>
              <description>
              select trigger source
              0: task will not be triggered
              others: task will be triggered by selected source
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TAR2</name>
          <displayName>TAR2</displayName>
          <description></description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ADDR</name>
              <description>
              peripheral address to access to
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TDR2</name>
          <displayName>TDR2</displayName>
          <description></description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              data value for task operation
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TCR3</name>
          <displayName>TCR3</displayName>
          <description></description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>13</bitWidth>
            </field>
            <field>
              <name>OP</name>
              <description>
              task operation
              3'b000: direct write data
              3'b100: read then XOR with data and write back
              3'b101: read then OR with data and write back
              3'b110: read then AND with data and write back
              3'b111: read then add with data and write back
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>TRIGSEL</name>
              <description>
              select trigger source
              0: task will not be triggered
              others: task will be triggered by selected source
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TAR3</name>
          <displayName>TAR3</displayName>
          <description></description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ADDR</name>
              <description>
              peripheral address to access to
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TDR3</name>
          <displayName>TDR3</displayName>
          <description></description>
          <addressOffset>0x2c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              data value for task operation
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TCR4</name>
          <displayName>TCR4</displayName>
          <description></description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>13</bitWidth>
            </field>
            <field>
              <name>OP</name>
              <description>
              task operation
              3'b000: direct write data
              3'b100: read then XOR with data and write back
              3'b101: read then OR with data and write back
              3'b110: read then AND with data and write back
              3'b111: read then add with data and write back
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>TRIGSEL</name>
              <description>
              select trigger source
              0: task will not be triggered
              others: task will be triggered by selected source
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TAR4</name>
          <displayName>TAR4</displayName>
          <description></description>
          <addressOffset>0x34</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ADDR</name>
              <description>
              peripheral address to access to
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TDR4</name>
          <displayName>TDR4</displayName>
          <description></description>
          <addressOffset>0x38</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              data value for task operation
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TCR5</name>
          <displayName>TCR5</displayName>
          <description></description>
          <addressOffset>0x3c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>13</bitWidth>
            </field>
            <field>
              <name>OP</name>
              <description>
              task operation
              3'b000: direct write data
              3'b100: read then XOR with data and write back
              3'b101: read then OR with data and write back
              3'b110: read then AND with data and write back
              3'b111: read then add with data and write back
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>TRIGSEL</name>
              <description>
              select trigger source
              0: task will not be triggered
              others: task will be triggered by selected source
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TAR5</name>
          <displayName>TAR5</displayName>
          <description></description>
          <addressOffset>0x40</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ADDR</name>
              <description>
              peripheral address to access to
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TDR5</name>
          <displayName>TDR5</displayName>
          <description></description>
          <addressOffset>0x44</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              data value for task operation
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TCR6</name>
          <displayName>TCR6</displayName>
          <description></description>
          <addressOffset>0x48</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>13</bitWidth>
            </field>
            <field>
              <name>OP</name>
              <description>
              task operation
              3'b000: direct write data
              3'b100: read then XOR with data and write back
              3'b101: read then OR with data and write back
              3'b110: read then AND with data and write back
              3'b111: read then add with data and write back
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>TRIGSEL</name>
              <description>
              select trigger source
              0: task will not be triggered
              others: task will be triggered by selected source
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TAR6</name>
          <displayName>TAR6</displayName>
          <description></description>
          <addressOffset>0x4c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ADDR</name>
              <description>
              peripheral address to access to
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TDR6</name>
          <displayName>TDR6</displayName>
          <description></description>
          <addressOffset>0x50</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              data value for task operation
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TCR7</name>
          <displayName>TCR7</displayName>
          <description></description>
          <addressOffset>0x54</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>13</bitWidth>
            </field>
            <field>
              <name>OP</name>
              <description>
              task operation
              3'b000: direct write data
              3'b100: read then XOR with data and write back
              3'b101: read then OR with data and write back
              3'b110: read then AND with data and write back
              3'b111: read then add with data and write back
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>TRIGSEL</name>
              <description>
              select trigger source
              0: task will not be triggered
              others: task will be triggered by selected source
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TAR7</name>
          <displayName>TAR7</displayName>
          <description></description>
          <addressOffset>0x58</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ADDR</name>
              <description>
              peripheral address to access to
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TDR7</name>
          <displayName>TDR7</displayName>
          <description></description>
          <addressOffset>0x5c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              data value for task operation
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TCR8</name>
          <displayName>TCR8</displayName>
          <description></description>
          <addressOffset>0x60</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>13</bitWidth>
            </field>
            <field>
              <name>OP</name>
              <description>
              task operation
              3'b000: direct write data
              3'b100: read then XOR with data and write back
              3'b101: read then OR with data and write back
              3'b110: read then AND with data and write back
              3'b111: read then add with data and write back
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>TRIGSEL</name>
              <description>
              select trigger source
              0: task will not be triggered
              others: task will be triggered by selected source
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TAR8</name>
          <displayName>TAR8</displayName>
          <description></description>
          <addressOffset>0x64</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ADDR</name>
              <description>
              peripheral address to access to
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TDR8</name>
          <displayName>TDR8</displayName>
          <description></description>
          <addressOffset>0x68</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              data value for task operation
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD1</name>
          <displayName>RSVD1</displayName>
          <description></description>
          <addressOffset>0x6C</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>MEM1</name>
          <displayName>MEM1</displayName>
          <description>temporary memory 1</description>
          <addressOffset>0x70</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              memory to store temporary variables
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>MEM2</name>
          <displayName>MEM2</displayName>
          <description>temporary memory 2</description>
          <addressOffset>0x74</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              memory to store temporary variables
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>MEM3</name>
          <displayName>MEM3</displayName>
          <description>temporary memory 3</description>
          <addressOffset>0x78</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              memory to store temporary variables
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>MEM4</name>
          <displayName>MEM4</displayName>
          <description>temporary memory 4</description>
          <addressOffset>0x7c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              memory to store temporary variables
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>GPIO31_0</name>
          <displayName>GPIO31_0</displayName>
          <description></description>
          <addressOffset>0x80</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>SELD</name>
              <description>
              select trigger D of GPIO 31~0
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>SELC</name>
              <description>
              select trigger C of GPIO 31~0
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>SELB</name>
              <description>
              select trigger B of GPIO 31~0
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>SELA</name>
              <description>
              select trigger A of GPIO 31~0
              0: select GPIO 0
              1: select GPIO 1
              ......
              31: select GPIO 31
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>GPIO63_32</name>
          <displayName>GPIO63_32</displayName>
          <description></description>
          <addressOffset>0x84</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>SELD</name>
              <description>
              select trigger D of GPIO 63~32
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>SELC</name>
              <description>
              select trigger C of GPIO 63~32
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>SELB</name>
              <description>
              select trigger B of GPIO 63~32
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>SELA</name>
              <description>
              select trigger A of GPIO 63~32
              0: select GPIO 32
              1: select GPIO 33
              ......
              31: select GPIO 63
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>GPIO95_64</name>
          <displayName>GPIO95_64</displayName>
          <description></description>
          <addressOffset>0x88</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>SELD</name>
              <description>
              select trigger D of GPIO 95~64
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>SELC</name>
              <description>
              select trigger C of GPIO 95~64
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>SELB</name>
              <description>
              select trigger B of GPIO 95~64
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>SELA</name>
              <description>
              select trigger A of GPIO 95~64
              0: select GPIO 64
              1: select GPIO 65
              ......
              31: select GPIO 95
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>I2C3</name>
      <description></description>
      <groupName>I2C</groupName>
      <baseAddress>0x40022000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CR</name>
          <displayName>CR</displayName>
          <description>Control register</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>UR</name>
              <description>
              Unit Reset. Software need first assert to reset then deassert to release.
              0 = No reset.
              1 = Reset I2C module.
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSTREQ</name>
              <description>
              I2C will do bus reset upon this bit set. Will be cleared by HW automatically after RSTCYC cycles of SCL generated.
              1 = request for i2c bus reset
              0 = bus reset finished
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BRGRST</name>
              <description>
              Reset bus related state machine and signals. Will be cleared by HW automatically
              1 = request for reset
              0 = reset finished
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>14</bitWidth>
            </field>
            <field>
              <name>DNF</name>
              <description>
              Digital noise filter
              These bits are used to configure the digital noise filter on SDA and SCL input. The digital filter will filter spikes with a length of up to DNF*Tfclk.
              0: Digital filter disabled 
              1: Digital filter enabled and filtering capability up to 1 Tfclk
              ...
              7: digital filter enabled and filtering capability up to 7 Tfclk
              Note: Digital filter is added to analog filter. Digital filter will introduce delay on SCL and SDA processing, which is essential in hs-mode. 
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>SCLPP</name>
              <description>
              Push-pull mode Enable for SCL.
              0 = open drain output for SCL.
              1 = Push-pull output for SCL
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MSDE</name>
              <description>
              Master Stop Detected Enable:
              0 = Master Stop Detect (MSD) status is not enabled.
              1 = Master Stop Detect (MSD) status is enabled.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LASTSTOP</name>
              <description>
              Generate STOP for last DMA transfer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LASTNACK</name>
              <description>
              Generate NACK for last DMA Read transfer
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMAEN</name>
              <description>
              DMA Enable for both TX and RX
              0 = DMA mode is NOT enabled
              1 = DMA mode enabled
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SCLE</name>
              <description>
              SCL Enable:
              0 = Disables the I2C from driving the SCL line.
              1 = Enables the I2C clock output for master-mode operation.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IUE</name>
              <description>
              I2C Unit Enable:
              0 = Disables the unit and does not master any transactions or respond to any slave transactions.
              1 = Enables the I2C (defaults to slave-receive mode).
              Software must guarantee the I2C bus is idle before setting this bit.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MODE</name>
              <description>
              Bus Mode (Master operation):
              2'b00: standard-mode
              2'b01: fast-mode and fast-mode plus
              2'b10: HS-mode (standard mode when not doing a high speed transfer)
              2'b11: HS-mode (fast mode when not doing a high speed transfer)
              Bus Mode (Slave operation):
              2'b0x: HS-mode is disabled. I2C unit uses Standard/Fast mode timing on the SDA pin.
              2'b1x: HS-mode is enabled. I2C unit uses HS-mode timing on the SDA pin when a master code is received.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TCR</name>
          <displayName>TCR</displayName>
          <description>Transfer Control register</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>ABORTDMA</name>
              <description>
              Abort DMA operation. Will be cleared by HW automatically
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RXREQ</name>
              <description>
              Request DMA RX. Will be cleared by HW automatically
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TXREQ</name>
              <description>
              Request DMA TX. Will be cleared by HW automatically
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MA</name>
              <description>
              Master Abort:
              Used by the I2C in master mode to generate a Stop without transmitting another data byte:
              0 = The I2C transmits Stop on if TCR[STOP] is set.
              1 = The I2C sends Stop without data transmission.
              When in master-transmit mode, after transmitting a data byte, the TCR[TB] bit is cleared. When no more data bytes need to be sent, setting master abort bit sends the Stop. The TCR[TB] bit must remain clear.
              In master-receive mode, when a NAK is sent without a Stop (TCR[STOP] bit was not set) and CPU does not send a repeated Start, setting this bit sends the Stop. Once again, the TCR[TB] bit must remain clear. Master Abort can be done immediately after the address phase (Master Transmit mode only).
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>NACK</name>
              <description>
              The positive/negative acknowledge control bit, defines the type of acknowledge pulse sent by the I2C when in master receive mode:
              0 = Send a positive acknowledge (ACK) pulse after receiving a data byte.
              1 = Send a negative acknowledge (NACK) pulse after receiving a data byte.
              The I2C automatically sends an ACK pulse when responding to its slave address or when responding in slave-receive mode, regardless of the NACK control-bit setting.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>STOP</name>
              <description>
              Stop:
              Used to initiate a Stop condition after transferring the next data byte on the I2C bus when in master mode. In master-receive mode, the NACK control bit must be set in conjunction with the STOP bit. 
              0 = Do not send a Stop.
              1 = Send a Stop.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>START</name>
              <description>
              Start:
              Used to initiate a Start condition to the I2C unit when in master mode. 
              0 = Do not send a Start pulse.
              1 = Send a Start pulse.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TB</name>
              <description>
              Transfer Byte:
              Used to send or receive a byte on the I2C bus:
              0 = Cleared by I2C when the byte is sent/received.
              1 = Send/receive a byte. 
              CPU can monitor this bit to determine when the byte transfer has completed. In master or slave mode, after each byte transfer including acknowledge pulse, the I2C holds the SCL line low (inserting wait states) until TB is set.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IER</name>
          <displayName>IER</displayName>
          <description>Interrupt Enable register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>UFIE</name>
              <description>
              FIFO Underflow Interrupt Enable
              0 = FIFO Underflow interrupt is not enabled
              1 = FIFO Underflow interrupt is enabled
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OFIE</name>
              <description>
              FIFO Overflow Interrupt Enable
              0 = FIFO Overflow interrupt is not enabled
              1 = FIFO Overflow interrupt is enabled
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMADONEIE</name>
              <description>
              DMA Transaction Done Interrupt Enable
              0 = DMA Transaction done interrupt is not enabled.
              1 = DMA Transaction done interrupt is enabled.
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MSDIE</name>
              <description>
              Master Stop Detected Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C unit to interrupt upon detecting a Master Stop sent by the I2C unit.
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BEDIE</name>
              <description>
              Bus Error Detected Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C to interrupt for the following I2C bus errors:
              As a master transmitter, no ACK was detected after a byte was sent.
              As a slave receiver, the I2C generated a NACK pulse.
              Software is responsible for guaranteeing that misplaced Start and Stop conditions do not occur.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SADIE</name>
              <description>
              Slave Address Detected Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C to interrupt upon detecting a slave address match or a general call address.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RFIE</name>
              <description>
              DBR Receive Full Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C to interrupt when the DBR has received a data byte from the I2C bus.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIE</name>
              <description>
              DBR Transmit Empty Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C to interrupt after transmitting a byte onto the I2C bus.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ALDIE</name>
              <description>
              Arbitration Loss Detected Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C to interrupt upon losing arbitration while in master mode.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SSDIE</name>
              <description>
              Slave Stop Detected Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C to interrupt when it detects a Stop condition while in slave mode.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SR</name>
          <displayName>SR</displayName>
          <description>Status register</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>UF</name>
              <description>
              FIFO Underflow Flag. Asserted when FIFO is empty and a POP request generated without a PUSH. Cleared if write 1
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OF</name>
              <description>
              FIFO Overflow Flag. Asserted when FIFO is full and a PUSH request generated without a POP. Cleared if write 1
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMADONE</name>
              <description>
              DMA Transaction Done. Asserted when both APB and I2C bus have finished transfer. Cleared if write 1
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MSD</name>
              <description>
              Master Stop Detected:
              0 = No Master Stop Detected.
              1 = This bit is set by the I2C unit when all of the following are true:
              This bit is enabled (CR[MSDE] = 1);
              I2C unit is configured as a master;
              I2C transmits a STOP signal
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EBB</name>
              <description>
              Early Bus Busy
              0 = I2C bus is idle or the I2C is using the bus (that is, unit busy).
              1 = Set when the unit detects that the SCL or SDA line is low without a START condition. Bit will remain set until the I2C unit detects the bus is idle by detecting a STOP condition. Bit will also be set whenever the IBB bit is set.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BED</name>
              <description>
              Bus Error Detected:
              0 = No error detected.
              1 = The I2C sets this bit when it detects one of the following error conditions:
              As a master transmitter, no ACK was detected on the interface after a byte was sent.
              As a slave receiver, the I2C generates a NACK pulse.
              When an error occurs, I2C bus transactions continue. Software must guarantee that misplaced Start and Stop conditions do not occur. 
              Cleared if write 1
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SAD</name>
              <description>
              Slave Address Detected:
              0 = No slave address was detected.
              1 = The I2C detected a seven-bit address that matches the general call address or SAR. An interrupt is signalled when enabled in the CR. 
              Cleared if write 1
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RF</name>
              <description>
              DBR Receive Full:
              0 = The DBR has not received a new data byte or the I2C is idle.
              1 = The DBR register received a new data byte from the I2C bus. An interrupt is signalled when enabled in the CR. 
              Cleared if write 1
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TE</name>
              <description>
              DBR Transmit Empty:
              0 = The data byte is still being transmitted.
              1 = The I2C has finished transmitting a data byte on the I2C bus. An interrupt is signalled when enabled in the CR.
              Cleared if write 1
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ALD</name>
              <description>
              Arbitration Loss Detected:
              Used during multi-master operation:
              0 = Cleared when arbitration is won or never took place.
              1 = Set when the I2C loses arbitration. 
              Cleared if write 1
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SSD</name>
              <description>
              Slave Stop Detected:
              0 = No Stop detected.
              1 = Set when the I2C detects a Stop while in slave-receive or slave-transmit mode. 
              Cleared if write 1
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IBB</name>
              <description>
              I2C Bus Busy:
              0 = I2C bus is idle or the I2C is using the bus (that is, unit busy).
              1 = Set when the I2C bus is busy but local I2C is not involved in the transaction.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UB</name>
              <description>
              Unit Busy:
              0 = I2C not busy.
              1 = Set when local I2C is busy. This is defined as the time between the first Start and Stop. 
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>NACK</name>
              <description>
              ACK/NACK Status:
              0 = The I2C received or sent an ACK on the bus. 
              1 = The I2C received or sent a NACK.on the bus.
              This bit is used in slave-transmit mode to determine when the byte transferred is the last one. This bit is updated after each byte and ACK/NACK information is received.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RWM</name>
              <description>
              Read/write Mode:
              0 = The I2C is in master-transmit or slave-receive mode. 
              1 = The I2C is in master-receive or slave-transmit mode. 
              This is the R/nW bit of the slave address. It is cleared automatically by hardware after a Stop state.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DBR</name>
          <displayName>DBR</displayName>
          <description>Data Buffer register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>DATA</name>
              <description>
              use the I2C Data Buffer register to transmit and receive data from the I2C bus. The DBR is accessed by software on one Side and by the I2C Shift register on the other. The DBR receives data coming into the I2C unit after a full byte is received and acknowledged. CPU writes data going out of the I2C to the DBR and sends it to the serial bus. 
              When the I2C is in transmit mode (master or slave), CPU writes data to the DBR over the internal bus. CPU write data to the DBR when a master transaction is initiated or when the DBR transmit-empty interrupt is signalled. Data moves from the DBR to the Shift register when the transfer byte bit is set. The DBR transmit-empty interrupt is signalled (if enabled) when a byte is transferred on the I2C bus and the acknowledge cycle is complete. If the DBR is not written, and a Stop condition is not in place before the I2C bus is ready to transfer the next byte packet, the I2C unit inserts wait states until CPU writes the DBR and sets the transfer byte bit.
              When the I2C is in receive mode (master or slave), CPU reads DBR data over the internal bus. CPU reads data from the DBR when the DBR receive-full interrupt is signalled. The data moves from the Shift register to the DBR when the acknowledge cycle is complete. The I2C inserts wait states until the DBR is read. After the software reads the DBR, CR[NACK] are written by the software, allowing the next byte transfer to proceed to the I2C bus.
              In DMA mode, DBR is automatically filled from FIFO in master transmit mode, or fetched and stored in FIFO in master receive mode until DMA done or aborted.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SAR</name>
          <displayName>SAR</displayName>
          <description>Slave Address Register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000047</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>25</bitWidth>
            </field>
            <field>
              <name>ADDR</name>
              <description>
              The seven-bit address to which the I2C responds when in slave-receive mode
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>LCR</name>
          <displayName>LCR</displayName>
          <description>Load Count Register</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x081C3675</resetValue>
          <fields>
            <field>
              <name>HLVH</name>
              <description>
              Decrementer Load value for High Speed Mode SCL (master mode) for high phase. 
              Thigh=Tfclk*(HLVH+4+DNF)
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>HLVL</name>
              <description>
              Decrementer Load value for High Speed Mode SCL (master mode) for low phase. 
              Tlow=Tfclk*(HLVL+3+DNF). Data rate is generated as 1/(Thigh+Tlow), or Ffclk/(HLVH+HLVL+7+2*DNF). 
              3.2Mbps data rate is generated by default if fclk is 48MHz.
              HLVL also controls setup time and hold time for START and STOP condition in High Speed Mode(master mode). 
              Thdsta=Tsusta=Tsusto=Tfclk*(HLVL+1)
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
            <field>
              <name>FLV</name>
              <description>
              Decrementer Load value for Fast Mode (or Fast Mode Plus) SCL (master mode) for both high and low phase. 
              Data rate is generated as Ffclk/(FLV+max(FLV,CNT*2+6)+7+DNF) approximately. 
              FLV also controls setup time and hold time for START and STOP condition in Fast Mode(master mode). 
              Thdsta=Tsusta=Tsusto=Tfclk*FLV
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
            <field>
              <name>SLV</name>
              <description>
              Decrementer Load value for Standard Mode SCL (master mode) for both high and low phase. 
              Data rate is generated as Ffclk/(SLV+max(SLV,CNT*2+6)+7+DNF) approximately. 
              SLV also controls setup time and hold time for START and STOP condition in Standard Mode(master mode). 
              Thdsta=Tsusta=Tsusto=Tfclk*SLV
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>WCR</name>
          <displayName>WCR</displayName>
          <description>Wait Count Register</description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0000000A</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>27</bitWidth>
            </field>
            <field>
              <name>CNT</name>
              <description>
              Controls the counter values defining the setup and hold times in standard and fast mode
              Tvddat=Thddat=Tfclk*(CNT+2)
              Tsudat=max(Tlow-Thddat,Thddat)
              Lower counter values may violate setup and hold times.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RCCR</name>
          <displayName>RCCR</displayName>
          <description>Bus Reset Cycle Counter Register</description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000009</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>28</bitWidth>
            </field>
            <field>
              <name>RSTCYC</name>
              <description>
              The cycles of SCL during bus reset
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BMR</name>
          <displayName>BMR</displayName>
          <description>Bus Monitor Register</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000003</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>30</bitWidth>
            </field>
            <field>
              <name>SCL</name>
              <description>
              value of the SCL pin. Software can check bus level when the I2C bus is hung and the I2C unit must be reset.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SDA</name>
              <description>
              value of the SDA pin.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DNR</name>
          <displayName>DNR</displayName>
          <description>DMA number register</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>NDT</name>
              <description>
              Write as number of data to transfer in byte. Read as left data number to transfer
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD1</name>
          <displayName>RSVD1</displayName>
          <description></description>
          <addressOffset>0x2C</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>FIFO</name>
          <displayName>FIFO</displayName>
          <description>FIFO Register</description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>DATA</name>
              <description>
              Write to push send data into FIFO. Read to pop received data from FIFO
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>HPSYS_AON</name>
      <description></description>
      <groupName>HPSYS_AON</groupName>
      <baseAddress>0x40030000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>PMR</name>
          <displayName>PMR</displayName>
          <description>Power Mode Register</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>FORCE_SLEEP</name>
              <description>
              force to enter low power mode (for debug only)
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>29</bitWidth>
            </field>
            <field>
              <name>MODE</name>
              <description>
              Power Mode: 2'h0 - active/idle; 2'h1 - light sleep; 2'h2 - deep sleep; 2'h3 - standby
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CR</name>
          <displayName>CR</displayName>
          <description>Control Register</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>19</bitWidth>
            </field>
            <field>
              <name>GTIM_EN</name>
              <description>
              Enable global timer
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN3_MODE</name>
              <description>
              mode for wakeup PIN3 (PA80)
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>PIN2_MODE</name>
              <description>
              mode for wakeup PIN2 (PA79)
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>PIN1_MODE</name>
              <description>
              mode for wakeup PIN1 (PA78)
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>PIN0_MODE</name>
              <description>
              mode for wakeup PIN0 (PA77)
              0 - high level, 1 - low level, 2 - pos edge, 3 - neg edge, 4/5/6/7: pos or neg edge
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ACR</name>
          <displayName>ACR</displayName>
          <description>Active Mode Control register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>HXT48_RDY</name>
              <description>
              Indicate hxt48 is ready
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HRC48_RDY</name>
              <description>
              Indicate hrc48 is ready
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>DS_ULPMEM</name>
              <description>
              for debug only
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PD_LPMEM</name>
              <description>
              for debug only
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EXTPWR_REQ</name>
              <description>
              Request power for LPSYS during Active mode
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PWR_REQ</name>
              <description>
              Request power for HPSYS during Active mode
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HXT48_REQ</name>
              <description>
              Request hxt48 in active mode
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HRC48_REQ</name>
              <description>
              Request hrc48 in active mode
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>LSCR</name>
          <displayName>LSCR</displayName>
          <description>Light Sleep Ctrl Register</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>28</bitWidth>
            </field>
            <field>
              <name>EXTPWR_REQ</name>
              <description>
              Request power for LPSYS during Light Sleep mode
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PWR_REQ</name>
              <description>
              Request power for HPSYS during Light Sleep mode
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HXT48_REQ</name>
              <description>
              Request hxt48 in Light Sleep mode
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HRC48_REQ</name>
              <description>
              Request hrc48 in Light Sleep mode
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DSCR</name>
          <displayName>DSCR</displayName>
          <description>Deep Sleep Ctrl Register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>28</bitWidth>
            </field>
            <field>
              <name>EXTPWR_REQ</name>
              <description>
              Request power for LPSYS during Deep Sleep mode
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PWR_REQ</name>
              <description>
              Request power for HPSYS during Deep Sleep mode
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HXT48_REQ</name>
              <description>
              Request hxt48 in Deep Sleep mode
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HRC48_REQ</name>
              <description>
              Request hrc48 in Deep Sleep mode
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SBCR</name>
          <displayName>SBCR</displayName>
          <description>Standby Mode Ctrl Register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>28</bitWidth>
            </field>
            <field>
              <name>EXTPWR_REQ</name>
              <description>
              Request power for LPSYS during Standby mode
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PWR_REQ</name>
              <description>
              Request power for HPSYS during Standby mode
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HXT48_REQ</name>
              <description>
              Request hxt48 in Standby mode
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HRC48_REQ</name>
              <description>
              Request hrc48 in Standby mode
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>WER</name>
          <displayName>WER</displayName>
          <description>Wakeup Enable register</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>22</bitWidth>
            </field>
            <field>
              <name>LP2HP_IRQ</name>
              <description>
              Set 1 to enable MAILBOX2 as wakeup source
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LP2HP_REQ</name>
              <description>
              Set 1 to enable LPSYS request as wakeup source
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>PIN3</name>
              <description>
              Set 1 to enable PA80 as wakeup source
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN2</name>
              <description>
              Set 1 to enable PA79 as wakeup source
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN1</name>
              <description>
              Set 1 to enable PA78 as wakeup source
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN0</name>
              <description>
              Set 1 to enable PA77 as wakeup source
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LPTIM1</name>
              <description>
              Set 1 to enable LPTIM1 as wakeup source
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RTC</name>
              <description>
              Set 1 to enable RTC as wakeup source
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>WSR</name>
          <displayName>WSR</displayName>
          <description>Wakeup Status register</description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>22</bitWidth>
            </field>
            <field>
              <name>LP2HP_IRQ</name>
              <description>
              Indicates the wakeup status from MAILBOX2. Note: the status is masked by WER
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LP2HP_REQ</name>
              <description>
              Indicates the wakeup status from LPSYS request. Note: the status is masked by WER
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>PIN3</name>
              <description>
              Indicates the wakeup status from PA80 request. Note: the status is masked by WER
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN2</name>
              <description>
              Indicates the wakeup status from PA79 request. Note: the status is masked by WER
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN1</name>
              <description>
              Indicates the wakeup status from PA78 request. Note: the status is masked by WER
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN0</name>
              <description>
              Indicates the wakeup status from PA77 request. Note: the status is masked by WER
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LPTIM1</name>
              <description>
              Indicates the wakeup status from LPTIM1. Note: the status is masked by WER
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RTC</name>
              <description>
              Indicates the wakeup status from RTC. Note: the status is masked by WER
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>WCR</name>
          <displayName>WCR</displayName>
          <description>Wakeup Clear register</description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>AON</name>
              <description>
              Write 1 to clear the AON wakeup IRQ status
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>25</bitWidth>
            </field>
            <field>
              <name>PIN3</name>
              <description>
              Write 1 to clear the PA80 wakeup source. Only valid if PIN wakeup is configured as edge trigger
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN2</name>
              <description>
              Write 1 to clear the PA79 wakeup source. Only valid if PIN wakeup is configured as edge trigger
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN1</name>
              <description>
              Write 1 to clear the PA78 wakeup source. Only valid if PIN wakeup is configured as edge trigger
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN0</name>
              <description>
              Write 1 to clear the PA77 wakeup source. Only valid if PIN wakeup is configured as edge trigger
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              Note: for LPTIM and RTC, clear the wakeup status directly in the orignal module
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ISSR</name>
          <displayName>ISSR</displayName>
          <description>Inter System Wakeup Register</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>26</bitWidth>
            </field>
            <field>
              <name>LP_ACTIVE</name>
              <description>
              read 1 indicates LPSYS is active
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HP_ACTIVE</name>
              <description>
              write 1 to indicates HPSYS is active
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>LP2HP_REQ</name>
              <description>
              indicate LPSYS request exists
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HP2LP_REQ</name>
              <description>
              write 1 to request LPSYS to stay in active mode
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ANACR</name>
          <displayName>ANACR</displayName>
          <description>Analog Control Register</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>31</bitWidth>
            </field>
            <field>
              <name>PA_ISO</name>
              <description>
              Set 1 to force IO(PA) into retention mode
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>GTIMR</name>
          <displayName>GTIMR</displayName>
          <description>Global Timer Register</description>
          <addressOffset>0x2c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>CNT</name>
              <description>
              Global timer value
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RESERVE0</name>
          <displayName>RESERVE0</displayName>
          <description>Reserved Register 0</description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              for debug only
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RESERVE1</name>
          <displayName>RESERVE1</displayName>
          <description>Reserved Register 1</description>
          <addressOffset>0x34</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              for debug only
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>LPTIM1</name>
      <description></description>
      <groupName>LPTIM</groupName>
      <baseAddress>0x40031000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>ISR</name>
          <displayName>ISR</displayName>
          <description>LPTIM interrupt and status register</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>21</bitWidth>
            </field>
            <field>
              <name>OCWKUP</name>
              <description>
              Indicates output compare wakeup occurred
              The OCWKUP bit is set by hardware when LPTIM_CNT register value reached the LPTIM_CMP register's value. To clear OCWKUP, first  write 0 to the OCWE bit in the LPTIM_IER register to disable, then write 1 to the WKUPCLR bit in the LPTIM_ICR register. 
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OFWKUP</name>
              <description>
              Indicates overflow wakeup occurred
              OFWKUP is set by hardware when LPTIM_CNT register's value reached the LPTIM_ARR register's value and count from zero again. To clear OFWKUP, first  write 0 to the OFWE bit in the LPTIM_IER register to disable, then write 1 to the WKUPCLR bit in the LPTIM_ICR register. 
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UEWKUP</name>
              <description>
              Indicates update event wakeup occurred
              UEWKUP is set by hardware when an update event was generated (overflow occurred while repetition counter reached zero). To clear UEWKUP, first  write 0 to the UEWE bit in the LPTIM_IER register to disable, then write 1 to the WKUPCLR bit in the LPTIM_ICR register. 
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>ET</name>
              <description>
              External trigger edge event
              ET is set by hardware to inform application that a valid edge on the selected external trigger input has occurred. If the trigger is ignored because the timer has already started, then this flag is not set. ET flag can be cleared by writing 1 to the ETCLR bit in the LPTIM_ICR register.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OC</name>
              <description>
              Output compare match
              The OC bit is set by hardware to inform application that LPTIM_CNT register value reached the LPTIM_CMP register's value. OC flag can be cleared by writing 1 to the OCCLR bit in the LPTIM_ICR register.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OF</name>
              <description>
              Overflow occurred
              OF is set by hardware to inform application that LPTIM_CNT register's value reached the LPTIM_ARR register's value and count from zero again. OF flag can be cleared by writing 1 to the OFCLR bit in the LPTIM_ICR register.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UE</name>
              <description>
              LPTIM update event occurred
              UE is set by hardware to inform application that an update event was generated when overflow occurred while repetition counter reached zero. UE flag can be cleared by writing 1 to the UECLR bit in the LPTIM_ICR register. 
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ICR</name>
          <displayName>ICR</displayName>
          <description>LPTIM interrupt and status clear register</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>WKUPCLR</name>
              <description>
              wakeup status clear flag
              Writing 1 to this bit clears all wakeup status flags in the LPTIM_ISR register.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>ETCLR</name>
              <description>
              External trigger valid edge clear flag
              Writing 1 to this bit clears the ET flag in the LPTIM_ISR register
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OCCLR</name>
              <description>
              Output compare clear flag
              Writing 1 to this bit clears the OC flag in the LPTIM_ISR register
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OFCLR</name>
              <description>
              Overflow clear flag
              Writing 1 to this bit clears the OF flag in the LPTIM_ISR register
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UECLR</name>
              <description>
              Update event clear flag
              Writing 1 to this bit clear the UE flag in the LPTIM_ISR register.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IER</name>
          <displayName>IER</displayName>
          <description>LPTIM interrupt and wakeup enable register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>21</bitWidth>
            </field>
            <field>
              <name>OCWE</name>
              <description>
              Output compare Wakeup Enable
              0: Output compare wakeup disabled
              1: Output compare wakeup enabled
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OFWE</name>
              <description>
              Overflow Wakeup Enable
              0: Overflow Wakeup disabled
              1: Overflow Wakeup enabled
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UEWE</name>
              <description>
              Update event Wakeup enable
              0: Update event Wakeup disabled
              1: Update event Wakeup enabled
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>ETIE</name>
              <description>
              External trigger valid edge Interrupt Enable
              0: External trigger interrupt disabled
              1: External trigger interrupt enabled
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OCIE</name>
              <description>
              Output compare Interrupt Enable
              0: Output compare interrupt disabled
              1: Output compare interrupt enabled
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OFIE</name>
              <description>
              Overflow Interrupt Enable
              0: Overflow interrupt disabled
              1: Overflow interrupt enabled
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UEIE</name>
              <description>
              Update event interrupt enable
              0: Update event interrupt disabled
              1: Update event interrupt enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CFGR</name>
          <displayName>CFGR</displayName>
          <description>LPTIM configuration register</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>COUNTMODE</name>
              <description>
              counter mode in internal clock source mode (CKSEL=0). If CKSEL=1, this bit has no effect.
              0: the counter is incremented following each internal clock pulse
              1: the counter is incremented following each valid pulse on the external clock
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>WAVPOL</name>
              <description>
              Waveform shape polarity
              The WAVEPOL bit controls the output polarity
              0: The LPTIM output reflects the compare results between LPTIM_ARR and LPTIM_CMP registers
              1: The LPTIM output reflects the inverse of the compare results between LPTIM_ARR and LPTIM_CMP registers
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>WAVE</name>
              <description>
              Waveform shape
              The WAVE bit controls the output shape
              0: Deactivate Set-once mode
              1: Activate the Set-once mode
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TIMOUT</name>
              <description>
              Timeout enable
              The TIMOUT bit controls the Timeout feature
              0: A trigger event arriving when the timer is already started will be ignored
              1: A trigger event arriving when the timer is already started will reset and restart the LPTIM counter and the repetition counter
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TRIGEN</name>
              <description>
              Trigger enable and polarity
              The TRIGEN bits controls whether the LPTIM counter is started by an external trigger or not. If the external trigger option is selected, three configurations are possible for the trigger active edge:
              00: software trigger (counting start is initiated by software)
              01: rising edge is the active edge
              10: falling edge is the active edge
              11: both edges are active edges
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TRIGSEL</name>
              <description>
              Trigger selector
              The TRIGSEL bits select the trigger source that will serve as a trigger event for the LPTIM among the below 8 available sources:
              000: lptim_ext0
              001: lptim_ext1
              010: lptim_ext2
              011: lptim_ext3
              100: lptim_ext4
              101: lptim_ext5
              110: lptim_ext6
              111: lptim_ext7
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PRESC</name>
              <description>
              Clock prescaler
              The PRESC bits configure the prescaler division factor. It can be one among the following division factors:
              000: /1
              001: /2
              010: /4
              011: /8
              100: /16
              101: /32
              110: /64
              111: /128
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>EXTCKSEL</name>
              <description>
              External clock source selector
              0: external clock source is from lptim_in
              1: external clock source is from LPCOMP (if LPCOMP integrated)
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TRGFLT</name>
              <description>
              Configurable digital filter for trigger
              The TRGFLT value sets the number of consecutive equal samples that should be detected when a level change occurs on an internal trigger before it is considered as a valid level transition. An internal clock source must be present to use this feature
              00: any trigger active level change is considered as a valid trigger
              01: trigger active level change must be stable for at least 2 clock periods before it is considered as valid trigger.
              10: trigger active level change must be stable for at least 4 clock periods before it is considered as valid trigger.
              11: trigger active level change must be stable for at least 8 clock periods before it is considered as valid trigger.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>INTCKSEL</name>
              <description>
              Internal clock source selector
              0: internal clock source is clk_lp
              1: internal clock source is pclk2
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CKFLT</name>
              <description>
              Configurable digital filter for external clock
              The CKFLT value sets the number of consecutive equal samples that should be detected when a level change occurs on an external clock signal before it is considered as a valid level transition. An internal clock source must be present to use this feature
              00: any external clock signal level change is considered as a valid transition
              01: external clock signal level change must be stable for at least 2 clock periods before it is considered as valid transition.
              10: external clock signal level change must be stable for at least 4 clock periods before it is considered as valid transition.
              11: external clock signal level change must be stable for at least 8 clock periods before it is considered as valid transition.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>CKPOL</name>
              <description>
              Clock Polarity
              If LPTIM is clocked by an external clock source, CKPOL bits is used to configure the active edge or edges used by the counter:
              00: the rising edge is the active edge used for counting
              01: the falling edge is the active edge used for counting
              10: both edges are active edges. When both external clock signal edges are considered active ones, the LPTIM must also be clocked by an internal clock source with a frequency equal to at least four time the external clock frequency.
              11: not allowed
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>CKSEL</name>
              <description>
              Clock selector
              The CKSEL bit selects which clock source the LPTIM will use:
              0: LPTIM is clocked by internal clock source, according to INTCKSEL
              1: LPTIM is clocked by external clock source, according to EXTCKSEL
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CR</name>
          <displayName>CR</displayName>
          <description>LPTIM control register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>28</bitWidth>
            </field>
            <field>
              <name>COUNTRST</name>
              <description>
              Counter reset
              This bit is set by software and cleared by hardware. When set to 1 this bit will trigger a synchronous reset of the CNT register. Due to the synchronous nature of this reset, it only takes place after a synchronization delay.
              COUNTRST must never be set to 1 by software before it is already cleared to 0 by hardware. Software should consequently check that COUNTRST bit is already cleared to 0 before attempting to set it to 1.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CNTSTRT</name>
              <description>
              Timer start in Continuous mode
              This bit is set by software and cleared by hardware.
              In case of software start (TRIGEN[1:0] = 00), setting this bit starts the LPTIM in Continuous mode.
              If the software start is disabled (TRIGEN[1:0] different than 00), setting this bit starts the timer in Continuous mode as soon as an external trigger is detected.
              If this bit is set when a single pulse mode counting is ongoing, then the timer will not stop at the next match between ARR and CNT registers and the LPTIM counter keeps counting in Continuous mode.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SNGSTRT</name>
              <description>
              LPTIM start in Single mode
              This bit is set by software and cleared by hardware.
              In case of software start (TRIGEN[1:0] = 00), setting this bit starts the LPTIM in single pulse mode.
              If the software start is disabled (TRIGEN[1:0] different than 00), setting this bit starts the LPTIM in single pulse mode as soon as an external trigger is detected.
              If this bit is set when the LPTIM is in continuous counting mode, then the LPTIM will stop at the following match between ARR and CNT registers.
              If this bit is set simultaneously with CNTSTRT, then LPTIM will be in continuous counting mode.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ENABLE</name>
              <description>
              LPTIM enable
              The ENABLE bit is set and cleared by software. 
              0:LPTIM is disabled
              1:LPTIM is enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CMP</name>
          <displayName>CMP</displayName>
          <description>LPTIM compare register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>CMP</name>
              <description>
              Compare value
              CMP is the compare value used by the LPTIM.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ARR</name>
          <displayName>ARR</displayName>
          <description>LPTIM autoreload register</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>ARR</name>
              <description>
              Auto reload value
              ARR is the autoreload value for the LPTIM. This value must be strictly greater than the CMP[15:0] value.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CNT</name>
          <displayName>CNT</displayName>
          <description>LPTIM counter register</description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>CNT</name>
              <description>
              Counter value
              When the LPTIM is running with an asynchronous clock, reading the CNT register may return unreliable values. So in this case it is necessary to perform two consecutive read accesses and verify that the two returned values are identical.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RCR</name>
          <displayName>RCR</displayName>
          <description>LPTIM repetition register</description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>REP</name>
              <description>
              Repetition register value
              REP is the repetition value for the LPTIM.
              Read REP will return left repetition times. It should be noted that for a reliable REP register read access, two consecutive read accesses must be performed and compared. A read access can be considered reliable when the values of the two consecutive read accesses are equal.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>HPSYS_GPIO</name>
      <description></description>
      <groupName>HPSYS_GPIO</groupName>
      <baseAddress>0x50000000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>DIR0</name>
          <displayName>DIR0</displayName>
          <description>Data Input Register</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>IN</name>
              <description>
              GPIO[31:0] input value
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DOR0</name>
          <displayName>DOR0</displayName>
          <description>Data Output Register</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>OUT</name>
              <description>
              GPIO[31:0] output value if output enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DOER0</name>
          <displayName>DOER0</displayName>
          <description>Data Output Enable Register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>DOE</name>
              <description>
              GPIO[31:0] output enable
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>OESR0</name>
          <displayName>OESR0</displayName>
          <description>Data Output Enable Set Register</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>OES</name>
              <description>
              set 1 to enable output of corresponding GPIO[31:0]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>OECR0</name>
          <displayName>OECR0</displayName>
          <description>Data Output Enable Clear Register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>OEC</name>
              <description>
              set 1 to disable output of corresponding GPIO[31:0]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IER0</name>
          <displayName>IER0</displayName>
          <description>Interrupt Enable Register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>IER</name>
              <description>
              GPIO[31:0]  interrupt  enable
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IESR0</name>
          <displayName>IESR0</displayName>
          <description>Interrupt Enable Set Register</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>IES</name>
              <description>
              set 1 to enable interrupt of corresponding GPIO[31:0]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IECR0</name>
          <displayName>IECR0</displayName>
          <description>Interrupt Enable Clear Register</description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>IEC</name>
              <description>
              set 1 to disable interrupt of corresponding GPIO[31:0]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ITR0</name>
          <displayName>ITR0</displayName>
          <description>Interrupt Type Register</description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>ITR</name>
              <description>
              GPIO[31:0]  interrupt  type
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ITSR0</name>
          <displayName>ITSR0</displayName>
          <description>Interrupt Type Set Register</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>ITS</name>
              <description>
              set 1 for edge-sensitive interrupt mode of corresponding GPIO[31:0]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ITCR0</name>
          <displayName>ITCR0</displayName>
          <description>Interrupt Type Clear Register</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>ITC</name>
              <description>
              set 1 for level-sensitive interrupt mode of corresponding GPIO[31:0]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IPSR0</name>
          <displayName>IPSR0</displayName>
          <description>Interrupt Polarity Set Register</description>
          <addressOffset>0x2c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>IPS</name>
              <description>
              set 1 for rising edge in edge mode, or high level in level mode of corresponding GPIO[31:0]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IPCR0</name>
          <displayName>IPCR0</displayName>
          <description>Interrupt Polarity Clear Register</description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>IPC</name>
              <description>
              set 1 for falling edge in edge mode, or low level in level mode of corresponding GPIO[31:0]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ISR0</name>
          <displayName>ISR0</displayName>
          <description>Interrupt Status Register</description>
          <addressOffset>0x34</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>IS</name>
              <description>
              Interrupt status. Write 1 will clear interrupt status of corresponding GPIO[31:0]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DIR1</name>
          <displayName>DIR1</displayName>
          <description>Data Input Register</description>
          <addressOffset>0x38</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>IN</name>
              <description>
              GPIO[63:32] input value
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DOR1</name>
          <displayName>DOR1</displayName>
          <description>Data Output Register</description>
          <addressOffset>0x3c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>OUT</name>
              <description>
              GPIO[63:32] output value if output enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DOER1</name>
          <displayName>DOER1</displayName>
          <description>Data Direction Register</description>
          <addressOffset>0x40</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>DOE</name>
              <description>
              GPIO[63:32] output enable
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>OESR1</name>
          <displayName>OESR1</displayName>
          <description>Data Output Enable Set Register</description>
          <addressOffset>0x44</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>OES</name>
              <description>
              set 1 to enable output of corresponding GPIO[63:32]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>OECR1</name>
          <displayName>OECR1</displayName>
          <description>Data Output Enable Clear Register</description>
          <addressOffset>0x48</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>OEC</name>
              <description>
              set 1 to disable output of corresponding GPIO[63:32]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IER1</name>
          <displayName>IER1</displayName>
          <description>Interrupt Enable  Register</description>
          <addressOffset>0x4c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>IER</name>
              <description>
              GPIO[63:32]  interrupt  enable
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IESR1</name>
          <displayName>IESR1</displayName>
          <description>Interrupt Enable Set Register</description>
          <addressOffset>0x50</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>IES</name>
              <description>
              set 1 to enable interrupt of corresponding GPIO[63:32]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IECR1</name>
          <displayName>IECR1</displayName>
          <description>Interrupt Enable Clear Register</description>
          <addressOffset>0x54</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>IEC</name>
              <description>
              set 1 to disable interrupt of corresponding GPIO[63:32]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ITR1</name>
          <displayName>ITR1</displayName>
          <description>Interrupt Type Register</description>
          <addressOffset>0x58</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>ITR</name>
              <description>
              GPIO[63:32]  interrupt  type
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ITSR1</name>
          <displayName>ITSR1</displayName>
          <description>Interrupt Type Set Register</description>
          <addressOffset>0x5c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>ITS</name>
              <description>
              set 1 for edge-sensitive interrupt mode of corresponding GPIO[63:32]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ITCR1</name>
          <displayName>ITCR1</displayName>
          <description>Interrupt Type Clear Register</description>
          <addressOffset>0x60</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>ITC</name>
              <description>
              set 1 for level-sensitive interrupt mode of corresponding GPIO[63:32]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IPSR1</name>
          <displayName>IPSR1</displayName>
          <description>Interrupt Polarity Set Register</description>
          <addressOffset>0x64</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>IPS</name>
              <description>
              set 1 for rising edge in edge mode, or high level in level mode of corresponding GPIO[63:32]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IPCR1</name>
          <displayName>IPCR1</displayName>
          <description>Interrupt Polarity Clear Register</description>
          <addressOffset>0x68</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>IPC</name>
              <description>
              set 1 for falling edge in edge mode, or low level in level mode of corresponding GPIO[63:32]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ISR1</name>
          <displayName>ISR1</displayName>
          <description>Interrupt Status Register</description>
          <addressOffset>0x6c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>IS</name>
              <description>
              Interrupt status. Write 1 will clear interrupt status of corresponding GPIO[63:32]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DIR2</name>
          <displayName>DIR2</displayName>
          <description>Data Input Register</description>
          <addressOffset>0x70</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>15</bitWidth>
            </field>
            <field>
              <name>IN</name>
              <description>
              GPIO[80:64] input value
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DOR2</name>
          <displayName>DOR2</displayName>
          <description>Data Output Register</description>
          <addressOffset>0x74</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>15</bitWidth>
            </field>
            <field>
              <name>OUT</name>
              <description>
              GPIO[80:64] output value if output enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DOER2</name>
          <displayName>DOER2</displayName>
          <description>Data Output Enable Register</description>
          <addressOffset>0x78</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>15</bitWidth>
            </field>
            <field>
              <name>DOE</name>
              <description>
              GPIO[80:64] output enable
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>OESR2</name>
          <displayName>OESR2</displayName>
          <description>Data Output Enable Set Register</description>
          <addressOffset>0x7c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>15</bitWidth>
            </field>
            <field>
              <name>OES</name>
              <description>
              set 1 to enable output of corresponding GPIO[80:64]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>OECR2</name>
          <displayName>OECR2</displayName>
          <description>Data Output Enable Clear Register</description>
          <addressOffset>0x80</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>15</bitWidth>
            </field>
            <field>
              <name>OEC</name>
              <description>
              set 1 to disable output of corresponding GPIO[80:64]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IER2</name>
          <displayName>IER2</displayName>
          <description>Interrupt Enable Register</description>
          <addressOffset>0x84</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>15</bitWidth>
            </field>
            <field>
              <name>IER</name>
              <description>
              GPIO[80:64]  interrupt  enable
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IESR2</name>
          <displayName>IESR2</displayName>
          <description>Interrupt Enable Set Register</description>
          <addressOffset>0x88</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>15</bitWidth>
            </field>
            <field>
              <name>IES</name>
              <description>
              set 1 to enable interrupt of corresponding GPIO[80:64]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IECR2</name>
          <displayName>IECR2</displayName>
          <description>Interrupt Enable Clear Register</description>
          <addressOffset>0x8c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>15</bitWidth>
            </field>
            <field>
              <name>IEC</name>
              <description>
              set 1 to disable interrupt of corresponding GPIO[80:64]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ITR2</name>
          <displayName>ITR2</displayName>
          <description>Interrupt Type Register</description>
          <addressOffset>0x90</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>15</bitWidth>
            </field>
            <field>
              <name>ITR</name>
              <description>
              GPIO[80:64]  interrupt  type
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ITSR2</name>
          <displayName>ITSR2</displayName>
          <description>Interrupt Type Set Register</description>
          <addressOffset>0x94</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>15</bitWidth>
            </field>
            <field>
              <name>ITS</name>
              <description>
              set 1 for edge-sensitive interrupt mode of corresponding GPIO[80:64]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ITCR2</name>
          <displayName>ITCR2</displayName>
          <description>Interrupt Type Clear Register</description>
          <addressOffset>0x98</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>15</bitWidth>
            </field>
            <field>
              <name>ITC</name>
              <description>
              set 1 for level-sensitive interrupt mode of corresponding GPIO[80:64]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IPSR2</name>
          <displayName>IPSR2</displayName>
          <description>Interrupt Polarity Set Register</description>
          <addressOffset>0x9c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>15</bitWidth>
            </field>
            <field>
              <name>IPS</name>
              <description>
              set 1 for rising edge in edge mode, or high level in level mode of corresponding GPIO[80:64]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IPCR2</name>
          <displayName>IPCR2</displayName>
          <description>Interrupt Polarity Clear Register</description>
          <addressOffset>0xa0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>15</bitWidth>
            </field>
            <field>
              <name>IPC</name>
              <description>
              set 1 for falling edge in edge mode, or low level in level mode of corresponding GPIO[80:64]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ISR2</name>
          <displayName>ISR2</displayName>
          <description>Interrupt Status Register</description>
          <addressOffset>0xa4</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>15</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Interrupt status. Write 1 will clear interrupt status of corresponding GPIO[80:64]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>SDMMC1</name>
      <description></description>
      <groupName>SDMMC</groupName>
      <baseAddress>0x50004000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>SAR</name>
          <displayName>SAR</displayName>
          <description>System Address/Argument2 Register</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>ADDR</name>
              <description>
              This register contains the physical system memory address used for DMA transfers or the second argument for the Auto CMD23. 
              (1) SDMA System Address 
              This register contains the system memory address for a SDMA transfer. 
              The SDMA transfer waits at the every boundary specified by BSR_SDMABDY. After SDMA has stopped, the next system address of the next contiguous data position cannot be read from this register but from NSAR. The Host Controller generates ISR_DMA Interrupt to request the Host Driver to update this register. The Host Driver sets the next system address of the next data position to this register. When the most upper byte of this register is written, the Host Controller restarts the SDMA transfer. 
              (2) Argument 2 
              This register is used with the Auto CMD23 to set a 32-bit block count value to the argument of the CMD23 while executing Auto CMD23. If Auto CMD23 is used with ADMA, the full 32-bit block count value can be used. If Auto CMD23 is used without AMDA, the available block count value is limited by BSR_BCNT. 65535 blocks is the maximum value in this case. 
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BSR</name>
          <displayName>BSR</displayName>
          <description>Block Size Register</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>BCNT</name>
              <description>
              Blocks Count For Current Transfer.
              This register is enabled when MULTIBLK is set to 1 and is valid only for multiple block transfers. Controller decrements the block count after each block transfer. Setting the block count to 0 results in no data blocks is transferred. 
              This register should be accessed only when no transaction is executing (i.e., after transactions are stopped). During data transfer, read operations on this register may return an invalid value and write operations are ignored. 
              When a suspend command is completed, the number of blocks yet to be transferred can be determined by reading this register. Before issuing a resume command, the Host Driver shall restore the previously saved block count. 
              FFFFh 65535 blocks 
              ... ... 
              0002h 2 blocks 
              0001h 1 block 
              0000h Stop Count
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SDMABDY</name>
              <description>
              Host SDMA Buffer Boundary.
              The large contiguous memory space may not be available in the virtual memory system. To perform long SDMA transfer, SDMA System Address register shall be updated at every system memory boundary during SDMA transfer. 
              These bits specify the size of contiguous buffer in the system memory. The SDMA transfer shall wait at the every boundary specified by these fields and the Controller generates the ISR_DMA Interrupt to request the Host Driver to update the SDMA System Address register. At the end of transfer, the Controller may issue or may not issue ISR_DMA Interrupt. In particular, ISR_DMA Interrupt shall not be issued after ISR_TC Interrupt is issued. 
              In case of this register is set to 0 (buffer size = 4K bytes), lower 12-bit of byte address points data in the contiguous buffer and the upper 20-bit points the location of the buffer in the system memory. The SDMA transfer stops when the Controller detects carry out of the address from bit 11 to 12. 
              ADMA does not use this register. 
              000b 4K bytes (Detects A11 carry out) 
              001b 8K bytes (Detects A12 carry out) 
              010b 16K Bytes (Detects A13 carry out) 
              011b 32K Bytes (Detects A14 carry out) 
              100b 64K bytes (Detects A15 carry out) 
              101b 128K Bytes (Detects A16 carry out) 
              110b 256K Bytes (Detects A17 carry out) 
              111b 512K Bytes (Detects A18 carry out) 
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>BSIZE</name>
              <description>
              Transfer Block Size
              This register specifies the block size of data transfers such as CMD17, CMD18, CMD24, CMD25, and CMD53. Usually set to 512 for SD and eMMC access.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ARG1</name>
          <displayName>ARG1</displayName>
          <description>Argument 1</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>ARG</name>
              <description>
              Command Argument 1 
              The SD command argument is specified as bit39-8 of Command-Format in the Physical Layer Specification. 
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CR1</name>
          <displayName>CR1</displayName>
          <description>Control and Command Register 1</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>CMDIDX</name>
              <description>
              Command Index 
              These bits shall be set to the command number (CMD0-63, ACMD0-63) that is specified in bits 45-40 of the Command-Format in the Physical Layer Specification and SDIO Card Specification. 
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>CMDTYPE</name>
              <description>
              Command Type
              There are three types of special commands: Suspend, Resume and Abort. These bits shall be set to 00b for all other commands. 
              (1) Suspend Command 
              If the Suspend command succeeds, the Controller shall assume the SD Bus has been released and that it is possible to issue the next command, which uses the DAT line. The Controller shall de-assert Read Wait for read transactions and stop checking busy for write transactions. The interrupt cycle shall start, in 4-bit mode. If the Suspend command fails, the Controller shall maintain its current state, and the Host Driver shall restart the transfer by setting CR2_CONTREQ. 
              (2) Resume Command 
              The Host Driver re-starts the data transfer. The Controller shall check for busy before starting write transfers. 
              (3) Abort Command 
              If this command is set when executing a read transfer, the Controller shall stop reads to the buffer. If this command is set when executing a write transfer, the Controller shall stop driving the DAT line. After issuing the Abort command, the Host Driver should issue a software reset. 
              11b Abort CMD12, CMD52 for writing "I/O Abort" in CCCR 
              10b Resume CMD52 for writing "Function Select" in CCCR 
              01b Suspend CMD52 for writing "Bus Suspend" in CCCR 
              00b Normal Other commands
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>DATAPRESENT</name>
              <description>
              Data Present Select 
              This bit is set to 1 to indicate that data is present and shall be transferred using the DAT line. It is set to 0 for the following: 
              (1) Commands using only CMD line (ex. CMD52). 
              (2) Commands with no data transfer but using busy signal on DAT[0] line (R1b or R5b ex. CMD38) 
              (3) Resume command 
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CHECKIDX</name>
              <description>
              Command Index Check Enable 
              If this bit is set to 1, the Controller shall check the Index field in the response to see if it has the same value as the command index. If it is not, it is reported as a Command Index Error. If this bit is set to 0, the Index field is not checked. 
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CHECKCRC</name>
              <description>
              Command CRC Check Enable 
              If this bit is set to 1, the Controller shall check the CRC field in the response. If an error is detected, it is reported as a Command CRC Error. If this bit is set to 0, the CRC field is not checked. The position of CRC field is determined according to the length of the response. 
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSPTYPE</name>
              <description>
              Response Type Select 
              00 No Response 
              01 Response Length 136 
              10 Response Length 48 
              11 Response Length 48 check Busy after
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>STREAMMODE</name>
              <description>
              Stream Mode Enable 
              The Host driver has to set this bit for MMC CMD11 / CMD20 Stream Read/Write Operations. 
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>MULTIBLK</name>
              <description>
              Multi / Single Block Select 
              This bit is set when issuing multiple-block transfer commands using DAT line. For any other commands, this bit shall be set to 0. If this bit is 0, it is not necessary to set BSR_BCNT
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DIR</name>
              <description>
              Data Transfer Direction Select 
              This bit defines the direction of DAT line data transfers. The bit is set to 1 to read data from the SD card to the Controller and it is set to 0 for all other commands. 
              1 Read (Card to Host) 
              0 Write (Host to Card) 
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>AUTOCMD</name>
              <description>
              Auto CMD Enable 
              This field determines use of auto command functions. 
              00b Auto Command Disabled 
              01b Auto CMD12 Enabled 
              10b Auto CMD23 Enabled 
              11b Reserved 
              There are two methods to stop Multiple-block read and write operation. 
              (1) Auto CMD12 Enable 
              When this field is set to 01b, the Controller issues CMD12 automatically when last block transfer is completed. Auto CMD12 error is indicated to CR4. 
              The Host Driver shall not set this bit if the command does not require CMD12. 
              (2) Auto CMD23 Enable 
              When this bit field is set to 10b, the Controller issues a CMD23 automatically before issuing a command specified. The following conditions are required to use the Auto CMD23. 
               A memory card that supports CMD23 (SCR[33]=1) 
               If DMA is used, it shall be ADMA. 
               Only when CMD18 or CMD25 is issued (Note, the Controller does not check command index.) 
              Auto CMD23 can be used with or without ADMA. The Controller issues a CMD23 first and then issues a command specified by CR1. If response errors of CMD23 are detected, the second command is not issued. A CMD23 error is indicated in CR4. 
              32-bit block count value for CMD23 is set to SAR. 
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>BCNTEN</name>
              <description>
              Block Count Enable 
              This bit is used to enable the Block Count register, which is only relevant for multiple block transfers. When this bit is 0, the Block Count register is disabled, which is useful in executing an infinite transfer. 
              If ADMA data transfer is more than 65535 blocks, this bit shall be set to 0. In this case, data transfer length is designated by Descriptor Table. 
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMAEN</name>
              <description>
              DMA Enable
              This bit enables DMA functionality. SDMA or ADMA mode can be selected by CR2_DMAMODE.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSP1</name>
          <displayName>RSP1</displayName>
          <description>Command Response 31~0</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSP</name>
              <description>
              Command Response [31:0]
              The Response Field indicates bit positions of "Responses" defined in the Physical Layer Spec. Most responses with a length of 48 (R[47:0]) have 32 bits of the response data (R[39:8]) stored in RSP1. Responses of type R1b (Auto CMD12 responses) and R1 (Auto CMD23 response) have response data bits R[39:8] stored in RSP4. Responses with length 136 (R[135:0]) have 120 bits of the response data (R[127:8]) stored in RSP1~RSP4. 
              To be able to read the response status efficiently, the Controller only stores part of the response data. This enables the Host Driver to read 32 bits of response data efficiently in one read cycle on a 32-bit bus system. Parts of the response, the Index field and the CRC, are checked by the Controller (as specified by CR1_CHECKIDX and the CR1_CHECKCRC) and generate an error interrupt if an error is detected. The bit range for the CRC check depends on the response length. If the response length is 48, the Controller shall check R[47:1], and if the response length is 136 the Controller shall check R[119:1]. 
              Since the Controller may have a multiple block data DAT line transfer executing concurrently with a CMD_wo_DAT command, the Controller stores the Auto CMD12 response in RSP4. The CMD_wo_DAT response is stored in RSP1. This allows the Controller to avoid overwriting the Auto CMD12 response with the CMD_wo_DAT and vice versa. 
              While executing Auto CMD23, the response of CMD23 is saved to RSP4 and the response of multiple-block read and write command is save to RSP1. The response error of CMD23 is indicated in CR4. 
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSP2</name>
          <displayName>RSP2</displayName>
          <description>Command Response 63~32</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSP</name>
              <description>
              Command Response [63:32]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSP3</name>
          <displayName>RSP3</displayName>
          <description>Command Response 95~64</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSP</name>
              <description>
              Command Response [95:64]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSP4</name>
          <displayName>RSP4</displayName>
          <description>Command Response 127~96</description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSP</name>
              <description>
              Command Response [127:96]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BUF</name>
          <displayName>BUF</displayName>
          <description>Buffer Data Port Register</description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              Buffer Data 
              The Controller buffer can be accessed through this 32-bit Data Port register. 
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SR</name>
          <displayName>SR</displayName>
          <description>Present State Register</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
            <field>
              <name>CMDLVL</name>
              <description>
              CMD Line Signal Level 
              This status is used to check the CMD line level to recover from errors, and for debugging.
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DATLVL</name>
              <description>
              DAT-DAT3 Line Signal Level 
              This status is used to check the DAT line level to recover from errors, and for debugging. This is especially useful in detecting the busy signal level from DAT [0].
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>BUFREN</name>
              <description>
              Buffer Read Enable 
              This status is used for non-DMA read transfers. 
              The Controller may implement multiple buffers to transfer data efficiently. This read only flag indicates that valid data exists in the host side buffer. If this bit is 1, readable data exists in the buffer. A change of this bit from 1 to 0 occurs when all the block data is read from the buffer. A change of this bit from 0 to 1 occurs when block data is ready in the buffer and generates ISR_BUFRRDY. 
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BUFWEN</name>
              <description>
              Buffer Write Enable
              This status is used for non-DMA write transfers.
              The Controller can implement multiple buffers to transfer data efficiently. This read only flag indicates if space is available for write data. If this bit is 1, data can be written to the buffer. A change of this bit from 1 to 0 occurs when all the block data is written to the buffer. A change of this bit from 0 to 1 occurs when top of block data can be written to the buffer and generates ISR_BUFWRDY. The Controller should neither set Buffer Write Enable nor generate ISR_BUFWRDY after the last block data is written to the Buffer Data Port Register.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RACTIVE</name>
              <description>
              Read Transfer Active 
              This status is used for detecting completion of a read transfer. 
              This bit is set to 1 for either of the following conditions: 
              (1) After the end bit of the readcommand. 
              (2) When read operation is restarted by writing 1 to CR2_CONTREQ. 
              This bit is cleared to 0 for either of the following conditions:
              (1) When the last data block as specified by block length is transferred to the System. 
              (2) In case of ADMA, end of read operation is designated by Descriptor Table. 
              (3) When all valid data blocks in the Controller have been transferred to the System and no current block transfers are being sent as a result of CR2_BLKGAPSTOP being set to 1. 
              A Transfer Complete interrupt is generated when this bit changes to 0.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>WACTIVE</name>
              <description>
              Write Transfer Active 
              This status indicates a write transfer is active. If this bit is 0, it means no valid write data exists in the Controller. 
              This bit is set in either of the following cases: 
               After the end bit of the write command. 
               When write operation is restarted by writing 1 to CR2_CONTREQ. 
              This bit is cleared in either of the following cases: 
               After getting the CRC status of the last data block as specified by the transfer count (Single and Multiple) In case of ADMA, transfer count is designated by Descriptor Table. 
               After getting the CRC status of any block where data transmission is about to be stopped by CR2_BLKGAPSTOP. 
              During a write transaction, ISR_BLKGAP is generated when this bit is changed to 0, as the result of CR2_BLKGAPSTOP begin set. This status is useful for the Host Driver in determining non DAT line commands can be issued during write busy. 
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>DATACTIVE</name>
              <description>
              DAT Line Active 
              This bit indicates whether one of the DAT line on SD Bus is in use. 
              (a) In the case of read transactions 
              This status indicates whether a read transfer is executing on the SD Bus. Changing this value from 1 to 0 generates ISR_BLKGAP, as the result of CR2_BLKGAPSTOP being set. 
              This bit shall be set in either of the following cases: 
              (1) After the end bit of the read command. 
              (2) When writing 1 to CR2_CONTREQ to restart a read transfer. 
              This bit shall be cleared in either of the following cases 
              (1) When the end bit of the last data block is sent from the SD Bus to the Controller. In case of ADMA, the last block is designated by the last transfer of Descriptor Table. 
              (2) When a read transfer is stopped at the block gap initiated by CR2_BLKGAPSTOP. 
              The Controller shall stop read operation at the start of the interrupt cycle of the next block gap by driving Read Wait or stopping SD clock. If the Read Wait signal is already driven (due to data buffer cannot receive data), the Controller can continue to stop read operation by driving the Read Wait signal. It is necessary to support Read Wait in order to use suspend / resume function. 
              (b) In the case of write transactions 
              This status indicates that a write transfer is executing on the SD Bus. Changing this value from 1 to 0 generate ISR_TC.
              This bit shall be set in either of the following cases: 
              (1) After the end bit of the write command. 
              (2) When writing 1 to CR2_CONTREQ to continue a write transfer. 
              This bit shall be cleared in either of the following cases: 
              (1) When the SD card releases write busy of the last data block. If SD card does not drive busy signal for 8 SD Clocks, the Controller shall consider the card drive "Not Busy". In case of ADMA, the last block is designated by the last transfer of Descriptor Table. 
              (2) When the SD card releases write busy prior to waiting for write transfer as a result of CR2_BLKGAPSTOP. 
              (c) Command with busy
              This status indicates whether a command indicates busy (ex. erase command for memory) is executing on the SD Bus. This bit is set after the end bit of the command with busy and cleared when busy is de-asserted. Changing this bit from 1 to 0 generate ISR_TC. 
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DATBUSY</name>
              <description>
              Command Inhibit (DAT) 
              This status bit is generated if either the DAT Line Active or the Read Transfer Active is set to 1. If this bit is 0, it indicates the Controller can issue the next SD Command. Commands with busy signal belong to Command Inhibit (DAT) (ex. R1b, R5b type). 
              Changing from 1 to 0 generates ISR_TC interrupt. 
              1 Cannot issue command which uses the DAT line 
              0 Can issue command which uses the DAT line
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CMDBUSY</name>
              <description>
              Command Inhibit (CMD) 
              If this bit is 0, it indicates the CMD line is not in use and the Controller can issue a SD Command using the CMD line. 
              This bit is set immediately after CR1 is written. This bit is cleared when the command response is received. Auto CMD12 and Auto CMD23 consist of two responses. In this case, this bit is not cleared by the response of CMD12 or CMD23 but cleared by the response of a read/write command. Status issuing Auto CMD12 is not read from this bit. So if a command is issued during Auto CMD12 operation, Controller shall manage to issue two commands: CMD12 and a command set by CR1. 
              Even if the DATBUSY is set to 1, commands using only the CMD line can be issued if this bit is 0. Changing from 1 to 0 generates ISR_CC Interrupt. 
              If the Controller cannot issue the command because of a command conflict error or because of Command Not Issued By Auto CMD12 Error, this bit shall remain 1 and the Command Complete is not set. 
              1 Cannot issue command 
              0 Can issue command using only CMD line
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CR2</name>
          <displayName>CR2</displayName>
          <description>Control Register 2</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
            <field>
              <name>BLKGAPIE</name>
              <description>
              Interrupt At Block Gap 
              This bit is valid only in 4-bit mode of the SDIO card and selects a sample point in the interrupt cycle. Setting to 1 enables interrupt detection at the block gap for a multiple block transfer. Setting to 0 disables interrupt detection during a multiple block transfer. If the SD card cannot signal an interrupt during a multiple block transfer, this bit should be set to 0. The Host Driver shall set this bit according to the CCCR of the SDIO card. 
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RWAITEN</name>
              <description>
              Read Wait Control 
              The read wait function is optional for SDIO cards. If the card supports read wait, set this bit to enable use of the read wait protocol to stop read data using the DAT2 line. Otherwise, the Controller has to stop the SD Clock to hold read data, which restricts commands generation. The Host Driver shall set this bit according to the CCCR of the SDIO card. 
              If the card does not support read wait, this bit shall never be set to 1 otherwise DAT line conflict may occur. If this bit is set to 0, Suspend/Resume cannot be supported.
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CONTREQ</name>
              <description>
              Continue Request
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BLKGAPSTOP</name>
              <description>
              Stop At Block Gap request
              This bit is used to stop executing read and write transaction at the next block gap for non-DMA, SDMA and ADMA transfers. The Host Driver shall leave this bit set to 1 until the Transfer Complete is set to 1. Clearing both Stop At Block Gap Request and Continue Request shall not cause the transaction to restart. The Controller shall stop read transfer by using Read Wait or stopping SD clock. In case of write transfers in which the Host Driver writes data to the Buffer Data Port register, the Host Driver shall set this bit after all block data is written. If this bit is set to 1, the Host Driver shall not write data to BUF. 
              1 Stop 
              0 Transfer
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>PPMODE</name>
              <description>
              CMD line output mode. Open drain mode should only be used when accessing eMMC device.
              1 Push Pull Mode 
              0 Open Drain Mode 
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>EXTWIDTH</name>
              <description>
              Extended Data Transfer Width 
              1 8-bit Bus Width 
              0 Bus Width is Selected by DATAWIDTH
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMAMODE</name>
              <description>
              DMA Select 
              One of supported DMA modes can be selected. DMA mode is enabled by CR1_DMAEN. 
              00b SDMA
              01b Reserved
              10b ADMA
              11b Reserved 
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>HSMODE</name>
              <description>
              Reserved for debug. Adjust output timing of CMD line and DAT lines. 
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DATWIDTH</name>
              <description>
              Data Transfer Width 
              This bit selects the data width of the Controller when EXTWIDTH is 0. The Host Driver shall set it to match the data width of the SD card. 
              1 4-bit mode 
              0 1-bit mode 
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CR3</name>
          <displayName>CR3</displayName>
          <description>Control Register 3</description>
          <addressOffset>0x2c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>RSTDAT</name>
              <description>
              Software Reset For DAT Line 
              Only part of data circuit is reset. DMA circuit is also reset. Will be cleared automatically. Because it takes some time to complete software reset, the SD Host Driver shall confirm that these bits are 0.
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSTCMD</name>
              <description>
              Software Reset For CMD Line 
              Only part of command circuit is reset. Will be cleared automatically. Because it takes some time to complete software reset, the SD Host Driver shall confirm that these bits are 0.
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RST</name>
              <description>
              This reset affects the entire Controller except for the card detection circuit. Register bits (except read-only bits) are cleared to 0. During its initialization, the Host Driver shall set this bit to 1 to reset the Controller. If this bit is set to 1, the host driver should issue reset command and reinitialize the SD card. Will be cleared automatically. Because it takes some time to complete software reset, the SD Host Driver shall confirm that these bits are 0.
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>DTOCNT</name>
              <description>
              Data Timeout Counter Value 
              This value determines the interval by which DAT line timeouts are detected. 
              Timeout period is defined as:
              1111b Reserved 
              1110b 4096*2^14 FCLK periods
              ............ ............ 
              0001b 4096*2^1 FCLK periods
              0000b 4096*2 FCLK periods
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>CLKDIVL</name>
              <description>
              CLK divider lower 8 bits
              10-bit CLKDIV is {CLKDIVU,CLKDIVL}. 
              If CLKDIV=0, CLK = FCLK. 
              If CLKDIV!=0,  CLK = FCLK/(2*CLKDIV).
              e.g. FCLK=192MHz, CLKDIV=240, then CLK frequency is 400KHz.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>CLKDIVU</name>
              <description>
              CLK divider upper 2 bits
              These bits expand clk divider to 10-bit. 
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>CLKEN</name>
              <description>
              SD Clock Enable
              0: SD clock disabled
              1: SD clock enabled
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>INTCLKEN</name>
              <description>
              Internal Clock Enable
              0: Internal clock disabled
              1: Internal clock enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ISR</name>
          <displayName>ISR</displayName>
          <description>Interrupt State Register</description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>ADMAERR</name>
              <description>
              ADMA Error 
              This bit is set when the Controller detects errors during ADMA based data transfer. The state of the ADMA at an error occurrence is saved in the AESR, In addition, the Controller generates this Interrupt when it detects invalid descriptor data (Valid=0). ADMA Error State in the ADMA Error Status indicates that an error occurs. The Host Driver may find that Valid bit is not set at the error descriptor. 
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ACERR</name>
              <description>
              Auto CMD Error 
              Auto CMD12 and Auto CMD23 use this error status. In case of Auto CMD12, this bit is set to 1, not only when the errors in Auto CMD12 occur but also when Auto CMD12 is not executed due to the previous command error. 
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DEBERR</name>
              <description>
              Data End Bit Error 
              Occurs either when detecting 0 at the end bit position of read data which uses the DAT line or at the end bit position of the CRC Status. 
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DCRCERR</name>
              <description>
              Data CRC Error 
              Occurs when detecting CRC error when transferring read data which uses the DAT line or when detecting the Write CRC status having a value of other than "010". 
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DTOERR</name>
              <description>
              Data Timeout Error 
              This bit is set when detecting one of following timeout conditions. 
               Busy timeout for R1b,R5b type 
               Busy timeout after Write CRC status 
               Write CRC Status timeout 
               Read Data timeout.
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IDXERR</name>
              <description>
              Command Index Error
              This bit is set if a Command Index error occurs in the command response.
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CEBERR</name>
              <description>
              Command End Bit Error 
              This bit is set when detecting that the end bit of a command response is 0.
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CCRCERR</name>
              <description>
              Command CRC Error 
              Command CRC Error is generated in two cases. 
              If a response is returned and the Command Timeout Error is set to 0 (indicating no timeout), this bit is set to 1 when detecting a CRC error in the command response. 
              The Controller detects a CMD line conflict by monitoring the CMD line when a command is issued. If the Controller drives the CMD line to 1 level, but detects 0 level on the CMD line at the next SD clock edge, then the Controller shall abort the command (Stop driving CMD line) and set this bit to 1. The Command Timeout Error shall also be set to 1 to distinguish CMD line conflict 
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTOERR</name>
              <description>
              Command Timeout Error
              This bit is set only if no response is returned within 64 SD clock cycles from the end bit of the command. If the Controller detects a CMD line conflict, in which case Command CRC Error shall also be set, this bit shall be set without waiting for 64 SD clock cycles because the command will be aborted by the Controller.
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ERR</name>
              <description>
              Error Interrupt 
              If any error bit (bit16~bit31) of ISR are set, then this bit is set. Therefore the Host Driver can efficiently test for an error by checking this bit first. This bit is read only.
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>CARD</name>
              <description>
              Card Interrupt 
              Writing this bit to 1 does not clear this bit. It is cleared by resetting the SD card interrupt factor.
              In 4-bit mode, the card interrupt signal is sampled during the interrupt cycle, so there are some sample delays between the interrupt signal from the SD card and the interrupt to the Host System. 
              When this status has been set and the Host Driver needs to start this interrupt service, ISER_CARDEN may be set to 0 in order to clear the card interrupt statuses latched in the Controller and to stop driving the interrupt signal to the Host System. After completion of the card interrupt service (It should reset interrupt factors in the SD card and the interrupt signal may not be asserted), set ISER_CARDEN to 1 and start sampling the interrupt signal again. 
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>BUFRRDY</name>
              <description>
              Buffer Read Ready 
              This status is set if the Buffer Read Enable changes from 0 to 1. Refer to SR_BUFREN register. 
              1 Ready to read buffer 
              0 Not ready to read buffer 
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BUFWRDY</name>
              <description>
              Buffer Write Ready
              This status is set if the Buffer Write Enable changes from 0 to 1. Refer to SR_BUFWEN register. 
              1 Ready to write buffer 
              0 Not ready to write buffer
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMA</name>
              <description>
              DMA Interrupt 
              This status is set if the Controller detects the Host SDMA Buffer boundary during transfer. Refer to BSR_SDMABDY. 
              In case of ADMA, by setting INT field in the descriptor table, Controller generates this interrupt. This interrupt shall not be generated after the Transfer Complete.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BLKGAP</name>
              <description>
              Block Gap Event 
              If CR2_BLKGAPSTOP is set, this bit is set when both a read / write transaction is stopped at a block gap. If CR2_BLKGAPSTOP is not set to 1, this bit is not set to 1. 
              (1) In the case of a Read Transaction 
              This bit is set at the falling edge of the DAT Line Active Status (When the transaction is stopped at SD Bus timing. The Read Wait shall be supported in order to use this function. 
              (2) Case of Write Transaction 
              This bit is set at the falling edge of Write Transfer Active Status (After getting CRC status at SD Bus timing). 
              1 Transaction stopped at block
              0 No Block Gap Event 
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TC</name>
              <description>
              Transfer Complete 
              This bit is set when a read / write transfer and a command with busy is completed. 
              (1) In the case of a Read Transaction
              This bit is set at the falling edge of Read Transfer Active Status. This interrupt is generated in two cases. The first is when a data transfer is completed as specified by data length (After the last data has been read to the Host System). The second is when data has stopped at the block gap and completed the data transfer by setting CR2_BLKGAPSTOP (After valid data has been read to the Host System). 
              (2) In the case of a Write Transaction
              This bit is set at the falling edge of the DAT Line Active Status. This interrupt is generated in two cases. The first is when the last data is written to the SD card as specified by data length and the busy signal released. The second is when data transfers are stopped at the block gap by setting CR2_BLKGAPSTOP and data transfers completed. (After valid data is written to the SD card and the busy signal released). 
              (3) In the case of a command with busy
              This bit is set when busy is de-asserted. Refer to SR_DATACTIVE and SR_CMDBUSY.
              Transfer Complete has higher priority than Data Timeout Error. If both bits are set to 1, execution of a command can be considered to be completed.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC</name>
              <description>
              Command Complete 
              This bit is set when get the end bit of the command response. Auto CMD12 and Auto CMD23 consist of two responses. Command Complete is not generated by the response of CMD12 or CMD23 but generated by the response of a read/write command. 
              Command Timeout Error has higher priority than Command Complete. If both bits are set to 1, it can be considered that the response was not received correctly.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ISER</name>
          <displayName>ISER</displayName>
          <description>Interrupt Status Enable Register</description>
          <addressOffset>0x34</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>ADMAERREN</name>
              <description>
              ADMA Error Status Enable 
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ACERREN</name>
              <description>
              Auto CMD Error Status Enable 
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DEBERREN</name>
              <description>
              Data End Bit Error Status Enable 
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DCRCERREN</name>
              <description>
              Data CRC Error Status Enable 
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DTOERREN</name>
              <description>
              Data Timeout Error Status Enable 
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IDXERREN</name>
              <description>
              Command Index Error Status Enable
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CEBERREN</name>
              <description>
              Command End Bit Error Status Enable 
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CCRCERREN</name>
              <description>
              Command CRC Error Status Enable 
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTOERREN</name>
              <description>
              Command Timeout Error Status Enable 
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
            <field>
              <name>CARDEN</name>
              <description>
              Card Interrupt Status Enable 
              If this bit is set to 0, the Controller shall clear interrupt request to the System. The Card Interrupt detection is stopped when this bit is cleared and restarted when this bit is set to 1. The Host Driver may clear the Card Interrupt Status Enable before servicing the Card Interrupt and may set this bit again after all interrupt requests from the card are cleared to prevent inadvertent interrupts.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>BUFRRDYEN</name>
              <description>
              Buffer Read Ready Status Enable 
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BUFWRDYEN</name>
              <description>
              Buffer Write Ready Status Enable 
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMAEN</name>
              <description>
              DMA Interrupt Status Enable 
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BLKGAPEN</name>
              <description>
              Block Gap Event Status Enable 
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCEN</name>
              <description>
              Transfer Complete Status Enable 
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CCEN</name>
              <description>
              Command Complete Status Enable 
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IER</name>
          <displayName>IER</displayName>
          <description>Interrupt Enable Register</description>
          <addressOffset>0x38</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>ADMAERRIE</name>
              <description>
              ADMA Error Interrupt Enable 
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ACERRIE</name>
              <description>
              Auto CMD Error Interrupt Enable 
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DEBERRIE</name>
              <description>
              Data End Bit Error Interrupt Enable 
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DCRCERRIE</name>
              <description>
              Data CRC Error Interrupt Enable 
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DTOERRIE</name>
              <description>
              Data Timeout Error Interrupt Enable 
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IDXERRIE</name>
              <description>
              Command Index Error Interrupt Enable
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CEBERRIE</name>
              <description>
              Command End Bit Error Interrupt Enable 
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CCRCERRIE</name>
              <description>
              Command CRC Error Interrupt Enable 
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTOERRIE</name>
              <description>
              Command Timeout Error Interrupt Enable 
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
            <field>
              <name>CARDIE</name>
              <description>
              Card Interrupt Interrupt Enable 
              If this bit is set to 0, the Controller shall clear interrupt request to the System. The Card Interrupt detection is stopped when this bit is cleared and restarted when this bit is set to 1. The Host Driver may clear the Card Interrupt Status Enable before servicing the Card Interrupt and may set this bit again after all interrupt requests from the card are cleared to prevent inadvertent interrupts.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>BUFRRDYIE</name>
              <description>
              Buffer Read Ready Interrupt Enable 
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BUFWRDYIE</name>
              <description>
              Buffer Write Ready Interrupt Enable 
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMAIE</name>
              <description>
              DMA Interrupt Interrupt Enable 
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BLKGAPIE</name>
              <description>
              Block Gap Event Interrupt Enable 
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIE</name>
              <description>
              Transfer Complete Interrupt Enable 
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CCIE</name>
              <description>
              Command Complete Interrupt Enable 
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CR4</name>
          <displayName>CR4</displayName>
          <description>Control Register 4</description>
          <addressOffset>0x3c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>13</bitWidth>
            </field>
            <field>
              <name>UHSMODE</name>
              <description>
              UHS Mode Select 
              100b DDR
              others SDR
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>CNIERR</name>
              <description>
              Command Not Issued By Auto CMD12 Error 
              Setting this bit to 1 means CMD_wo_DAT is not executed due to an Auto CMD12 Error in this register. 
              This bit is set to 0 when Auto CMD Error is generated by Auto CMD23. 
              1 Not Issued 
              0 No Error 
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>ACIDXERR</name>
              <description>
              Auto CMD Index Error 
              This bit is set if the Command Index error occurs in response to a command
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ACEBERR</name>
              <description>
              Auto CMD End Bit Error 
              This bit is set when detecting that the end bit of command response is 0.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ACCRCERR</name>
              <description>
              Auto CMD CRC Error 
              This bit is set when detecting a CRC error in the command response. 
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ACTOERR</name>
              <description>
              Auto CMD Timeout Error 
              This bit is set if no response is returned within 64 SDCLK cycles from the end bit of command. If this bit is set to1, the other error status bits are meaningless. 
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ACNE</name>
              <description>
              Auto CMD12 Not Executed 
              If memory multiple block data transfer is not started due to command error, this bit is not set because it is not necessary to issue Auto CMD12. Setting this bit to 1 means the Controller cannot issue Auto CMD12 to stop memory multiple block data transfer due to some error. If this bit is set to 1, other error status bits are meaningless. 
              This bit is set to 0 when Auto CMD Error is generated by Auto CMD23. 
              1 Not Executed 
              0 Executed
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD3</name>
          <displayName>RSVD3</displayName>
          <description></description>
          <addressOffset>0x40</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>AESR</name>
          <displayName>AESR</displayName>
          <description>ADMA Error Status Register</description>
          <addressOffset>0x54</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>29</bitWidth>
            </field>
            <field>
              <name>LENERR</name>
              <description>
              ADMA Length Mismatch Error 
              This error occurs in the following 2 cases. 
              (1) While CR1_BCNTEN being set, the total data length specified by the Descriptor table is different from that specified by the Block Count and Block Length. 
              (2) Total data length cannot be divided by the block length. 
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ERRSTATE</name>
              <description>
              ADMA Error State 
              This field indicates the state of ADMA when error is occurred during ADMA data transfer. This field never indicates "10" because ADMA never stops in this state. 
              00 ST_STOP (Stop DMA) Points next of the error descriptor 
              01 ST_FDS (Fetch Descriptor) Points the error descriptor 
              10 Never set this state (Not used) 
              11 ST_TFR (Transfer Data) Points the next of the error descriptor 
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ASAR</name>
          <displayName>ASAR</displayName>
          <description>ADMA System Address Register</description>
          <addressOffset>0x58</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>ADDR</name>
              <description>
              ADMA System Address
              This register holds byte address of executing command of the Descriptor table.
              At the start of ADMA, the Host Driver shall set start address of the Descriptor table. The ADMA increments this register address, which points to next line, when every fetching a Descriptor line. When the ADMA Error Interrupt is generated, this register shall hold valid Descriptor address depending on the ADMA state. The Host Driver shall program Descriptor Table on 32-bit boundary and set 32-bit boundary address to this register. Lower 2-bit of this register is ignored and assumes it to be 00b. 
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>NSAR</name>
          <displayName>NSAR</displayName>
          <description>Next System Address Register</description>
          <addressOffset>0x5c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>ADDR</name>
              <description>
              This register contains next physical system memory address used for SDMA transfer.
              When the Host Controller stops a SDMA transfer, this register shall point to the system address of the next contiguous data position. It can be accessed only if no transaction is executing (i.e., after a transaction has stopped). Read operations during transfers may return an invalid value. After SDMA has stopped, the next system address of the next contiguous data position can be read from this register. 
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD2</name>
          <displayName>RSVD2</displayName>
          <description></description>
          <addressOffset>0x60</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>ABSR</name>
          <displayName>ABSR</displayName>
          <description> AHB Burst Size Register</description>
          <addressOffset>0xec</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>25</bitWidth>
            </field>
            <field>
              <name>BSIZE</name>
              <description>
              AHB Master Burst Size Register 
              AHB Master performs Burst operations as per this register. 
              0  Disabled 
              1  Enabled
              Bit 00 INCR4 
              Bit 01 INCR8 
              Bit 02 INCR16 
              Bit 03 INCR 
              Bit 04 WRAP4 
              Bit 05 WRAP8 
              Bit 06 WRAP16
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD1</name>
          <displayName>RSVD1</displayName>
          <description></description>
          <addressOffset>0xF0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>SCR</name>
          <displayName>SCR</displayName>
          <description>Sampling Clock Register</description>
          <addressOffset>0xf4</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>SEL</name>
              <description>
              select sampling clock source (delay line input)
              0: use internal clock
              1: use loopback clock
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DLY</name>
              <description>
              Stages of delay line for sampling clock
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>SDMMC2</name>
      <description></description>
      <groupName>SDMMC</groupName>
      <baseAddress>0x50005000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>SAR</name>
          <displayName>SAR</displayName>
          <description>System Address/Argument2 Register</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>ADDR</name>
              <description>
              This register contains the physical system memory address used for DMA transfers or the second argument for the Auto CMD23. 
              (1) SDMA System Address 
              This register contains the system memory address for a SDMA transfer. 
              The SDMA transfer waits at the every boundary specified by BSR_SDMABDY. After SDMA has stopped, the next system address of the next contiguous data position cannot be read from this register but from NSAR. The Host Controller generates ISR_DMA Interrupt to request the Host Driver to update this register. The Host Driver sets the next system address of the next data position to this register. When the most upper byte of this register is written, the Host Controller restarts the SDMA transfer. 
              (2) Argument 2 
              This register is used with the Auto CMD23 to set a 32-bit block count value to the argument of the CMD23 while executing Auto CMD23. If Auto CMD23 is used with ADMA, the full 32-bit block count value can be used. If Auto CMD23 is used without AMDA, the available block count value is limited by BSR_BCNT. 65535 blocks is the maximum value in this case. 
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BSR</name>
          <displayName>BSR</displayName>
          <description>Block Size Register</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>BCNT</name>
              <description>
              Blocks Count For Current Transfer.
              This register is enabled when MULTIBLK is set to 1 and is valid only for multiple block transfers. Controller decrements the block count after each block transfer. Setting the block count to 0 results in no data blocks is transferred. 
              This register should be accessed only when no transaction is executing (i.e., after transactions are stopped). During data transfer, read operations on this register may return an invalid value and write operations are ignored. 
              When a suspend command is completed, the number of blocks yet to be transferred can be determined by reading this register. Before issuing a resume command, the Host Driver shall restore the previously saved block count. 
              FFFFh 65535 blocks 
              ... ... 
              0002h 2 blocks 
              0001h 1 block 
              0000h Stop Count
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SDMABDY</name>
              <description>
              Host SDMA Buffer Boundary.
              The large contiguous memory space may not be available in the virtual memory system. To perform long SDMA transfer, SDMA System Address register shall be updated at every system memory boundary during SDMA transfer. 
              These bits specify the size of contiguous buffer in the system memory. The SDMA transfer shall wait at the every boundary specified by these fields and the Controller generates the ISR_DMA Interrupt to request the Host Driver to update the SDMA System Address register. At the end of transfer, the Controller may issue or may not issue ISR_DMA Interrupt. In particular, ISR_DMA Interrupt shall not be issued after ISR_TC Interrupt is issued. 
              In case of this register is set to 0 (buffer size = 4K bytes), lower 12-bit of byte address points data in the contiguous buffer and the upper 20-bit points the location of the buffer in the system memory. The SDMA transfer stops when the Controller detects carry out of the address from bit 11 to 12. 
              ADMA does not use this register. 
              000b 4K bytes (Detects A11 carry out) 
              001b 8K bytes (Detects A12 carry out) 
              010b 16K Bytes (Detects A13 carry out) 
              011b 32K Bytes (Detects A14 carry out) 
              100b 64K bytes (Detects A15 carry out) 
              101b 128K Bytes (Detects A16 carry out) 
              110b 256K Bytes (Detects A17 carry out) 
              111b 512K Bytes (Detects A18 carry out) 
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>BSIZE</name>
              <description>
              Transfer Block Size
              This register specifies the block size of data transfers such as CMD17, CMD18, CMD24, CMD25, and CMD53. Usually set to 512 for SD and eMMC access.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ARG1</name>
          <displayName>ARG1</displayName>
          <description>Argument 1</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>ARG</name>
              <description>
              Command Argument 1 
              The SD command argument is specified as bit39-8 of Command-Format in the Physical Layer Specification. 
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CR1</name>
          <displayName>CR1</displayName>
          <description>Control and Command Register 1</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>CMDIDX</name>
              <description>
              Command Index 
              These bits shall be set to the command number (CMD0-63, ACMD0-63) that is specified in bits 45-40 of the Command-Format in the Physical Layer Specification and SDIO Card Specification. 
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>CMDTYPE</name>
              <description>
              Command Type
              There are three types of special commands: Suspend, Resume and Abort. These bits shall be set to 00b for all other commands. 
              (1) Suspend Command 
              If the Suspend command succeeds, the Controller shall assume the SD Bus has been released and that it is possible to issue the next command, which uses the DAT line. The Controller shall de-assert Read Wait for read transactions and stop checking busy for write transactions. The interrupt cycle shall start, in 4-bit mode. If the Suspend command fails, the Controller shall maintain its current state, and the Host Driver shall restart the transfer by setting CR2_CONTREQ. 
              (2) Resume Command 
              The Host Driver re-starts the data transfer. The Controller shall check for busy before starting write transfers. 
              (3) Abort Command 
              If this command is set when executing a read transfer, the Controller shall stop reads to the buffer. If this command is set when executing a write transfer, the Controller shall stop driving the DAT line. After issuing the Abort command, the Host Driver should issue a software reset. 
              11b Abort CMD12, CMD52 for writing "I/O Abort" in CCCR 
              10b Resume CMD52 for writing "Function Select" in CCCR 
              01b Suspend CMD52 for writing "Bus Suspend" in CCCR 
              00b Normal Other commands
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>DATAPRESENT</name>
              <description>
              Data Present Select 
              This bit is set to 1 to indicate that data is present and shall be transferred using the DAT line. It is set to 0 for the following: 
              (1) Commands using only CMD line (ex. CMD52). 
              (2) Commands with no data transfer but using busy signal on DAT[0] line (R1b or R5b ex. CMD38) 
              (3) Resume command 
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CHECKIDX</name>
              <description>
              Command Index Check Enable 
              If this bit is set to 1, the Controller shall check the Index field in the response to see if it has the same value as the command index. If it is not, it is reported as a Command Index Error. If this bit is set to 0, the Index field is not checked. 
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CHECKCRC</name>
              <description>
              Command CRC Check Enable 
              If this bit is set to 1, the Controller shall check the CRC field in the response. If an error is detected, it is reported as a Command CRC Error. If this bit is set to 0, the CRC field is not checked. The position of CRC field is determined according to the length of the response. 
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSPTYPE</name>
              <description>
              Response Type Select 
              00 No Response 
              01 Response Length 136 
              10 Response Length 48 
              11 Response Length 48 check Busy after
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>STREAMMODE</name>
              <description>
              Stream Mode Enable 
              The Host driver has to set this bit for MMC CMD11 / CMD20 Stream Read/Write Operations. 
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>MULTIBLK</name>
              <description>
              Multi / Single Block Select 
              This bit is set when issuing multiple-block transfer commands using DAT line. For any other commands, this bit shall be set to 0. If this bit is 0, it is not necessary to set BSR_BCNT
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DIR</name>
              <description>
              Data Transfer Direction Select 
              This bit defines the direction of DAT line data transfers. The bit is set to 1 to read data from the SD card to the Controller and it is set to 0 for all other commands. 
              1 Read (Card to Host) 
              0 Write (Host to Card) 
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>AUTOCMD</name>
              <description>
              Auto CMD Enable 
              This field determines use of auto command functions. 
              00b Auto Command Disabled 
              01b Auto CMD12 Enabled 
              10b Auto CMD23 Enabled 
              11b Reserved 
              There are two methods to stop Multiple-block read and write operation. 
              (1) Auto CMD12 Enable 
              When this field is set to 01b, the Controller issues CMD12 automatically when last block transfer is completed. Auto CMD12 error is indicated to CR4. 
              The Host Driver shall not set this bit if the command does not require CMD12. 
              (2) Auto CMD23 Enable 
              When this bit field is set to 10b, the Controller issues a CMD23 automatically before issuing a command specified. The following conditions are required to use the Auto CMD23. 
               A memory card that supports CMD23 (SCR[33]=1) 
               If DMA is used, it shall be ADMA. 
               Only when CMD18 or CMD25 is issued (Note, the Controller does not check command index.) 
              Auto CMD23 can be used with or without ADMA. The Controller issues a CMD23 first and then issues a command specified by CR1. If response errors of CMD23 are detected, the second command is not issued. A CMD23 error is indicated in CR4. 
              32-bit block count value for CMD23 is set to SAR. 
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>BCNTEN</name>
              <description>
              Block Count Enable 
              This bit is used to enable the Block Count register, which is only relevant for multiple block transfers. When this bit is 0, the Block Count register is disabled, which is useful in executing an infinite transfer. 
              If ADMA data transfer is more than 65535 blocks, this bit shall be set to 0. In this case, data transfer length is designated by Descriptor Table. 
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMAEN</name>
              <description>
              DMA Enable
              This bit enables DMA functionality. SDMA or ADMA mode can be selected by CR2_DMAMODE.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSP1</name>
          <displayName>RSP1</displayName>
          <description>Command Response 31~0</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSP</name>
              <description>
              Command Response [31:0]
              The Response Field indicates bit positions of "Responses" defined in the Physical Layer Spec. Most responses with a length of 48 (R[47:0]) have 32 bits of the response data (R[39:8]) stored in RSP1. Responses of type R1b (Auto CMD12 responses) and R1 (Auto CMD23 response) have response data bits R[39:8] stored in RSP4. Responses with length 136 (R[135:0]) have 120 bits of the response data (R[127:8]) stored in RSP1~RSP4. 
              To be able to read the response status efficiently, the Controller only stores part of the response data. This enables the Host Driver to read 32 bits of response data efficiently in one read cycle on a 32-bit bus system. Parts of the response, the Index field and the CRC, are checked by the Controller (as specified by CR1_CHECKIDX and the CR1_CHECKCRC) and generate an error interrupt if an error is detected. The bit range for the CRC check depends on the response length. If the response length is 48, the Controller shall check R[47:1], and if the response length is 136 the Controller shall check R[119:1]. 
              Since the Controller may have a multiple block data DAT line transfer executing concurrently with a CMD_wo_DAT command, the Controller stores the Auto CMD12 response in RSP4. The CMD_wo_DAT response is stored in RSP1. This allows the Controller to avoid overwriting the Auto CMD12 response with the CMD_wo_DAT and vice versa. 
              While executing Auto CMD23, the response of CMD23 is saved to RSP4 and the response of multiple-block read and write command is save to RSP1. The response error of CMD23 is indicated in CR4. 
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSP2</name>
          <displayName>RSP2</displayName>
          <description>Command Response 63~32</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSP</name>
              <description>
              Command Response [63:32]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSP3</name>
          <displayName>RSP3</displayName>
          <description>Command Response 95~64</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSP</name>
              <description>
              Command Response [95:64]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSP4</name>
          <displayName>RSP4</displayName>
          <description>Command Response 127~96</description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSP</name>
              <description>
              Command Response [127:96]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BUF</name>
          <displayName>BUF</displayName>
          <description>Buffer Data Port Register</description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              Buffer Data 
              The Controller buffer can be accessed through this 32-bit Data Port register. 
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SR</name>
          <displayName>SR</displayName>
          <description>Present State Register</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
            <field>
              <name>CMDLVL</name>
              <description>
              CMD Line Signal Level 
              This status is used to check the CMD line level to recover from errors, and for debugging.
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DATLVL</name>
              <description>
              DAT-DAT3 Line Signal Level 
              This status is used to check the DAT line level to recover from errors, and for debugging. This is especially useful in detecting the busy signal level from DAT [0].
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>BUFREN</name>
              <description>
              Buffer Read Enable 
              This status is used for non-DMA read transfers. 
              The Controller may implement multiple buffers to transfer data efficiently. This read only flag indicates that valid data exists in the host side buffer. If this bit is 1, readable data exists in the buffer. A change of this bit from 1 to 0 occurs when all the block data is read from the buffer. A change of this bit from 0 to 1 occurs when block data is ready in the buffer and generates ISR_BUFRRDY. 
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BUFWEN</name>
              <description>
              Buffer Write Enable
              This status is used for non-DMA write transfers.
              The Controller can implement multiple buffers to transfer data efficiently. This read only flag indicates if space is available for write data. If this bit is 1, data can be written to the buffer. A change of this bit from 1 to 0 occurs when all the block data is written to the buffer. A change of this bit from 0 to 1 occurs when top of block data can be written to the buffer and generates ISR_BUFWRDY. The Controller should neither set Buffer Write Enable nor generate ISR_BUFWRDY after the last block data is written to the Buffer Data Port Register.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RACTIVE</name>
              <description>
              Read Transfer Active 
              This status is used for detecting completion of a read transfer. 
              This bit is set to 1 for either of the following conditions: 
              (1) After the end bit of the readcommand. 
              (2) When read operation is restarted by writing 1 to CR2_CONTREQ. 
              This bit is cleared to 0 for either of the following conditions:
              (1) When the last data block as specified by block length is transferred to the System. 
              (2) In case of ADMA, end of read operation is designated by Descriptor Table. 
              (3) When all valid data blocks in the Controller have been transferred to the System and no current block transfers are being sent as a result of CR2_BLKGAPSTOP being set to 1. 
              A Transfer Complete interrupt is generated when this bit changes to 0.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>WACTIVE</name>
              <description>
              Write Transfer Active 
              This status indicates a write transfer is active. If this bit is 0, it means no valid write data exists in the Controller. 
              This bit is set in either of the following cases: 
               After the end bit of the write command. 
               When write operation is restarted by writing 1 to CR2_CONTREQ. 
              This bit is cleared in either of the following cases: 
               After getting the CRC status of the last data block as specified by the transfer count (Single and Multiple) In case of ADMA, transfer count is designated by Descriptor Table. 
               After getting the CRC status of any block where data transmission is about to be stopped by CR2_BLKGAPSTOP. 
              During a write transaction, ISR_BLKGAP is generated when this bit is changed to 0, as the result of CR2_BLKGAPSTOP begin set. This status is useful for the Host Driver in determining non DAT line commands can be issued during write busy. 
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>DATACTIVE</name>
              <description>
              DAT Line Active 
              This bit indicates whether one of the DAT line on SD Bus is in use. 
              (a) In the case of read transactions 
              This status indicates whether a read transfer is executing on the SD Bus. Changing this value from 1 to 0 generates ISR_BLKGAP, as the result of CR2_BLKGAPSTOP being set. 
              This bit shall be set in either of the following cases: 
              (1) After the end bit of the read command. 
              (2) When writing 1 to CR2_CONTREQ to restart a read transfer. 
              This bit shall be cleared in either of the following cases 
              (1) When the end bit of the last data block is sent from the SD Bus to the Controller. In case of ADMA, the last block is designated by the last transfer of Descriptor Table. 
              (2) When a read transfer is stopped at the block gap initiated by CR2_BLKGAPSTOP. 
              The Controller shall stop read operation at the start of the interrupt cycle of the next block gap by driving Read Wait or stopping SD clock. If the Read Wait signal is already driven (due to data buffer cannot receive data), the Controller can continue to stop read operation by driving the Read Wait signal. It is necessary to support Read Wait in order to use suspend / resume function. 
              (b) In the case of write transactions 
              This status indicates that a write transfer is executing on the SD Bus. Changing this value from 1 to 0 generate ISR_TC.
              This bit shall be set in either of the following cases: 
              (1) After the end bit of the write command. 
              (2) When writing 1 to CR2_CONTREQ to continue a write transfer. 
              This bit shall be cleared in either of the following cases: 
              (1) When the SD card releases write busy of the last data block. If SD card does not drive busy signal for 8 SD Clocks, the Controller shall consider the card drive "Not Busy". In case of ADMA, the last block is designated by the last transfer of Descriptor Table. 
              (2) When the SD card releases write busy prior to waiting for write transfer as a result of CR2_BLKGAPSTOP. 
              (c) Command with busy
              This status indicates whether a command indicates busy (ex. erase command for memory) is executing on the SD Bus. This bit is set after the end bit of the command with busy and cleared when busy is de-asserted. Changing this bit from 1 to 0 generate ISR_TC. 
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DATBUSY</name>
              <description>
              Command Inhibit (DAT) 
              This status bit is generated if either the DAT Line Active or the Read Transfer Active is set to 1. If this bit is 0, it indicates the Controller can issue the next SD Command. Commands with busy signal belong to Command Inhibit (DAT) (ex. R1b, R5b type). 
              Changing from 1 to 0 generates ISR_TC interrupt. 
              1 Cannot issue command which uses the DAT line 
              0 Can issue command which uses the DAT line
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CMDBUSY</name>
              <description>
              Command Inhibit (CMD) 
              If this bit is 0, it indicates the CMD line is not in use and the Controller can issue a SD Command using the CMD line. 
              This bit is set immediately after CR1 is written. This bit is cleared when the command response is received. Auto CMD12 and Auto CMD23 consist of two responses. In this case, this bit is not cleared by the response of CMD12 or CMD23 but cleared by the response of a read/write command. Status issuing Auto CMD12 is not read from this bit. So if a command is issued during Auto CMD12 operation, Controller shall manage to issue two commands: CMD12 and a command set by CR1. 
              Even if the DATBUSY is set to 1, commands using only the CMD line can be issued if this bit is 0. Changing from 1 to 0 generates ISR_CC Interrupt. 
              If the Controller cannot issue the command because of a command conflict error or because of Command Not Issued By Auto CMD12 Error, this bit shall remain 1 and the Command Complete is not set. 
              1 Cannot issue command 
              0 Can issue command using only CMD line
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CR2</name>
          <displayName>CR2</displayName>
          <description>Control Register 2</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
            <field>
              <name>BLKGAPIE</name>
              <description>
              Interrupt At Block Gap 
              This bit is valid only in 4-bit mode of the SDIO card and selects a sample point in the interrupt cycle. Setting to 1 enables interrupt detection at the block gap for a multiple block transfer. Setting to 0 disables interrupt detection during a multiple block transfer. If the SD card cannot signal an interrupt during a multiple block transfer, this bit should be set to 0. The Host Driver shall set this bit according to the CCCR of the SDIO card. 
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RWAITEN</name>
              <description>
              Read Wait Control 
              The read wait function is optional for SDIO cards. If the card supports read wait, set this bit to enable use of the read wait protocol to stop read data using the DAT2 line. Otherwise, the Controller has to stop the SD Clock to hold read data, which restricts commands generation. The Host Driver shall set this bit according to the CCCR of the SDIO card. 
              If the card does not support read wait, this bit shall never be set to 1 otherwise DAT line conflict may occur. If this bit is set to 0, Suspend/Resume cannot be supported.
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CONTREQ</name>
              <description>
              Continue Request
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BLKGAPSTOP</name>
              <description>
              Stop At Block Gap request
              This bit is used to stop executing read and write transaction at the next block gap for non-DMA, SDMA and ADMA transfers. The Host Driver shall leave this bit set to 1 until the Transfer Complete is set to 1. Clearing both Stop At Block Gap Request and Continue Request shall not cause the transaction to restart. The Controller shall stop read transfer by using Read Wait or stopping SD clock. In case of write transfers in which the Host Driver writes data to the Buffer Data Port register, the Host Driver shall set this bit after all block data is written. If this bit is set to 1, the Host Driver shall not write data to BUF. 
              1 Stop 
              0 Transfer
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>PPMODE</name>
              <description>
              CMD line output mode. Open drain mode should only be used when accessing eMMC device.
              1 Push Pull Mode 
              0 Open Drain Mode 
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>EXTWIDTH</name>
              <description>
              Extended Data Transfer Width 
              1 8-bit Bus Width 
              0 Bus Width is Selected by DATAWIDTH
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMAMODE</name>
              <description>
              DMA Select 
              One of supported DMA modes can be selected. DMA mode is enabled by CR1_DMAEN. 
              00b SDMA
              01b Reserved
              10b ADMA
              11b Reserved 
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>HSMODE</name>
              <description>
              Reserved for debug. Adjust output timing of CMD line and DAT lines. 
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DATWIDTH</name>
              <description>
              Data Transfer Width 
              This bit selects the data width of the Controller when EXTWIDTH is 0. The Host Driver shall set it to match the data width of the SD card. 
              1 4-bit mode 
              0 1-bit mode 
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CR3</name>
          <displayName>CR3</displayName>
          <description>Control Register 3</description>
          <addressOffset>0x2c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>RSTDAT</name>
              <description>
              Software Reset For DAT Line 
              Only part of data circuit is reset. DMA circuit is also reset. Will be cleared automatically. Because it takes some time to complete software reset, the SD Host Driver shall confirm that these bits are 0.
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSTCMD</name>
              <description>
              Software Reset For CMD Line 
              Only part of command circuit is reset. Will be cleared automatically. Because it takes some time to complete software reset, the SD Host Driver shall confirm that these bits are 0.
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RST</name>
              <description>
              This reset affects the entire Controller except for the card detection circuit. Register bits (except read-only bits) are cleared to 0. During its initialization, the Host Driver shall set this bit to 1 to reset the Controller. If this bit is set to 1, the host driver should issue reset command and reinitialize the SD card. Will be cleared automatically. Because it takes some time to complete software reset, the SD Host Driver shall confirm that these bits are 0.
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>DTOCNT</name>
              <description>
              Data Timeout Counter Value 
              This value determines the interval by which DAT line timeouts are detected. 
              Timeout period is defined as:
              1111b Reserved 
              1110b 4096*2^14 FCLK periods
              ............ ............ 
              0001b 4096*2^1 FCLK periods
              0000b 4096*2 FCLK periods
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>CLKDIVL</name>
              <description>
              CLK divider lower 8 bits
              10-bit CLKDIV is {CLKDIVU,CLKDIVL}. 
              If CLKDIV=0, CLK = FCLK. 
              If CLKDIV!=0,  CLK = FCLK/(2*CLKDIV).
              e.g. FCLK=192MHz, CLKDIV=240, then CLK frequency is 400KHz.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>CLKDIVU</name>
              <description>
              CLK divider upper 2 bits
              These bits expand clk divider to 10-bit. 
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>CLKEN</name>
              <description>
              SD Clock Enable
              0: SD clock disabled
              1: SD clock enabled
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>INTCLKEN</name>
              <description>
              Internal Clock Enable
              0: Internal clock disabled
              1: Internal clock enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ISR</name>
          <displayName>ISR</displayName>
          <description>Interrupt State Register</description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>ADMAERR</name>
              <description>
              ADMA Error 
              This bit is set when the Controller detects errors during ADMA based data transfer. The state of the ADMA at an error occurrence is saved in the AESR, In addition, the Controller generates this Interrupt when it detects invalid descriptor data (Valid=0). ADMA Error State in the ADMA Error Status indicates that an error occurs. The Host Driver may find that Valid bit is not set at the error descriptor. 
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ACERR</name>
              <description>
              Auto CMD Error 
              Auto CMD12 and Auto CMD23 use this error status. In case of Auto CMD12, this bit is set to 1, not only when the errors in Auto CMD12 occur but also when Auto CMD12 is not executed due to the previous command error. 
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DEBERR</name>
              <description>
              Data End Bit Error 
              Occurs either when detecting 0 at the end bit position of read data which uses the DAT line or at the end bit position of the CRC Status. 
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DCRCERR</name>
              <description>
              Data CRC Error 
              Occurs when detecting CRC error when transferring read data which uses the DAT line or when detecting the Write CRC status having a value of other than "010". 
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DTOERR</name>
              <description>
              Data Timeout Error 
              This bit is set when detecting one of following timeout conditions. 
               Busy timeout for R1b,R5b type 
               Busy timeout after Write CRC status 
               Write CRC Status timeout 
               Read Data timeout.
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IDXERR</name>
              <description>
              Command Index Error
              This bit is set if a Command Index error occurs in the command response.
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CEBERR</name>
              <description>
              Command End Bit Error 
              This bit is set when detecting that the end bit of a command response is 0.
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CCRCERR</name>
              <description>
              Command CRC Error 
              Command CRC Error is generated in two cases. 
              If a response is returned and the Command Timeout Error is set to 0 (indicating no timeout), this bit is set to 1 when detecting a CRC error in the command response. 
              The Controller detects a CMD line conflict by monitoring the CMD line when a command is issued. If the Controller drives the CMD line to 1 level, but detects 0 level on the CMD line at the next SD clock edge, then the Controller shall abort the command (Stop driving CMD line) and set this bit to 1. The Command Timeout Error shall also be set to 1 to distinguish CMD line conflict 
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTOERR</name>
              <description>
              Command Timeout Error
              This bit is set only if no response is returned within 64 SD clock cycles from the end bit of the command. If the Controller detects a CMD line conflict, in which case Command CRC Error shall also be set, this bit shall be set without waiting for 64 SD clock cycles because the command will be aborted by the Controller.
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ERR</name>
              <description>
              Error Interrupt 
              If any error bit (bit16~bit31) of ISR are set, then this bit is set. Therefore the Host Driver can efficiently test for an error by checking this bit first. This bit is read only.
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>CARD</name>
              <description>
              Card Interrupt 
              Writing this bit to 1 does not clear this bit. It is cleared by resetting the SD card interrupt factor.
              In 4-bit mode, the card interrupt signal is sampled during the interrupt cycle, so there are some sample delays between the interrupt signal from the SD card and the interrupt to the Host System. 
              When this status has been set and the Host Driver needs to start this interrupt service, ISER_CARDEN may be set to 0 in order to clear the card interrupt statuses latched in the Controller and to stop driving the interrupt signal to the Host System. After completion of the card interrupt service (It should reset interrupt factors in the SD card and the interrupt signal may not be asserted), set ISER_CARDEN to 1 and start sampling the interrupt signal again. 
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>BUFRRDY</name>
              <description>
              Buffer Read Ready 
              This status is set if the Buffer Read Enable changes from 0 to 1. Refer to SR_BUFREN register. 
              1 Ready to read buffer 
              0 Not ready to read buffer 
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BUFWRDY</name>
              <description>
              Buffer Write Ready
              This status is set if the Buffer Write Enable changes from 0 to 1. Refer to SR_BUFWEN register. 
              1 Ready to write buffer 
              0 Not ready to write buffer
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMA</name>
              <description>
              DMA Interrupt 
              This status is set if the Controller detects the Host SDMA Buffer boundary during transfer. Refer to BSR_SDMABDY. 
              In case of ADMA, by setting INT field in the descriptor table, Controller generates this interrupt. This interrupt shall not be generated after the Transfer Complete.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BLKGAP</name>
              <description>
              Block Gap Event 
              If CR2_BLKGAPSTOP is set, this bit is set when both a read / write transaction is stopped at a block gap. If CR2_BLKGAPSTOP is not set to 1, this bit is not set to 1. 
              (1) In the case of a Read Transaction 
              This bit is set at the falling edge of the DAT Line Active Status (When the transaction is stopped at SD Bus timing. The Read Wait shall be supported in order to use this function. 
              (2) Case of Write Transaction 
              This bit is set at the falling edge of Write Transfer Active Status (After getting CRC status at SD Bus timing). 
              1 Transaction stopped at block
              0 No Block Gap Event 
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TC</name>
              <description>
              Transfer Complete 
              This bit is set when a read / write transfer and a command with busy is completed. 
              (1) In the case of a Read Transaction
              This bit is set at the falling edge of Read Transfer Active Status. This interrupt is generated in two cases. The first is when a data transfer is completed as specified by data length (After the last data has been read to the Host System). The second is when data has stopped at the block gap and completed the data transfer by setting CR2_BLKGAPSTOP (After valid data has been read to the Host System). 
              (2) In the case of a Write Transaction
              This bit is set at the falling edge of the DAT Line Active Status. This interrupt is generated in two cases. The first is when the last data is written to the SD card as specified by data length and the busy signal released. The second is when data transfers are stopped at the block gap by setting CR2_BLKGAPSTOP and data transfers completed. (After valid data is written to the SD card and the busy signal released). 
              (3) In the case of a command with busy
              This bit is set when busy is de-asserted. Refer to SR_DATACTIVE and SR_CMDBUSY.
              Transfer Complete has higher priority than Data Timeout Error. If both bits are set to 1, execution of a command can be considered to be completed.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC</name>
              <description>
              Command Complete 
              This bit is set when get the end bit of the command response. Auto CMD12 and Auto CMD23 consist of two responses. Command Complete is not generated by the response of CMD12 or CMD23 but generated by the response of a read/write command. 
              Command Timeout Error has higher priority than Command Complete. If both bits are set to 1, it can be considered that the response was not received correctly.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ISER</name>
          <displayName>ISER</displayName>
          <description>Interrupt Status Enable Register</description>
          <addressOffset>0x34</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>ADMAERREN</name>
              <description>
              ADMA Error Status Enable 
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ACERREN</name>
              <description>
              Auto CMD Error Status Enable 
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DEBERREN</name>
              <description>
              Data End Bit Error Status Enable 
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DCRCERREN</name>
              <description>
              Data CRC Error Status Enable 
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DTOERREN</name>
              <description>
              Data Timeout Error Status Enable 
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IDXERREN</name>
              <description>
              Command Index Error Status Enable
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CEBERREN</name>
              <description>
              Command End Bit Error Status Enable 
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CCRCERREN</name>
              <description>
              Command CRC Error Status Enable 
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTOERREN</name>
              <description>
              Command Timeout Error Status Enable 
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
            <field>
              <name>CARDEN</name>
              <description>
              Card Interrupt Status Enable 
              If this bit is set to 0, the Controller shall clear interrupt request to the System. The Card Interrupt detection is stopped when this bit is cleared and restarted when this bit is set to 1. The Host Driver may clear the Card Interrupt Status Enable before servicing the Card Interrupt and may set this bit again after all interrupt requests from the card are cleared to prevent inadvertent interrupts.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>BUFRRDYEN</name>
              <description>
              Buffer Read Ready Status Enable 
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BUFWRDYEN</name>
              <description>
              Buffer Write Ready Status Enable 
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMAEN</name>
              <description>
              DMA Interrupt Status Enable 
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BLKGAPEN</name>
              <description>
              Block Gap Event Status Enable 
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCEN</name>
              <description>
              Transfer Complete Status Enable 
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CCEN</name>
              <description>
              Command Complete Status Enable 
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IER</name>
          <displayName>IER</displayName>
          <description>Interrupt Enable Register</description>
          <addressOffset>0x38</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>ADMAERRIE</name>
              <description>
              ADMA Error Interrupt Enable 
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ACERRIE</name>
              <description>
              Auto CMD Error Interrupt Enable 
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DEBERRIE</name>
              <description>
              Data End Bit Error Interrupt Enable 
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DCRCERRIE</name>
              <description>
              Data CRC Error Interrupt Enable 
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DTOERRIE</name>
              <description>
              Data Timeout Error Interrupt Enable 
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IDXERRIE</name>
              <description>
              Command Index Error Interrupt Enable
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CEBERRIE</name>
              <description>
              Command End Bit Error Interrupt Enable 
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CCRCERRIE</name>
              <description>
              Command CRC Error Interrupt Enable 
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTOERRIE</name>
              <description>
              Command Timeout Error Interrupt Enable 
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
            <field>
              <name>CARDIE</name>
              <description>
              Card Interrupt Interrupt Enable 
              If this bit is set to 0, the Controller shall clear interrupt request to the System. The Card Interrupt detection is stopped when this bit is cleared and restarted when this bit is set to 1. The Host Driver may clear the Card Interrupt Status Enable before servicing the Card Interrupt and may set this bit again after all interrupt requests from the card are cleared to prevent inadvertent interrupts.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>BUFRRDYIE</name>
              <description>
              Buffer Read Ready Interrupt Enable 
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BUFWRDYIE</name>
              <description>
              Buffer Write Ready Interrupt Enable 
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMAIE</name>
              <description>
              DMA Interrupt Interrupt Enable 
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BLKGAPIE</name>
              <description>
              Block Gap Event Interrupt Enable 
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIE</name>
              <description>
              Transfer Complete Interrupt Enable 
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CCIE</name>
              <description>
              Command Complete Interrupt Enable 
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CR4</name>
          <displayName>CR4</displayName>
          <description>Control Register 4</description>
          <addressOffset>0x3c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>13</bitWidth>
            </field>
            <field>
              <name>UHSMODE</name>
              <description>
              UHS Mode Select 
              100b DDR
              others SDR
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>CNIERR</name>
              <description>
              Command Not Issued By Auto CMD12 Error 
              Setting this bit to 1 means CMD_wo_DAT is not executed due to an Auto CMD12 Error in this register. 
              This bit is set to 0 when Auto CMD Error is generated by Auto CMD23. 
              1 Not Issued 
              0 No Error 
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>ACIDXERR</name>
              <description>
              Auto CMD Index Error 
              This bit is set if the Command Index error occurs in response to a command
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ACEBERR</name>
              <description>
              Auto CMD End Bit Error 
              This bit is set when detecting that the end bit of command response is 0.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ACCRCERR</name>
              <description>
              Auto CMD CRC Error 
              This bit is set when detecting a CRC error in the command response. 
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ACTOERR</name>
              <description>
              Auto CMD Timeout Error 
              This bit is set if no response is returned within 64 SDCLK cycles from the end bit of command. If this bit is set to1, the other error status bits are meaningless. 
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ACNE</name>
              <description>
              Auto CMD12 Not Executed 
              If memory multiple block data transfer is not started due to command error, this bit is not set because it is not necessary to issue Auto CMD12. Setting this bit to 1 means the Controller cannot issue Auto CMD12 to stop memory multiple block data transfer due to some error. If this bit is set to 1, other error status bits are meaningless. 
              This bit is set to 0 when Auto CMD Error is generated by Auto CMD23. 
              1 Not Executed 
              0 Executed
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD3</name>
          <displayName>RSVD3</displayName>
          <description></description>
          <addressOffset>0x40</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>AESR</name>
          <displayName>AESR</displayName>
          <description>ADMA Error Status Register</description>
          <addressOffset>0x54</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>29</bitWidth>
            </field>
            <field>
              <name>LENERR</name>
              <description>
              ADMA Length Mismatch Error 
              This error occurs in the following 2 cases. 
              (1) While CR1_BCNTEN being set, the total data length specified by the Descriptor table is different from that specified by the Block Count and Block Length. 
              (2) Total data length cannot be divided by the block length. 
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ERRSTATE</name>
              <description>
              ADMA Error State 
              This field indicates the state of ADMA when error is occurred during ADMA data transfer. This field never indicates "10" because ADMA never stops in this state. 
              00 ST_STOP (Stop DMA) Points next of the error descriptor 
              01 ST_FDS (Fetch Descriptor) Points the error descriptor 
              10 Never set this state (Not used) 
              11 ST_TFR (Transfer Data) Points the next of the error descriptor 
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ASAR</name>
          <displayName>ASAR</displayName>
          <description>ADMA System Address Register</description>
          <addressOffset>0x58</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>ADDR</name>
              <description>
              ADMA System Address
              This register holds byte address of executing command of the Descriptor table.
              At the start of ADMA, the Host Driver shall set start address of the Descriptor table. The ADMA increments this register address, which points to next line, when every fetching a Descriptor line. When the ADMA Error Interrupt is generated, this register shall hold valid Descriptor address depending on the ADMA state. The Host Driver shall program Descriptor Table on 32-bit boundary and set 32-bit boundary address to this register. Lower 2-bit of this register is ignored and assumes it to be 00b. 
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>NSAR</name>
          <displayName>NSAR</displayName>
          <description>Next System Address Register</description>
          <addressOffset>0x5c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>ADDR</name>
              <description>
              This register contains next physical system memory address used for SDMA transfer.
              When the Host Controller stops a SDMA transfer, this register shall point to the system address of the next contiguous data position. It can be accessed only if no transaction is executing (i.e., after a transaction has stopped). Read operations during transfers may return an invalid value. After SDMA has stopped, the next system address of the next contiguous data position can be read from this register. 
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD2</name>
          <displayName>RSVD2</displayName>
          <description></description>
          <addressOffset>0x60</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>ABSR</name>
          <displayName>ABSR</displayName>
          <description> AHB Burst Size Register</description>
          <addressOffset>0xec</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>25</bitWidth>
            </field>
            <field>
              <name>BSIZE</name>
              <description>
              AHB Master Burst Size Register 
              AHB Master performs Burst operations as per this register. 
              0  Disabled 
              1  Enabled
              Bit 00 INCR4 
              Bit 01 INCR8 
              Bit 02 INCR16 
              Bit 03 INCR 
              Bit 04 WRAP4 
              Bit 05 WRAP8 
              Bit 06 WRAP16
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD1</name>
          <displayName>RSVD1</displayName>
          <description></description>
          <addressOffset>0xF0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>SCR</name>
          <displayName>SCR</displayName>
          <description>Sampling Clock Register</description>
          <addressOffset>0xf4</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>SEL</name>
              <description>
              select sampling clock source (delay line input)
              0: use internal clock
              1: use loopback clock
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DLY</name>
              <description>
              Stages of delay line for sampling clock
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>LPSYS_RCC</name>
      <description></description>
      <groupName>LPSYS_RCC</groupName>
      <baseAddress>0x40040000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>RSTR1</name>
          <displayName>RSTR1</displayName>
          <description>Reset Register</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>BUSMON2</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LCDC2</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PTC2</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TSEN</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LPCOMP</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SDADC</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GPADC</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>WDT2</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BTIM4</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BTIM3</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GPTIM5</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GPTIM4</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GPTIM3</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SYSCFG2</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>I2C6</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>I2C5</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>I2C4</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SPI4</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SPI3</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>USART5</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>USART4</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>USART3</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PATCH</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PINMUX2</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MAILBOX2</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMAC2</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LCPU</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSTR2</name>
          <displayName>RSTR2</displayName>
          <description>Reset Register2</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>27</bitWidth>
            </field>
            <field>
              <name>MAC</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PHY</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RFC</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>QSPI4</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GPIO2</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ENR1</name>
          <displayName>ENR1</displayName>
          <description>Enable Register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>BUSMON2</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LCDC2</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PTC2</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TSEN</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LPCOMP</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SDADC</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GPADC</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>WDT2</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BTIM4</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BTIM3</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GPTIM5</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GPTIM4</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GPTIM3</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SYSCFG2</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>I2C6</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>I2C5</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>I2C4</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SPI4</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SPI3</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>USART5</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>USART4</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>USART3</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PATCH</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PINMUX2</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MAILBOX2</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMAC2</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD5</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ENR2</name>
          <displayName>ENR2</displayName>
          <description>Enable Register2</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>27</bitWidth>
            </field>
            <field>
              <name>MAC</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PHY</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RFC</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>QSPI4</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GPIO2</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CSR</name>
          <displayName>CSR</displayName>
          <description>Clock Select Register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>FORCE_BUS</name>
              <description>
              for debug only
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FORCE_MAC</name>
              <description>
              for debug only
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>SEL_USART5</name>
              <description>
              0 - hrc48; 1 - hxt48
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SEL_USART4</name>
              <description>
              0 - hrc48; 1 - hxt48
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SEL_USART3</name>
              <description>
              0 - hrc48; 1 - hxt48
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>SEL_SYS</name>
              <description>
              select clk_sys source
              0 - hrc48; 1 - hxt48; 2 - CLK_LP; 3 - RSVD
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CFGR</name>
          <displayName>CFGR</displayName>
          <description>Clock Configuration Register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>MACFREQ</name>
              <description>
              clock frequency of MAC clock
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>MACDIV</name>
              <description>
              MAC clock divider
              MAC clock = hclk / MACDIV
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PDIV2</name>
              <description>
              pclk2 = hclk / (2^PDIV2), by default divided by 8
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PDIV1</name>
              <description>
              pclk1 = hclk / (2^PDIV1), by default divided by 2
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HDIV2</name>
              <description>
              should set to 0 if hclk frequency no higher than 24MHz
              should set to 1 if hclk frequency higher than 24MHz
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HDIV1</name>
              <description>
              hclk = clk_sys / HDIV1
              if HDIV1=0, hclk = clk_sys
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>DMAC2</name>
      <description></description>
      <groupName>DMAC</groupName>
      <baseAddress>0x40041000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>ISR</name>
          <displayName>ISR</displayName>
          <description></description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>TEIF8</name>
              <description>
              channel transfer error flag
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HTIF8</name>
              <description>
              channel half transfer flag
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIF8</name>
              <description>
              channel transfer complete flag
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GIF8</name>
              <description>
              channel global interrupt flag
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIF7</name>
              <description>
              channel transfer error flag
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HTIF7</name>
              <description>
              channel half transfer flag
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIF7</name>
              <description>
              channel transfer complete flag
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GIF7</name>
              <description>
              channel global interrupt flag
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIF6</name>
              <description>
              channel transfer error flag
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HTIF6</name>
              <description>
              channel half transfer flag
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIF6</name>
              <description>
              channel transfer complete flag
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GIF6</name>
              <description>
              channel global interrupt flag
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIF5</name>
              <description>
              channel transfer error flag
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HTIF5</name>
              <description>
              channel half transfer flag
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIF5</name>
              <description>
              channel transfer complete flag
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GIF5</name>
              <description>
              channel global interrupt flag
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIF4</name>
              <description>
              channel transfer error flag
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HTIF4</name>
              <description>
              channel half transfer flag
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIF4</name>
              <description>
              channel transfer complete flag
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GIF4</name>
              <description>
              channel global interrupt flag
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIF3</name>
              <description>
              channel transfer error flag
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HTIF3</name>
              <description>
              channel half transfer flag
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIF3</name>
              <description>
              channel transfer complete flag
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GIF3</name>
              <description>
              channel global interrupt flag
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIF2</name>
              <description>
              channel transfer error flag
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HTIF2</name>
              <description>
              channel half transfer flag
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIF2</name>
              <description>
              channel transfer complete flag
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GIF2</name>
              <description>
              channel global interrupt flag
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIF1</name>
              <description>
              channel transfer error flag. Set when bus error detected. Cleared when write 1 to CTEIF or CGIF.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HTIF1</name>
              <description>
              channel half transfer flag. Set when half NDT are transferred. Cleared when write 1 to CHTIF or CGIF.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIF1</name>
              <description>
              channel transfer complete flag. Set when all NDT are transferred.  Cleared when write 1 to CTCIF or CGIF.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GIF1</name>
              <description>
              channel global interrupt flag. Set when any of TEIF/HTIF/TCIF asserted. Cleared when TEIF/HTIF/TCIF all cleared.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IFCR</name>
          <displayName>IFCR</displayName>
          <description></description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>CTEIF8</name>
              <description>
              CTEIF, transfer error flag clear
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CHTIF8</name>
              <description>
              CHTIF, half transfer flag clear
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTCIF8</name>
              <description>
              CTCIF, transfer complete flag clear
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CGIF8</name>
              <description>
              CGIF,  global interrupt flag clear
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTEIF7</name>
              <description>
              CTEIF, transfer error flag clear
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CHTIF7</name>
              <description>
              CHTIF, half transfer flag clear
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTCIF7</name>
              <description>
              CTCIF, transfer complete flag clear
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CGIF7</name>
              <description>
              CGIF,  global interrupt flag clear
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTEIF6</name>
              <description>
              CTEIF, transfer error flag clear
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CHTIF6</name>
              <description>
              CHTIF, half transfer flag clear
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTCIF6</name>
              <description>
              CTCIF, transfer complete flag clear
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CGIF6</name>
              <description>
              CGIF,  global interrupt flag clear
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTEIF5</name>
              <description>
              CTEIF, transfer error flag clear
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CHTIF5</name>
              <description>
              CHTIF, half transfer flag clear
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTCIF5</name>
              <description>
              CTCIF, transfer complete flag clear
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CGIF5</name>
              <description>
              CGIF,  global interrupt flag clear
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTEIF4</name>
              <description>
              CTEIF, transfer error flag clear
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CHTIF4</name>
              <description>
              CHTIF, half transfer flag clear
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTCIF4</name>
              <description>
              CTCIF, transfer complete flag clear
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CGIF4</name>
              <description>
              CGIF,  global interrupt flag clear
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTEIF3</name>
              <description>
              CTEIF, transfer error flag clear
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CHTIF3</name>
              <description>
              CHTIF, half transfer flag clear
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTCIF3</name>
              <description>
              CTCIF, transfer complete flag clear
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CGIF3</name>
              <description>
              CGIF,  global interrupt flag clear
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTEIF2</name>
              <description>
              CTEIF, transfer error flag clear
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CHTIF2</name>
              <description>
              CHTIF, half transfer flag clear
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTCIF2</name>
              <description>
              CTCIF, transfer complete flag clear
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CGIF2</name>
              <description>
              CGIF,  global interrupt flag clear
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTEIF1</name>
              <description>
              CTEIF, transfer error flag clear. Write 1 to clear TEIF.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CHTIF1</name>
              <description>
              CHTIF, half transfer flag clear. Write 1 to clear HTIF.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTCIF1</name>
              <description>
              CTCIF, transfer complete flag clear. Write 1 to clear TCIF.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CGIF1</name>
              <description>
              CGIF,  global interrupt flag clear. Write 1 to clear all TEIF/HTIF/TCIF.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR1</name>
          <displayName>CCR1</displayName>
          <description></description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
            <field>
              <name>MEM2MEM</name>
              <description>
              memory-to-memory mode
              0: disabled
              1: enabled
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PL</name>
              <description>
              priority level
              00: low
              01: medium
              10: high
              11: very high
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>MSIZE</name>
              <description>
              memory size
              Defines the data size of each DMA transfer to the identified memory.
              In memory-to-memory mode, this field identifies the memory source if DIR = 1 and the memory destination if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.
              00: 8 bits
              01: 16 bits
              10: 32 bits
              11: reserved
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>PSIZE</name>
              <description>
              peripheral size
              Defines the data size of each DMA transfer to the identified peripheral.
              In memory-to-memory mode, this field identifies the memory destination if DIR = 1 and the memory source if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR = 1 and the peripheral source if DIR = 0.
              00: 8 bits
              01: 16 bits
              10: 32 bits
              11: reserved
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>MINC</name>
              <description>
              memory increment mode
              Defines the increment mode for each DMA transfer to the identified memory.
              In memory-to-memory mode, this field identifies the memory source if DIR = 1 and the memory destination if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.
              0: disabled
              1: enabled
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PINC</name>
              <description>
              peripheral increment mode
              Defines the increment mode for each DMA transfer to the identified peripheral.
              n memory-to-memory mode, this field identifies the memory destination if DIR = 1 and the 
              memory source if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR = 1 and 
              the peripheral source if DIR = 0.
              0: disabled
              1: enabled
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CIRC</name>
              <description>
              circular mode
              0: disabled
              1: enabled
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DIR</name>
              <description>
              data transfer direction
              This bit must be set only in memory-to-peripheral and peripheral-to-memory modes.
              0: read from peripheral
                 Source attributes are defined by PSIZE and PINC, plus the CPARx register. This is still valid in a memory-to-memory mode.
                 Destination attributes are defined by MSIZE and MINC, plus the CM0ARx register. This is still valid in a peripheral-to-peripheral mode.
              1: read from memory
                 Destination attributes are defined by PSIZE and PINC, plus the CPARx register. This is still valid in a memory-to-memory mode.
                 Source attributes are defined by MSIZE and MINC, plus the CM0ARx register. This is still valid in a peripheral-to-peripheral mode.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIE</name>
              <description>
              transfer error interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HTIE</name>
              <description>
              half transfer interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIE</name>
              <description>
              transfer complete interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EN</name>
              <description>
              channel enable
              When a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the ISR register is cleared (by setting the CTEIFx bit of the IFCR register).
              0: disabled
              1: enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CNDTR1</name>
          <displayName>CNDTR1</displayName>
          <description></description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>NDT</name>
              <description>
              number of data to transfer (0 to 2^16 - 1)
              This field is updated by hardware when the channel is enabled:
                 It is decremented after each single DMA 'read followed by write' transfer, indicating the remaining amount of data items to transfer.
                 It is kept at zero when the programmed amount of data to transfer is reached, if the channel is not in circular mode (CIRC = 0 in the CCRx register).
                 It is reloaded automatically by the previously programmed value, when the transfer is complete, if the channel is in circular mode (CIRC = 1).
              If this field is zero, no transfer can be served whatever the channel status (enabled or not).
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CPAR1</name>
          <displayName>CPAR1</displayName>
          <description></description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>PA</name>
              <description>
              peripheral address
              It contains the base address of the peripheral data register from/to which the data will be read/written.
              In memory-to-memory mode, this register identifies the memory destination address if DIR = 1 and the memory source address if DIR = 0.
              In peripheral-to-peripheral mode, this register identifies the peripheral destination address DIR = 1 and the peripheral source address if DIR = 0.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0AR1</name>
          <displayName>CM0AR1</displayName>
          <description></description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>MA</name>
              <description>
              memory address
              It contains the base address of the memory from/to which the data will be read/written.
              In memory-to-memory mode, this register identifies the memory source address if DIR = 1 and the memory destination address if DIR = 0.
              In peripheral-to-peripheral mode, this register identifies the peripheral source address DIR = 1 and the peripheral destination address if DIR = 0.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CBSR1</name>
          <displayName>CBSR1</displayName>
          <description></description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>BS</name>
              <description>
              burst size in non-m2m mode
              When BS>1, DMA will transfer for BS times for each request if left NDT is larger than BS, or else transfer for left NDT times.
              When BS=0 or 1, DMA will always do single transfer for each request.
              In memory-to-memory mode, BS is ignored.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR2</name>
          <displayName>CCR2</displayName>
          <description></description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
            <field>
              <name>MEM2MEM</name>
              <description>
              memory-to-memory mode
              0: disabled
              1: enabled
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PL</name>
              <description>
              priority level
              00: low
              01: medium
              10: high
              11: very high
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>MSIZE</name>
              <description>
              memory size
              Defines the data size of each DMA transfer to the identified memory.
              In memory-to-memory mode, this field identifies the memory source if DIR = 1 and the memory destination if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.
              00: 8 bits
              01: 16 bits
              10: 32 bits
              11: reserved
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>PSIZE</name>
              <description>
              peripheral size
              Defines the data size of each DMA transfer to the identified peripheral.
              In memory-to-memory mode, this field identifies the memory destination if DIR = 1 and the memory source if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR = 1 and the peripheral source if DIR = 0.
              00: 8 bits
              01: 16 bits
              10: 32 bits
              11: reserved
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>MINC</name>
              <description>
              memory increment mode
              Defines the increment mode for each DMA transfer to the identified memory.
              In memory-to-memory mode, this field identifies the memory source if DIR = 1 and the memory destination if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.
              0: disabled
              1: enabled
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PINC</name>
              <description>
              peripheral increment mode
              Defines the increment mode for each DMA transfer to the identified peripheral.
              n memory-to-memory mode, this field identifies the memory destination if DIR = 1 and the 
              memory source if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR = 1 and 
              the peripheral source if DIR = 0.
              0: disabled
              1: enabled
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CIRC</name>
              <description>
              circular mode
              0: disabled
              1: enabled
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DIR</name>
              <description>
              data transfer direction
              This bit must be set only in memory-to-peripheral and peripheral-to-memory modes.
              0: read from peripheral
                 Source attributes are defined by PSIZE and PINC, plus the CPARx register. This is still valid in a memory-to-memory mode.
                 Destination attributes are defined by MSIZE and MINC, plus the CM0ARx register. This is still valid in a peripheral-to-peripheral mode.
              1: read from memory
                 Destination attributes are defined by PSIZE and PINC, plus the CPARx register. This is still valid in a memory-to-memory mode.
                 Source attributes are defined by MSIZE and MINC, plus the CM0ARx register. This is still valid in a peripheral-to-peripheral mode.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIE</name>
              <description>
              transfer error interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HTIE</name>
              <description>
              half transfer interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIE</name>
              <description>
              transfer complete interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EN</name>
              <description>
              channel enable
              When a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the ISR register is cleared (by setting the CTEIFx bit of the IFCR register).
              0: disabled
              1: enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CNDTR2</name>
          <displayName>CNDTR2</displayName>
          <description></description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>NDT</name>
              <description>
              number of data to transfer (0 to 2^16 - 1)
              This field is updated by hardware when the channel is enabled:
                 It is decremented after each single DMA 'read followed by write' transfer, indicating the remaining amount of data items to transfer.
                 It is kept at zero when the programmed amount of data to transfer is reached, if the channel is not in circular mode (CIRC = 0 in the CCRx register).
                 It is reloaded automatically by the previously programmed value, when the transfer is complete, if the channel is in circular mode (CIRC = 1).
              If this field is zero, no transfer can be served whatever the channel status (enabled or not).
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CPAR2</name>
          <displayName>CPAR2</displayName>
          <description></description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>PA</name>
              <description>
              peripheral address
              It contains the base address of the peripheral data register from/to which the data will be read/written.
              In memory-to-memory mode, this register identifies the memory destination address if DIR = 1 and the memory source address if DIR = 0.
              In peripheral-to-peripheral mode, this register identifies the peripheral destination address DIR = 1 and the peripheral source address if DIR = 0.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0AR2</name>
          <displayName>CM0AR2</displayName>
          <description></description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>MA</name>
              <description>
              peripheral address
              It contains the base address of the memory from/to which the data will be read/written.
              In memory-to-memory mode, this register identifies the memory source address if DIR = 1 and the memory destination address if DIR = 0.
              In peripheral-to-peripheral mode, this register identifies the peripheral source address DIR = 1 and the peripheral destination address if DIR = 0.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CBSR2</name>
          <displayName>CBSR2</displayName>
          <description></description>
          <addressOffset>0x2c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>BS</name>
              <description>
              burst size in non-m2m mode
              When BS>1, DMA will transfer for BS times for each request if left NDT is larger than BS, or else transfer for left NDT times.
              When BS=0 or 1, DMA will always do single transfer for each request.
              In memory-to-memory mode, BS is ignored.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR3</name>
          <displayName>CCR3</displayName>
          <description></description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
            <field>
              <name>MEM2MEM</name>
              <description>
              memory-to-memory mode
              0: disabled
              1: enabled
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PL</name>
              <description>
              priority level
              00: low
              01: medium
              10: high
              11: very high
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>MSIZE</name>
              <description>
              memory size
              Defines the data size of each DMA transfer to the identified memory.
              In memory-to-memory mode, this field identifies the memory source if DIR = 1 and the memory destination if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.
              00: 8 bits
              01: 16 bits
              10: 32 bits
              11: reserved
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>PSIZE</name>
              <description>
              peripheral size
              Defines the data size of each DMA transfer to the identified peripheral.
              In memory-to-memory mode, this field identifies the memory destination if DIR = 1 and the memory source if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR = 1 and the peripheral source if DIR = 0.
              00: 8 bits
              01: 16 bits
              10: 32 bits
              11: reserved
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>MINC</name>
              <description>
              memory increment mode
              Defines the increment mode for each DMA transfer to the identified memory.
              In memory-to-memory mode, this field identifies the memory source if DIR = 1 and the memory destination if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.
              0: disabled
              1: enabled
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PINC</name>
              <description>
              peripheral increment mode
              Defines the increment mode for each DMA transfer to the identified peripheral.
              n memory-to-memory mode, this field identifies the memory destination if DIR = 1 and the 
              memory source if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR = 1 and 
              the peripheral source if DIR = 0.
              0: disabled
              1: enabled
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CIRC</name>
              <description>
              circular mode
              0: disabled
              1: enabled
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DIR</name>
              <description>
              data transfer direction
              This bit must be set only in memory-to-peripheral and peripheral-to-memory modes.
              0: read from peripheral
                 Source attributes are defined by PSIZE and PINC, plus the CPARx register. This is still valid in a memory-to-memory mode.
                 Destination attributes are defined by MSIZE and MINC, plus the CM0ARx register. This is still valid in a peripheral-to-peripheral mode.
              1: read from memory
                 Destination attributes are defined by PSIZE and PINC, plus the CPARx register. This is still valid in a memory-to-memory mode.
                 Source attributes are defined by MSIZE and MINC, plus the CM0ARx register. This is still valid in a peripheral-to-peripheral mode.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIE</name>
              <description>
              transfer error interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HTIE</name>
              <description>
              half transfer interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIE</name>
              <description>
              transfer complete interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EN</name>
              <description>
              channel enable
              When a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the ISR register is cleared (by setting the CTEIFx bit of the IFCR register).
              0: disabled
              1: enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CNDTR3</name>
          <displayName>CNDTR3</displayName>
          <description></description>
          <addressOffset>0x34</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>NDT</name>
              <description>
              number of data to transfer (0 to 2^16 - 1)
              This field is updated by hardware when the channel is enabled:
                 It is decremented after each single DMA 'read followed by write' transfer, indicating the remaining amount of data items to transfer.
                 It is kept at zero when the programmed amount of data to transfer is reached, if the channel is not in circular mode (CIRC = 0 in the CCRx register).
                 It is reloaded automatically by the previously programmed value, when the transfer is complete, if the channel is in circular mode (CIRC = 1).
              If this field is zero, no transfer can be served whatever the channel status (enabled or not).
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CPAR3</name>
          <displayName>CPAR3</displayName>
          <description></description>
          <addressOffset>0x38</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>PA</name>
              <description>
              peripheral address
              It contains the base address of the peripheral data register from/to which the data will be read/written.
              In memory-to-memory mode, this register identifies the memory destination address if DIR = 1 and the memory source address if DIR = 0.
              In peripheral-to-peripheral mode, this register identifies the peripheral destination address DIR = 1 and the peripheral source address if DIR = 0.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0AR3</name>
          <displayName>CM0AR3</displayName>
          <description></description>
          <addressOffset>0x3c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>MA</name>
              <description>
              peripheral address
              It contains the base address of the memory from/to which the data will be read/written.
              In memory-to-memory mode, this register identifies the memory source address if DIR = 1 and the memory destination address if DIR = 0.
              In peripheral-to-peripheral mode, this register identifies the peripheral source address DIR = 1 and the peripheral destination address if DIR = 0.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CBSR3</name>
          <displayName>CBSR3</displayName>
          <description></description>
          <addressOffset>0x40</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>BS</name>
              <description>
              burst size in non-m2m mode
              When BS>1, DMA will transfer for BS times for each request if left NDT is larger than BS, or else transfer for left NDT times.
              When BS=0 or 1, DMA will always do single transfer for each request.
              In memory-to-memory mode, BS is ignored.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR4</name>
          <displayName>CCR4</displayName>
          <description></description>
          <addressOffset>0x44</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
            <field>
              <name>MEM2MEM</name>
              <description>
              memory-to-memory mode
              0: disabled
              1: enabled
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PL</name>
              <description>
              priority level
              00: low
              01: medium
              10: high
              11: very high
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>MSIZE</name>
              <description>
              memory size
              Defines the data size of each DMA transfer to the identified memory.
              In memory-to-memory mode, this field identifies the memory source if DIR = 1 and the memory destination if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.
              00: 8 bits
              01: 16 bits
              10: 32 bits
              11: reserved
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>PSIZE</name>
              <description>
              peripheral size
              Defines the data size of each DMA transfer to the identified peripheral.
              In memory-to-memory mode, this field identifies the memory destination if DIR = 1 and the memory source if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR = 1 and the peripheral source if DIR = 0.
              00: 8 bits
              01: 16 bits
              10: 32 bits
              11: reserved
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>MINC</name>
              <description>
              memory increment mode
              Defines the increment mode for each DMA transfer to the identified memory.
              In memory-to-memory mode, this field identifies the memory source if DIR = 1 and the memory destination if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.
              0: disabled
              1: enabled
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PINC</name>
              <description>
              peripheral increment mode
              Defines the increment mode for each DMA transfer to the identified peripheral.
              n memory-to-memory mode, this field identifies the memory destination if DIR = 1 and the 
              memory source if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR = 1 and 
              the peripheral source if DIR = 0.
              0: disabled
              1: enabled
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CIRC</name>
              <description>
              circular mode
              0: disabled
              1: enabled
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DIR</name>
              <description>
              data transfer direction
              This bit must be set only in memory-to-peripheral and peripheral-to-memory modes.
              0: read from peripheral
                 Source attributes are defined by PSIZE and PINC, plus the CPARx register. This is still valid in a memory-to-memory mode.
                 Destination attributes are defined by MSIZE and MINC, plus the CM0ARx register. This is still valid in a peripheral-to-peripheral mode.
              1: read from memory
                 Destination attributes are defined by PSIZE and PINC, plus the CPARx register. This is still valid in a memory-to-memory mode.
                 Source attributes are defined by MSIZE and MINC, plus the CM0ARx register. This is still valid in a peripheral-to-peripheral mode.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIE</name>
              <description>
              transfer error interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HTIE</name>
              <description>
              half transfer interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIE</name>
              <description>
              transfer complete interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EN</name>
              <description>
              channel enable
              When a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the ISR register is cleared (by setting the CTEIFx bit of the IFCR register).
              0: disabled
              1: enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CNDTR4</name>
          <displayName>CNDTR4</displayName>
          <description></description>
          <addressOffset>0x48</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>NDT</name>
              <description>
              number of data to transfer (0 to 2^16 - 1)
              This field is updated by hardware when the channel is enabled:
                 It is decremented after each single DMA 'read followed by write' transfer, indicating the remaining amount of data items to transfer.
                 It is kept at zero when the programmed amount of data to transfer is reached, if the channel is not in circular mode (CIRC = 0 in the CCRx register).
                 It is reloaded automatically by the previously programmed value, when the transfer is complete, if the channel is in circular mode (CIRC = 1).
              If this field is zero, no transfer can be served whatever the channel status (enabled or not).
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CPAR4</name>
          <displayName>CPAR4</displayName>
          <description></description>
          <addressOffset>0x4c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>PA</name>
              <description>
              peripheral address
              It contains the base address of the peripheral data register from/to which the data will be read/written.
              In memory-to-memory mode, this register identifies the memory destination address if DIR = 1 and the memory source address if DIR = 0.
              In peripheral-to-peripheral mode, this register identifies the peripheral destination address DIR = 1 and the peripheral source address if DIR = 0.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0AR4</name>
          <displayName>CM0AR4</displayName>
          <description></description>
          <addressOffset>0x50</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>MA</name>
              <description>
              peripheral address
              It contains the base address of the memory from/to which the data will be read/written.
              In memory-to-memory mode, this register identifies the memory source address if DIR = 1 and the memory destination address if DIR = 0.
              In peripheral-to-peripheral mode, this register identifies the peripheral source address DIR = 1 and the peripheral destination address if DIR = 0.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CBSR4</name>
          <displayName>CBSR4</displayName>
          <description></description>
          <addressOffset>0x54</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>BS</name>
              <description>
              burst size in non-m2m mode
              When BS>1, DMA will transfer for BS times for each request if left NDT is larger than BS, or else transfer for left NDT times.
              When BS=0 or 1, DMA will always do single transfer for each request.
              In memory-to-memory mode, BS is ignored.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR5</name>
          <displayName>CCR5</displayName>
          <description></description>
          <addressOffset>0x58</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
            <field>
              <name>MEM2MEM</name>
              <description>
              memory-to-memory mode
              0: disabled
              1: enabled
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PL</name>
              <description>
              priority level
              00: low
              01: medium
              10: high
              11: very high
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>MSIZE</name>
              <description>
              memory size
              Defines the data size of each DMA transfer to the identified memory.
              In memory-to-memory mode, this field identifies the memory source if DIR = 1 and the memory destination if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.
              00: 8 bits
              01: 16 bits
              10: 32 bits
              11: reserved
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>PSIZE</name>
              <description>
              peripheral size
              Defines the data size of each DMA transfer to the identified peripheral.
              In memory-to-memory mode, this field identifies the memory destination if DIR = 1 and the memory source if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR = 1 and the peripheral source if DIR = 0.
              00: 8 bits
              01: 16 bits
              10: 32 bits
              11: reserved
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>MINC</name>
              <description>
              memory increment mode
              Defines the increment mode for each DMA transfer to the identified memory.
              In memory-to-memory mode, this field identifies the memory source if DIR = 1 and the memory destination if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.
              0: disabled
              1: enabled
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PINC</name>
              <description>
              peripheral increment mode
              Defines the increment mode for each DMA transfer to the identified peripheral.
              n memory-to-memory mode, this field identifies the memory destination if DIR = 1 and the 
              memory source if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR = 1 and 
              the peripheral source if DIR = 0.
              0: disabled
              1: enabled
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CIRC</name>
              <description>
              circular mode
              0: disabled
              1: enabled
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DIR</name>
              <description>
              data transfer direction
              This bit must be set only in memory-to-peripheral and peripheral-to-memory modes.
              0: read from peripheral
                 Source attributes are defined by PSIZE and PINC, plus the CPARx register. This is still valid in a memory-to-memory mode.
                 Destination attributes are defined by MSIZE and MINC, plus the CM0ARx register. This is still valid in a peripheral-to-peripheral mode.
              1: read from memory
                 Destination attributes are defined by PSIZE and PINC, plus the CPARx register. This is still valid in a memory-to-memory mode.
                 Source attributes are defined by MSIZE and MINC, plus the CM0ARx register. This is still valid in a peripheral-to-peripheral mode.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIE</name>
              <description>
              transfer error interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HTIE</name>
              <description>
              half transfer interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIE</name>
              <description>
              transfer complete interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EN</name>
              <description>
              channel enable
              When a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the ISR register is cleared (by setting the CTEIFx bit of the IFCR register).
              0: disabled
              1: enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CNDTR5</name>
          <displayName>CNDTR5</displayName>
          <description></description>
          <addressOffset>0x5c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>NDT</name>
              <description>
              number of data to transfer (0 to 2^16 - 1)
              This field is updated by hardware when the channel is enabled:
                 It is decremented after each single DMA 'read followed by write' transfer, indicating the remaining amount of data items to transfer.
                 It is kept at zero when the programmed amount of data to transfer is reached, if the channel is not in circular mode (CIRC = 0 in the CCRx register).
                 It is reloaded automatically by the previously programmed value, when the transfer is complete, if the channel is in circular mode (CIRC = 1).
              If this field is zero, no transfer can be served whatever the channel status (enabled or not).
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CPAR5</name>
          <displayName>CPAR5</displayName>
          <description></description>
          <addressOffset>0x60</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>PA</name>
              <description>
              peripheral address
              It contains the base address of the peripheral data register from/to which the data will be read/written.
              In memory-to-memory mode, this register identifies the memory destination address if DIR = 1 and the memory source address if DIR = 0.
              In peripheral-to-peripheral mode, this register identifies the peripheral destination address DIR = 1 and the peripheral source address if DIR = 0.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0AR5</name>
          <displayName>CM0AR5</displayName>
          <description></description>
          <addressOffset>0x64</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>MA</name>
              <description>
              peripheral address
              It contains the base address of the memory from/to which the data will be read/written.
              In memory-to-memory mode, this register identifies the memory source address if DIR = 1 and the memory destination address if DIR = 0.
              In peripheral-to-peripheral mode, this register identifies the peripheral source address DIR = 1 and the peripheral destination address if DIR = 0.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CBSR5</name>
          <displayName>CBSR5</displayName>
          <description></description>
          <addressOffset>0x68</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>BS</name>
              <description>
              burst size in non-m2m mode
              When BS>1, DMA will transfer for BS times for each request if left NDT is larger than BS, or else transfer for left NDT times.
              When BS=0 or 1, DMA will always do single transfer for each request.
              In memory-to-memory mode, BS is ignored.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR6</name>
          <displayName>CCR6</displayName>
          <description></description>
          <addressOffset>0x6c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
            <field>
              <name>MEM2MEM</name>
              <description>
              memory-to-memory mode
              0: disabled
              1: enabled
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PL</name>
              <description>
              priority level
              00: low
              01: medium
              10: high
              11: very high
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>MSIZE</name>
              <description>
              memory size
              Defines the data size of each DMA transfer to the identified memory.
              In memory-to-memory mode, this field identifies the memory source if DIR = 1 and the memory destination if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.
              00: 8 bits
              01: 16 bits
              10: 32 bits
              11: reserved
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>PSIZE</name>
              <description>
              peripheral size
              Defines the data size of each DMA transfer to the identified peripheral.
              In memory-to-memory mode, this field identifies the memory destination if DIR = 1 and the memory source if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR = 1 and the peripheral source if DIR = 0.
              00: 8 bits
              01: 16 bits
              10: 32 bits
              11: reserved
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>MINC</name>
              <description>
              memory increment mode
              Defines the increment mode for each DMA transfer to the identified memory.
              In memory-to-memory mode, this field identifies the memory source if DIR = 1 and the memory destination if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.
              0: disabled
              1: enabled
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PINC</name>
              <description>
              peripheral increment mode
              Defines the increment mode for each DMA transfer to the identified peripheral.
              n memory-to-memory mode, this field identifies the memory destination if DIR = 1 and the 
              memory source if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR = 1 and 
              the peripheral source if DIR = 0.
              0: disabled
              1: enabled
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CIRC</name>
              <description>
              circular mode
              0: disabled
              1: enabled
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DIR</name>
              <description>
              data transfer direction
              This bit must be set only in memory-to-peripheral and peripheral-to-memory modes.
              0: read from peripheral
                 Source attributes are defined by PSIZE and PINC, plus the CPARx register. This is still valid in a memory-to-memory mode.
                 Destination attributes are defined by MSIZE and MINC, plus the CM0ARx register. This is still valid in a peripheral-to-peripheral mode.
              1: read from memory
                 Destination attributes are defined by PSIZE and PINC, plus the CPARx register. This is still valid in a memory-to-memory mode.
                 Source attributes are defined by MSIZE and MINC, plus the CM0ARx register. This is still valid in a peripheral-to-peripheral mode.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIE</name>
              <description>
              transfer error interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HTIE</name>
              <description>
              half transfer interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIE</name>
              <description>
              transfer complete interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EN</name>
              <description>
              channel enable
              When a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the ISR register is cleared (by setting the CTEIFx bit of the IFCR register).
              0: disabled
              1: enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CNDTR6</name>
          <displayName>CNDTR6</displayName>
          <description></description>
          <addressOffset>0x70</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>NDT</name>
              <description>
              number of data to transfer (0 to 2^16 - 1)
              This field is updated by hardware when the channel is enabled:
                 It is decremented after each single DMA 'read followed by write' transfer, indicating the remaining amount of data items to transfer.
                 It is kept at zero when the programmed amount of data to transfer is reached, if the channel is not in circular mode (CIRC = 0 in the CCRx register).
                 It is reloaded automatically by the previously programmed value, when the transfer is complete, if the channel is in circular mode (CIRC = 1).
              If this field is zero, no transfer can be served whatever the channel status (enabled or not).
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CPAR6</name>
          <displayName>CPAR6</displayName>
          <description></description>
          <addressOffset>0x74</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>PA</name>
              <description>
              peripheral address
              It contains the base address of the peripheral data register from/to which the data will be read/written.
              In memory-to-memory mode, this register identifies the memory destination address if DIR = 1 and the memory source address if DIR = 0.
              In peripheral-to-peripheral mode, this register identifies the peripheral destination address DIR = 1 and the peripheral source address if DIR = 0.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0AR6</name>
          <displayName>CM0AR6</displayName>
          <description></description>
          <addressOffset>0x78</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>MA</name>
              <description>
              peripheral address
              It contains the base address of the memory from/to which the data will be read/written.
              In memory-to-memory mode, this register identifies the memory source address if DIR = 1 and the memory destination address if DIR = 0.
              In peripheral-to-peripheral mode, this register identifies the peripheral source address DIR = 1 and the peripheral destination address if DIR = 0.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CBSR6</name>
          <displayName>CBSR6</displayName>
          <description></description>
          <addressOffset>0x7c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>BS</name>
              <description>
              burst size in non-m2m mode
              When BS>1, DMA will transfer for BS times for each request if left NDT is larger than BS, or else transfer for left NDT times.
              When BS=0 or 1, DMA will always do single transfer for each request.
              In memory-to-memory mode, BS is ignored.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR7</name>
          <displayName>CCR7</displayName>
          <description></description>
          <addressOffset>0x80</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
            <field>
              <name>MEM2MEM</name>
              <description>
              memory-to-memory mode
              0: disabled
              1: enabled
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PL</name>
              <description>
              priority level
              00: low
              01: medium
              10: high
              11: very high
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>MSIZE</name>
              <description>
              memory size
              Defines the data size of each DMA transfer to the identified memory.
              In memory-to-memory mode, this field identifies the memory source if DIR = 1 and the memory destination if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.
              00: 8 bits
              01: 16 bits
              10: 32 bits
              11: reserved
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>PSIZE</name>
              <description>
              peripheral size
              Defines the data size of each DMA transfer to the identified peripheral.
              In memory-to-memory mode, this field identifies the memory destination if DIR = 1 and the memory source if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR = 1 and the peripheral source if DIR = 0.
              00: 8 bits
              01: 16 bits
              10: 32 bits
              11: reserved
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>MINC</name>
              <description>
              memory increment mode
              Defines the increment mode for each DMA transfer to the identified memory.
              In memory-to-memory mode, this field identifies the memory source if DIR = 1 and the memory destination if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.
              0: disabled
              1: enabled
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PINC</name>
              <description>
              peripheral increment mode
              Defines the increment mode for each DMA transfer to the identified peripheral.
              n memory-to-memory mode, this field identifies the memory destination if DIR = 1 and the 
              memory source if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR = 1 and 
              the peripheral source if DIR = 0.
              0: disabled
              1: enabled
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CIRC</name>
              <description>
              circular mode
              0: disabled
              1: enabled
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DIR</name>
              <description>
              data transfer direction
              This bit must be set only in memory-to-peripheral and peripheral-to-memory modes.
              0: read from peripheral
                 Source attributes are defined by PSIZE and PINC, plus the CPARx register. This is still valid in a memory-to-memory mode.
                 Destination attributes are defined by MSIZE and MINC, plus the CM0ARx register. This is still valid in a peripheral-to-peripheral mode.
              1: read from memory
                 Destination attributes are defined by PSIZE and PINC, plus the CPARx register. This is still valid in a memory-to-memory mode.
                 Source attributes are defined by MSIZE and MINC, plus the CM0ARx register. This is still valid in a peripheral-to-peripheral mode.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIE</name>
              <description>
              transfer error interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HTIE</name>
              <description>
              half transfer interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIE</name>
              <description>
              transfer complete interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EN</name>
              <description>
              channel enable
              When a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the ISR register is cleared (by setting the CTEIFx bit of the IFCR register).
              0: disabled
              1: enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CNDTR7</name>
          <displayName>CNDTR7</displayName>
          <description></description>
          <addressOffset>0x84</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>NDT</name>
              <description>
              number of data to transfer (0 to 2^16 - 1)
              This field is updated by hardware when the channel is enabled:
                 It is decremented after each single DMA 'read followed by write' transfer, indicating the remaining amount of data items to transfer.
                 It is kept at zero when the programmed amount of data to transfer is reached, if the channel is not in circular mode (CIRC = 0 in the CCRx register).
                 It is reloaded automatically by the previously programmed value, when the transfer is complete, if the channel is in circular mode (CIRC = 1).
              If this field is zero, no transfer can be served whatever the channel status (enabled or not).
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CPAR7</name>
          <displayName>CPAR7</displayName>
          <description></description>
          <addressOffset>0x88</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>PA</name>
              <description>
              peripheral address
              It contains the base address of the peripheral data register from/to which the data will be read/written.
              In memory-to-memory mode, this register identifies the memory destination address if DIR = 1 and the memory source address if DIR = 0.
              In peripheral-to-peripheral mode, this register identifies the peripheral destination address DIR = 1 and the peripheral source address if DIR = 0.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0AR7</name>
          <displayName>CM0AR7</displayName>
          <description></description>
          <addressOffset>0x8c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>MA</name>
              <description>
              peripheral address
              It contains the base address of the memory from/to which the data will be read/written.
              In memory-to-memory mode, this register identifies the memory source address if DIR = 1 and the memory destination address if DIR = 0.
              In peripheral-to-peripheral mode, this register identifies the peripheral source address DIR = 1 and the peripheral destination address if DIR = 0.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CBSR7</name>
          <displayName>CBSR7</displayName>
          <description></description>
          <addressOffset>0x90</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>BS</name>
              <description>
              burst size in non memory-to-memory mode
              When BS>1, DMA will transfer for BS times for each request if left NDT is larger than BS, or else transfer for left NDT times.
              When BS=0 or 1, DMA will always do single transfer for each request.
              In memory-to-memory mode, BS is ignored.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR8</name>
          <displayName>CCR8</displayName>
          <description></description>
          <addressOffset>0x94</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
            <field>
              <name>MEM2MEM</name>
              <description>
              memory-to-memory mode
              0: disabled
              1: enabled
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PL</name>
              <description>
              priority level
              00: low
              01: medium
              10: high
              11: very high
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>MSIZE</name>
              <description>
              memory size
              Defines the data size of each DMA transfer to the identified memory.
              In memory-to-memory mode, this field identifies the memory source if DIR = 1 and the memory destination if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.
              00: 8 bits
              01: 16 bits
              10: 32 bits
              11: reserved
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>PSIZE</name>
              <description>
              peripheral size
              Defines the data size of each DMA transfer to the identified peripheral.
              In memory-to-memory mode, this field identifies the memory destination if DIR = 1 and the memory source if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR = 1 and the peripheral source if DIR = 0.
              00: 8 bits
              01: 16 bits
              10: 32 bits
              11: reserved
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>MINC</name>
              <description>
              memory increment mode
              Defines the increment mode for each DMA transfer to the identified memory.
              In memory-to-memory mode, this field identifies the memory source if DIR = 1 and the memory destination if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.
              0: disabled
              1: enabled
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PINC</name>
              <description>
              peripheral increment mode
              Defines the increment mode for each DMA transfer to the identified peripheral.
              n memory-to-memory mode, this field identifies the memory destination if DIR = 1 and the 
              memory source if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR = 1 and 
              the peripheral source if DIR = 0.
              0: disabled
              1: enabled
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CIRC</name>
              <description>
              circular mode
              0: disabled
              1: enabled
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DIR</name>
              <description>
              data transfer direction
              This bit must be set only in memory-to-peripheral and peripheral-to-memory modes.
              0: read from peripheral
                 Source attributes are defined by PSIZE and PINC, plus the CPARx register. This is still valid in a memory-to-memory mode.
                 Destination attributes are defined by MSIZE and MINC, plus the CM0ARx register. This is still valid in a peripheral-to-peripheral mode.
              1: read from memory
                 Destination attributes are defined by PSIZE and PINC, plus the CPARx register. This is still valid in a memory-to-memory mode.
                 Source attributes are defined by MSIZE and MINC, plus the CM0ARx register. This is still valid in a peripheral-to-peripheral mode.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIE</name>
              <description>
              transfer error interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HTIE</name>
              <description>
              half transfer interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIE</name>
              <description>
              transfer complete interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EN</name>
              <description>
              channel enable
              When a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the ISR register is cleared (by setting the CTEIFx bit of the IFCR register).
              0: disabled
              1: enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CNDTR8</name>
          <displayName>CNDTR8</displayName>
          <description></description>
          <addressOffset>0x98</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>NDT</name>
              <description>
              number of data to transfer (0 to 2^16 - 1)
              This field is updated by hardware when the channel is enabled:
                 It is decremented after each single DMA 'read followed by write' transfer, indicating the remaining amount of data items to transfer.
                 It is kept at zero when the programmed amount of data to transfer is reached, if the channel is not in circular mode (CIRC = 0 in the CCRx register).
                 It is reloaded automatically by the previously programmed value, when the transfer is complete, if the channel is in circular mode (CIRC = 1).
              If this field is zero, no transfer can be served whatever the channel status (enabled or not).
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CPAR8</name>
          <displayName>CPAR8</displayName>
          <description></description>
          <addressOffset>0x9c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>PA</name>
              <description>
              peripheral address
              It contains the base address of the peripheral data register from/to which the data will be read/written.
              In memory-to-memory mode, this register identifies the memory destination address if DIR = 1 and the memory source address if DIR = 0.
              In peripheral-to-peripheral mode, this register identifies the peripheral destination address DIR = 1 and the peripheral source address if DIR = 0.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0AR8</name>
          <displayName>CM0AR8</displayName>
          <description></description>
          <addressOffset>0xa0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>MA</name>
              <description>
              peripheral address
              It contains the base address of the memory from/to which the data will be read/written.
              In memory-to-memory mode, this register identifies the memory source address if DIR = 1 and the memory destination address if DIR = 0.
              In peripheral-to-peripheral mode, this register identifies the peripheral source address DIR = 1 and the peripheral destination address if DIR = 0.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CBSR8</name>
          <displayName>CBSR8</displayName>
          <description></description>
          <addressOffset>0xa4</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>BS</name>
              <description>
              burst size in non-m2m mode
              When BS>1, DMA will transfer for BS times for each request if left NDT is larger than BS, or else transfer for left NDT times.
              When BS=0 or 1, DMA will always do single transfer for each request.
              In memory-to-memory mode, BS is ignored.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CSELR1</name>
          <displayName>CSELR1</displayName>
          <description></description>
          <addressOffset>0xa8</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>C4S</name>
              <description>
              DMA channel 4 selection
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>C3S</name>
              <description>
              DMA channel 3 selection
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>C2S</name>
              <description>
              DMA channel 2 selection
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>C1S</name>
              <description>
              DMA channel 1 selection
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CSELR2</name>
          <displayName>CSELR2</displayName>
          <description></description>
          <addressOffset>0xac</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>C8S</name>
              <description>
              DMA channel 8 selection
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>C7S</name>
              <description>
              DMA channel 7 selection
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>C6S</name>
              <description>
              DMA channel 6 selection
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>C5S</name>
              <description>
              DMA channel 5 selection
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>LPSYS_PINMUX</name>
      <description></description>
      <groupName>LPSYS_PINMUX</groupName>
      <baseAddress>0x40043000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>PAD_PB00</name>
          <displayName>PAD_PB00</displayName>
          <description></description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PB01</name>
          <displayName>PAD_PB01</displayName>
          <description></description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PB02</name>
          <displayName>PAD_PB02</displayName>
          <description></description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PB03</name>
          <displayName>PAD_PB03</displayName>
          <description></description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PB04</name>
          <displayName>PAD_PB04</displayName>
          <description></description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS</name>
              <description>
              Drive select. Logic LOW selects 4mA drive, logic HIGH selects 20mA drive.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MODE</name>
              <description>
              Mode select. Logic LOW enables GPIO mode, logic HIGH enables I2C mode.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PB05</name>
          <displayName>PAD_PB05</displayName>
          <description></description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS</name>
              <description>
              Drive select. Logic LOW selects 4mA drive, logic HIGH selects 20mA drive.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MODE</name>
              <description>
              Mode select. Logic LOW enables GPIO mode, logic HIGH enables I2C mode.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PB06</name>
          <displayName>PAD_PB06</displayName>
          <description></description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PB07</name>
          <displayName>PAD_PB07</displayName>
          <description></description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PB08</name>
          <displayName>PAD_PB08</displayName>
          <description></description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PB09</name>
          <displayName>PAD_PB09</displayName>
          <description></description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PB10</name>
          <displayName>PAD_PB10</displayName>
          <description></description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PB11</name>
          <displayName>PAD_PB11</displayName>
          <description></description>
          <addressOffset>0x2c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PB12</name>
          <displayName>PAD_PB12</displayName>
          <description></description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PB13</name>
          <displayName>PAD_PB13</displayName>
          <description></description>
          <addressOffset>0x34</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PB14</name>
          <displayName>PAD_PB14</displayName>
          <description></description>
          <addressOffset>0x38</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PB15</name>
          <displayName>PAD_PB15</displayName>
          <description></description>
          <addressOffset>0x3c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PB16</name>
          <displayName>PAD_PB16</displayName>
          <description></description>
          <addressOffset>0x40</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PB17</name>
          <displayName>PAD_PB17</displayName>
          <description></description>
          <addressOffset>0x44</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PB18</name>
          <displayName>PAD_PB18</displayName>
          <description></description>
          <addressOffset>0x48</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PB19</name>
          <displayName>PAD_PB19</displayName>
          <description></description>
          <addressOffset>0x4c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PB20</name>
          <displayName>PAD_PB20</displayName>
          <description></description>
          <addressOffset>0x50</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PB21</name>
          <displayName>PAD_PB21</displayName>
          <description></description>
          <addressOffset>0x54</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PB22</name>
          <displayName>PAD_PB22</displayName>
          <description></description>
          <addressOffset>0x58</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PB23</name>
          <displayName>PAD_PB23</displayName>
          <description></description>
          <addressOffset>0x5c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PB24</name>
          <displayName>PAD_PB24</displayName>
          <description></description>
          <addressOffset>0x60</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PB25</name>
          <displayName>PAD_PB25</displayName>
          <description></description>
          <addressOffset>0x64</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PB26</name>
          <displayName>PAD_PB26</displayName>
          <description></description>
          <addressOffset>0x68</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PB27</name>
          <displayName>PAD_PB27</displayName>
          <description></description>
          <addressOffset>0x6c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PB28</name>
          <displayName>PAD_PB28</displayName>
          <description></description>
          <addressOffset>0x70</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PB29</name>
          <displayName>PAD_PB29</displayName>
          <description></description>
          <addressOffset>0x74</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PB30</name>
          <displayName>PAD_PB30</displayName>
          <description></description>
          <addressOffset>0x78</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PB31</name>
          <displayName>PAD_PB31</displayName>
          <description></description>
          <addressOffset>0x7c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PB32</name>
          <displayName>PAD_PB32</displayName>
          <description></description>
          <addressOffset>0x80</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PB33</name>
          <displayName>PAD_PB33</displayName>
          <description></description>
          <addressOffset>0x84</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PB34</name>
          <displayName>PAD_PB34</displayName>
          <description></description>
          <addressOffset>0x88</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PB35</name>
          <displayName>PAD_PB35</displayName>
          <description></description>
          <addressOffset>0x8c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PB36</name>
          <displayName>PAD_PB36</displayName>
          <description></description>
          <addressOffset>0x90</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PB37</name>
          <displayName>PAD_PB37</displayName>
          <description></description>
          <addressOffset>0x94</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PB38</name>
          <displayName>PAD_PB38</displayName>
          <description></description>
          <addressOffset>0x98</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PB39</name>
          <displayName>PAD_PB39</displayName>
          <description></description>
          <addressOffset>0x9c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PB40</name>
          <displayName>PAD_PB40</displayName>
          <description></description>
          <addressOffset>0xa0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PB41</name>
          <displayName>PAD_PB41</displayName>
          <description></description>
          <addressOffset>0xa4</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PB42</name>
          <displayName>PAD_PB42</displayName>
          <description></description>
          <addressOffset>0xa8</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PB43</name>
          <displayName>PAD_PB43</displayName>
          <description></description>
          <addressOffset>0xac</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS</name>
              <description>
              Drive select. Logic LOW selects 4mA drive, logic HIGH selects 20mA drive.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MODE</name>
              <description>
              Mode select. Logic LOW enables GPIO mode, logic HIGH enables I2C mode.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PB44</name>
          <displayName>PAD_PB44</displayName>
          <description></description>
          <addressOffset>0xb0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS</name>
              <description>
              Drive select. Logic LOW selects 4mA drive, logic HIGH selects 20mA drive.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MODE</name>
              <description>
              Mode select. Logic LOW enables GPIO mode, logic HIGH enables I2C mode.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PB45</name>
          <displayName>PAD_PB45</displayName>
          <description></description>
          <addressOffset>0xb4</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS</name>
              <description>
              Drive select. Logic LOW selects 4mA drive, logic HIGH selects 20mA drive.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MODE</name>
              <description>
              Mode select. Logic LOW enables GPIO mode, logic HIGH enables I2C mode.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PB46</name>
          <displayName>PAD_PB46</displayName>
          <description></description>
          <addressOffset>0xb8</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS</name>
              <description>
              Drive select. Logic LOW selects 4mA drive, logic HIGH selects 20mA drive.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MODE</name>
              <description>
              Mode select. Logic LOW enables GPIO mode, logic HIGH enables I2C mode.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PB47</name>
          <displayName>PAD_PB47</displayName>
          <description></description>
          <addressOffset>0xbc</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PB48</name>
          <displayName>PAD_PB48</displayName>
          <description></description>
          <addressOffset>0xc0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Parametric output enable. Logic LOW forces PO HIGH.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive select 1. Used to select output drive strength.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive select 0. Used to select output drive strength.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input select. Logic LOW selects CMOS input, and logic HIGH selects Schmitt input.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input enable. Logic HIGH enables the input buffer.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull select. Logic HIGH selects pull-up, logic LOW selected pull-down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull enable. Logic HIGH enables weak pull device.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>USART3</name>
      <description></description>
      <groupName>USART</groupName>
      <baseAddress>0x40045000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CR1</name>
          <displayName>CR1</displayName>
          <description>Control Register 1</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>M</name>
              <description>
              Mode bit indicates the length of the packet, including data bits and parity. Stop bits not included.
              0: 6 bits (e.g. 6 data bits + no parity bit)
              1: 7 bits (e.g. 6 data bits + 1 parity bit)
              2: 8 bits (e.g. 7 data bits + 1 parity bit, or 6 data bits + 2 parity bits)
              3: 9 bits (e.g. 8 data bits + 1 parity bit, or 7 data bits + 2 parity bits)
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>RSVD5</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>OVER8</name>
              <description>
              Oversampling mode
              0: Oversampling by 16
              1: Oversampling by 8
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD6</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD7</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD8</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PCE</name>
              <description>
              Parity check enable. If enabled, parity bit is inserted at the MSB position 
              0: parity check disabled
              1: parity check enabled
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Parity select
              0: even parity
              1: odd parity
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PEIE</name>
              <description>
              Parity error interrupt enable
              0: interrupt disabled
              1: interrupt is generated whenever PE=1 in the ISR register
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TXEIE</name>
              <description>
              Tx empty interrupt enable
              0: interrupt disabled
              1: interrupt is generated whenver TXE=1 in the ISR register
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIE</name>
              <description>
              Transfer compelete interrupt enable
              0: interrupt disabled
              1: interrupt is generated whenever TC=1 in the ISR register
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RXNEIE</name>
              <description>
              Rx not empty interrupt enable
              0: interrupt disabled
              1: interrupt is generated whenever RXNE=1 in the ISR register
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IDLEIE</name>
              <description>
              Idle line interrupt enable
              0: interrupt disabled
              1: interrupt is generated whenever IDLE=1 in the ISR  register
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TE</name>
              <description>
              Transmitter enable
              0: transmitter is disabled
              1: transmitter is enabled
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RE</name>
              <description>
              Receiver enable
              0: receiver is disabled
              1: receiver is enabled
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD9</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UE</name>
              <description>
              USART enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CR2</name>
          <displayName>CR2</displayName>
          <description>Control Register 2</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD5</name>
              <description>
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD6</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD7</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD8</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD9</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD10</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>STOP</name>
              <description>
              Stop bits
              0/1: 1 stop bit
              2/3: 2 stop bits
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD11</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD12</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD13</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD14</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD15</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD16</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD17</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD18</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD19</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CR3</name>
          <displayName>CR3</displayName>
          <description>Control Register 3</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD5</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD6</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD7</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD8</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD9</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD10</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OVRDIS</name>
              <description>
              Overrun disable
              0: overrun error flag (ORE) will be set if new data received but previous data not read. New data will not overwrite the content in RDR register.
              1: overrun disabled. If new data is received before previous data is read, the new data will overwrite the content in RDR register and ORE flag remains unset.
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ONEBIT</name>
              <description>
              One bit sampling mode
              0: 3-bit sampling mode, the sampling value is determined by the voted result out of 3 bits
              1: 1-bit sampling mode
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTSIE</name>
              <description>
              CTS interrupt enable
              0: interrupt disabled
              1: interrupt is generated whenever CTSIF=1 in the ISR register
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTSE</name>
              <description>
              CTS enable
              0: CTS hardware flow control disabled
              1: CTS hardware flow control enabled, data is transmitted only when CTS input is asserted low
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RTSE</name>
              <description>
              RTS enable
              0: RTS hardware flow control disabled
              1: RTS hardware flow control enabled, RTS output is asserted low when new data can be received
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMAT</name>
              <description>
              Transmitter DMA enable
              0: DMA mode disabled for transmission
              1: DMA mode enabled for transmission
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMAR</name>
              <description>
              Receiver DMA enable
              0: DMA mode disabled for reception
              1: DMA mode enabled for reception
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD11</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD12</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD13</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD14</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD15</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EIE</name>
              <description>
              Error interrupt enable
              0: interrupt disabled
              1: interrupt is generated whenever FE=1 or ORE=1 or NF=1 in the ISR register
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BRR</name>
          <displayName>BRR</displayName>
          <description>Baud Rate Register</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>INT</name>
              <description>
              Integer part of baud rate prescaler
              If OVER8 = 0, Baud Rate = 48000000 / (INT + FRAC/16) / 16
              If OVER8 = 1, Baud Rate = 48000000 / (INT + FRAC/16) / 8
              For example:
              OVER=0, INT=3, FRAC=0, Baud Rate = 48000000/(3+0)/16 = 1Mbps
              OVER=0, INT=3, FRAC=4, Baud Rate = 48000000/(3+4/16)/16 = 923077 = 921600 + 1.6
              OVER=1, INT=52, FRAC=1, Baud Rate = 48000000/(52+1/16)/8 = 115246 = 115200 + 0.4
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
            <field>
              <name>FRAC</name>
              <description>
              Fractional part of baud rate prescaler
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD1</name>
          <displayName>RSVD1</displayName>
          <description></description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>RQR</name>
          <displayName>RQR</displayName>
          <description>Request Register</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>27</bitWidth>
            </field>
            <field>
              <name>TXFRQ</name>
              <description>
              Tx data flush request Reserved-Do not modify
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RXFRQ</name>
              <description>
              Rx data flush request. Write 1 to clear the RXNE flag and discard the current data in RDR
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ISR</name>
          <displayName>ISR</displayName>
          <description>Interrupt and Status Register</description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x020000C0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD5</name>
              <description>
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD6</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD7</name>
              <description>
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD8</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD9</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD10</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD11</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD12</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD13</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD14</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD15</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTS</name>
              <description>
              CTS input. Read this bit to get the raw status of the CTS line.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTSIF</name>
              <description>
              CTS interrupt flag. This bit is set by hardware whenever CTS input toggles.
              0: no change on the CTS line
              1: there is a change on the CTS line
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD16</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TXE</name>
              <description>
              Tx data empty
              0: data is ready in TDR
              1: data is already transferred to shift register, i.e. transmission is in progress or complete
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TC</name>
              <description>
              transmission complete. This bit is set by hardware if the transmission is complete
              0: transmission is not complete
              1: transmission is complete
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RXNE</name>
              <description>
              Rx data not empty. This bit is set by hardware when the received data is transferred into RDR register.
              0: data is not received
              1: data is ready in RDR to be read
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IDLE</name>
              <description>
              Idle line detected
              0: no idle line is detected
              1: idle line is detected
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ORE</name>
              <description>
              Overrun error. When new data is received but Rx buffer is not empty (i.e. previous data is not read yet), ORE is asserted and current RDR content is not lost. This feature can be disabled by set CR3_OVRDIS to 1.
              0: no overrun error
              1: overrun error is detected
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>NF</name>
              <description>
              Noise flag. Noise means the samping values in the 3-bit sampling mode are not the same.
              0: no noise is detected
              1: noise is detected
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FE</name>
              <description>
              Framing error. This bit is set by hardware when stop bit is not correctly received
              0: no framing error is detected
              1: framing error is detected
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Parity error. This bit is set when a parity error is detected in the received packet.
              0: no parity error
              1: parity error detected
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ICR</name>
          <displayName>ICR</displayName>
          <description>Interrupt flag Clear Register</description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD5</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>RSVD6</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD7</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD8</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTSCF</name>
              <description>
              CTS clear flag. Writing 1 to this bit clears the CTSIF flag in the ISR register.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD9</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD10</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCCF</name>
              <description>
              Transmission complete clear flag. Writing 1 to this bit clears the TC flag in the ISR register.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD11</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IDLECF</name>
              <description>
              Idle line detected clear flag. Writing 1 to this bit clears the IDLECF flag in the ISR register.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ORECF</name>
              <description>
              Overrun error clear flag. Writing 1 to this bit clears the ORE flag in the ISR register.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>NCF</name>
              <description>
              Noise detected clear flag. Writing 1 to this bit clears the NF flag in the ISR register.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FECF</name>
              <description>
              Framing error clear flag. Writing 1 to this bit clears the FE flag in the ISR register.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PECF</name>
              <description>
              Parity error clear flag. Wriring 1 to this bit clears the PE flag in the ISR register.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RDR</name>
          <displayName>RDR</displayName>
          <description>Receive Data Register</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>RDR</name>
              <description>
              Received data
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TDR</name>
          <displayName>TDR</displayName>
          <description>Transmit Data Register</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>TDR</name>
              <description>
              Transmit data
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>MISCR</name>
          <displayName>MISCR</displayName>
          <description>Miscellaneous Register</description>
          <addressOffset>0x2c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>RTSBIT</name>
              <description>
              assert RTS ahead of the frame completion (in number of bits) Reserved-Do not modify
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>SMPLINI</name>
              <description>
              initial sample count, count down from this value to zero to reach the middle of the start bit in Rx Reserved-Do not modify
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>USART4</name>
      <description></description>
      <groupName>USART</groupName>
      <baseAddress>0x40046000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CR1</name>
          <displayName>CR1</displayName>
          <description>Control Register 1</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>M</name>
              <description>
              Mode bit indicates the length of the packet, including data bits and parity. Stop bits not included.
              0: 6 bits (e.g. 6 data bits + no parity bit)
              1: 7 bits (e.g. 6 data bits + 1 parity bit)
              2: 8 bits (e.g. 7 data bits + 1 parity bit, or 6 data bits + 2 parity bits)
              3: 9 bits (e.g. 8 data bits + 1 parity bit, or 7 data bits + 2 parity bits)
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>RSVD5</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>OVER8</name>
              <description>
              Oversampling mode
              0: Oversampling by 16
              1: Oversampling by 8
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD6</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD7</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD8</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PCE</name>
              <description>
              Parity check enable. If enabled, parity bit is inserted at the MSB position 
              0: parity check disabled
              1: parity check enabled
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Parity select
              0: even parity
              1: odd parity
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PEIE</name>
              <description>
              Parity error interrupt enable
              0: interrupt disabled
              1: interrupt is generated whenever PE=1 in the ISR register
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TXEIE</name>
              <description>
              Tx empty interrupt enable
              0: interrupt disabled
              1: interrupt is generated whenver TXE=1 in the ISR register
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIE</name>
              <description>
              Transfer compelete interrupt enable
              0: interrupt disabled
              1: interrupt is generated whenever TC=1 in the ISR register
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RXNEIE</name>
              <description>
              Rx not empty interrupt enable
              0: interrupt disabled
              1: interrupt is generated whenever RXNE=1 in the ISR register
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IDLEIE</name>
              <description>
              Idle line interrupt enable
              0: interrupt disabled
              1: interrupt is generated whenever IDLE=1 in the ISR  register
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TE</name>
              <description>
              Transmitter enable
              0: transmitter is disabled
              1: transmitter is enabled
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RE</name>
              <description>
              Receiver enable
              0: receiver is disabled
              1: receiver is enabled
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD9</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UE</name>
              <description>
              USART enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CR2</name>
          <displayName>CR2</displayName>
          <description>Control Register 2</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD5</name>
              <description>
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD6</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD7</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD8</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD9</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD10</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>STOP</name>
              <description>
              Stop bits
              0/1: 1 stop bit
              2/3: 2 stop bits
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD11</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD12</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD13</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD14</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD15</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD16</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD17</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD18</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD19</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CR3</name>
          <displayName>CR3</displayName>
          <description>Control Register 3</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD5</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD6</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD7</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD8</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD9</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD10</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OVRDIS</name>
              <description>
              Overrun disable
              0: overrun error flag (ORE) will be set if new data received but previous data not read. New data will not overwrite the content in RDR register.
              1: overrun disabled. If new data is received before previous data is read, the new data will overwrite the content in RDR register and ORE flag remains unset.
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ONEBIT</name>
              <description>
              One bit sampling mode
              0: 3-bit sampling mode, the sampling value is determined by the voted result out of 3 bits
              1: 1-bit sampling mode
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTSIE</name>
              <description>
              CTS interrupt enable
              0: interrupt disabled
              1: interrupt is generated whenever CTSIF=1 in the ISR register
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTSE</name>
              <description>
              CTS enable
              0: CTS hardware flow control disabled
              1: CTS hardware flow control enabled, data is transmitted only when CTS input is asserted low
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RTSE</name>
              <description>
              RTS enable
              0: RTS hardware flow control disabled
              1: RTS hardware flow control enabled, RTS output is asserted low when new data can be received
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMAT</name>
              <description>
              Transmitter DMA enable
              0: DMA mode disabled for transmission
              1: DMA mode enabled for transmission
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMAR</name>
              <description>
              Receiver DMA enable
              0: DMA mode disabled for reception
              1: DMA mode enabled for reception
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD11</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD12</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD13</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD14</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD15</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EIE</name>
              <description>
              Error interrupt enable
              0: interrupt disabled
              1: interrupt is generated whenever FE=1 or ORE=1 or NF=1 in the ISR register
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BRR</name>
          <displayName>BRR</displayName>
          <description>Baud Rate Register</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>INT</name>
              <description>
              Integer part of baud rate prescaler
              If OVER8 = 0, Baud Rate = 48000000 / (INT + FRAC/16) / 16
              If OVER8 = 1, Baud Rate = 48000000 / (INT + FRAC/16) / 8
              For example:
              OVER=0, INT=3, FRAC=0, Baud Rate = 48000000/(3+0)/16 = 1Mbps
              OVER=0, INT=3, FRAC=4, Baud Rate = 48000000/(3+4/16)/16 = 923077 = 921600 + 1.6
              OVER=1, INT=52, FRAC=1, Baud Rate = 48000000/(52+1/16)/8 = 115246 = 115200 + 0.4
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
            <field>
              <name>FRAC</name>
              <description>
              Fractional part of baud rate prescaler
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD1</name>
          <displayName>RSVD1</displayName>
          <description></description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>RQR</name>
          <displayName>RQR</displayName>
          <description>Request Register</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>27</bitWidth>
            </field>
            <field>
              <name>TXFRQ</name>
              <description>
              Tx data flush request Reserved-Do not modify
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RXFRQ</name>
              <description>
              Rx data flush request. Write 1 to clear the RXNE flag and discard the current data in RDR
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ISR</name>
          <displayName>ISR</displayName>
          <description>Interrupt and Status Register</description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x020000C0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD5</name>
              <description>
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD6</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD7</name>
              <description>
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD8</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD9</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD10</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD11</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD12</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD13</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD14</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD15</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTS</name>
              <description>
              CTS input. Read this bit to get the raw status of the CTS line.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTSIF</name>
              <description>
              CTS interrupt flag. This bit is set by hardware whenever CTS input toggles.
              0: no change on the CTS line
              1: there is a change on the CTS line
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD16</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TXE</name>
              <description>
              Tx data empty
              0: data is ready in TDR
              1: data is already transferred to shift register, i.e. transmission is in progress or complete
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TC</name>
              <description>
              transmission complete. This bit is set by hardware if the transmission is complete
              0: transmission is not complete
              1: transmission is complete
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RXNE</name>
              <description>
              Rx data not empty. This bit is set by hardware when the received data is transferred into RDR register.
              0: data is not received
              1: data is ready in RDR to be read
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IDLE</name>
              <description>
              Idle line detected
              0: no idle line is detected
              1: idle line is detected
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ORE</name>
              <description>
              Overrun error. When new data is received but Rx buffer is not empty (i.e. previous data is not read yet), ORE is asserted and current RDR content is not lost. This feature can be disabled by set CR3_OVRDIS to 1.
              0: no overrun error
              1: overrun error is detected
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>NF</name>
              <description>
              Noise flag. Noise means the samping values in the 3-bit sampling mode are not the same.
              0: no noise is detected
              1: noise is detected
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FE</name>
              <description>
              Framing error. This bit is set by hardware when stop bit is not correctly received
              0: no framing error is detected
              1: framing error is detected
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Parity error. This bit is set when a parity error is detected in the received packet.
              0: no parity error
              1: parity error detected
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ICR</name>
          <displayName>ICR</displayName>
          <description>Interrupt flag Clear Register</description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD5</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>RSVD6</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD7</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD8</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTSCF</name>
              <description>
              CTS clear flag. Writing 1 to this bit clears the CTSIF flag in the ISR register.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD9</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD10</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCCF</name>
              <description>
              Transmission complete clear flag. Writing 1 to this bit clears the TC flag in the ISR register.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD11</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IDLECF</name>
              <description>
              Idle line detected clear flag. Writing 1 to this bit clears the IDLECF flag in the ISR register.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ORECF</name>
              <description>
              Overrun error clear flag. Writing 1 to this bit clears the ORE flag in the ISR register.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>NCF</name>
              <description>
              Noise detected clear flag. Writing 1 to this bit clears the NF flag in the ISR register.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FECF</name>
              <description>
              Framing error clear flag. Writing 1 to this bit clears the FE flag in the ISR register.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PECF</name>
              <description>
              Parity error clear flag. Wriring 1 to this bit clears the PE flag in the ISR register.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RDR</name>
          <displayName>RDR</displayName>
          <description>Receive Data Register</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>RDR</name>
              <description>
              Received data
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TDR</name>
          <displayName>TDR</displayName>
          <description>Transmit Data Register</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>TDR</name>
              <description>
              Transmit data
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>MISCR</name>
          <displayName>MISCR</displayName>
          <description>Miscellaneous Register</description>
          <addressOffset>0x2c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>RTSBIT</name>
              <description>
              assert RTS ahead of the frame completion (in number of bits) Reserved-Do not modify
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>SMPLINI</name>
              <description>
              initial sample count, count down from this value to zero to reach the middle of the start bit in Rx Reserved-Do not modify
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>USART5</name>
      <description></description>
      <groupName>USART</groupName>
      <baseAddress>0x40047000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CR1</name>
          <displayName>CR1</displayName>
          <description>Control Register 1</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>M</name>
              <description>
              Mode bit indicates the length of the packet, including data bits and parity. Stop bits not included.
              0: 6 bits (e.g. 6 data bits + no parity bit)
              1: 7 bits (e.g. 6 data bits + 1 parity bit)
              2: 8 bits (e.g. 7 data bits + 1 parity bit, or 6 data bits + 2 parity bits)
              3: 9 bits (e.g. 8 data bits + 1 parity bit, or 7 data bits + 2 parity bits)
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>RSVD5</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>OVER8</name>
              <description>
              Oversampling mode
              0: Oversampling by 16
              1: Oversampling by 8
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD6</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD7</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD8</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PCE</name>
              <description>
              Parity check enable. If enabled, parity bit is inserted at the MSB position 
              0: parity check disabled
              1: parity check enabled
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Parity select
              0: even parity
              1: odd parity
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PEIE</name>
              <description>
              Parity error interrupt enable
              0: interrupt disabled
              1: interrupt is generated whenever PE=1 in the ISR register
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TXEIE</name>
              <description>
              Tx empty interrupt enable
              0: interrupt disabled
              1: interrupt is generated whenver TXE=1 in the ISR register
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIE</name>
              <description>
              Transfer compelete interrupt enable
              0: interrupt disabled
              1: interrupt is generated whenever TC=1 in the ISR register
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RXNEIE</name>
              <description>
              Rx not empty interrupt enable
              0: interrupt disabled
              1: interrupt is generated whenever RXNE=1 in the ISR register
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IDLEIE</name>
              <description>
              Idle line interrupt enable
              0: interrupt disabled
              1: interrupt is generated whenever IDLE=1 in the ISR  register
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TE</name>
              <description>
              Transmitter enable
              0: transmitter is disabled
              1: transmitter is enabled
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RE</name>
              <description>
              Receiver enable
              0: receiver is disabled
              1: receiver is enabled
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD9</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UE</name>
              <description>
              USART enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CR2</name>
          <displayName>CR2</displayName>
          <description>Control Register 2</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD5</name>
              <description>
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD6</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD7</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD8</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD9</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD10</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>STOP</name>
              <description>
              Stop bits
              0/1: 1 stop bit
              2/3: 2 stop bits
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD11</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD12</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD13</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD14</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD15</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD16</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD17</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD18</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD19</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CR3</name>
          <displayName>CR3</displayName>
          <description>Control Register 3</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD5</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD6</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD7</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD8</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD9</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD10</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OVRDIS</name>
              <description>
              Overrun disable
              0: overrun error flag (ORE) will be set if new data received but previous data not read. New data will not overwrite the content in RDR register.
              1: overrun disabled. If new data is received before previous data is read, the new data will overwrite the content in RDR register and ORE flag remains unset.
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ONEBIT</name>
              <description>
              One bit sampling mode
              0: 3-bit sampling mode, the sampling value is determined by the voted result out of 3 bits
              1: 1-bit sampling mode
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTSIE</name>
              <description>
              CTS interrupt enable
              0: interrupt disabled
              1: interrupt is generated whenever CTSIF=1 in the ISR register
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTSE</name>
              <description>
              CTS enable
              0: CTS hardware flow control disabled
              1: CTS hardware flow control enabled, data is transmitted only when CTS input is asserted low
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RTSE</name>
              <description>
              RTS enable
              0: RTS hardware flow control disabled
              1: RTS hardware flow control enabled, RTS output is asserted low when new data can be received
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMAT</name>
              <description>
              Transmitter DMA enable
              0: DMA mode disabled for transmission
              1: DMA mode enabled for transmission
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMAR</name>
              <description>
              Receiver DMA enable
              0: DMA mode disabled for reception
              1: DMA mode enabled for reception
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD11</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD12</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD13</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD14</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD15</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EIE</name>
              <description>
              Error interrupt enable
              0: interrupt disabled
              1: interrupt is generated whenever FE=1 or ORE=1 or NF=1 in the ISR register
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BRR</name>
          <displayName>BRR</displayName>
          <description>Baud Rate Register</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>INT</name>
              <description>
              Integer part of baud rate prescaler
              If OVER8 = 0, Baud Rate = 48000000 / (INT + FRAC/16) / 16
              If OVER8 = 1, Baud Rate = 48000000 / (INT + FRAC/16) / 8
              For example:
              OVER=0, INT=3, FRAC=0, Baud Rate = 48000000/(3+0)/16 = 1Mbps
              OVER=0, INT=3, FRAC=4, Baud Rate = 48000000/(3+4/16)/16 = 923077 = 921600 + 1.6
              OVER=1, INT=52, FRAC=1, Baud Rate = 48000000/(52+1/16)/8 = 115246 = 115200 + 0.4
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
            <field>
              <name>FRAC</name>
              <description>
              Fractional part of baud rate prescaler
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD1</name>
          <displayName>RSVD1</displayName>
          <description></description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>RQR</name>
          <displayName>RQR</displayName>
          <description>Request Register</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>27</bitWidth>
            </field>
            <field>
              <name>TXFRQ</name>
              <description>
              Tx data flush request Reserved-Do not modify
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RXFRQ</name>
              <description>
              Rx data flush request. Write 1 to clear the RXNE flag and discard the current data in RDR
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ISR</name>
          <displayName>ISR</displayName>
          <description>Interrupt and Status Register</description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x020000C0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD5</name>
              <description>
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD6</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD7</name>
              <description>
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD8</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD9</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD10</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD11</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD12</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD13</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD14</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD15</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTS</name>
              <description>
              CTS input. Read this bit to get the raw status of the CTS line.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTSIF</name>
              <description>
              CTS interrupt flag. This bit is set by hardware whenever CTS input toggles.
              0: no change on the CTS line
              1: there is a change on the CTS line
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD16</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TXE</name>
              <description>
              Tx data empty
              0: data is ready in TDR
              1: data is already transferred to shift register, i.e. transmission is in progress or complete
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TC</name>
              <description>
              transmission complete. This bit is set by hardware if the transmission is complete
              0: transmission is not complete
              1: transmission is complete
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RXNE</name>
              <description>
              Rx data not empty. This bit is set by hardware when the received data is transferred into RDR register.
              0: data is not received
              1: data is ready in RDR to be read
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IDLE</name>
              <description>
              Idle line detected
              0: no idle line is detected
              1: idle line is detected
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ORE</name>
              <description>
              Overrun error. When new data is received but Rx buffer is not empty (i.e. previous data is not read yet), ORE is asserted and current RDR content is not lost. This feature can be disabled by set CR3_OVRDIS to 1.
              0: no overrun error
              1: overrun error is detected
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>NF</name>
              <description>
              Noise flag. Noise means the samping values in the 3-bit sampling mode are not the same.
              0: no noise is detected
              1: noise is detected
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FE</name>
              <description>
              Framing error. This bit is set by hardware when stop bit is not correctly received
              0: no framing error is detected
              1: framing error is detected
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Parity error. This bit is set when a parity error is detected in the received packet.
              0: no parity error
              1: parity error detected
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ICR</name>
          <displayName>ICR</displayName>
          <description>Interrupt flag Clear Register</description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD5</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>RSVD6</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD7</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD8</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTSCF</name>
              <description>
              CTS clear flag. Writing 1 to this bit clears the CTSIF flag in the ISR register.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD9</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD10</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCCF</name>
              <description>
              Transmission complete clear flag. Writing 1 to this bit clears the TC flag in the ISR register.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD11</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IDLECF</name>
              <description>
              Idle line detected clear flag. Writing 1 to this bit clears the IDLECF flag in the ISR register.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ORECF</name>
              <description>
              Overrun error clear flag. Writing 1 to this bit clears the ORE flag in the ISR register.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>NCF</name>
              <description>
              Noise detected clear flag. Writing 1 to this bit clears the NF flag in the ISR register.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FECF</name>
              <description>
              Framing error clear flag. Writing 1 to this bit clears the FE flag in the ISR register.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PECF</name>
              <description>
              Parity error clear flag. Wriring 1 to this bit clears the PE flag in the ISR register.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RDR</name>
          <displayName>RDR</displayName>
          <description>Receive Data Register</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>RDR</name>
              <description>
              Received data
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TDR</name>
          <displayName>TDR</displayName>
          <description>Transmit Data Register</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>TDR</name>
              <description>
              Transmit data
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>MISCR</name>
          <displayName>MISCR</displayName>
          <description>Miscellaneous Register</description>
          <addressOffset>0x2c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>RTSBIT</name>
              <description>
              assert RTS ahead of the frame completion (in number of bits) Reserved-Do not modify
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>SMPLINI</name>
              <description>
              initial sample count, count down from this value to zero to reach the middle of the start bit in Rx Reserved-Do not modify
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>SPI3</name>
      <description></description>
      <groupName>SPI</groupName>
      <baseAddress>0x40049000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>TOP_CTRL</name>
          <displayName>TOP_CTRL</displayName>
          <description>Top Control Register</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>13</bitWidth>
            </field>
            <field>
              <name>TTELP</name>
              <description>
              TXD Three-state Enable On Last Phase 0 = TXDx is three-stated 1/2 clock cycle after the beginning of the LSB 1 = TXDx output signal is three-stated on the clock edge that ends the LSB
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TTE</name>
              <description>
              TXD Three-State Enable 0 = TXDx output signal is not three-stated 1 = TXD is three-stated when not transmitting data
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SCFR</name>
              <description>
              Slave Clock Free Running 0 = Clock input to SSPSCLKx is continuously running 1 = Clock input to SSPSCLKx is only active during data transfers. 
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IFS</name>
              <description>
              Invert Frame Signal 0 = SSPSFRMx polarity is determined by the PSP polarity bits 1 = SSPSFRMx will be inverted from normal-SSPSFRMx (as defined by the PSP polarity bits). (Works in all frame formats: SPI, SSP, and PSP)
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HOLD_FRAME_LOW</name>
              <description>
              Hold Frame Low Control 1=After this field is set to 1 and the SSP is operating in master mode, the output frame clock ssp_sfrm_gpio will hold low. Used for SPI and NMW Format Rx FIFO Auto Full Control, which makes the frame clock is still low during there's no bit clock, or the data transfers before the stop clock will be discarded.  
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TRAIL</name>
              <description>
              Trailing Byte 0 = Trailing bytes are handled by CPU 1 = Trailing bytes are handled by DMA bursts
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SPH</name>
              <description>
              Motorola SPI SSPSCLK phase setting 0 = SSPSCLKx is inactive until one cycle after the start of a frame and active until 1/2 cycle before the end of a frame 1 = SSPSCLKx is inactive until 1/2 cycle after the start of a frame and active until one cycle before the end of a frame
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SPO</name>
              <description>
              Motorola SPI SSPSCLK Polarity Setting 0 = The inactive or idle state of SSPSCLKx is low 1 = The inactive or idle state of SSPSCLKx is high
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DSS</name>
              <description>
              SSP Work data size,  register bits value 0~31 indicated data size 1~32 bits,  usually use data size 8bits, 16bits, 24bits, 32bits
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>SFRMDIR</name>
              <description>
              SSP Frame (SSPSFRMx) Direction 0 = Master mode, SSPx port drives SSPSFRMx 1 = Slave mode, SSPx port receives SSPSFRMx
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SCLKDIR</name>
              <description>
              SSP Serial Bit Rate Clock (SSPSCLKx) Direction 0 = Master mode, SSPx port drives SSPSCLKx 1 = Slave mode, SSPx port receives SSPSCLKx
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FRF</name>
              <description>
              Frame Format 0x0 = Motorola* Serial Peripheral Interface (SPI)  0x1 = Texas Instruments* Synchronous Serial Protocol (SSP) 0x2 = National Semiconductor Microwire* 0x3 = Programmable Serial Protocol (PSP) 
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>SSE</name>
              <description>
              Synchronous Serial Port Enable 0 = SSPx port is disabled  1 = SSPx port is enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>FIFO_CTRL</name>
          <displayName>FIFO_CTRL</displayName>
          <description>FIFO Control Register</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>14</bitWidth>
            </field>
            <field>
              <name>RXFIFO_AUTO_FULL_CTRL</name>
              <description>
              Rx FIFO Auto Full Control =1After this field is set to 1 and the SSP is operating in master mode, the SSP FSM returns to IDLE state and stops the ssp_sclk_gpio. When Rx FIFO is full, the SSP FSM continues transferring data after the Rx FIFO is not full. This field is used to avoid an Rx FIFO overrun issue. 1= Enable Rx FIFO auto full control
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FPCKE</name>
              <description>
              FIFO Packing Enable 0 = FIFO packing mode disabled 1 = FIFO packing mode enabled
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TXFIFO_WR_ENDIAN</name>
              <description>
              apb_pwdata Write to Tx FIFO Endian 0x0 = txfifo_wdata[31:0] = apb_pwdata[31:0] 0x1 = fifo_wdata[31:0] = {apb_pwdata[15:0], apb_pwdata[31:16]} 0x2 = txfifo_wdata[31:0] = {apb_pwdata[7:0], apb_pwdata[15:8], apb_pwdata[23:16], apb_pwdata[31:24]} 0x3 = txfifo_wdata[31:0] = {apb_pwdata[23:16], apb_pwdata[31:24], apb_pwdata[7:0], apb_pwdata[15:8]}
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RXFIFO_RD_ENDIAN</name>
              <description>
              apb_prdata Read from Rx FIFO Endian 0x0 = apb_prdata[31:0] = rxfifo_wdata[31:0] 0x1 = apb_prdata[31:0] = {rxfifo_wdata[15:0], rxfifo_wdata[31:16]} 0x2 = apb_prdata[31:0]= {rxfifo_wdata[7:0], rxfifo_wdata[15:8], rxfifo_wdata[23:16], rxfifo_wdata[31:24]} 0x3 = apb_prdata[31:0]= {rxfifo_wdata[23:16], rxfifo_wdata[31:24], rxfifo_wdata[7:0], rxfifo_wdata[15:8]}
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSRE</name>
              <description>
              Receive Service Request Enable 0 = DMA service request is disabled 1 = DMA service request is enabled
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TSRE</name>
              <description>
              Transmit Service Request Enable 0 = DMA service request is disabled 1 = DMA service request is enabled
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RFT</name>
              <description>
              RXFIFO Trigger Threshold This field sets the threshold level at which RXFIFO asserts interrupt. The level should be set to the preferred threshold value minus 1.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>TFT</name>
              <description>
              TXFIFO Trigger Threshold This field sets the threshold level at which TXFIFO asserts interrupt. The level should be set to the preferred threshold value minus 1. 
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>INTE</name>
          <displayName>INTE</displayName>
          <description>Interrupt Enable Register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>26</bitWidth>
            </field>
            <field>
              <name>TIM</name>
              <description>
              Transmit FIFO Underrun Interrupt Mask 0 = TUR events generate an SSP interrupt 1 = TUR events do NOT generate an SSP interrupt 
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RIM</name>
              <description>
              Receive FIFO Overrun Interrupt Mask 0 = ROR events generate an SSP interrupt 1 = ROR events do NOT generate an SSP interrupt 
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TIE</name>
              <description>
              Transmit FIFO Interrupt Enable 0 = TXFIFO threshold-level-reached interrupt is disabled 1 = TXFIFO threshold-level-reached interrupt is enabled
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RIE</name>
              <description>
              Receive FIFO Interrupt Enable 0 = RXFIFO threshold-level-reached interrupt is disabled 1 = RXFIFO threshold-level-reached interrupt is enabled
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TINTE</name>
              <description>
              Receiver Time-out Interrupt Enable 0 = Receiver time-out interrupt is disabled 1 = Receiver time-out interrupt is enabled
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TO</name>
          <displayName>TO</displayName>
          <description>SPI Time Out Register</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>TIMEOUT</name>
              <description>
              Timeout Value TIMEOUT value is the value (0 to 2&lt;super 24>-1) that defines the time-out interval. The time-out interval is given by the equation shown in the TIMEOUT Interval Equation.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DATA</name>
          <displayName>DATA</displayName>
          <description>SPI DATA Register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              DATA This field is used for data to be written to the TXFIFO read from the RXFIFO.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS</name>
          <displayName>STATUS</displayName>
          <description>Status Register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>OSS</name>
              <description>
              Odd Sample Status 0 = RxFIFO entry has two samples 1 = RxFIFO entry has one sample  Note that this bit needs to be looked at only when FIFO Packing is enabled (&lt;FIFO Packing Enable> field in SSP FIFO Control Register is set). Otherwise, this bit is zero. When SSPx port is in Packed mode and the CPU is used instead of DMA to read the RxFIFO, the CPU should make sure that &lt;Receive FIFO Not Empty> = 1 AND this field = 0 before it attempts to read the RxFIFO.
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TX_OSS</name>
              <description>
              TX FIFO Odd Sample Status When SSPx port is in packed mode, the number of samples in the TX FIFO is:  (&lt;Transmit FIFO Level>*2 + this field), when &lt;Transmit FIFO Not Full> = 1 32, when &lt;Transmit FIFO Not Full> = 0. The TX FIFO cannot accept new data when &lt;Transmit FIFO Not Full> = 1 and &lt;Transmit FIFO Level> = 15 and this field = 1. (The TX FIFO has 31 samples).  0 = TxFIFO entry has an even number of samples 1 = TxFIFO entry has an odd number of samples Note that this bit needs to be read only when FIFO Packing is enabled (&lt;FIFO Packing Enable> in the SSP FIFO Control Register is set). Otherwise, this bit is zero.
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BCE</name>
              <description>
              Bit Count Error 0 = The SSPx port has not experienced a bit count error 1 = The SSPSFRMx signal was asserted when the bit counter was not zero
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ROR</name>
              <description>
              Receive FIFO Overrun 0 = RXFIFO has not experienced an overrun 1 = Attempted data write to full RXFIFO, causes an interrupt request
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RFL</name>
              <description>
              Receive FIFO Level This field is the number of entries minus one in RXFIFO. When the value 0x1F is read, the RXFIFO is either empty or full, and software should read the &lt;Receive FIFO Not Empty> field.
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>RNE</name>
              <description>
              Receive FIFO Not Empty 0 = RXFIFO is empty 1 = RXFIFO is not empty
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RFS</name>
              <description>
              Receive FIFO Service Request 0 = RXFIFO level is at or below RFT threshold (RFT) or SSPx port is disabled 1 = RXFIFO level exceeds RFT threshold (RFT), causes an interrupt request
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TUR</name>
              <description>
              Transmit FIFO Underrun 0 = The TXFIFO has not experienced an underrun 1 = A read from the TXFIFO was attempted when the TXFIFO was empty, causes an interrupt if it is enabled (&lt;Transmit FIFO Underrun Interrupt Mask> in the SSP INT EN Register  is 0)
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TFL</name>
              <description>
              Transmit FIFO Level This field is the number of entries in TXFIFO.When the value 0x0 is read, the TXFIFO is either empty or full, and software should read the &lt;Transmit FIFO Not Full> field.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>TNF</name>
              <description>
              Transmit FIFO Not Full 0 = TXFIFO is full 1 = TXFIFO is not full
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TFS</name>
              <description>
              Transmit FIFO Service Request 0 = TX FIFO level exceeds the TFT threshold (TFT + 1) or SSPx port disabled 1 = TXFIFO level is at or below TFT threshold (TFT + 1), causes an interrupt request
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EOC</name>
              <description>
              End Of Chain 0 = DMA has not signaled an end of chain condition 1 = DMA has signaled an end of chain condition
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TINT</name>
              <description>
              Receiver Time-out Interrupt 0 = No receiver time-out is pending 1 = Receiver time-out pending, causes an interrupt request
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PINT</name>
              <description>
              Peripheral Trailing Byte Interrupt 0 = No peripheral trailing byte interrupt is pending 1 = Peripheral trailing byte interrupt is pending
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CSS</name>
              <description>
              Clock Synchronization Status 0 = The SSPx port is ready for slave clock operations 1 = The SSPx port is currently busy synchronizing slave mode signals
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BSY</name>
              <description>
              SSP Busy 0 = SSPx port is idle or disabled 1 = SSPx port is currently transmitting or receiving framed data
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD3</name>
          <displayName>RSVD3</displayName>
          <description></description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>RWOT_CTRL</name>
          <displayName>RWOT_CTRL</displayName>
          <description>SSP RWOT Control Register</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>27</bitWidth>
            </field>
            <field>
              <name>MASK_RWOT_LAST_SAMPLE</name>
              <description>
              Mask last_sample_flag in RWOT Mode 1= Mask 0 = Unmask
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CLR_RWOT_CYCLE</name>
              <description>
              Clear SSP Internal rwot_counter This field clears the rwot_counter to 0. This field is self cleared by SSP after SSE = 1. 1 = Clear rwot_counter
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SET_RWOT_CYCLE</name>
              <description>
              Set RWOT Cycle This field is used to set the value of the SSP_RWOT_CCM register to the SSP internal rwot_counter. This field is self-cleared by SSP after SSE = 1. 1 = Set rwot_counter
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CYCLE_RWOT_EN</name>
              <description>
              Enable SSP RWOT Cycle Counter Mode 1 = Enable
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RWOT</name>
              <description>
              Receive Without Transmit 0 = Transmit/receive mode 1 = Receive without transmit mode
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RWOT_CCM</name>
          <displayName>RWOT_CCM</displayName>
          <description>SSP RWOT Counter Cycles Match Register</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>SSPRWOTCCM</name>
              <description>
              It's just total ssp_sclk_gpio Cycles The value of this register defines the total number of ssp_sclk_gpio cycles when SSP works in master and RWOT mode. When the rwot_counter matches this value, SSP returns to IDLE state and does not output ssp_sclk_gpio anymore.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RWOT_CVWRN</name>
          <displayName>RWOT_CVWRN</displayName>
          <description>SSP RWOT Counter Value Write for Red Request Register</description>
          <addressOffset>0x2c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>SSPRWOTCVWR</name>
              <description>
              SSPRWOTCVWR This register prevents the risk of instability on rwot_counter value reading, it's only valid after SSP has been enabled Write 0 = No effect Write 1 = Capture value of rwot_counter Read: Returns the captured value of rwot_counter
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD2</name>
          <displayName>RSVD2</displayName>
          <description></description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>CLK_CTRL</name>
          <displayName>CLK_CTRL</displayName>
          <description>SSP CLK  Control Register</description>
          <addressOffset>0x3c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>CLK_SEL</name>
              <description>
              0: select clk_div as clk_ssp 1: select clk_sys as clk_ssp
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CLK_DIV</name>
              <description>
              div ratio from clk_sys
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD1</name>
          <displayName>RSVD1</displayName>
          <description></description>
          <addressOffset>0x40</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>TRIWIRE_CTRL</name>
          <displayName>TRIWIRE_CTRL</displayName>
          <description>SSP Three Wire Mode  Control Register</description>
          <addressOffset>0x54</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>29</bitWidth>
            </field>
            <field>
              <name>SSP_WORK_WIDTH_DYN_CHANGE</name>
              <description>
              SSP_WORK_WIDTH_DYN_CHNAGE 1=SP can dynamicly change SSP_TOP_CTRL[9:5] without disabling SSP_TOP_CTRL[0] and re-enabling SSP_TOP_CTRL[0]   
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TXD_OEN</name>
              <description>
              TXD_OEN 1=TXD is input  0=TXD is output
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SPI_TRI_WIRE_EN</name>
              <description>
              SPI_THREE_WIRE_MODE_EN 1=enable
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>SPI4</name>
      <description></description>
      <groupName>SPI</groupName>
      <baseAddress>0x4004a000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>TOP_CTRL</name>
          <displayName>TOP_CTRL</displayName>
          <description>Top Control Register</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>13</bitWidth>
            </field>
            <field>
              <name>TTELP</name>
              <description>
              TXD Three-state Enable On Last Phase 0 = TXDx is three-stated 1/2 clock cycle after the beginning of the LSB 1 = TXDx output signal is three-stated on the clock edge that ends the LSB
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TTE</name>
              <description>
              TXD Three-State Enable 0 = TXDx output signal is not three-stated 1 = TXD is three-stated when not transmitting data
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SCFR</name>
              <description>
              Slave Clock Free Running 0 = Clock input to SSPSCLKx is continuously running 1 = Clock input to SSPSCLKx is only active during data transfers. 
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IFS</name>
              <description>
              Invert Frame Signal 0 = SSPSFRMx polarity is determined by the PSP polarity bits 1 = SSPSFRMx will be inverted from normal-SSPSFRMx (as defined by the PSP polarity bits). (Works in all frame formats: SPI, SSP, and PSP)
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HOLD_FRAME_LOW</name>
              <description>
              Hold Frame Low Control 1=After this field is set to 1 and the SSP is operating in master mode, the output frame clock ssp_sfrm_gpio will hold low. Used for SPI and NMW Format Rx FIFO Auto Full Control, which makes the frame clock is still low during there's no bit clock, or the data transfers before the stop clock will be discarded.  
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TRAIL</name>
              <description>
              Trailing Byte 0 = Trailing bytes are handled by CPU 1 = Trailing bytes are handled by DMA bursts
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SPH</name>
              <description>
              Motorola SPI SSPSCLK phase setting 0 = SSPSCLKx is inactive until one cycle after the start of a frame and active until 1/2 cycle before the end of a frame 1 = SSPSCLKx is inactive until 1/2 cycle after the start of a frame and active until one cycle before the end of a frame
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SPO</name>
              <description>
              Motorola SPI SSPSCLK Polarity Setting 0 = The inactive or idle state of SSPSCLKx is low 1 = The inactive or idle state of SSPSCLKx is high
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DSS</name>
              <description>
              SSP Work data size,  register bits value 0~31 indicated data size 1~32 bits,  usually use data size 8bits, 16bits, 24bits, 32bits
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>SFRMDIR</name>
              <description>
              SSP Frame (SSPSFRMx) Direction 0 = Master mode, SSPx port drives SSPSFRMx 1 = Slave mode, SSPx port receives SSPSFRMx
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SCLKDIR</name>
              <description>
              SSP Serial Bit Rate Clock (SSPSCLKx) Direction 0 = Master mode, SSPx port drives SSPSCLKx 1 = Slave mode, SSPx port receives SSPSCLKx
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FRF</name>
              <description>
              Frame Format 0x0 = Motorola* Serial Peripheral Interface (SPI)  0x1 = Texas Instruments* Synchronous Serial Protocol (SSP) 0x2 = National Semiconductor Microwire* 0x3 = Programmable Serial Protocol (PSP) 
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>SSE</name>
              <description>
              Synchronous Serial Port Enable 0 = SSPx port is disabled  1 = SSPx port is enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>FIFO_CTRL</name>
          <displayName>FIFO_CTRL</displayName>
          <description>FIFO Control Register</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>14</bitWidth>
            </field>
            <field>
              <name>RXFIFO_AUTO_FULL_CTRL</name>
              <description>
              Rx FIFO Auto Full Control =1After this field is set to 1 and the SSP is operating in master mode, the SSP FSM returns to IDLE state and stops the ssp_sclk_gpio. When Rx FIFO is full, the SSP FSM continues transferring data after the Rx FIFO is not full. This field is used to avoid an Rx FIFO overrun issue. 1= Enable Rx FIFO auto full control
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FPCKE</name>
              <description>
              FIFO Packing Enable 0 = FIFO packing mode disabled 1 = FIFO packing mode enabled
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TXFIFO_WR_ENDIAN</name>
              <description>
              apb_pwdata Write to Tx FIFO Endian 0x0 = txfifo_wdata[31:0] = apb_pwdata[31:0] 0x1 = fifo_wdata[31:0] = {apb_pwdata[15:0], apb_pwdata[31:16]} 0x2 = txfifo_wdata[31:0] = {apb_pwdata[7:0], apb_pwdata[15:8], apb_pwdata[23:16], apb_pwdata[31:24]} 0x3 = txfifo_wdata[31:0] = {apb_pwdata[23:16], apb_pwdata[31:24], apb_pwdata[7:0], apb_pwdata[15:8]}
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RXFIFO_RD_ENDIAN</name>
              <description>
              apb_prdata Read from Rx FIFO Endian 0x0 = apb_prdata[31:0] = rxfifo_wdata[31:0] 0x1 = apb_prdata[31:0] = {rxfifo_wdata[15:0], rxfifo_wdata[31:16]} 0x2 = apb_prdata[31:0]= {rxfifo_wdata[7:0], rxfifo_wdata[15:8], rxfifo_wdata[23:16], rxfifo_wdata[31:24]} 0x3 = apb_prdata[31:0]= {rxfifo_wdata[23:16], rxfifo_wdata[31:24], rxfifo_wdata[7:0], rxfifo_wdata[15:8]}
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSRE</name>
              <description>
              Receive Service Request Enable 0 = DMA service request is disabled 1 = DMA service request is enabled
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TSRE</name>
              <description>
              Transmit Service Request Enable 0 = DMA service request is disabled 1 = DMA service request is enabled
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RFT</name>
              <description>
              RXFIFO Trigger Threshold This field sets the threshold level at which RXFIFO asserts interrupt. The level should be set to the preferred threshold value minus 1.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>TFT</name>
              <description>
              TXFIFO Trigger Threshold This field sets the threshold level at which TXFIFO asserts interrupt. The level should be set to the preferred threshold value minus 1. 
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>INTE</name>
          <displayName>INTE</displayName>
          <description>Interrupt Enable Register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>26</bitWidth>
            </field>
            <field>
              <name>TIM</name>
              <description>
              Transmit FIFO Underrun Interrupt Mask 0 = TUR events generate an SSP interrupt 1 = TUR events do NOT generate an SSP interrupt 
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RIM</name>
              <description>
              Receive FIFO Overrun Interrupt Mask 0 = ROR events generate an SSP interrupt 1 = ROR events do NOT generate an SSP interrupt 
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TIE</name>
              <description>
              Transmit FIFO Interrupt Enable 0 = TXFIFO threshold-level-reached interrupt is disabled 1 = TXFIFO threshold-level-reached interrupt is enabled
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RIE</name>
              <description>
              Receive FIFO Interrupt Enable 0 = RXFIFO threshold-level-reached interrupt is disabled 1 = RXFIFO threshold-level-reached interrupt is enabled
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TINTE</name>
              <description>
              Receiver Time-out Interrupt Enable 0 = Receiver time-out interrupt is disabled 1 = Receiver time-out interrupt is enabled
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TO</name>
          <displayName>TO</displayName>
          <description>SPI Time Out Register</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>TIMEOUT</name>
              <description>
              Timeout Value TIMEOUT value is the value (0 to 2&lt;super 24>-1) that defines the time-out interval. The time-out interval is given by the equation shown in the TIMEOUT Interval Equation.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DATA</name>
          <displayName>DATA</displayName>
          <description>SPI DATA Register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              DATA This field is used for data to be written to the TXFIFO read from the RXFIFO.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS</name>
          <displayName>STATUS</displayName>
          <description>Status Register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>OSS</name>
              <description>
              Odd Sample Status 0 = RxFIFO entry has two samples 1 = RxFIFO entry has one sample  Note that this bit needs to be looked at only when FIFO Packing is enabled (&lt;FIFO Packing Enable> field in SSP FIFO Control Register is set). Otherwise, this bit is zero. When SSPx port is in Packed mode and the CPU is used instead of DMA to read the RxFIFO, the CPU should make sure that &lt;Receive FIFO Not Empty> = 1 AND this field = 0 before it attempts to read the RxFIFO.
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TX_OSS</name>
              <description>
              TX FIFO Odd Sample Status When SSPx port is in packed mode, the number of samples in the TX FIFO is:  (&lt;Transmit FIFO Level>*2 + this field), when &lt;Transmit FIFO Not Full> = 1 32, when &lt;Transmit FIFO Not Full> = 0. The TX FIFO cannot accept new data when &lt;Transmit FIFO Not Full> = 1 and &lt;Transmit FIFO Level> = 15 and this field = 1. (The TX FIFO has 31 samples).  0 = TxFIFO entry has an even number of samples 1 = TxFIFO entry has an odd number of samples Note that this bit needs to be read only when FIFO Packing is enabled (&lt;FIFO Packing Enable> in the SSP FIFO Control Register is set). Otherwise, this bit is zero.
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BCE</name>
              <description>
              Bit Count Error 0 = The SSPx port has not experienced a bit count error 1 = The SSPSFRMx signal was asserted when the bit counter was not zero
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ROR</name>
              <description>
              Receive FIFO Overrun 0 = RXFIFO has not experienced an overrun 1 = Attempted data write to full RXFIFO, causes an interrupt request
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RFL</name>
              <description>
              Receive FIFO Level This field is the number of entries minus one in RXFIFO. When the value 0x1F is read, the RXFIFO is either empty or full, and software should read the &lt;Receive FIFO Not Empty> field.
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>RNE</name>
              <description>
              Receive FIFO Not Empty 0 = RXFIFO is empty 1 = RXFIFO is not empty
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RFS</name>
              <description>
              Receive FIFO Service Request 0 = RXFIFO level is at or below RFT threshold (RFT) or SSPx port is disabled 1 = RXFIFO level exceeds RFT threshold (RFT), causes an interrupt request
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TUR</name>
              <description>
              Transmit FIFO Underrun 0 = The TXFIFO has not experienced an underrun 1 = A read from the TXFIFO was attempted when the TXFIFO was empty, causes an interrupt if it is enabled (&lt;Transmit FIFO Underrun Interrupt Mask> in the SSP INT EN Register  is 0)
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TFL</name>
              <description>
              Transmit FIFO Level This field is the number of entries in TXFIFO.When the value 0x0 is read, the TXFIFO is either empty or full, and software should read the &lt;Transmit FIFO Not Full> field.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>TNF</name>
              <description>
              Transmit FIFO Not Full 0 = TXFIFO is full 1 = TXFIFO is not full
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TFS</name>
              <description>
              Transmit FIFO Service Request 0 = TX FIFO level exceeds the TFT threshold (TFT + 1) or SSPx port disabled 1 = TXFIFO level is at or below TFT threshold (TFT + 1), causes an interrupt request
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EOC</name>
              <description>
              End Of Chain 0 = DMA has not signaled an end of chain condition 1 = DMA has signaled an end of chain condition
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TINT</name>
              <description>
              Receiver Time-out Interrupt 0 = No receiver time-out is pending 1 = Receiver time-out pending, causes an interrupt request
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PINT</name>
              <description>
              Peripheral Trailing Byte Interrupt 0 = No peripheral trailing byte interrupt is pending 1 = Peripheral trailing byte interrupt is pending
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CSS</name>
              <description>
              Clock Synchronization Status 0 = The SSPx port is ready for slave clock operations 1 = The SSPx port is currently busy synchronizing slave mode signals
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BSY</name>
              <description>
              SSP Busy 0 = SSPx port is idle or disabled 1 = SSPx port is currently transmitting or receiving framed data
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD3</name>
          <displayName>RSVD3</displayName>
          <description></description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>RWOT_CTRL</name>
          <displayName>RWOT_CTRL</displayName>
          <description>SSP RWOT Control Register</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>27</bitWidth>
            </field>
            <field>
              <name>MASK_RWOT_LAST_SAMPLE</name>
              <description>
              Mask last_sample_flag in RWOT Mode 1= Mask 0 = Unmask
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CLR_RWOT_CYCLE</name>
              <description>
              Clear SSP Internal rwot_counter This field clears the rwot_counter to 0. This field is self cleared by SSP after SSE = 1. 1 = Clear rwot_counter
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SET_RWOT_CYCLE</name>
              <description>
              Set RWOT Cycle This field is used to set the value of the SSP_RWOT_CCM register to the SSP internal rwot_counter. This field is self-cleared by SSP after SSE = 1. 1 = Set rwot_counter
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CYCLE_RWOT_EN</name>
              <description>
              Enable SSP RWOT Cycle Counter Mode 1 = Enable
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RWOT</name>
              <description>
              Receive Without Transmit 0 = Transmit/receive mode 1 = Receive without transmit mode
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RWOT_CCM</name>
          <displayName>RWOT_CCM</displayName>
          <description>SSP RWOT Counter Cycles Match Register</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>SSPRWOTCCM</name>
              <description>
              It's just total ssp_sclk_gpio Cycles The value of this register defines the total number of ssp_sclk_gpio cycles when SSP works in master and RWOT mode. When the rwot_counter matches this value, SSP returns to IDLE state and does not output ssp_sclk_gpio anymore.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RWOT_CVWRN</name>
          <displayName>RWOT_CVWRN</displayName>
          <description>SSP RWOT Counter Value Write for Red Request Register</description>
          <addressOffset>0x2c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>SSPRWOTCVWR</name>
              <description>
              SSPRWOTCVWR This register prevents the risk of instability on rwot_counter value reading, it's only valid after SSP has been enabled Write 0 = No effect Write 1 = Capture value of rwot_counter Read: Returns the captured value of rwot_counter
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD2</name>
          <displayName>RSVD2</displayName>
          <description></description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>CLK_CTRL</name>
          <displayName>CLK_CTRL</displayName>
          <description>SSP CLK  Control Register</description>
          <addressOffset>0x3c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>CLK_SEL</name>
              <description>
              0: select clk_div as clk_ssp 1: select clk_sys as clk_ssp
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CLK_DIV</name>
              <description>
              div ratio from clk_sys
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD1</name>
          <displayName>RSVD1</displayName>
          <description></description>
          <addressOffset>0x40</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>TRIWIRE_CTRL</name>
          <displayName>TRIWIRE_CTRL</displayName>
          <description>SSP Three Wire Mode  Control Register</description>
          <addressOffset>0x54</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>29</bitWidth>
            </field>
            <field>
              <name>SSP_WORK_WIDTH_DYN_CHANGE</name>
              <description>
              SSP_WORK_WIDTH_DYN_CHNAGE 1=SP can dynamicly change SSP_TOP_CTRL[9:5] without disabling SSP_TOP_CTRL[0] and re-enabling SSP_TOP_CTRL[0]   
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TXD_OEN</name>
              <description>
              TXD_OEN 1=TXD is input  0=TXD is output
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SPI_TRI_WIRE_EN</name>
              <description>
              SPI_THREE_WIRE_MODE_EN 1=enable
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>I2C4</name>
      <description></description>
      <groupName>I2C</groupName>
      <baseAddress>0x4004c000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CR</name>
          <displayName>CR</displayName>
          <description>Control register</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>UR</name>
              <description>
              Unit Reset. Software need first assert to reset then deassert to release.
              0 = No reset.
              1 = Reset I2C module.
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSTREQ</name>
              <description>
              I2C will do bus reset upon this bit set. Will be cleared by HW automatically after RSTCYC cycles of SCL generated.
              1 = request for i2c bus reset
              0 = bus reset finished
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BRGRST</name>
              <description>
              Reset bus related state machine and signals. Will be cleared by HW automatically
              1 = request for reset
              0 = reset finished
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>14</bitWidth>
            </field>
            <field>
              <name>DNF</name>
              <description>
              Digital noise filter
              These bits are used to configure the digital noise filter on SDA and SCL input. The digital filter will filter spikes with a length of up to DNF*Tfclk.
              0: Digital filter disabled 
              1: Digital filter enabled and filtering capability up to 1 Tfclk
              ...
              7: digital filter enabled and filtering capability up to 7 Tfclk
              Note: Digital filter is added to analog filter. Digital filter will introduce delay on SCL and SDA processing, which is essential in hs-mode. 
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>SCLPP</name>
              <description>
              Push-pull mode Enable for SCL.
              0 = open drain output for SCL.
              1 = Push-pull output for SCL
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MSDE</name>
              <description>
              Master Stop Detected Enable:
              0 = Master Stop Detect (MSD) status is not enabled.
              1 = Master Stop Detect (MSD) status is enabled.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LASTSTOP</name>
              <description>
              Generate STOP for last DMA transfer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LASTNACK</name>
              <description>
              Generate NACK for last DMA Read transfer
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMAEN</name>
              <description>
              DMA Enable for both TX and RX
              0 = DMA mode is NOT enabled
              1 = DMA mode enabled
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SCLE</name>
              <description>
              SCL Enable:
              0 = Disables the I2C from driving the SCL line.
              1 = Enables the I2C clock output for master-mode operation.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IUE</name>
              <description>
              I2C Unit Enable:
              0 = Disables the unit and does not master any transactions or respond to any slave transactions.
              1 = Enables the I2C (defaults to slave-receive mode).
              Software must guarantee the I2C bus is idle before setting this bit.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MODE</name>
              <description>
              Bus Mode (Master operation):
              2'b00: standard-mode
              2'b01: fast-mode and fast-mode plus
              2'b10: HS-mode (standard mode when not doing a high speed transfer)
              2'b11: HS-mode (fast mode when not doing a high speed transfer)
              Bus Mode (Slave operation):
              2'b0x: HS-mode is disabled. I2C unit uses Standard/Fast mode timing on the SDA pin.
              2'b1x: HS-mode is enabled. I2C unit uses HS-mode timing on the SDA pin when a master code is received.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TCR</name>
          <displayName>TCR</displayName>
          <description>Transfer Control register</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>ABORTDMA</name>
              <description>
              Abort DMA operation. Will be cleared by HW automatically
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RXREQ</name>
              <description>
              Request DMA RX. Will be cleared by HW automatically
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TXREQ</name>
              <description>
              Request DMA TX. Will be cleared by HW automatically
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MA</name>
              <description>
              Master Abort:
              Used by the I2C in master mode to generate a Stop without transmitting another data byte:
              0 = The I2C transmits Stop on if TCR[STOP] is set.
              1 = The I2C sends Stop without data transmission.
              When in master-transmit mode, after transmitting a data byte, the TCR[TB] bit is cleared. When no more data bytes need to be sent, setting master abort bit sends the Stop. The TCR[TB] bit must remain clear.
              In master-receive mode, when a NAK is sent without a Stop (TCR[STOP] bit was not set) and CPU does not send a repeated Start, setting this bit sends the Stop. Once again, the TCR[TB] bit must remain clear. Master Abort can be done immediately after the address phase (Master Transmit mode only).
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>NACK</name>
              <description>
              The positive/negative acknowledge control bit, defines the type of acknowledge pulse sent by the I2C when in master receive mode:
              0 = Send a positive acknowledge (ACK) pulse after receiving a data byte.
              1 = Send a negative acknowledge (NACK) pulse after receiving a data byte.
              The I2C automatically sends an ACK pulse when responding to its slave address or when responding in slave-receive mode, regardless of the NACK control-bit setting.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>STOP</name>
              <description>
              Stop:
              Used to initiate a Stop condition after transferring the next data byte on the I2C bus when in master mode. In master-receive mode, the NACK control bit must be set in conjunction with the STOP bit. 
              0 = Do not send a Stop.
              1 = Send a Stop.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>START</name>
              <description>
              Start:
              Used to initiate a Start condition to the I2C unit when in master mode. 
              0 = Do not send a Start pulse.
              1 = Send a Start pulse.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TB</name>
              <description>
              Transfer Byte:
              Used to send or receive a byte on the I2C bus:
              0 = Cleared by I2C when the byte is sent/received.
              1 = Send/receive a byte. 
              CPU can monitor this bit to determine when the byte transfer has completed. In master or slave mode, after each byte transfer including acknowledge pulse, the I2C holds the SCL line low (inserting wait states) until TB is set.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IER</name>
          <displayName>IER</displayName>
          <description>Interrupt Enable register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>UFIE</name>
              <description>
              FIFO Underflow Interrupt Enable
              0 = FIFO Underflow interrupt is not enabled
              1 = FIFO Underflow interrupt is enabled
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OFIE</name>
              <description>
              FIFO Overflow Interrupt Enable
              0 = FIFO Overflow interrupt is not enabled
              1 = FIFO Overflow interrupt is enabled
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMADONEIE</name>
              <description>
              DMA Transaction Done Interrupt Enable
              0 = DMA Transaction done interrupt is not enabled.
              1 = DMA Transaction done interrupt is enabled.
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MSDIE</name>
              <description>
              Master Stop Detected Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C unit to interrupt upon detecting a Master Stop sent by the I2C unit.
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BEDIE</name>
              <description>
              Bus Error Detected Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C to interrupt for the following I2C bus errors:
              As a master transmitter, no ACK was detected after a byte was sent.
              As a slave receiver, the I2C generated a NACK pulse.
              Software is responsible for guaranteeing that misplaced Start and Stop conditions do not occur.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SADIE</name>
              <description>
              Slave Address Detected Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C to interrupt upon detecting a slave address match or a general call address.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RFIE</name>
              <description>
              DBR Receive Full Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C to interrupt when the DBR has received a data byte from the I2C bus.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIE</name>
              <description>
              DBR Transmit Empty Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C to interrupt after transmitting a byte onto the I2C bus.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ALDIE</name>
              <description>
              Arbitration Loss Detected Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C to interrupt upon losing arbitration while in master mode.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SSDIE</name>
              <description>
              Slave Stop Detected Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C to interrupt when it detects a Stop condition while in slave mode.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SR</name>
          <displayName>SR</displayName>
          <description>Status register</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>UF</name>
              <description>
              FIFO Underflow Flag. Asserted when FIFO is empty and a POP request generated without a PUSH. Cleared if write 1
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OF</name>
              <description>
              FIFO Overflow Flag. Asserted when FIFO is full and a PUSH request generated without a POP. Cleared if write 1
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMADONE</name>
              <description>
              DMA Transaction Done. Asserted when both APB and I2C bus have finished transfer. Cleared if write 1
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MSD</name>
              <description>
              Master Stop Detected:
              0 = No Master Stop Detected.
              1 = This bit is set by the I2C unit when all of the following are true:
              This bit is enabled (CR[MSDE] = 1);
              I2C unit is configured as a master;
              I2C transmits a STOP signal
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EBB</name>
              <description>
              Early Bus Busy
              0 = I2C bus is idle or the I2C is using the bus (that is, unit busy).
              1 = Set when the unit detects that the SCL or SDA line is low without a START condition. Bit will remain set until the I2C unit detects the bus is idle by detecting a STOP condition. Bit will also be set whenever the IBB bit is set.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BED</name>
              <description>
              Bus Error Detected:
              0 = No error detected.
              1 = The I2C sets this bit when it detects one of the following error conditions:
              As a master transmitter, no ACK was detected on the interface after a byte was sent.
              As a slave receiver, the I2C generates a NACK pulse.
              When an error occurs, I2C bus transactions continue. Software must guarantee that misplaced Start and Stop conditions do not occur. 
              Cleared if write 1
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SAD</name>
              <description>
              Slave Address Detected:
              0 = No slave address was detected.
              1 = The I2C detected a seven-bit address that matches the general call address or SAR. An interrupt is signalled when enabled in the CR. 
              Cleared if write 1
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RF</name>
              <description>
              DBR Receive Full:
              0 = The DBR has not received a new data byte or the I2C is idle.
              1 = The DBR register received a new data byte from the I2C bus. An interrupt is signalled when enabled in the CR. 
              Cleared if write 1
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TE</name>
              <description>
              DBR Transmit Empty:
              0 = The data byte is still being transmitted.
              1 = The I2C has finished transmitting a data byte on the I2C bus. An interrupt is signalled when enabled in the CR.
              Cleared if write 1
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ALD</name>
              <description>
              Arbitration Loss Detected:
              Used during multi-master operation:
              0 = Cleared when arbitration is won or never took place.
              1 = Set when the I2C loses arbitration. 
              Cleared if write 1
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SSD</name>
              <description>
              Slave Stop Detected:
              0 = No Stop detected.
              1 = Set when the I2C detects a Stop while in slave-receive or slave-transmit mode. 
              Cleared if write 1
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IBB</name>
              <description>
              I2C Bus Busy:
              0 = I2C bus is idle or the I2C is using the bus (that is, unit busy).
              1 = Set when the I2C bus is busy but local I2C is not involved in the transaction.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UB</name>
              <description>
              Unit Busy:
              0 = I2C not busy.
              1 = Set when local I2C is busy. This is defined as the time between the first Start and Stop. 
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>NACK</name>
              <description>
              ACK/NACK Status:
              0 = The I2C received or sent an ACK on the bus. 
              1 = The I2C received or sent a NACK.on the bus.
              This bit is used in slave-transmit mode to determine when the byte transferred is the last one. This bit is updated after each byte and ACK/NACK information is received.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RWM</name>
              <description>
              Read/write Mode:
              0 = The I2C is in master-transmit or slave-receive mode. 
              1 = The I2C is in master-receive or slave-transmit mode. 
              This is the R/nW bit of the slave address. It is cleared automatically by hardware after a Stop state.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DBR</name>
          <displayName>DBR</displayName>
          <description>Data Buffer register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>DATA</name>
              <description>
              use the I2C Data Buffer register to transmit and receive data from the I2C bus. The DBR is accessed by software on one Side and by the I2C Shift register on the other. The DBR receives data coming into the I2C unit after a full byte is received and acknowledged. CPU writes data going out of the I2C to the DBR and sends it to the serial bus. 
              When the I2C is in transmit mode (master or slave), CPU writes data to the DBR over the internal bus. CPU write data to the DBR when a master transaction is initiated or when the DBR transmit-empty interrupt is signalled. Data moves from the DBR to the Shift register when the transfer byte bit is set. The DBR transmit-empty interrupt is signalled (if enabled) when a byte is transferred on the I2C bus and the acknowledge cycle is complete. If the DBR is not written, and a Stop condition is not in place before the I2C bus is ready to transfer the next byte packet, the I2C unit inserts wait states until CPU writes the DBR and sets the transfer byte bit.
              When the I2C is in receive mode (master or slave), CPU reads DBR data over the internal bus. CPU reads data from the DBR when the DBR receive-full interrupt is signalled. The data moves from the Shift register to the DBR when the acknowledge cycle is complete. The I2C inserts wait states until the DBR is read. After the software reads the DBR, CR[NACK] are written by the software, allowing the next byte transfer to proceed to the I2C bus.
              In DMA mode, DBR is automatically filled from FIFO in master transmit mode, or fetched and stored in FIFO in master receive mode until DMA done or aborted.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SAR</name>
          <displayName>SAR</displayName>
          <description>Slave Address Register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000047</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>25</bitWidth>
            </field>
            <field>
              <name>ADDR</name>
              <description>
              The seven-bit address to which the I2C responds when in slave-receive mode
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>LCR</name>
          <displayName>LCR</displayName>
          <description>Load Count Register</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x081C3675</resetValue>
          <fields>
            <field>
              <name>HLVH</name>
              <description>
              Decrementer Load value for High Speed Mode SCL (master mode) for high phase. 
              Thigh=Tfclk*(HLVH+4+DNF)
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>HLVL</name>
              <description>
              Decrementer Load value for High Speed Mode SCL (master mode) for low phase. 
              Tlow=Tfclk*(HLVL+3+DNF). Data rate is generated as 1/(Thigh+Tlow), or Ffclk/(HLVH+HLVL+7+2*DNF). 
              3.2Mbps data rate is generated by default if fclk is 48MHz.
              HLVL also controls setup time and hold time for START and STOP condition in High Speed Mode(master mode). 
              Thdsta=Tsusta=Tsusto=Tfclk*(HLVL+1)
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
            <field>
              <name>FLV</name>
              <description>
              Decrementer Load value for Fast Mode (or Fast Mode Plus) SCL (master mode) for both high and low phase. 
              Data rate is generated as Ffclk/(FLV+max(FLV,CNT*2+6)+7+DNF) approximately. 
              FLV also controls setup time and hold time for START and STOP condition in Fast Mode(master mode). 
              Thdsta=Tsusta=Tsusto=Tfclk*FLV
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
            <field>
              <name>SLV</name>
              <description>
              Decrementer Load value for Standard Mode SCL (master mode) for both high and low phase. 
              Data rate is generated as Ffclk/(SLV+max(SLV,CNT*2+6)+7+DNF) approximately. 
              SLV also controls setup time and hold time for START and STOP condition in Standard Mode(master mode). 
              Thdsta=Tsusta=Tsusto=Tfclk*SLV
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>WCR</name>
          <displayName>WCR</displayName>
          <description>Wait Count Register</description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0000000A</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>27</bitWidth>
            </field>
            <field>
              <name>CNT</name>
              <description>
              Controls the counter values defining the setup and hold times in standard and fast mode
              Tvddat=Thddat=Tfclk*(CNT+2)
              Tsudat=max(Tlow-Thddat,Thddat)
              Lower counter values may violate setup and hold times.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RCCR</name>
          <displayName>RCCR</displayName>
          <description>Bus Reset Cycle Counter Register</description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000009</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>28</bitWidth>
            </field>
            <field>
              <name>RSTCYC</name>
              <description>
              The cycles of SCL during bus reset
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BMR</name>
          <displayName>BMR</displayName>
          <description>Bus Monitor Register</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000003</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>30</bitWidth>
            </field>
            <field>
              <name>SCL</name>
              <description>
              value of the SCL pin. Software can check bus level when the I2C bus is hung and the I2C unit must be reset.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SDA</name>
              <description>
              value of the SDA pin.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DNR</name>
          <displayName>DNR</displayName>
          <description>DMA number register</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>NDT</name>
              <description>
              Write as number of data to transfer in byte. Read as left data number to transfer
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD1</name>
          <displayName>RSVD1</displayName>
          <description></description>
          <addressOffset>0x2C</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>FIFO</name>
          <displayName>FIFO</displayName>
          <description>FIFO Register</description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>DATA</name>
              <description>
              Write to push send data into FIFO. Read to pop received data from FIFO
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>I2C5</name>
      <description></description>
      <groupName>I2C</groupName>
      <baseAddress>0x4004d000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CR</name>
          <displayName>CR</displayName>
          <description>Control register</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>UR</name>
              <description>
              Unit Reset. Software need first assert to reset then deassert to release.
              0 = No reset.
              1 = Reset I2C module.
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSTREQ</name>
              <description>
              I2C will do bus reset upon this bit set. Will be cleared by HW automatically after RSTCYC cycles of SCL generated.
              1 = request for i2c bus reset
              0 = bus reset finished
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BRGRST</name>
              <description>
              Reset bus related state machine and signals. Will be cleared by HW automatically
              1 = request for reset
              0 = reset finished
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>14</bitWidth>
            </field>
            <field>
              <name>DNF</name>
              <description>
              Digital noise filter
              These bits are used to configure the digital noise filter on SDA and SCL input. The digital filter will filter spikes with a length of up to DNF*Tfclk.
              0: Digital filter disabled 
              1: Digital filter enabled and filtering capability up to 1 Tfclk
              ...
              7: digital filter enabled and filtering capability up to 7 Tfclk
              Note: Digital filter is added to analog filter. Digital filter will introduce delay on SCL and SDA processing, which is essential in hs-mode. 
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>SCLPP</name>
              <description>
              Push-pull mode Enable for SCL.
              0 = open drain output for SCL.
              1 = Push-pull output for SCL
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MSDE</name>
              <description>
              Master Stop Detected Enable:
              0 = Master Stop Detect (MSD) status is not enabled.
              1 = Master Stop Detect (MSD) status is enabled.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LASTSTOP</name>
              <description>
              Generate STOP for last DMA transfer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LASTNACK</name>
              <description>
              Generate NACK for last DMA Read transfer
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMAEN</name>
              <description>
              DMA Enable for both TX and RX
              0 = DMA mode is NOT enabled
              1 = DMA mode enabled
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SCLE</name>
              <description>
              SCL Enable:
              0 = Disables the I2C from driving the SCL line.
              1 = Enables the I2C clock output for master-mode operation.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IUE</name>
              <description>
              I2C Unit Enable:
              0 = Disables the unit and does not master any transactions or respond to any slave transactions.
              1 = Enables the I2C (defaults to slave-receive mode).
              Software must guarantee the I2C bus is idle before setting this bit.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MODE</name>
              <description>
              Bus Mode (Master operation):
              2'b00: standard-mode
              2'b01: fast-mode and fast-mode plus
              2'b10: HS-mode (standard mode when not doing a high speed transfer)
              2'b11: HS-mode (fast mode when not doing a high speed transfer)
              Bus Mode (Slave operation):
              2'b0x: HS-mode is disabled. I2C unit uses Standard/Fast mode timing on the SDA pin.
              2'b1x: HS-mode is enabled. I2C unit uses HS-mode timing on the SDA pin when a master code is received.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TCR</name>
          <displayName>TCR</displayName>
          <description>Transfer Control register</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>ABORTDMA</name>
              <description>
              Abort DMA operation. Will be cleared by HW automatically
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RXREQ</name>
              <description>
              Request DMA RX. Will be cleared by HW automatically
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TXREQ</name>
              <description>
              Request DMA TX. Will be cleared by HW automatically
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MA</name>
              <description>
              Master Abort:
              Used by the I2C in master mode to generate a Stop without transmitting another data byte:
              0 = The I2C transmits Stop on if TCR[STOP] is set.
              1 = The I2C sends Stop without data transmission.
              When in master-transmit mode, after transmitting a data byte, the TCR[TB] bit is cleared. When no more data bytes need to be sent, setting master abort bit sends the Stop. The TCR[TB] bit must remain clear.
              In master-receive mode, when a NAK is sent without a Stop (TCR[STOP] bit was not set) and CPU does not send a repeated Start, setting this bit sends the Stop. Once again, the TCR[TB] bit must remain clear. Master Abort can be done immediately after the address phase (Master Transmit mode only).
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>NACK</name>
              <description>
              The positive/negative acknowledge control bit, defines the type of acknowledge pulse sent by the I2C when in master receive mode:
              0 = Send a positive acknowledge (ACK) pulse after receiving a data byte.
              1 = Send a negative acknowledge (NACK) pulse after receiving a data byte.
              The I2C automatically sends an ACK pulse when responding to its slave address or when responding in slave-receive mode, regardless of the NACK control-bit setting.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>STOP</name>
              <description>
              Stop:
              Used to initiate a Stop condition after transferring the next data byte on the I2C bus when in master mode. In master-receive mode, the NACK control bit must be set in conjunction with the STOP bit. 
              0 = Do not send a Stop.
              1 = Send a Stop.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>START</name>
              <description>
              Start:
              Used to initiate a Start condition to the I2C unit when in master mode. 
              0 = Do not send a Start pulse.
              1 = Send a Start pulse.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TB</name>
              <description>
              Transfer Byte:
              Used to send or receive a byte on the I2C bus:
              0 = Cleared by I2C when the byte is sent/received.
              1 = Send/receive a byte. 
              CPU can monitor this bit to determine when the byte transfer has completed. In master or slave mode, after each byte transfer including acknowledge pulse, the I2C holds the SCL line low (inserting wait states) until TB is set.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IER</name>
          <displayName>IER</displayName>
          <description>Interrupt Enable register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>UFIE</name>
              <description>
              FIFO Underflow Interrupt Enable
              0 = FIFO Underflow interrupt is not enabled
              1 = FIFO Underflow interrupt is enabled
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OFIE</name>
              <description>
              FIFO Overflow Interrupt Enable
              0 = FIFO Overflow interrupt is not enabled
              1 = FIFO Overflow interrupt is enabled
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMADONEIE</name>
              <description>
              DMA Transaction Done Interrupt Enable
              0 = DMA Transaction done interrupt is not enabled.
              1 = DMA Transaction done interrupt is enabled.
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MSDIE</name>
              <description>
              Master Stop Detected Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C unit to interrupt upon detecting a Master Stop sent by the I2C unit.
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BEDIE</name>
              <description>
              Bus Error Detected Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C to interrupt for the following I2C bus errors:
              As a master transmitter, no ACK was detected after a byte was sent.
              As a slave receiver, the I2C generated a NACK pulse.
              Software is responsible for guaranteeing that misplaced Start and Stop conditions do not occur.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SADIE</name>
              <description>
              Slave Address Detected Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C to interrupt upon detecting a slave address match or a general call address.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RFIE</name>
              <description>
              DBR Receive Full Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C to interrupt when the DBR has received a data byte from the I2C bus.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIE</name>
              <description>
              DBR Transmit Empty Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C to interrupt after transmitting a byte onto the I2C bus.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ALDIE</name>
              <description>
              Arbitration Loss Detected Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C to interrupt upon losing arbitration while in master mode.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SSDIE</name>
              <description>
              Slave Stop Detected Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C to interrupt when it detects a Stop condition while in slave mode.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SR</name>
          <displayName>SR</displayName>
          <description>Status register</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>UF</name>
              <description>
              FIFO Underflow Flag. Asserted when FIFO is empty and a POP request generated without a PUSH. Cleared if write 1
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OF</name>
              <description>
              FIFO Overflow Flag. Asserted when FIFO is full and a PUSH request generated without a POP. Cleared if write 1
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMADONE</name>
              <description>
              DMA Transaction Done. Asserted when both APB and I2C bus have finished transfer. Cleared if write 1
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MSD</name>
              <description>
              Master Stop Detected:
              0 = No Master Stop Detected.
              1 = This bit is set by the I2C unit when all of the following are true:
              This bit is enabled (CR[MSDE] = 1);
              I2C unit is configured as a master;
              I2C transmits a STOP signal
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EBB</name>
              <description>
              Early Bus Busy
              0 = I2C bus is idle or the I2C is using the bus (that is, unit busy).
              1 = Set when the unit detects that the SCL or SDA line is low without a START condition. Bit will remain set until the I2C unit detects the bus is idle by detecting a STOP condition. Bit will also be set whenever the IBB bit is set.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BED</name>
              <description>
              Bus Error Detected:
              0 = No error detected.
              1 = The I2C sets this bit when it detects one of the following error conditions:
              As a master transmitter, no ACK was detected on the interface after a byte was sent.
              As a slave receiver, the I2C generates a NACK pulse.
              When an error occurs, I2C bus transactions continue. Software must guarantee that misplaced Start and Stop conditions do not occur. 
              Cleared if write 1
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SAD</name>
              <description>
              Slave Address Detected:
              0 = No slave address was detected.
              1 = The I2C detected a seven-bit address that matches the general call address or SAR. An interrupt is signalled when enabled in the CR. 
              Cleared if write 1
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RF</name>
              <description>
              DBR Receive Full:
              0 = The DBR has not received a new data byte or the I2C is idle.
              1 = The DBR register received a new data byte from the I2C bus. An interrupt is signalled when enabled in the CR. 
              Cleared if write 1
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TE</name>
              <description>
              DBR Transmit Empty:
              0 = The data byte is still being transmitted.
              1 = The I2C has finished transmitting a data byte on the I2C bus. An interrupt is signalled when enabled in the CR.
              Cleared if write 1
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ALD</name>
              <description>
              Arbitration Loss Detected:
              Used during multi-master operation:
              0 = Cleared when arbitration is won or never took place.
              1 = Set when the I2C loses arbitration. 
              Cleared if write 1
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SSD</name>
              <description>
              Slave Stop Detected:
              0 = No Stop detected.
              1 = Set when the I2C detects a Stop while in slave-receive or slave-transmit mode. 
              Cleared if write 1
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IBB</name>
              <description>
              I2C Bus Busy:
              0 = I2C bus is idle or the I2C is using the bus (that is, unit busy).
              1 = Set when the I2C bus is busy but local I2C is not involved in the transaction.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UB</name>
              <description>
              Unit Busy:
              0 = I2C not busy.
              1 = Set when local I2C is busy. This is defined as the time between the first Start and Stop. 
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>NACK</name>
              <description>
              ACK/NACK Status:
              0 = The I2C received or sent an ACK on the bus. 
              1 = The I2C received or sent a NACK.on the bus.
              This bit is used in slave-transmit mode to determine when the byte transferred is the last one. This bit is updated after each byte and ACK/NACK information is received.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RWM</name>
              <description>
              Read/write Mode:
              0 = The I2C is in master-transmit or slave-receive mode. 
              1 = The I2C is in master-receive or slave-transmit mode. 
              This is the R/nW bit of the slave address. It is cleared automatically by hardware after a Stop state.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DBR</name>
          <displayName>DBR</displayName>
          <description>Data Buffer register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>DATA</name>
              <description>
              use the I2C Data Buffer register to transmit and receive data from the I2C bus. The DBR is accessed by software on one Side and by the I2C Shift register on the other. The DBR receives data coming into the I2C unit after a full byte is received and acknowledged. CPU writes data going out of the I2C to the DBR and sends it to the serial bus. 
              When the I2C is in transmit mode (master or slave), CPU writes data to the DBR over the internal bus. CPU write data to the DBR when a master transaction is initiated or when the DBR transmit-empty interrupt is signalled. Data moves from the DBR to the Shift register when the transfer byte bit is set. The DBR transmit-empty interrupt is signalled (if enabled) when a byte is transferred on the I2C bus and the acknowledge cycle is complete. If the DBR is not written, and a Stop condition is not in place before the I2C bus is ready to transfer the next byte packet, the I2C unit inserts wait states until CPU writes the DBR and sets the transfer byte bit.
              When the I2C is in receive mode (master or slave), CPU reads DBR data over the internal bus. CPU reads data from the DBR when the DBR receive-full interrupt is signalled. The data moves from the Shift register to the DBR when the acknowledge cycle is complete. The I2C inserts wait states until the DBR is read. After the software reads the DBR, CR[NACK] are written by the software, allowing the next byte transfer to proceed to the I2C bus.
              In DMA mode, DBR is automatically filled from FIFO in master transmit mode, or fetched and stored in FIFO in master receive mode until DMA done or aborted.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SAR</name>
          <displayName>SAR</displayName>
          <description>Slave Address Register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000047</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>25</bitWidth>
            </field>
            <field>
              <name>ADDR</name>
              <description>
              The seven-bit address to which the I2C responds when in slave-receive mode
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>LCR</name>
          <displayName>LCR</displayName>
          <description>Load Count Register</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x081C3675</resetValue>
          <fields>
            <field>
              <name>HLVH</name>
              <description>
              Decrementer Load value for High Speed Mode SCL (master mode) for high phase. 
              Thigh=Tfclk*(HLVH+4+DNF)
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>HLVL</name>
              <description>
              Decrementer Load value for High Speed Mode SCL (master mode) for low phase. 
              Tlow=Tfclk*(HLVL+3+DNF). Data rate is generated as 1/(Thigh+Tlow), or Ffclk/(HLVH+HLVL+7+2*DNF). 
              3.2Mbps data rate is generated by default if fclk is 48MHz.
              HLVL also controls setup time and hold time for START and STOP condition in High Speed Mode(master mode). 
              Thdsta=Tsusta=Tsusto=Tfclk*(HLVL+1)
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
            <field>
              <name>FLV</name>
              <description>
              Decrementer Load value for Fast Mode (or Fast Mode Plus) SCL (master mode) for both high and low phase. 
              Data rate is generated as Ffclk/(FLV+max(FLV,CNT*2+6)+7+DNF) approximately. 
              FLV also controls setup time and hold time for START and STOP condition in Fast Mode(master mode). 
              Thdsta=Tsusta=Tsusto=Tfclk*FLV
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
            <field>
              <name>SLV</name>
              <description>
              Decrementer Load value for Standard Mode SCL (master mode) for both high and low phase. 
              Data rate is generated as Ffclk/(SLV+max(SLV,CNT*2+6)+7+DNF) approximately. 
              SLV also controls setup time and hold time for START and STOP condition in Standard Mode(master mode). 
              Thdsta=Tsusta=Tsusto=Tfclk*SLV
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>WCR</name>
          <displayName>WCR</displayName>
          <description>Wait Count Register</description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0000000A</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>27</bitWidth>
            </field>
            <field>
              <name>CNT</name>
              <description>
              Controls the counter values defining the setup and hold times in standard and fast mode
              Tvddat=Thddat=Tfclk*(CNT+2)
              Tsudat=max(Tlow-Thddat,Thddat)
              Lower counter values may violate setup and hold times.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RCCR</name>
          <displayName>RCCR</displayName>
          <description>Bus Reset Cycle Counter Register</description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000009</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>28</bitWidth>
            </field>
            <field>
              <name>RSTCYC</name>
              <description>
              The cycles of SCL during bus reset
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BMR</name>
          <displayName>BMR</displayName>
          <description>Bus Monitor Register</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000003</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>30</bitWidth>
            </field>
            <field>
              <name>SCL</name>
              <description>
              value of the SCL pin. Software can check bus level when the I2C bus is hung and the I2C unit must be reset.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SDA</name>
              <description>
              value of the SDA pin.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DNR</name>
          <displayName>DNR</displayName>
          <description>DMA number register</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>NDT</name>
              <description>
              Write as number of data to transfer in byte. Read as left data number to transfer
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD1</name>
          <displayName>RSVD1</displayName>
          <description></description>
          <addressOffset>0x2C</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>FIFO</name>
          <displayName>FIFO</displayName>
          <description>FIFO Register</description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>DATA</name>
              <description>
              Write to push send data into FIFO. Read to pop received data from FIFO
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>I2C6</name>
      <description></description>
      <groupName>I2C</groupName>
      <baseAddress>0x4004e000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CR</name>
          <displayName>CR</displayName>
          <description>Control register</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>UR</name>
              <description>
              Unit Reset. Software need first assert to reset then deassert to release.
              0 = No reset.
              1 = Reset I2C module.
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSTREQ</name>
              <description>
              I2C will do bus reset upon this bit set. Will be cleared by HW automatically after RSTCYC cycles of SCL generated.
              1 = request for i2c bus reset
              0 = bus reset finished
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BRGRST</name>
              <description>
              Reset bus related state machine and signals. Will be cleared by HW automatically
              1 = request for reset
              0 = reset finished
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>14</bitWidth>
            </field>
            <field>
              <name>DNF</name>
              <description>
              Digital noise filter
              These bits are used to configure the digital noise filter on SDA and SCL input. The digital filter will filter spikes with a length of up to DNF*Tfclk.
              0: Digital filter disabled 
              1: Digital filter enabled and filtering capability up to 1 Tfclk
              ...
              7: digital filter enabled and filtering capability up to 7 Tfclk
              Note: Digital filter is added to analog filter. Digital filter will introduce delay on SCL and SDA processing, which is essential in hs-mode. 
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>SCLPP</name>
              <description>
              Push-pull mode Enable for SCL.
              0 = open drain output for SCL.
              1 = Push-pull output for SCL
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MSDE</name>
              <description>
              Master Stop Detected Enable:
              0 = Master Stop Detect (MSD) status is not enabled.
              1 = Master Stop Detect (MSD) status is enabled.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LASTSTOP</name>
              <description>
              Generate STOP for last DMA transfer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LASTNACK</name>
              <description>
              Generate NACK for last DMA Read transfer
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMAEN</name>
              <description>
              DMA Enable for both TX and RX
              0 = DMA mode is NOT enabled
              1 = DMA mode enabled
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SCLE</name>
              <description>
              SCL Enable:
              0 = Disables the I2C from driving the SCL line.
              1 = Enables the I2C clock output for master-mode operation.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IUE</name>
              <description>
              I2C Unit Enable:
              0 = Disables the unit and does not master any transactions or respond to any slave transactions.
              1 = Enables the I2C (defaults to slave-receive mode).
              Software must guarantee the I2C bus is idle before setting this bit.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MODE</name>
              <description>
              Bus Mode (Master operation):
              2'b00: standard-mode
              2'b01: fast-mode and fast-mode plus
              2'b10: HS-mode (standard mode when not doing a high speed transfer)
              2'b11: HS-mode (fast mode when not doing a high speed transfer)
              Bus Mode (Slave operation):
              2'b0x: HS-mode is disabled. I2C unit uses Standard/Fast mode timing on the SDA pin.
              2'b1x: HS-mode is enabled. I2C unit uses HS-mode timing on the SDA pin when a master code is received.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TCR</name>
          <displayName>TCR</displayName>
          <description>Transfer Control register</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>ABORTDMA</name>
              <description>
              Abort DMA operation. Will be cleared by HW automatically
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RXREQ</name>
              <description>
              Request DMA RX. Will be cleared by HW automatically
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TXREQ</name>
              <description>
              Request DMA TX. Will be cleared by HW automatically
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MA</name>
              <description>
              Master Abort:
              Used by the I2C in master mode to generate a Stop without transmitting another data byte:
              0 = The I2C transmits Stop on if TCR[STOP] is set.
              1 = The I2C sends Stop without data transmission.
              When in master-transmit mode, after transmitting a data byte, the TCR[TB] bit is cleared. When no more data bytes need to be sent, setting master abort bit sends the Stop. The TCR[TB] bit must remain clear.
              In master-receive mode, when a NAK is sent without a Stop (TCR[STOP] bit was not set) and CPU does not send a repeated Start, setting this bit sends the Stop. Once again, the TCR[TB] bit must remain clear. Master Abort can be done immediately after the address phase (Master Transmit mode only).
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>NACK</name>
              <description>
              The positive/negative acknowledge control bit, defines the type of acknowledge pulse sent by the I2C when in master receive mode:
              0 = Send a positive acknowledge (ACK) pulse after receiving a data byte.
              1 = Send a negative acknowledge (NACK) pulse after receiving a data byte.
              The I2C automatically sends an ACK pulse when responding to its slave address or when responding in slave-receive mode, regardless of the NACK control-bit setting.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>STOP</name>
              <description>
              Stop:
              Used to initiate a Stop condition after transferring the next data byte on the I2C bus when in master mode. In master-receive mode, the NACK control bit must be set in conjunction with the STOP bit. 
              0 = Do not send a Stop.
              1 = Send a Stop.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>START</name>
              <description>
              Start:
              Used to initiate a Start condition to the I2C unit when in master mode. 
              0 = Do not send a Start pulse.
              1 = Send a Start pulse.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TB</name>
              <description>
              Transfer Byte:
              Used to send or receive a byte on the I2C bus:
              0 = Cleared by I2C when the byte is sent/received.
              1 = Send/receive a byte. 
              CPU can monitor this bit to determine when the byte transfer has completed. In master or slave mode, after each byte transfer including acknowledge pulse, the I2C holds the SCL line low (inserting wait states) until TB is set.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IER</name>
          <displayName>IER</displayName>
          <description>Interrupt Enable register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>UFIE</name>
              <description>
              FIFO Underflow Interrupt Enable
              0 = FIFO Underflow interrupt is not enabled
              1 = FIFO Underflow interrupt is enabled
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OFIE</name>
              <description>
              FIFO Overflow Interrupt Enable
              0 = FIFO Overflow interrupt is not enabled
              1 = FIFO Overflow interrupt is enabled
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMADONEIE</name>
              <description>
              DMA Transaction Done Interrupt Enable
              0 = DMA Transaction done interrupt is not enabled.
              1 = DMA Transaction done interrupt is enabled.
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MSDIE</name>
              <description>
              Master Stop Detected Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C unit to interrupt upon detecting a Master Stop sent by the I2C unit.
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BEDIE</name>
              <description>
              Bus Error Detected Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C to interrupt for the following I2C bus errors:
              As a master transmitter, no ACK was detected after a byte was sent.
              As a slave receiver, the I2C generated a NACK pulse.
              Software is responsible for guaranteeing that misplaced Start and Stop conditions do not occur.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SADIE</name>
              <description>
              Slave Address Detected Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C to interrupt upon detecting a slave address match or a general call address.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RFIE</name>
              <description>
              DBR Receive Full Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C to interrupt when the DBR has received a data byte from the I2C bus.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIE</name>
              <description>
              DBR Transmit Empty Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C to interrupt after transmitting a byte onto the I2C bus.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ALDIE</name>
              <description>
              Arbitration Loss Detected Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C to interrupt upon losing arbitration while in master mode.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SSDIE</name>
              <description>
              Slave Stop Detected Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C to interrupt when it detects a Stop condition while in slave mode.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SR</name>
          <displayName>SR</displayName>
          <description>Status register</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>UF</name>
              <description>
              FIFO Underflow Flag. Asserted when FIFO is empty and a POP request generated without a PUSH. Cleared if write 1
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OF</name>
              <description>
              FIFO Overflow Flag. Asserted when FIFO is full and a PUSH request generated without a POP. Cleared if write 1
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMADONE</name>
              <description>
              DMA Transaction Done. Asserted when both APB and I2C bus have finished transfer. Cleared if write 1
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MSD</name>
              <description>
              Master Stop Detected:
              0 = No Master Stop Detected.
              1 = This bit is set by the I2C unit when all of the following are true:
              This bit is enabled (CR[MSDE] = 1);
              I2C unit is configured as a master;
              I2C transmits a STOP signal
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EBB</name>
              <description>
              Early Bus Busy
              0 = I2C bus is idle or the I2C is using the bus (that is, unit busy).
              1 = Set when the unit detects that the SCL or SDA line is low without a START condition. Bit will remain set until the I2C unit detects the bus is idle by detecting a STOP condition. Bit will also be set whenever the IBB bit is set.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BED</name>
              <description>
              Bus Error Detected:
              0 = No error detected.
              1 = The I2C sets this bit when it detects one of the following error conditions:
              As a master transmitter, no ACK was detected on the interface after a byte was sent.
              As a slave receiver, the I2C generates a NACK pulse.
              When an error occurs, I2C bus transactions continue. Software must guarantee that misplaced Start and Stop conditions do not occur. 
              Cleared if write 1
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SAD</name>
              <description>
              Slave Address Detected:
              0 = No slave address was detected.
              1 = The I2C detected a seven-bit address that matches the general call address or SAR. An interrupt is signalled when enabled in the CR. 
              Cleared if write 1
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RF</name>
              <description>
              DBR Receive Full:
              0 = The DBR has not received a new data byte or the I2C is idle.
              1 = The DBR register received a new data byte from the I2C bus. An interrupt is signalled when enabled in the CR. 
              Cleared if write 1
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TE</name>
              <description>
              DBR Transmit Empty:
              0 = The data byte is still being transmitted.
              1 = The I2C has finished transmitting a data byte on the I2C bus. An interrupt is signalled when enabled in the CR.
              Cleared if write 1
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ALD</name>
              <description>
              Arbitration Loss Detected:
              Used during multi-master operation:
              0 = Cleared when arbitration is won or never took place.
              1 = Set when the I2C loses arbitration. 
              Cleared if write 1
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SSD</name>
              <description>
              Slave Stop Detected:
              0 = No Stop detected.
              1 = Set when the I2C detects a Stop while in slave-receive or slave-transmit mode. 
              Cleared if write 1
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IBB</name>
              <description>
              I2C Bus Busy:
              0 = I2C bus is idle or the I2C is using the bus (that is, unit busy).
              1 = Set when the I2C bus is busy but local I2C is not involved in the transaction.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UB</name>
              <description>
              Unit Busy:
              0 = I2C not busy.
              1 = Set when local I2C is busy. This is defined as the time between the first Start and Stop. 
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>NACK</name>
              <description>
              ACK/NACK Status:
              0 = The I2C received or sent an ACK on the bus. 
              1 = The I2C received or sent a NACK.on the bus.
              This bit is used in slave-transmit mode to determine when the byte transferred is the last one. This bit is updated after each byte and ACK/NACK information is received.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RWM</name>
              <description>
              Read/write Mode:
              0 = The I2C is in master-transmit or slave-receive mode. 
              1 = The I2C is in master-receive or slave-transmit mode. 
              This is the R/nW bit of the slave address. It is cleared automatically by hardware after a Stop state.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DBR</name>
          <displayName>DBR</displayName>
          <description>Data Buffer register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>DATA</name>
              <description>
              use the I2C Data Buffer register to transmit and receive data from the I2C bus. The DBR is accessed by software on one Side and by the I2C Shift register on the other. The DBR receives data coming into the I2C unit after a full byte is received and acknowledged. CPU writes data going out of the I2C to the DBR and sends it to the serial bus. 
              When the I2C is in transmit mode (master or slave), CPU writes data to the DBR over the internal bus. CPU write data to the DBR when a master transaction is initiated or when the DBR transmit-empty interrupt is signalled. Data moves from the DBR to the Shift register when the transfer byte bit is set. The DBR transmit-empty interrupt is signalled (if enabled) when a byte is transferred on the I2C bus and the acknowledge cycle is complete. If the DBR is not written, and a Stop condition is not in place before the I2C bus is ready to transfer the next byte packet, the I2C unit inserts wait states until CPU writes the DBR and sets the transfer byte bit.
              When the I2C is in receive mode (master or slave), CPU reads DBR data over the internal bus. CPU reads data from the DBR when the DBR receive-full interrupt is signalled. The data moves from the Shift register to the DBR when the acknowledge cycle is complete. The I2C inserts wait states until the DBR is read. After the software reads the DBR, CR[NACK] are written by the software, allowing the next byte transfer to proceed to the I2C bus.
              In DMA mode, DBR is automatically filled from FIFO in master transmit mode, or fetched and stored in FIFO in master receive mode until DMA done or aborted.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SAR</name>
          <displayName>SAR</displayName>
          <description>Slave Address Register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000047</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>25</bitWidth>
            </field>
            <field>
              <name>ADDR</name>
              <description>
              The seven-bit address to which the I2C responds when in slave-receive mode
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>LCR</name>
          <displayName>LCR</displayName>
          <description>Load Count Register</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x081C3675</resetValue>
          <fields>
            <field>
              <name>HLVH</name>
              <description>
              Decrementer Load value for High Speed Mode SCL (master mode) for high phase. 
              Thigh=Tfclk*(HLVH+4+DNF)
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>HLVL</name>
              <description>
              Decrementer Load value for High Speed Mode SCL (master mode) for low phase. 
              Tlow=Tfclk*(HLVL+3+DNF). Data rate is generated as 1/(Thigh+Tlow), or Ffclk/(HLVH+HLVL+7+2*DNF). 
              3.2Mbps data rate is generated by default if fclk is 48MHz.
              HLVL also controls setup time and hold time for START and STOP condition in High Speed Mode(master mode). 
              Thdsta=Tsusta=Tsusto=Tfclk*(HLVL+1)
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
            <field>
              <name>FLV</name>
              <description>
              Decrementer Load value for Fast Mode (or Fast Mode Plus) SCL (master mode) for both high and low phase. 
              Data rate is generated as Ffclk/(FLV+max(FLV,CNT*2+6)+7+DNF) approximately. 
              FLV also controls setup time and hold time for START and STOP condition in Fast Mode(master mode). 
              Thdsta=Tsusta=Tsusto=Tfclk*FLV
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
            <field>
              <name>SLV</name>
              <description>
              Decrementer Load value for Standard Mode SCL (master mode) for both high and low phase. 
              Data rate is generated as Ffclk/(SLV+max(SLV,CNT*2+6)+7+DNF) approximately. 
              SLV also controls setup time and hold time for START and STOP condition in Standard Mode(master mode). 
              Thdsta=Tsusta=Tsusto=Tfclk*SLV
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>WCR</name>
          <displayName>WCR</displayName>
          <description>Wait Count Register</description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0000000A</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>27</bitWidth>
            </field>
            <field>
              <name>CNT</name>
              <description>
              Controls the counter values defining the setup and hold times in standard and fast mode
              Tvddat=Thddat=Tfclk*(CNT+2)
              Tsudat=max(Tlow-Thddat,Thddat)
              Lower counter values may violate setup and hold times.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RCCR</name>
          <displayName>RCCR</displayName>
          <description>Bus Reset Cycle Counter Register</description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000009</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>28</bitWidth>
            </field>
            <field>
              <name>RSTCYC</name>
              <description>
              The cycles of SCL during bus reset
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BMR</name>
          <displayName>BMR</displayName>
          <description>Bus Monitor Register</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000003</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>30</bitWidth>
            </field>
            <field>
              <name>SCL</name>
              <description>
              value of the SCL pin. Software can check bus level when the I2C bus is hung and the I2C unit must be reset.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SDA</name>
              <description>
              value of the SDA pin.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DNR</name>
          <displayName>DNR</displayName>
          <description>DMA number register</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>NDT</name>
              <description>
              Write as number of data to transfer in byte. Read as left data number to transfer
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD1</name>
          <displayName>RSVD1</displayName>
          <description></description>
          <addressOffset>0x2C</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>FIFO</name>
          <displayName>FIFO</displayName>
          <description>FIFO Register</description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>DATA</name>
              <description>
              Write to push send data into FIFO. Read to pop received data from FIFO
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>LPSYS_CFG</name>
      <description></description>
      <groupName>LPSYS_CFG</groupName>
      <baseAddress>0x4004f000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>SWCR</name>
          <displayName>SWCR</displayName>
          <description>SW Control Register</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>31</bitWidth>
            </field>
            <field>
              <name>SWSEL</name>
              <description>
              0 - SWD connected to HCPU
              1 - SWD connected to LCPU
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ULPMCR</name>
          <displayName>ULPMCR</displayName>
          <description>ULP Memory Control register</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>FORCE_ON</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
            <field>
              <name>ROM_RME</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ROM_RM</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RAM_WPULSE</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RAM_WA</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RAM_RA</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RAM_RME</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RAM_RM</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RTC_TR</name>
          <displayName>RTC_TR</displayName>
          <description>Mirrored RTC Time Register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>PM</name>
              <description>
              AM/PM notation
              0: AM
              1: PM
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HT</name>
              <description>
              Hour tens in BCD format
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>HU</name>
              <description>
              Hour units in BCD format
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>MNT</name>
              <description>
              Minute tens in BCD format
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>MNU</name>
              <description>
              Minute units in BCD format
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>ST</name>
              <description>
              Second tens in BCD format
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>SU</name>
              <description>
              Second units in BCD format
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SS</name>
              <description>
              Sub-second counter
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RTC_DR</name>
          <displayName>RTC_DR</displayName>
          <description>Mirrored RTC Date Register</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>ERR</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>CB</name>
              <description>
              Century flag
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>YT</name>
              <description>
              Year tens in BCD format
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>YU</name>
              <description>
              Year units in BCD format
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>WD</name>
              <description>
              Week day units
              000: forbidden
              001: Monday
              ...
              111: Sunday
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>MT</name>
              <description>
              Month tens in BCD format
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MU</name>
              <description>
              Month units in BCD format
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>DT</name>
              <description>
              Date tens in BCD format
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>DU</name>
              <description>
              Date units in BCD format
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>LSDBGR</name>
          <displayName>LSDBGR</displayName>
          <description>Light Sleep Debug Register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>22</bitWidth>
            </field>
            <field>
              <name>LS_ROM</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LS_CACHE</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LS_DTCM</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LS_ITCM</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LS_RAM5</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LS_RAM4</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LS_RAM3</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LS_RAM2</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LS_RAM1</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LS_RAM0</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DBGR</name>
          <displayName>DBGR</displayName>
          <description>Debug Select Register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>BITEN_H</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>SEL_H</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>BITEN_L</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>SEL_L</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DBGCLKR</name>
          <displayName>DBGCLKR</displayName>
          <description>Debug Clock Register</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>28</bitWidth>
            </field>
            <field>
              <name>CLK_EN</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CLK_SEL</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>GPTIM3</name>
      <description></description>
      <groupName>GPTIM</groupName>
      <baseAddress>0x40050000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CR1</name>
          <displayName>CR1</displayName>
          <description>TIM control register 1</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>UIFREMAP</name>
              <description>
              UIF status bit remapping
              0: No remapping. UIF status bit is not copied to CNT register bit 31
              1: Remapping enabled. UIF status bit is copied to CNT register bit 31
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>ARPE</name>
              <description>
              Auto-reload preload enable
              0: ARR register is not buffered
              1: ARR register is buffered
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CMS</name>
              <description>
              Center-aligned mode selection
              00: Edge-aligned mode. The counter counts up or down depending on the direction bit (DIR).
              01: Center-aligned mode 1. The counter counts up and down alternatively. Output compare interrupt flags of channels configured in output (CCxS=00 in CCMRx register) are set only when the counter is counting down.
              10: Center-aligned mode 2. The counter counts up and down alternatively. Output compare interrupt flags of channels configured in output (CCxS=00 in CCMRx register) are set only when the counter is counting up.
              11: Center-aligned mode 3. The counter counts up and down alternatively. Output compare interrupt flags of channels configured in output (CCxS=00 in CCMRx register) are set both when the counter is counting up or down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>DIR</name>
              <description>
              Direction
              0: Counter used as upcounter
              1: Counter used as downcounter
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OPM</name>
              <description>
              One-pulse mode
              0: Counter is not stopped at update event
              1: Counter stops counting at the next update event (clearing the bit CEN)
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>URS</name>
              <description>
              Update request source
              This bit is set and cleared by software to select the UEV event sources.
              0: Any of the following events generate an update interrupt or DMA request if enabled. 
              These events can be: 
                 Counter overflow/underflow
                 Setting the UG bit
                 Update generation through the slave mode controller
              1: Only counter overflow/underflow generates an update interrupt or DMA request if enabled.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UDIS</name>
              <description>
              Update disable
              This bit is set and cleared by software to enable/disable UEV event generation.
              0: UEV enabled. The Update (UEV) event is generated by one of the following events:
                 Counter overflow/underflow
                 Setting the UG bit
                 Update generation through the slave mode controller
              Buffered registers are then loaded with their preload values.
              1: UEV disabled. The Update event is not generated, shadow registers keep their value (ARR, PSC, CCRx). However the counter and the prescaler are reinitialized if the UG bit is set or if a hardware reset is received from the slave mode controller.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CEN</name>
              <description>
              Counter enable
              0: Counter disabled
              1: Counter enabled
              Note: External clock, gated mode and encoder mode can work only if the CEN bit has been previously set by software. However trigger mode can set the CEN bit automatically by hardware. 
              CEN is cleared automatically in one-pulse mode, when an update event occurs.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CR2</name>
          <displayName>CR2</displayName>
          <description>TIM control register 2</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>TI1S</name>
              <description>
              TI1 selection
              0: The CH1 pin is connected to TI1 input
              1: The CH1, CH2 and CH3 pins are connected to the TI1 input (XOR combination) 
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MMS</name>
              <description>
              Master mode selection
              These bits allow to select the information to be sent in master mode to slave timers for synchronization (TRGO). The combination is as follows:
              000: Reset - the UG bit from the EGR register is used as trigger output (TRGO). If the reset is generated by the trigger input (slave mode controller configured in reset mode) then the signal on TRGO is delayed compared to the actual reset.
              001: Enable - the Counter enable signal is used as trigger output (TRGO). It is useful to start several timers at the same time or to control a window in which a slave timer is enabled. The Counter Enable signal is generated by a logic OR between CEN control bit and the trigger input when configured in gated mode. 
              When the Counter Enable signal is controlled by the trigger input, there is a delay on TRGO, except if the master/slave mode is selected.
              010: Update - The update event is selected as trigger output (TRGO). For instance a master timer can then be used as a prescaler for a slave timer.
              011: Compare Pulse - The trigger output send a positive pulse when the CC1IF flag is to be set (even if it was already high), as soon as a capture or a compare match occurred. (TRGO)
              100: Compare - OC1REF signal is used as trigger output (TRGO)
              101: Compare - OC2REF signal is used as trigger output (TRGO)
              110: Compare - OC3REF signal is used as trigger output (TRGO)
              111: Compare - OC4REF signal is used as trigger output (TRGO)
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>CCDS</name>
              <description>
              Capture/compare DMA selection
              0: CCx DMA request sent when CCx event occurs
              1: CCx DMA requests sent when update event occurs
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SMCR</name>
          <displayName>SMCR</displayName>
          <description>TIM slave mode control register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
            <field>
              <name>SMS</name>
              <description>
              Slave mode selection
              When external signals are selected the active edge of the trigger signal (TRGI) is linked to the polarity selected on the external input.
              0000: Slave mode disabled.
              0001: Encoder mode 1 - Counter counts up/down on TI1FP1 edge depending on TI2FP2 level.
              0010: Encoder mode 2 - Counter counts up/down on TI2FP2 edge depending on TI1FP1 level.
              0011: Encoder mode 3 - Counter counts up/down on both TI1FP1 and TI2FP2 edges depending on the level of the other input.
              0100: Reset Mode - Rising edge of the selected trigger input (TRGI) reinitializes the counter and generates an update of the registers.
              0101: Gated Mode - The counter clock is enabled when the trigger input (TRGI) is high. The counter stops (but is not reset) as soon as the trigger becomes low. Both start and stop of the counter are controlled.
              0110: Trigger Mode - The counter starts at a rising edge of the trigger TRGI (but it is not reset). Only the start of the counter is controlled.
              0111: External Clock Mode 1 - Rising edges of the selected trigger (TRGI) clock the counter.
              1000: Combined reset + trigger mode - Rising edge of the selected trigger input (TRGI) reinitializes the counter, generates an update of the registers and starts the counter.
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>ETP</name>
              <description>
              External trigger polarity
              0: ETR is non-inverted, active at high level or rising edge
              1: ETR is inverted, active at low level or falling edge
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ECE</name>
              <description>
              External clock enable
              This bit enables External clock mode 2.
              0: External clock mode 2 disabled
              1: External clock mode 2 enabled. The counter is clocked by any active edge on the ETRF signal.
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ETPS</name>
              <description>
              External trigger prescaler
              External trigger signal ETRP frequency must be at most 1/4 of CK_INT frequency. A prescaler can be enabled to reduce ETRP frequency. It is useful when inputting fast external clocks.
              00: Prescaler OFF
              01: ETRP frequency divided by 2
              10: ETRP frequency divided by 4
              11: ETRP frequency divided by 8
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>ETF</name>
              <description>
              External trigger filter
              This bit-field then defines the frequency used to sample ETRP signal and the length of the digital filter applied to ETRP. The digital filter is made of an event counter in which N 
              consecutive events are needed to validate a transition on the output:
              0000: No filter
              0001:   fSAMPLING=fCLK, N=2
              0010:   fSAMPLING=fCLK, N=4
              0011:   fSAMPLING=fCLK, N=8
              0100:   fSAMPLING=fCLK/2, N=6
              0101:   fSAMPLING=fCLK/2, N=8
              0110:   fSAMPLING=fCLK/4, N=6
              0111:   fSAMPLING=fCLK/4, N=8
              1000:   fSAMPLING=fCLK/8, N=6
              1001:   fSAMPLING=fCLK/8, N=8
              1010:   fSAMPLING=fCLK/16, N=5
              1011:   fSAMPLING=fCLK/16, N=6
              1100:   fSAMPLING=fCLK/16, N=8
              1101:   fSAMPLING=fCLK/32, N=5
              1110:   fSAMPLING=fCLK/32, N=6
              1111:   fSAMPLING=fCLK/32, N=8
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>MSM</name>
              <description>
              Master/Slave mode
              0: No action
              1: The effect of an event on the trigger input (TRGI) is delayed to allow a perfect synchronization between the current timer and its slaves (through TRGO). It is useful if we want to synchronize several timers on a single external event.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TS</name>
              <description>
              Trigger selection
              This bit-field selects the trigger input to be used to synchronize the counter.
              000: Internal Trigger 0 (ITR0)
              001: Internal Trigger 1 (ITR1) 
              010: Internal Trigger 2 (ITR2)
              011: Internal Trigger 3 (ITR3)
              100: TI1 Edge Detector (TI1F_ED)
              101: Filtered Timer Input 1 (TI1FP1)
              110: Filtered Timer Input 2 (TI2FP2)
              111: External Trigger input (ETRF)
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DIER</name>
          <displayName>DIER</displayName>
          <description>TIM DMA/Interrupt enable register</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
            <field>
              <name>TDE</name>
              <description>
              Trigger DMA request enable
              0: Trigger DMA request disabled.
              1: Trigger DMA request enabled.
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC4DE</name>
              <description>
              Capture/Compare 4 DMA request enable
              0: CC4 DMA request disabled.
              1: CC4 DMA request enabled
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC3DE</name>
              <description>
              Capture/Compare 3 DMA request enable
              0: CC3 DMA request disabled.
              1: CC3 DMA request enabled.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC2DE</name>
              <description>
              Capture/Compare 2 DMA request enable
              0: CC2 DMA request disabled.
              1: CC2 DMA request enabled.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC1DE</name>
              <description>
              Capture/Compare 1 DMA request enable
              0: CC1 DMA request disabled.
              1: CC1 DMA request enabled.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UDE</name>
              <description>
              Update DMA request enable
              0: Update DMA request disabled.
              1: Update DMA request enabled
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TIE</name>
              <description>
              Trigger interrupt enable
              0: Trigger interrupt disabled.
              1: Trigger interrupt enabled
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC4IE</name>
              <description>
              Capture/Compare 4 interrupt enable
              0: CC4 interrupt disabled.
              1: CC4 interrupt enabled
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC3IE</name>
              <description>
              Capture/Compare 3 interrupt enable
              0: CC3 interrupt disabled.
              1: CC3 interrupt enabled
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC2IE</name>
              <description>
              Capture/Compare 2 interrupt enable
              0: CC2 interrupt disabled.
              1: CC2 interrupt enabled.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC1IE</name>
              <description>
              Capture/Compare 1 interrupt enable
              0: CC1 interrupt disabled.
              1: CC1 interrupt enabled
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UIE</name>
              <description>
              Update interrupt enable
              0: Update interrupt disabled.
              1: Update interrupt enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SR</name>
          <displayName>SR</displayName>
          <description>TIM status register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>19</bitWidth>
            </field>
            <field>
              <name>CC4OF</name>
              <description>
              Capture/Compare 4 overcapture flag
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC3OF</name>
              <description>
              Capture/Compare 3 overcapture flag
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC2OF</name>
              <description>
              Capture/Compare 2 overcapture flag
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC1OF</name>
              <description>
              Capture/Compare 1 overcapture flag
              This flag is set by hardware only when the corresponding channel is configured in input capture mode. It is cleared by software by writing it to '0'.
              0: No overcapture has been detected.
              1: The counter value has been captured in CCR1 register while CC1IF flag was already set
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>TIF</name>
              <description>
              Trigger interrupt flag
              This flag is set by hardware on trigger event (active edge detected on TRGI input when the slave mode controller is enabled in all modes but gated mode). It is set when the counter starts or stops when gated mode is selected. It is cleared by software.
              0: No trigger event occurred.
              1: Trigger interrupt pending.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC4IF</name>
              <description>
              Capture/Compare 4 interrupt flag
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC3IF</name>
              <description>
              Capture/Compare 3 interrupt flag
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC2IF</name>
              <description>
              Capture/Compare 2 interrupt flag
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC1IF</name>
              <description>
              Capture/Compare 1 interrupt flag
              If channel CC1 is configured as output: This flag is set by hardware when the counter matches the compare value. It is cleared by software.
              0: No match.
              1: The content of the counter CNT has matched the content of the CCR1 register.
              If channel CC1 is configured as input: This bit is set by hardware on a capture. It is cleared by software or by reading the CCR1 register.
              0: No input capture occurred.
              1: The counter value has been captured in CCR1 register (An edge has been detected on IC1 which matches the selected polarity).
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UIF</name>
              <description>
              Update interrupt flag
              This bit is set by hardware on an update event. It is cleared by software.
              0: No update occurred
              1: Update interrupt pending. This bit is set by hardware when the registers are updated:
              At overflow or underflow and if UDIS=0 in the CR1 register.
              When CNT is reinitialized by software using the UG bit in EGR register, if URS=0 and UDIS=0 in the CR1 register.
              When CNT is reinitialized by a trigger event, if URS=0 and UDIS=0 in the CR1 register.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>EGR</name>
          <displayName>EGR</displayName>
          <description>Event generation register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>25</bitWidth>
            </field>
            <field>
              <name>TG</name>
              <description>
              Trigger generation
              This bit is set by software in order to generate an event, it is automatically cleared by hardware.
              0: No action
              1: The TIF flag is set in SR register. Related interrupt or DMA transfer can occur if enabled.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC4G</name>
              <description>
              Capture/compare 4 generation
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC3G</name>
              <description>
              Capture/compare 3 generation
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC2G</name>
              <description>
              Capture/compare 2 generation
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC1G</name>
              <description>
              Capture/compare 1 generation
              This bit is set by software in order to generate an event, it is automatically cleared by hardware.
              0: No action
              1: A capture/compare event is generated on channel 1:
              If channel CC1 is configured as output:
              CC1IF flag is set, Corresponding interrupt or DMA request is sent if enabled.
              If channel CC1 is configured as input:
              The current value of the counter is captured in CCR1 register. The CC1IF flag is set, the corresponding interrupt or DMA request is sent if enabled. The CC1OF flag is set if the CC1IF flag was already high.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UG</name>
              <description>
              Update generation
              This bit can be set by software, it is automatically cleared by hardware.
              0: No action
              1: Re-initialize the counter and generates an update of the registers. Note that the prescaler counter is cleared too (anyway the prescaler ratio is not affected). The counter is cleared if the center-aligned mode is selected or if DIR=0 (upcounting), else it takes the auto-reload value (ARR) if DIR=1 (downcounting).
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCMR1</name>
          <displayName>CCMR1</displayName>
          <description>TIM capture/compare mode register 1</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>OC2M</name>
              <description>
              Output compare 2 mode
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>OC2PE</name>
              <description>
              Output compare 2 preload enable
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>OC2CE</name>
              <description>
              Output compare 2 clear enable
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OC1M</name>
              <description>
              Output compare 1 mode
              These bits define the behavior of the output reference signal OC1REF from which OC1 and OC1N are derived. OC1REF is active high whereas OC1 and OC1N active level depends on CC1P and CC1NP bits.
              0000: Frozen - The comparison between the output compare register CCR1 and the counter CNT has no effect on the outputs.(this mode is used to generate a timing base).
              0001: Set channel 1 to active level on match. OC1REF signal is forced high when the counter CNT matches the capture/compare register 1 (CCR1).
              0010: Set channel 1 to inactive level on match. OC1REF signal is forced low when the counter CNT matches the capture/compare register 1 (CCR1).
              0011: Toggle - OC1REF toggles when CNT=CCR1.
              0100: Force inactive level - OC1REF is forced low.
              0101: Force active level - OC1REF is forced high.
              0110: PWM mode 1 - In upcounting, channel 1 is active as long as CNT&lt;CCR1 else inactive. In downcounting, channel 1 is inactive (OC1REF='0) as long as CNT>CCR1 else active (OC1REF=1).
              0111: PWM mode 2 - In upcounting, channel 1 is inactive as long as CNT&lt;CCR1 else active. In downcounting, channel 1 is active as long as CNT>CCR1 else inactive.
              1000: Retriggerable OPM mode 1 - In up-counting mode, the channel is active until a trigger event is detected (on TRGI signal). Then, a comparison is performed as in PWM mode 1 and the channels becomes inactive again at the next update. In down-counting mode, the channel is inactive until a trigger event is detected (on TRGI signal). Then, a comparison is performed as in PWM mode 1 and the channels becomes inactive again at the next update.
              1001: Retriggerable OPM mode 2 - In up-counting mode, the channel is inactive until a trigger event is detected (on TRGI signal). Then, a comparison is performed as in PWM mode 2 and the channels becomes inactive again at the next update. In down-counting mode, the channel is active until a trigger event is detected (on TRGI signal). Then, a comparison is performed as in PWM mode 1 and the channels becomes active again at the next update.
              1010: Reserved,
              1011: Reserved,
              1100: Combined PWM mode 1 - OC1REF has the same behavior as in PWM mode 1. OC1REFC is the logical OR between OC1REF and OC2REF.
              1101: Combined PWM mode 2 - OC1REF has the same behavior as in PWM mode 2. OC1REFC is the logical AND between OC1REF and OC2REF.
              1110: Asymmetric PWM mode 1 - OC1REF has the same behavior as in PWM mode 1. OC1REFC outputs OC1REF when the counter is counting up, OC2REF when it is counting down.
              1111: Asymmetric PWM mode 2 - OC1REF has the same behavior as in PWM mode 2. OC1REFC outputs OC1REF when the counter is counting up, OC2REF when it is counting down.
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>OC1PE</name>
              <description>
              Output compare 1 preload enable
              0: Preload register on CCR1 disabled. CCR1 can be written at anytime, the new value is taken in account immediately.
              1: Preload register on CCR1 enabled. Read/Write operations access the preload register. CCR1 preload value is loaded in the active register at each update event.
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>OC1CE</name>
              <description>
              Output compare 1 clear enable
              0: OC1Ref is not affected by the ETRF input
              1: OC1Ref is cleared as soon as a High level is detected on ETRF input
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IC2F</name>
              <description>
              Input capture 2 filter
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>IC2PSC</name>
              <description>
              Input capture 2 prescaler
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>CC2S</name>
              <description>
              Capture/Compare 2 selection
              This bit-field defines the direction of the channel (input/output) as well as the used input. 
              00: CC2 channel is configured as output
              01: CC2 channel is configured as input, IC2 is mapped on TI2
              10: CC2 channel is configured as input, IC2 is mapped on TI1
              11: CC2 channel is configured as input, IC2 is mapped on TRC. This mode is working only if an internal trigger input is selected through the TS bit (SMCR register)
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>IC1F</name>
              <description>
              Input capture 1 filter
              This bit-field defines the frequency used to sample TI1 input and the length of the digital filter applied to TI1. The digital filter is made of an event counter in which N consecutive events are needed to validate a transition on the output:
              0000: No filter, sampling is done at fCLK
              0001: fSAMPLING=fCLK, N=2
              0010: fSAMPLING=fCLK, N=4
              0011: fSAMPLING=fCLK, N=8
              0100: fSAMPLING=fCLK/2, N=6
              0101: fSAMPLING=fCLK/2, N=8
              0110: fSAMPLING=fCLK/4, N=6
              0111: fSAMPLING=fCLK/4, N=8
              1000: fSAMPLING=fCLK/8, N=6
              1001: fSAMPLING=fCLK/8, N=8
              1010: fSAMPLING=fCLK/16, N=5
              1011: fSAMPLING=fCLK/16, N=6
              1100: fSAMPLING=fCLK/16, N=8
              1101: fSAMPLING=fCLK/32, N=5
              1110: fSAMPLING=fCLK/32, N=6
              1111: fSAMPLING=fCLK/32, N=8
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>IC1PSC</name>
              <description>
              Input capture 1 prescaler
              This bit-field defines the ratio of the prescaler acting on CC1 input (IC1). The prescaler is reset as soon as CC1E=0.
              00: no prescaler, capture is done each time an edge is detected on the capture input
              01: capture is done once every 2 events
              10: capture is done once every 4 events
              11: capture is done once every 8 events
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>CC1S</name>
              <description>
              Capture/Compare 1 selection
              This bit-field defines the direction of the channel (input/output) as well as the used input. 
              00: CC1 channel is configured as output
              01: CC1 channel is configured as input, IC1 is mapped on TI1
              10: CC1 channel is configured as input, IC1 is mapped on TI2
              11: CC1 channel is configured as input, IC1 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (SMCR register)
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCMR2</name>
          <displayName>CCMR2</displayName>
          <description>TIM capture/compare mode register 2</description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>OC4M</name>
              <description>
              Output compare 4 mode
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>OC4PE</name>
              <description>
              Output compare 4 preload enable
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>OC4CE</name>
              <description>
              Output compare 4 clear enable
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OC3M</name>
              <description>
              Output compare 3 mode
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>OC3PE</name>
              <description>
              Output compare 3 preload enable
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>OC3CE</name>
              <description>
              Output compare 3 clear enable
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IC4F</name>
              <description>
              Input capture 4 filter
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>IC4PSC</name>
              <description>
              Input capture 4 prescaler
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>CC4S</name>
              <description>
              Capture/Compare 4 selection
              This bit-field defines the direction of the channel (input/output) as well as the used input. 
              00: CC4 channel is configured as output
              01: CC4 channel is configured as input, IC4 is mapped on TI4
              10: CC4 channel is configured as input, IC4 is mapped on TI3
              11: CC4 channel is configured as input, IC4 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (SMCR register)
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>IC3F</name>
              <description>
              Input capture 3 filter
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>IC3PSC</name>
              <description>
              Input capture 3 prescaler
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>CC3S</name>
              <description>
              Capture/Compare 3 selection
              This bit-field defines the direction of the channel (input/output) as well as the used input. 
              00: CC3 channel is configured as output
              01: CC3 channel is configured as input, IC3 is mapped on TI3
              10: CC3 channel is configured as input, IC3 is mapped on TI4
              11: CC3 channel is configured as input, IC3 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (SMCR register)
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCER</name>
          <displayName>CCER</displayName>
          <description>Capture/Compare enable register</description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>CC4NP</name>
              <description>
              Capture/Compare 4 output Polarity.
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC4P</name>
              <description>
              Capture/Compare 4 output Polarity.
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC4E</name>
              <description>
              Capture/Compare 4 output enable.
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC3NP</name>
              <description>
              Capture/Compare 3 output Polarity.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC3P</name>
              <description>
              Capture/Compare 3 output Polarity.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC3E</name>
              <description>
              Capture/Compare 3 output enable.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC2NP</name>
              <description>
              Capture/Compare 2 output Polarity.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC2P</name>
              <description>
              Capture/Compare 2 output Polarity.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC2E</name>
              <description>
              Capture/Compare 2 output enable.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC1NP</name>
              <description>
              Capture/Compare 1 output Polarity.
              CC1 channel configured as output: CC1NP must be kept cleared in this case.
              CC1 channel configured as input: This bit is used in conjunction with CC1P to define TI1FP1/TI2FP1 polarity. refer to CC1P description.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD5</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC1P</name>
              <description>
              Capture/Compare 1 output Polarity.
              CC1 channel configured as output:
              0: OC1 active high
              1: OC1 active low
              CC1 channel configured as input: CC1NP/CC1P bits select TI1FP1 and TI2FP1 polarity for trigger or capture operations.
              00: noninverted/rising edge
              Circuit is sensitive to TIxFP1 rising edge (capture, trigger in reset, external clock or trigger mode), TIxFP1 is not inverted (trigger in gated mode, encoder mode).
              01: inverted/falling edge
              Circuit is sensitive to TIxFP1 falling edge (capture, trigger in reset, external clock or trigger mode), TIxFP1 is inverted (trigger in gated mode, encoder mode).
              10: reserved, do not use this configuration.
              11: noninverted/both edges
              Circuit is sensitive to both TIxFP1 rising and falling edges (capture, trigger in reset, external clock or trigger mode), TIxFP1 is not inverted (trigger in gated mode). This configuration must not be used for encoder mode.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC1E</name>
              <description>
              Capture/Compare 1 output enable.
              CC1 channel configured as output:
              0: Off - OC1 is not active
              1: On - OC1 signal is output on the corresponding output pin
              CC1 channel configured as input: This bit determines if a capture of the counter value can actually be done into the input capture/compare register 1 (CCR1) or not.
              0: Capture disabled
              1: Capture enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CNT</name>
          <displayName>CNT</displayName>
          <description>Counter</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>UIFCPY</name>
              <description>
              Value depends on IUFREMAP in CR1.
              If UIFREMAP = 1
              UIFCPY: UIF Copy
              This bit is a read-only copy of the UIF bit of the ISR register
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>15</bitWidth>
            </field>
            <field>
              <name>CNT</name>
              <description>
              counter value
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PSC</name>
          <displayName>PSC</displayName>
          <description>Prescaler</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>PSC</name>
              <description>
              Prescaler value
              The counter clock frequency is equal to fCLK / (PSC[15:0] + 1).
              PSC contains the value to be loaded in the active prescaler register at each update event (including when the counter is cleared through UG bit of EGR register or through trigger controller when configured in 'reset mode').
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ARR</name>
          <displayName>ARR</displayName>
          <description>Auto-reload register</description>
          <addressOffset>0x2c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>ARR</name>
              <description>
              Auto-reload value
              ARR is the value to be loaded in the actual auto-reload register.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RCR</name>
          <displayName>RCR</displayName>
          <description>Repetition counter register</description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>REP</name>
              <description>
              Repetition counter value
              These bits allow the user to set-up the update rate of the compare registers (i.e. periodic transfers from preload to active registers) when preload registers are enable, as well as the update interrupt generation rate, if this interrupt is enable.
              Each time the REP_CNT related downcounter reaches zero, an update event is generated and it restarts counting from REP value. As REP_CNT is reloaded with REP value only at the repetition update event, any write to the RCR register is not taken in account until the next repetition update event.
              It means in PWM mode (REP+1) corresponds to the number of PWM periods in edge-aligned mode.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR1</name>
          <displayName>CCR1</displayName>
          <description>Capture/Compare register 1</description>
          <addressOffset>0x34</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>CCR1</name>
              <description>
              Capture/Compare 1 value
              If channel CC1 is configured as output:
              CCR1 is the value to be loaded in the actual capture/compare 1 register (preload value).It is loaded permanently if the preload feature is not selected in the CCMR1 register (bit OC1PE). Else the preload value is copied in the active capture/compare 1 register when an update event occurs.
              The active capture/compare register contains the value to be compared to the counter CNT and signaled on OC1 output.
              If channel CC1is configured as input:
              CCR1 is the counter value transferred by the last input capture 1 event (IC1). The CCR1 register is read-only and cannot be programmed.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR2</name>
          <displayName>CCR2</displayName>
          <description>Capture/Compare register 2</description>
          <addressOffset>0x38</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>CCR2</name>
              <description>
              Capture/Compare 2 value
              If channel CC2 is configured as output:
              CCR2 is the value to be loaded in the actual capture/compare 2 register (preload value).It is loaded permanently if the preload feature is not selected in the CCMR1 register (bit OC2PE). Else the preload value is copied in the active capture/compare 2 register when an update event occurs.
              The active capture/compare register contains the value to be compared to the counter CNT and signalled on OC2 output.
              If channel CC2 is configured as input:
              CCR2 is the counter value transferred by the last input capture 2 event (IC2). The CCR2 register is read-only and cannot be programmed.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR3</name>
          <displayName>CCR3</displayName>
          <description>Capture/Compare register 3</description>
          <addressOffset>0x3c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>CCR3</name>
              <description>
              Capture/Compare value
              If channel CC3 is configured as output:
              CCR3 is the value to be loaded in the actual capture/compare 3 register (preload value).It is loaded permanently if the preload feature is not selected in the CCMR2 register (bit OC3PE). Else the preload value is copied in the active capture/compare 3 register when an update event occurs.
              The active capture/compare register contains the value to be compared to the counter CNT and signalled on OC3 output.
              If channel CC3is configured as input:
              CCR3 is the counter value transferred by the last input capture 3 event (IC3). The CCR3 register is read-only and cannot be programmed.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR4</name>
          <displayName>CCR4</displayName>
          <description>Capture/Compare register 4</description>
          <addressOffset>0x40</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>CCR4</name>
              <description>
              Capture/Compare value
              1. if CC4 channel is configured as output:
              CCR4 is the value to be loaded in the actual capture/compare 4 register (preload value).It is loaded permanently if the preload feature is not selected in the CCMR2 register (bit OC4PE). Else the preload value is copied in the active capture/compare 4 register when an update event occurs.
              The active capture/compare register contains the value to be compared to the counter CNT and signalled on OC4 output.
              2.  if CC4 channel is configured as input:
              CCR4 is the counter value transferred by the last input capture 4 event (IC4). The CCR4 register is read-only and cannot be programmed.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>GPTIM4</name>
      <description></description>
      <groupName>GPTIM</groupName>
      <baseAddress>0x40051000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CR1</name>
          <displayName>CR1</displayName>
          <description>TIM control register 1</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>UIFREMAP</name>
              <description>
              UIF status bit remapping
              0: No remapping. UIF status bit is not copied to CNT register bit 31
              1: Remapping enabled. UIF status bit is copied to CNT register bit 31
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>ARPE</name>
              <description>
              Auto-reload preload enable
              0: ARR register is not buffered
              1: ARR register is buffered
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CMS</name>
              <description>
              Center-aligned mode selection
              00: Edge-aligned mode. The counter counts up or down depending on the direction bit (DIR).
              01: Center-aligned mode 1. The counter counts up and down alternatively. Output compare interrupt flags of channels configured in output (CCxS=00 in CCMRx register) are set only when the counter is counting down.
              10: Center-aligned mode 2. The counter counts up and down alternatively. Output compare interrupt flags of channels configured in output (CCxS=00 in CCMRx register) are set only when the counter is counting up.
              11: Center-aligned mode 3. The counter counts up and down alternatively. Output compare interrupt flags of channels configured in output (CCxS=00 in CCMRx register) are set both when the counter is counting up or down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>DIR</name>
              <description>
              Direction
              0: Counter used as upcounter
              1: Counter used as downcounter
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OPM</name>
              <description>
              One-pulse mode
              0: Counter is not stopped at update event
              1: Counter stops counting at the next update event (clearing the bit CEN)
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>URS</name>
              <description>
              Update request source
              This bit is set and cleared by software to select the UEV event sources.
              0: Any of the following events generate an update interrupt or DMA request if enabled. 
              These events can be: 
                 Counter overflow/underflow
                 Setting the UG bit
                 Update generation through the slave mode controller
              1: Only counter overflow/underflow generates an update interrupt or DMA request if enabled.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UDIS</name>
              <description>
              Update disable
              This bit is set and cleared by software to enable/disable UEV event generation.
              0: UEV enabled. The Update (UEV) event is generated by one of the following events:
                 Counter overflow/underflow
                 Setting the UG bit
                 Update generation through the slave mode controller
              Buffered registers are then loaded with their preload values.
              1: UEV disabled. The Update event is not generated, shadow registers keep their value (ARR, PSC, CCRx). However the counter and the prescaler are reinitialized if the UG bit is set or if a hardware reset is received from the slave mode controller.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CEN</name>
              <description>
              Counter enable
              0: Counter disabled
              1: Counter enabled
              Note: External clock, gated mode and encoder mode can work only if the CEN bit has been previously set by software. However trigger mode can set the CEN bit automatically by hardware. 
              CEN is cleared automatically in one-pulse mode, when an update event occurs.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CR2</name>
          <displayName>CR2</displayName>
          <description>TIM control register 2</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>TI1S</name>
              <description>
              TI1 selection
              0: The CH1 pin is connected to TI1 input
              1: The CH1, CH2 and CH3 pins are connected to the TI1 input (XOR combination) 
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MMS</name>
              <description>
              Master mode selection
              These bits allow to select the information to be sent in master mode to slave timers for synchronization (TRGO). The combination is as follows:
              000: Reset - the UG bit from the EGR register is used as trigger output (TRGO). If the reset is generated by the trigger input (slave mode controller configured in reset mode) then the signal on TRGO is delayed compared to the actual reset.
              001: Enable - the Counter enable signal is used as trigger output (TRGO). It is useful to start several timers at the same time or to control a window in which a slave timer is enabled. The Counter Enable signal is generated by a logic OR between CEN control bit and the trigger input when configured in gated mode. 
              When the Counter Enable signal is controlled by the trigger input, there is a delay on TRGO, except if the master/slave mode is selected.
              010: Update - The update event is selected as trigger output (TRGO). For instance a master timer can then be used as a prescaler for a slave timer.
              011: Compare Pulse - The trigger output send a positive pulse when the CC1IF flag is to be set (even if it was already high), as soon as a capture or a compare match occurred. (TRGO)
              100: Compare - OC1REF signal is used as trigger output (TRGO)
              101: Compare - OC2REF signal is used as trigger output (TRGO)
              110: Compare - OC3REF signal is used as trigger output (TRGO)
              111: Compare - OC4REF signal is used as trigger output (TRGO)
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>CCDS</name>
              <description>
              Capture/compare DMA selection
              0: CCx DMA request sent when CCx event occurs
              1: CCx DMA requests sent when update event occurs
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SMCR</name>
          <displayName>SMCR</displayName>
          <description>TIM slave mode control register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
            <field>
              <name>SMS</name>
              <description>
              Slave mode selection
              When external signals are selected the active edge of the trigger signal (TRGI) is linked to the polarity selected on the external input.
              0000: Slave mode disabled.
              0001: Encoder mode 1 - Counter counts up/down on TI1FP1 edge depending on TI2FP2 level.
              0010: Encoder mode 2 - Counter counts up/down on TI2FP2 edge depending on TI1FP1 level.
              0011: Encoder mode 3 - Counter counts up/down on both TI1FP1 and TI2FP2 edges depending on the level of the other input.
              0100: Reset Mode - Rising edge of the selected trigger input (TRGI) reinitializes the counter and generates an update of the registers.
              0101: Gated Mode - The counter clock is enabled when the trigger input (TRGI) is high. The counter stops (but is not reset) as soon as the trigger becomes low. Both start and stop of the counter are controlled.
              0110: Trigger Mode - The counter starts at a rising edge of the trigger TRGI (but it is not reset). Only the start of the counter is controlled.
              0111: External Clock Mode 1 - Rising edges of the selected trigger (TRGI) clock the counter.
              1000: Combined reset + trigger mode - Rising edge of the selected trigger input (TRGI) reinitializes the counter, generates an update of the registers and starts the counter.
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>ETP</name>
              <description>
              External trigger polarity
              0: ETR is non-inverted, active at high level or rising edge
              1: ETR is inverted, active at low level or falling edge
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ECE</name>
              <description>
              External clock enable
              This bit enables External clock mode 2.
              0: External clock mode 2 disabled
              1: External clock mode 2 enabled. The counter is clocked by any active edge on the ETRF signal.
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ETPS</name>
              <description>
              External trigger prescaler
              External trigger signal ETRP frequency must be at most 1/4 of CK_INT frequency. A prescaler can be enabled to reduce ETRP frequency. It is useful when inputting fast external clocks.
              00: Prescaler OFF
              01: ETRP frequency divided by 2
              10: ETRP frequency divided by 4
              11: ETRP frequency divided by 8
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>ETF</name>
              <description>
              External trigger filter
              This bit-field then defines the frequency used to sample ETRP signal and the length of the digital filter applied to ETRP. The digital filter is made of an event counter in which N 
              consecutive events are needed to validate a transition on the output:
              0000: No filter
              0001:   fSAMPLING=fCLK, N=2
              0010:   fSAMPLING=fCLK, N=4
              0011:   fSAMPLING=fCLK, N=8
              0100:   fSAMPLING=fCLK/2, N=6
              0101:   fSAMPLING=fCLK/2, N=8
              0110:   fSAMPLING=fCLK/4, N=6
              0111:   fSAMPLING=fCLK/4, N=8
              1000:   fSAMPLING=fCLK/8, N=6
              1001:   fSAMPLING=fCLK/8, N=8
              1010:   fSAMPLING=fCLK/16, N=5
              1011:   fSAMPLING=fCLK/16, N=6
              1100:   fSAMPLING=fCLK/16, N=8
              1101:   fSAMPLING=fCLK/32, N=5
              1110:   fSAMPLING=fCLK/32, N=6
              1111:   fSAMPLING=fCLK/32, N=8
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>MSM</name>
              <description>
              Master/Slave mode
              0: No action
              1: The effect of an event on the trigger input (TRGI) is delayed to allow a perfect synchronization between the current timer and its slaves (through TRGO). It is useful if we want to synchronize several timers on a single external event.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TS</name>
              <description>
              Trigger selection
              This bit-field selects the trigger input to be used to synchronize the counter.
              000: Internal Trigger 0 (ITR0)
              001: Internal Trigger 1 (ITR1) 
              010: Internal Trigger 2 (ITR2)
              011: Internal Trigger 3 (ITR3)
              100: TI1 Edge Detector (TI1F_ED)
              101: Filtered Timer Input 1 (TI1FP1)
              110: Filtered Timer Input 2 (TI2FP2)
              111: External Trigger input (ETRF)
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DIER</name>
          <displayName>DIER</displayName>
          <description>TIM DMA/Interrupt enable register</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
            <field>
              <name>TDE</name>
              <description>
              Trigger DMA request enable
              0: Trigger DMA request disabled.
              1: Trigger DMA request enabled.
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC4DE</name>
              <description>
              Capture/Compare 4 DMA request enable
              0: CC4 DMA request disabled.
              1: CC4 DMA request enabled
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC3DE</name>
              <description>
              Capture/Compare 3 DMA request enable
              0: CC3 DMA request disabled.
              1: CC3 DMA request enabled.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC2DE</name>
              <description>
              Capture/Compare 2 DMA request enable
              0: CC2 DMA request disabled.
              1: CC2 DMA request enabled.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC1DE</name>
              <description>
              Capture/Compare 1 DMA request enable
              0: CC1 DMA request disabled.
              1: CC1 DMA request enabled.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UDE</name>
              <description>
              Update DMA request enable
              0: Update DMA request disabled.
              1: Update DMA request enabled
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TIE</name>
              <description>
              Trigger interrupt enable
              0: Trigger interrupt disabled.
              1: Trigger interrupt enabled
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC4IE</name>
              <description>
              Capture/Compare 4 interrupt enable
              0: CC4 interrupt disabled.
              1: CC4 interrupt enabled
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC3IE</name>
              <description>
              Capture/Compare 3 interrupt enable
              0: CC3 interrupt disabled.
              1: CC3 interrupt enabled
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC2IE</name>
              <description>
              Capture/Compare 2 interrupt enable
              0: CC2 interrupt disabled.
              1: CC2 interrupt enabled.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC1IE</name>
              <description>
              Capture/Compare 1 interrupt enable
              0: CC1 interrupt disabled.
              1: CC1 interrupt enabled
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UIE</name>
              <description>
              Update interrupt enable
              0: Update interrupt disabled.
              1: Update interrupt enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SR</name>
          <displayName>SR</displayName>
          <description>TIM status register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>19</bitWidth>
            </field>
            <field>
              <name>CC4OF</name>
              <description>
              Capture/Compare 4 overcapture flag
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC3OF</name>
              <description>
              Capture/Compare 3 overcapture flag
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC2OF</name>
              <description>
              Capture/Compare 2 overcapture flag
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC1OF</name>
              <description>
              Capture/Compare 1 overcapture flag
              This flag is set by hardware only when the corresponding channel is configured in input capture mode. It is cleared by software by writing it to '0'.
              0: No overcapture has been detected.
              1: The counter value has been captured in CCR1 register while CC1IF flag was already set
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>TIF</name>
              <description>
              Trigger interrupt flag
              This flag is set by hardware on trigger event (active edge detected on TRGI input when the slave mode controller is enabled in all modes but gated mode). It is set when the counter starts or stops when gated mode is selected. It is cleared by software.
              0: No trigger event occurred.
              1: Trigger interrupt pending.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC4IF</name>
              <description>
              Capture/Compare 4 interrupt flag
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC3IF</name>
              <description>
              Capture/Compare 3 interrupt flag
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC2IF</name>
              <description>
              Capture/Compare 2 interrupt flag
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC1IF</name>
              <description>
              Capture/Compare 1 interrupt flag
              If channel CC1 is configured as output: This flag is set by hardware when the counter matches the compare value. It is cleared by software.
              0: No match.
              1: The content of the counter CNT has matched the content of the CCR1 register.
              If channel CC1 is configured as input: This bit is set by hardware on a capture. It is cleared by software or by reading the CCR1 register.
              0: No input capture occurred.
              1: The counter value has been captured in CCR1 register (An edge has been detected on IC1 which matches the selected polarity).
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UIF</name>
              <description>
              Update interrupt flag
              This bit is set by hardware on an update event. It is cleared by software.
              0: No update occurred
              1: Update interrupt pending. This bit is set by hardware when the registers are updated:
              At overflow or underflow and if UDIS=0 in the CR1 register.
              When CNT is reinitialized by software using the UG bit in EGR register, if URS=0 and UDIS=0 in the CR1 register.
              When CNT is reinitialized by a trigger event, if URS=0 and UDIS=0 in the CR1 register.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>EGR</name>
          <displayName>EGR</displayName>
          <description>Event generation register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>25</bitWidth>
            </field>
            <field>
              <name>TG</name>
              <description>
              Trigger generation
              This bit is set by software in order to generate an event, it is automatically cleared by hardware.
              0: No action
              1: The TIF flag is set in SR register. Related interrupt or DMA transfer can occur if enabled.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC4G</name>
              <description>
              Capture/compare 4 generation
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC3G</name>
              <description>
              Capture/compare 3 generation
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC2G</name>
              <description>
              Capture/compare 2 generation
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC1G</name>
              <description>
              Capture/compare 1 generation
              This bit is set by software in order to generate an event, it is automatically cleared by hardware.
              0: No action
              1: A capture/compare event is generated on channel 1:
              If channel CC1 is configured as output:
              CC1IF flag is set, Corresponding interrupt or DMA request is sent if enabled.
              If channel CC1 is configured as input:
              The current value of the counter is captured in CCR1 register. The CC1IF flag is set, the corresponding interrupt or DMA request is sent if enabled. The CC1OF flag is set if the CC1IF flag was already high.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UG</name>
              <description>
              Update generation
              This bit can be set by software, it is automatically cleared by hardware.
              0: No action
              1: Re-initialize the counter and generates an update of the registers. Note that the prescaler counter is cleared too (anyway the prescaler ratio is not affected). The counter is cleared if the center-aligned mode is selected or if DIR=0 (upcounting), else it takes the auto-reload value (ARR) if DIR=1 (downcounting).
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCMR1</name>
          <displayName>CCMR1</displayName>
          <description>TIM capture/compare mode register 1</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>OC2M</name>
              <description>
              Output compare 2 mode
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>OC2PE</name>
              <description>
              Output compare 2 preload enable
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>OC2CE</name>
              <description>
              Output compare 2 clear enable
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OC1M</name>
              <description>
              Output compare 1 mode
              These bits define the behavior of the output reference signal OC1REF from which OC1 and OC1N are derived. OC1REF is active high whereas OC1 and OC1N active level depends on CC1P and CC1NP bits.
              0000: Frozen - The comparison between the output compare register CCR1 and the counter CNT has no effect on the outputs.(this mode is used to generate a timing base).
              0001: Set channel 1 to active level on match. OC1REF signal is forced high when the counter CNT matches the capture/compare register 1 (CCR1).
              0010: Set channel 1 to inactive level on match. OC1REF signal is forced low when the counter CNT matches the capture/compare register 1 (CCR1).
              0011: Toggle - OC1REF toggles when CNT=CCR1.
              0100: Force inactive level - OC1REF is forced low.
              0101: Force active level - OC1REF is forced high.
              0110: PWM mode 1 - In upcounting, channel 1 is active as long as CNT&lt;CCR1 else inactive. In downcounting, channel 1 is inactive (OC1REF='0) as long as CNT>CCR1 else active (OC1REF=1).
              0111: PWM mode 2 - In upcounting, channel 1 is inactive as long as CNT&lt;CCR1 else active. In downcounting, channel 1 is active as long as CNT>CCR1 else inactive.
              1000: Retriggerable OPM mode 1 - In up-counting mode, the channel is active until a trigger event is detected (on TRGI signal). Then, a comparison is performed as in PWM mode 1 and the channels becomes inactive again at the next update. In down-counting mode, the channel is inactive until a trigger event is detected (on TRGI signal). Then, a comparison is performed as in PWM mode 1 and the channels becomes inactive again at the next update.
              1001: Retriggerable OPM mode 2 - In up-counting mode, the channel is inactive until a trigger event is detected (on TRGI signal). Then, a comparison is performed as in PWM mode 2 and the channels becomes inactive again at the next update. In down-counting mode, the channel is active until a trigger event is detected (on TRGI signal). Then, a comparison is performed as in PWM mode 1 and the channels becomes active again at the next update.
              1010: Reserved,
              1011: Reserved,
              1100: Combined PWM mode 1 - OC1REF has the same behavior as in PWM mode 1. OC1REFC is the logical OR between OC1REF and OC2REF.
              1101: Combined PWM mode 2 - OC1REF has the same behavior as in PWM mode 2. OC1REFC is the logical AND between OC1REF and OC2REF.
              1110: Asymmetric PWM mode 1 - OC1REF has the same behavior as in PWM mode 1. OC1REFC outputs OC1REF when the counter is counting up, OC2REF when it is counting down.
              1111: Asymmetric PWM mode 2 - OC1REF has the same behavior as in PWM mode 2. OC1REFC outputs OC1REF when the counter is counting up, OC2REF when it is counting down.
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>OC1PE</name>
              <description>
              Output compare 1 preload enable
              0: Preload register on CCR1 disabled. CCR1 can be written at anytime, the new value is taken in account immediately.
              1: Preload register on CCR1 enabled. Read/Write operations access the preload register. CCR1 preload value is loaded in the active register at each update event.
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>OC1CE</name>
              <description>
              Output compare 1 clear enable
              0: OC1Ref is not affected by the ETRF input
              1: OC1Ref is cleared as soon as a High level is detected on ETRF input
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IC2F</name>
              <description>
              Input capture 2 filter
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>IC2PSC</name>
              <description>
              Input capture 2 prescaler
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>CC2S</name>
              <description>
              Capture/Compare 2 selection
              This bit-field defines the direction of the channel (input/output) as well as the used input. 
              00: CC2 channel is configured as output
              01: CC2 channel is configured as input, IC2 is mapped on TI2
              10: CC2 channel is configured as input, IC2 is mapped on TI1
              11: CC2 channel is configured as input, IC2 is mapped on TRC. This mode is working only if an internal trigger input is selected through the TS bit (SMCR register)
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>IC1F</name>
              <description>
              Input capture 1 filter
              This bit-field defines the frequency used to sample TI1 input and the length of the digital filter applied to TI1. The digital filter is made of an event counter in which N consecutive events are needed to validate a transition on the output:
              0000: No filter, sampling is done at fCLK
              0001: fSAMPLING=fCLK, N=2
              0010: fSAMPLING=fCLK, N=4
              0011: fSAMPLING=fCLK, N=8
              0100: fSAMPLING=fCLK/2, N=6
              0101: fSAMPLING=fCLK/2, N=8
              0110: fSAMPLING=fCLK/4, N=6
              0111: fSAMPLING=fCLK/4, N=8
              1000: fSAMPLING=fCLK/8, N=6
              1001: fSAMPLING=fCLK/8, N=8
              1010: fSAMPLING=fCLK/16, N=5
              1011: fSAMPLING=fCLK/16, N=6
              1100: fSAMPLING=fCLK/16, N=8
              1101: fSAMPLING=fCLK/32, N=5
              1110: fSAMPLING=fCLK/32, N=6
              1111: fSAMPLING=fCLK/32, N=8
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>IC1PSC</name>
              <description>
              Input capture 1 prescaler
              This bit-field defines the ratio of the prescaler acting on CC1 input (IC1). The prescaler is reset as soon as CC1E=0.
              00: no prescaler, capture is done each time an edge is detected on the capture input
              01: capture is done once every 2 events
              10: capture is done once every 4 events
              11: capture is done once every 8 events
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>CC1S</name>
              <description>
              Capture/Compare 1 selection
              This bit-field defines the direction of the channel (input/output) as well as the used input. 
              00: CC1 channel is configured as output
              01: CC1 channel is configured as input, IC1 is mapped on TI1
              10: CC1 channel is configured as input, IC1 is mapped on TI2
              11: CC1 channel is configured as input, IC1 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (SMCR register)
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCMR2</name>
          <displayName>CCMR2</displayName>
          <description>TIM capture/compare mode register 2</description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>OC4M</name>
              <description>
              Output compare 4 mode
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>OC4PE</name>
              <description>
              Output compare 4 preload enable
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>OC4CE</name>
              <description>
              Output compare 4 clear enable
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OC3M</name>
              <description>
              Output compare 3 mode
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>OC3PE</name>
              <description>
              Output compare 3 preload enable
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>OC3CE</name>
              <description>
              Output compare 3 clear enable
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IC4F</name>
              <description>
              Input capture 4 filter
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>IC4PSC</name>
              <description>
              Input capture 4 prescaler
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>CC4S</name>
              <description>
              Capture/Compare 4 selection
              This bit-field defines the direction of the channel (input/output) as well as the used input. 
              00: CC4 channel is configured as output
              01: CC4 channel is configured as input, IC4 is mapped on TI4
              10: CC4 channel is configured as input, IC4 is mapped on TI3
              11: CC4 channel is configured as input, IC4 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (SMCR register)
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>IC3F</name>
              <description>
              Input capture 3 filter
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>IC3PSC</name>
              <description>
              Input capture 3 prescaler
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>CC3S</name>
              <description>
              Capture/Compare 3 selection
              This bit-field defines the direction of the channel (input/output) as well as the used input. 
              00: CC3 channel is configured as output
              01: CC3 channel is configured as input, IC3 is mapped on TI3
              10: CC3 channel is configured as input, IC3 is mapped on TI4
              11: CC3 channel is configured as input, IC3 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (SMCR register)
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCER</name>
          <displayName>CCER</displayName>
          <description>Capture/Compare enable register</description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>CC4NP</name>
              <description>
              Capture/Compare 4 output Polarity.
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC4P</name>
              <description>
              Capture/Compare 4 output Polarity.
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC4E</name>
              <description>
              Capture/Compare 4 output enable.
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC3NP</name>
              <description>
              Capture/Compare 3 output Polarity.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC3P</name>
              <description>
              Capture/Compare 3 output Polarity.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC3E</name>
              <description>
              Capture/Compare 3 output enable.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC2NP</name>
              <description>
              Capture/Compare 2 output Polarity.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC2P</name>
              <description>
              Capture/Compare 2 output Polarity.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC2E</name>
              <description>
              Capture/Compare 2 output enable.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC1NP</name>
              <description>
              Capture/Compare 1 output Polarity.
              CC1 channel configured as output: CC1NP must be kept cleared in this case.
              CC1 channel configured as input: This bit is used in conjunction with CC1P to define TI1FP1/TI2FP1 polarity. refer to CC1P description.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD5</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC1P</name>
              <description>
              Capture/Compare 1 output Polarity.
              CC1 channel configured as output:
              0: OC1 active high
              1: OC1 active low
              CC1 channel configured as input: CC1NP/CC1P bits select TI1FP1 and TI2FP1 polarity for trigger or capture operations.
              00: noninverted/rising edge
              Circuit is sensitive to TIxFP1 rising edge (capture, trigger in reset, external clock or trigger mode), TIxFP1 is not inverted (trigger in gated mode, encoder mode).
              01: inverted/falling edge
              Circuit is sensitive to TIxFP1 falling edge (capture, trigger in reset, external clock or trigger mode), TIxFP1 is inverted (trigger in gated mode, encoder mode).
              10: reserved, do not use this configuration.
              11: noninverted/both edges
              Circuit is sensitive to both TIxFP1 rising and falling edges (capture, trigger in reset, external clock or trigger mode), TIxFP1 is not inverted (trigger in gated mode). This configuration must not be used for encoder mode.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC1E</name>
              <description>
              Capture/Compare 1 output enable.
              CC1 channel configured as output:
              0: Off - OC1 is not active
              1: On - OC1 signal is output on the corresponding output pin
              CC1 channel configured as input: This bit determines if a capture of the counter value can actually be done into the input capture/compare register 1 (CCR1) or not.
              0: Capture disabled
              1: Capture enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CNT</name>
          <displayName>CNT</displayName>
          <description>Counter</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>UIFCPY</name>
              <description>
              Value depends on IUFREMAP in CR1.
              If UIFREMAP = 1
              UIFCPY: UIF Copy
              This bit is a read-only copy of the UIF bit of the ISR register
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>15</bitWidth>
            </field>
            <field>
              <name>CNT</name>
              <description>
              counter value
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PSC</name>
          <displayName>PSC</displayName>
          <description>Prescaler</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>PSC</name>
              <description>
              Prescaler value
              The counter clock frequency is equal to fCLK / (PSC[15:0] + 1).
              PSC contains the value to be loaded in the active prescaler register at each update event (including when the counter is cleared through UG bit of EGR register or through trigger controller when configured in 'reset mode').
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ARR</name>
          <displayName>ARR</displayName>
          <description>Auto-reload register</description>
          <addressOffset>0x2c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>ARR</name>
              <description>
              Auto-reload value
              ARR is the value to be loaded in the actual auto-reload register.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RCR</name>
          <displayName>RCR</displayName>
          <description>Repetition counter register</description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>REP</name>
              <description>
              Repetition counter value
              These bits allow the user to set-up the update rate of the compare registers (i.e. periodic transfers from preload to active registers) when preload registers are enable, as well as the update interrupt generation rate, if this interrupt is enable.
              Each time the REP_CNT related downcounter reaches zero, an update event is generated and it restarts counting from REP value. As REP_CNT is reloaded with REP value only at the repetition update event, any write to the RCR register is not taken in account until the next repetition update event.
              It means in PWM mode (REP+1) corresponds to the number of PWM periods in edge-aligned mode.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR1</name>
          <displayName>CCR1</displayName>
          <description>Capture/Compare register 1</description>
          <addressOffset>0x34</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>CCR1</name>
              <description>
              Capture/Compare 1 value
              If channel CC1 is configured as output:
              CCR1 is the value to be loaded in the actual capture/compare 1 register (preload value).It is loaded permanently if the preload feature is not selected in the CCMR1 register (bit OC1PE). Else the preload value is copied in the active capture/compare 1 register when an update event occurs.
              The active capture/compare register contains the value to be compared to the counter CNT and signaled on OC1 output.
              If channel CC1is configured as input:
              CCR1 is the counter value transferred by the last input capture 1 event (IC1). The CCR1 register is read-only and cannot be programmed.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR2</name>
          <displayName>CCR2</displayName>
          <description>Capture/Compare register 2</description>
          <addressOffset>0x38</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>CCR2</name>
              <description>
              Capture/Compare 2 value
              If channel CC2 is configured as output:
              CCR2 is the value to be loaded in the actual capture/compare 2 register (preload value).It is loaded permanently if the preload feature is not selected in the CCMR1 register (bit OC2PE). Else the preload value is copied in the active capture/compare 2 register when an update event occurs.
              The active capture/compare register contains the value to be compared to the counter CNT and signalled on OC2 output.
              If channel CC2 is configured as input:
              CCR2 is the counter value transferred by the last input capture 2 event (IC2). The CCR2 register is read-only and cannot be programmed.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR3</name>
          <displayName>CCR3</displayName>
          <description>Capture/Compare register 3</description>
          <addressOffset>0x3c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>CCR3</name>
              <description>
              Capture/Compare value
              If channel CC3 is configured as output:
              CCR3 is the value to be loaded in the actual capture/compare 3 register (preload value).It is loaded permanently if the preload feature is not selected in the CCMR2 register (bit OC3PE). Else the preload value is copied in the active capture/compare 3 register when an update event occurs.
              The active capture/compare register contains the value to be compared to the counter CNT and signalled on OC3 output.
              If channel CC3is configured as input:
              CCR3 is the counter value transferred by the last input capture 3 event (IC3). The CCR3 register is read-only and cannot be programmed.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR4</name>
          <displayName>CCR4</displayName>
          <description>Capture/Compare register 4</description>
          <addressOffset>0x40</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>CCR4</name>
              <description>
              Capture/Compare value
              1. if CC4 channel is configured as output:
              CCR4 is the value to be loaded in the actual capture/compare 4 register (preload value).It is loaded permanently if the preload feature is not selected in the CCMR2 register (bit OC4PE). Else the preload value is copied in the active capture/compare 4 register when an update event occurs.
              The active capture/compare register contains the value to be compared to the counter CNT and signalled on OC4 output.
              2.  if CC4 channel is configured as input:
              CCR4 is the counter value transferred by the last input capture 4 event (IC4). The CCR4 register is read-only and cannot be programmed.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>GPTIM5</name>
      <description></description>
      <groupName>GPTIM</groupName>
      <baseAddress>0x40052000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CR1</name>
          <displayName>CR1</displayName>
          <description>TIM control register 1</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>UIFREMAP</name>
              <description>
              UIF status bit remapping
              0: No remapping. UIF status bit is not copied to CNT register bit 31
              1: Remapping enabled. UIF status bit is copied to CNT register bit 31
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>ARPE</name>
              <description>
              Auto-reload preload enable
              0: ARR register is not buffered
              1: ARR register is buffered
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CMS</name>
              <description>
              Center-aligned mode selection
              00: Edge-aligned mode. The counter counts up or down depending on the direction bit (DIR).
              01: Center-aligned mode 1. The counter counts up and down alternatively. Output compare interrupt flags of channels configured in output (CCxS=00 in CCMRx register) are set only when the counter is counting down.
              10: Center-aligned mode 2. The counter counts up and down alternatively. Output compare interrupt flags of channels configured in output (CCxS=00 in CCMRx register) are set only when the counter is counting up.
              11: Center-aligned mode 3. The counter counts up and down alternatively. Output compare interrupt flags of channels configured in output (CCxS=00 in CCMRx register) are set both when the counter is counting up or down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>DIR</name>
              <description>
              Direction
              0: Counter used as upcounter
              1: Counter used as downcounter
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OPM</name>
              <description>
              One-pulse mode
              0: Counter is not stopped at update event
              1: Counter stops counting at the next update event (clearing the bit CEN)
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>URS</name>
              <description>
              Update request source
              This bit is set and cleared by software to select the UEV event sources.
              0: Any of the following events generate an update interrupt or DMA request if enabled. 
              These events can be: 
                 Counter overflow/underflow
                 Setting the UG bit
                 Update generation through the slave mode controller
              1: Only counter overflow/underflow generates an update interrupt or DMA request if enabled.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UDIS</name>
              <description>
              Update disable
              This bit is set and cleared by software to enable/disable UEV event generation.
              0: UEV enabled. The Update (UEV) event is generated by one of the following events:
                 Counter overflow/underflow
                 Setting the UG bit
                 Update generation through the slave mode controller
              Buffered registers are then loaded with their preload values.
              1: UEV disabled. The Update event is not generated, shadow registers keep their value (ARR, PSC, CCRx). However the counter and the prescaler are reinitialized if the UG bit is set or if a hardware reset is received from the slave mode controller.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CEN</name>
              <description>
              Counter enable
              0: Counter disabled
              1: Counter enabled
              Note: External clock, gated mode and encoder mode can work only if the CEN bit has been previously set by software. However trigger mode can set the CEN bit automatically by hardware. 
              CEN is cleared automatically in one-pulse mode, when an update event occurs.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CR2</name>
          <displayName>CR2</displayName>
          <description>TIM control register 2</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>TI1S</name>
              <description>
              TI1 selection
              0: The CH1 pin is connected to TI1 input
              1: The CH1, CH2 and CH3 pins are connected to the TI1 input (XOR combination) 
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MMS</name>
              <description>
              Master mode selection
              These bits allow to select the information to be sent in master mode to slave timers for synchronization (TRGO). The combination is as follows:
              000: Reset - the UG bit from the EGR register is used as trigger output (TRGO). If the reset is generated by the trigger input (slave mode controller configured in reset mode) then the signal on TRGO is delayed compared to the actual reset.
              001: Enable - the Counter enable signal is used as trigger output (TRGO). It is useful to start several timers at the same time or to control a window in which a slave timer is enabled. The Counter Enable signal is generated by a logic OR between CEN control bit and the trigger input when configured in gated mode. 
              When the Counter Enable signal is controlled by the trigger input, there is a delay on TRGO, except if the master/slave mode is selected.
              010: Update - The update event is selected as trigger output (TRGO). For instance a master timer can then be used as a prescaler for a slave timer.
              011: Compare Pulse - The trigger output send a positive pulse when the CC1IF flag is to be set (even if it was already high), as soon as a capture or a compare match occurred. (TRGO)
              100: Compare - OC1REF signal is used as trigger output (TRGO)
              101: Compare - OC2REF signal is used as trigger output (TRGO)
              110: Compare - OC3REF signal is used as trigger output (TRGO)
              111: Compare - OC4REF signal is used as trigger output (TRGO)
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>CCDS</name>
              <description>
              Capture/compare DMA selection
              0: CCx DMA request sent when CCx event occurs
              1: CCx DMA requests sent when update event occurs
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SMCR</name>
          <displayName>SMCR</displayName>
          <description>TIM slave mode control register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
            <field>
              <name>SMS</name>
              <description>
              Slave mode selection
              When external signals are selected the active edge of the trigger signal (TRGI) is linked to the polarity selected on the external input.
              0000: Slave mode disabled.
              0001: Encoder mode 1 - Counter counts up/down on TI1FP1 edge depending on TI2FP2 level.
              0010: Encoder mode 2 - Counter counts up/down on TI2FP2 edge depending on TI1FP1 level.
              0011: Encoder mode 3 - Counter counts up/down on both TI1FP1 and TI2FP2 edges depending on the level of the other input.
              0100: Reset Mode - Rising edge of the selected trigger input (TRGI) reinitializes the counter and generates an update of the registers.
              0101: Gated Mode - The counter clock is enabled when the trigger input (TRGI) is high. The counter stops (but is not reset) as soon as the trigger becomes low. Both start and stop of the counter are controlled.
              0110: Trigger Mode - The counter starts at a rising edge of the trigger TRGI (but it is not reset). Only the start of the counter is controlled.
              0111: External Clock Mode 1 - Rising edges of the selected trigger (TRGI) clock the counter.
              1000: Combined reset + trigger mode - Rising edge of the selected trigger input (TRGI) reinitializes the counter, generates an update of the registers and starts the counter.
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>ETP</name>
              <description>
              External trigger polarity
              0: ETR is non-inverted, active at high level or rising edge
              1: ETR is inverted, active at low level or falling edge
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ECE</name>
              <description>
              External clock enable
              This bit enables External clock mode 2.
              0: External clock mode 2 disabled
              1: External clock mode 2 enabled. The counter is clocked by any active edge on the ETRF signal.
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ETPS</name>
              <description>
              External trigger prescaler
              External trigger signal ETRP frequency must be at most 1/4 of CK_INT frequency. A prescaler can be enabled to reduce ETRP frequency. It is useful when inputting fast external clocks.
              00: Prescaler OFF
              01: ETRP frequency divided by 2
              10: ETRP frequency divided by 4
              11: ETRP frequency divided by 8
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>ETF</name>
              <description>
              External trigger filter
              This bit-field then defines the frequency used to sample ETRP signal and the length of the digital filter applied to ETRP. The digital filter is made of an event counter in which N 
              consecutive events are needed to validate a transition on the output:
              0000: No filter
              0001:   fSAMPLING=fCLK, N=2
              0010:   fSAMPLING=fCLK, N=4
              0011:   fSAMPLING=fCLK, N=8
              0100:   fSAMPLING=fCLK/2, N=6
              0101:   fSAMPLING=fCLK/2, N=8
              0110:   fSAMPLING=fCLK/4, N=6
              0111:   fSAMPLING=fCLK/4, N=8
              1000:   fSAMPLING=fCLK/8, N=6
              1001:   fSAMPLING=fCLK/8, N=8
              1010:   fSAMPLING=fCLK/16, N=5
              1011:   fSAMPLING=fCLK/16, N=6
              1100:   fSAMPLING=fCLK/16, N=8
              1101:   fSAMPLING=fCLK/32, N=5
              1110:   fSAMPLING=fCLK/32, N=6
              1111:   fSAMPLING=fCLK/32, N=8
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>MSM</name>
              <description>
              Master/Slave mode
              0: No action
              1: The effect of an event on the trigger input (TRGI) is delayed to allow a perfect synchronization between the current timer and its slaves (through TRGO). It is useful if we want to synchronize several timers on a single external event.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TS</name>
              <description>
              Trigger selection
              This bit-field selects the trigger input to be used to synchronize the counter.
              000: Internal Trigger 0 (ITR0)
              001: Internal Trigger 1 (ITR1) 
              010: Internal Trigger 2 (ITR2)
              011: Internal Trigger 3 (ITR3)
              100: TI1 Edge Detector (TI1F_ED)
              101: Filtered Timer Input 1 (TI1FP1)
              110: Filtered Timer Input 2 (TI2FP2)
              111: External Trigger input (ETRF)
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DIER</name>
          <displayName>DIER</displayName>
          <description>TIM DMA/Interrupt enable register</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
            <field>
              <name>TDE</name>
              <description>
              Trigger DMA request enable
              0: Trigger DMA request disabled.
              1: Trigger DMA request enabled.
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC4DE</name>
              <description>
              Capture/Compare 4 DMA request enable
              0: CC4 DMA request disabled.
              1: CC4 DMA request enabled
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC3DE</name>
              <description>
              Capture/Compare 3 DMA request enable
              0: CC3 DMA request disabled.
              1: CC3 DMA request enabled.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC2DE</name>
              <description>
              Capture/Compare 2 DMA request enable
              0: CC2 DMA request disabled.
              1: CC2 DMA request enabled.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC1DE</name>
              <description>
              Capture/Compare 1 DMA request enable
              0: CC1 DMA request disabled.
              1: CC1 DMA request enabled.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UDE</name>
              <description>
              Update DMA request enable
              0: Update DMA request disabled.
              1: Update DMA request enabled
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TIE</name>
              <description>
              Trigger interrupt enable
              0: Trigger interrupt disabled.
              1: Trigger interrupt enabled
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC4IE</name>
              <description>
              Capture/Compare 4 interrupt enable
              0: CC4 interrupt disabled.
              1: CC4 interrupt enabled
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC3IE</name>
              <description>
              Capture/Compare 3 interrupt enable
              0: CC3 interrupt disabled.
              1: CC3 interrupt enabled
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC2IE</name>
              <description>
              Capture/Compare 2 interrupt enable
              0: CC2 interrupt disabled.
              1: CC2 interrupt enabled.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC1IE</name>
              <description>
              Capture/Compare 1 interrupt enable
              0: CC1 interrupt disabled.
              1: CC1 interrupt enabled
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UIE</name>
              <description>
              Update interrupt enable
              0: Update interrupt disabled.
              1: Update interrupt enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SR</name>
          <displayName>SR</displayName>
          <description>TIM status register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>19</bitWidth>
            </field>
            <field>
              <name>CC4OF</name>
              <description>
              Capture/Compare 4 overcapture flag
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC3OF</name>
              <description>
              Capture/Compare 3 overcapture flag
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC2OF</name>
              <description>
              Capture/Compare 2 overcapture flag
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC1OF</name>
              <description>
              Capture/Compare 1 overcapture flag
              This flag is set by hardware only when the corresponding channel is configured in input capture mode. It is cleared by software by writing it to '0'.
              0: No overcapture has been detected.
              1: The counter value has been captured in CCR1 register while CC1IF flag was already set
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>TIF</name>
              <description>
              Trigger interrupt flag
              This flag is set by hardware on trigger event (active edge detected on TRGI input when the slave mode controller is enabled in all modes but gated mode). It is set when the counter starts or stops when gated mode is selected. It is cleared by software.
              0: No trigger event occurred.
              1: Trigger interrupt pending.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC4IF</name>
              <description>
              Capture/Compare 4 interrupt flag
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC3IF</name>
              <description>
              Capture/Compare 3 interrupt flag
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC2IF</name>
              <description>
              Capture/Compare 2 interrupt flag
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC1IF</name>
              <description>
              Capture/Compare 1 interrupt flag
              If channel CC1 is configured as output: This flag is set by hardware when the counter matches the compare value. It is cleared by software.
              0: No match.
              1: The content of the counter CNT has matched the content of the CCR1 register.
              If channel CC1 is configured as input: This bit is set by hardware on a capture. It is cleared by software or by reading the CCR1 register.
              0: No input capture occurred.
              1: The counter value has been captured in CCR1 register (An edge has been detected on IC1 which matches the selected polarity).
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UIF</name>
              <description>
              Update interrupt flag
              This bit is set by hardware on an update event. It is cleared by software.
              0: No update occurred
              1: Update interrupt pending. This bit is set by hardware when the registers are updated:
              At overflow or underflow and if UDIS=0 in the CR1 register.
              When CNT is reinitialized by software using the UG bit in EGR register, if URS=0 and UDIS=0 in the CR1 register.
              When CNT is reinitialized by a trigger event, if URS=0 and UDIS=0 in the CR1 register.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>EGR</name>
          <displayName>EGR</displayName>
          <description>Event generation register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>25</bitWidth>
            </field>
            <field>
              <name>TG</name>
              <description>
              Trigger generation
              This bit is set by software in order to generate an event, it is automatically cleared by hardware.
              0: No action
              1: The TIF flag is set in SR register. Related interrupt or DMA transfer can occur if enabled.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC4G</name>
              <description>
              Capture/compare 4 generation
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC3G</name>
              <description>
              Capture/compare 3 generation
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC2G</name>
              <description>
              Capture/compare 2 generation
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC1G</name>
              <description>
              Capture/compare 1 generation
              This bit is set by software in order to generate an event, it is automatically cleared by hardware.
              0: No action
              1: A capture/compare event is generated on channel 1:
              If channel CC1 is configured as output:
              CC1IF flag is set, Corresponding interrupt or DMA request is sent if enabled.
              If channel CC1 is configured as input:
              The current value of the counter is captured in CCR1 register. The CC1IF flag is set, the corresponding interrupt or DMA request is sent if enabled. The CC1OF flag is set if the CC1IF flag was already high.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UG</name>
              <description>
              Update generation
              This bit can be set by software, it is automatically cleared by hardware.
              0: No action
              1: Re-initialize the counter and generates an update of the registers. Note that the prescaler counter is cleared too (anyway the prescaler ratio is not affected). The counter is cleared if the center-aligned mode is selected or if DIR=0 (upcounting), else it takes the auto-reload value (ARR) if DIR=1 (downcounting).
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCMR1</name>
          <displayName>CCMR1</displayName>
          <description>TIM capture/compare mode register 1</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>OC2M</name>
              <description>
              Output compare 2 mode
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>OC2PE</name>
              <description>
              Output compare 2 preload enable
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>OC2CE</name>
              <description>
              Output compare 2 clear enable
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OC1M</name>
              <description>
              Output compare 1 mode
              These bits define the behavior of the output reference signal OC1REF from which OC1 and OC1N are derived. OC1REF is active high whereas OC1 and OC1N active level depends on CC1P and CC1NP bits.
              0000: Frozen - The comparison between the output compare register CCR1 and the counter CNT has no effect on the outputs.(this mode is used to generate a timing base).
              0001: Set channel 1 to active level on match. OC1REF signal is forced high when the counter CNT matches the capture/compare register 1 (CCR1).
              0010: Set channel 1 to inactive level on match. OC1REF signal is forced low when the counter CNT matches the capture/compare register 1 (CCR1).
              0011: Toggle - OC1REF toggles when CNT=CCR1.
              0100: Force inactive level - OC1REF is forced low.
              0101: Force active level - OC1REF is forced high.
              0110: PWM mode 1 - In upcounting, channel 1 is active as long as CNT&lt;CCR1 else inactive. In downcounting, channel 1 is inactive (OC1REF='0) as long as CNT>CCR1 else active (OC1REF=1).
              0111: PWM mode 2 - In upcounting, channel 1 is inactive as long as CNT&lt;CCR1 else active. In downcounting, channel 1 is active as long as CNT>CCR1 else inactive.
              1000: Retriggerable OPM mode 1 - In up-counting mode, the channel is active until a trigger event is detected (on TRGI signal). Then, a comparison is performed as in PWM mode 1 and the channels becomes inactive again at the next update. In down-counting mode, the channel is inactive until a trigger event is detected (on TRGI signal). Then, a comparison is performed as in PWM mode 1 and the channels becomes inactive again at the next update.
              1001: Retriggerable OPM mode 2 - In up-counting mode, the channel is inactive until a trigger event is detected (on TRGI signal). Then, a comparison is performed as in PWM mode 2 and the channels becomes inactive again at the next update. In down-counting mode, the channel is active until a trigger event is detected (on TRGI signal). Then, a comparison is performed as in PWM mode 1 and the channels becomes active again at the next update.
              1010: Reserved,
              1011: Reserved,
              1100: Combined PWM mode 1 - OC1REF has the same behavior as in PWM mode 1. OC1REFC is the logical OR between OC1REF and OC2REF.
              1101: Combined PWM mode 2 - OC1REF has the same behavior as in PWM mode 2. OC1REFC is the logical AND between OC1REF and OC2REF.
              1110: Asymmetric PWM mode 1 - OC1REF has the same behavior as in PWM mode 1. OC1REFC outputs OC1REF when the counter is counting up, OC2REF when it is counting down.
              1111: Asymmetric PWM mode 2 - OC1REF has the same behavior as in PWM mode 2. OC1REFC outputs OC1REF when the counter is counting up, OC2REF when it is counting down.
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>OC1PE</name>
              <description>
              Output compare 1 preload enable
              0: Preload register on CCR1 disabled. CCR1 can be written at anytime, the new value is taken in account immediately.
              1: Preload register on CCR1 enabled. Read/Write operations access the preload register. CCR1 preload value is loaded in the active register at each update event.
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>OC1CE</name>
              <description>
              Output compare 1 clear enable
              0: OC1Ref is not affected by the ETRF input
              1: OC1Ref is cleared as soon as a High level is detected on ETRF input
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IC2F</name>
              <description>
              Input capture 2 filter
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>IC2PSC</name>
              <description>
              Input capture 2 prescaler
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>CC2S</name>
              <description>
              Capture/Compare 2 selection
              This bit-field defines the direction of the channel (input/output) as well as the used input. 
              00: CC2 channel is configured as output
              01: CC2 channel is configured as input, IC2 is mapped on TI2
              10: CC2 channel is configured as input, IC2 is mapped on TI1
              11: CC2 channel is configured as input, IC2 is mapped on TRC. This mode is working only if an internal trigger input is selected through the TS bit (SMCR register)
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>IC1F</name>
              <description>
              Input capture 1 filter
              This bit-field defines the frequency used to sample TI1 input and the length of the digital filter applied to TI1. The digital filter is made of an event counter in which N consecutive events are needed to validate a transition on the output:
              0000: No filter, sampling is done at fCLK
              0001: fSAMPLING=fCLK, N=2
              0010: fSAMPLING=fCLK, N=4
              0011: fSAMPLING=fCLK, N=8
              0100: fSAMPLING=fCLK/2, N=6
              0101: fSAMPLING=fCLK/2, N=8
              0110: fSAMPLING=fCLK/4, N=6
              0111: fSAMPLING=fCLK/4, N=8
              1000: fSAMPLING=fCLK/8, N=6
              1001: fSAMPLING=fCLK/8, N=8
              1010: fSAMPLING=fCLK/16, N=5
              1011: fSAMPLING=fCLK/16, N=6
              1100: fSAMPLING=fCLK/16, N=8
              1101: fSAMPLING=fCLK/32, N=5
              1110: fSAMPLING=fCLK/32, N=6
              1111: fSAMPLING=fCLK/32, N=8
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>IC1PSC</name>
              <description>
              Input capture 1 prescaler
              This bit-field defines the ratio of the prescaler acting on CC1 input (IC1). The prescaler is reset as soon as CC1E=0.
              00: no prescaler, capture is done each time an edge is detected on the capture input
              01: capture is done once every 2 events
              10: capture is done once every 4 events
              11: capture is done once every 8 events
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>CC1S</name>
              <description>
              Capture/Compare 1 selection
              This bit-field defines the direction of the channel (input/output) as well as the used input. 
              00: CC1 channel is configured as output
              01: CC1 channel is configured as input, IC1 is mapped on TI1
              10: CC1 channel is configured as input, IC1 is mapped on TI2
              11: CC1 channel is configured as input, IC1 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (SMCR register)
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCMR2</name>
          <displayName>CCMR2</displayName>
          <description>TIM capture/compare mode register 2</description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>OC4M</name>
              <description>
              Output compare 4 mode
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>OC4PE</name>
              <description>
              Output compare 4 preload enable
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>OC4CE</name>
              <description>
              Output compare 4 clear enable
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OC3M</name>
              <description>
              Output compare 3 mode
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>OC3PE</name>
              <description>
              Output compare 3 preload enable
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>OC3CE</name>
              <description>
              Output compare 3 clear enable
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IC4F</name>
              <description>
              Input capture 4 filter
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>IC4PSC</name>
              <description>
              Input capture 4 prescaler
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>CC4S</name>
              <description>
              Capture/Compare 4 selection
              This bit-field defines the direction of the channel (input/output) as well as the used input. 
              00: CC4 channel is configured as output
              01: CC4 channel is configured as input, IC4 is mapped on TI4
              10: CC4 channel is configured as input, IC4 is mapped on TI3
              11: CC4 channel is configured as input, IC4 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (SMCR register)
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>IC3F</name>
              <description>
              Input capture 3 filter
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>IC3PSC</name>
              <description>
              Input capture 3 prescaler
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>CC3S</name>
              <description>
              Capture/Compare 3 selection
              This bit-field defines the direction of the channel (input/output) as well as the used input. 
              00: CC3 channel is configured as output
              01: CC3 channel is configured as input, IC3 is mapped on TI3
              10: CC3 channel is configured as input, IC3 is mapped on TI4
              11: CC3 channel is configured as input, IC3 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (SMCR register)
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCER</name>
          <displayName>CCER</displayName>
          <description>Capture/Compare enable register</description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>CC4NP</name>
              <description>
              Capture/Compare 4 output Polarity.
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC4P</name>
              <description>
              Capture/Compare 4 output Polarity.
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC4E</name>
              <description>
              Capture/Compare 4 output enable.
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC3NP</name>
              <description>
              Capture/Compare 3 output Polarity.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC3P</name>
              <description>
              Capture/Compare 3 output Polarity.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC3E</name>
              <description>
              Capture/Compare 3 output enable.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC2NP</name>
              <description>
              Capture/Compare 2 output Polarity.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC2P</name>
              <description>
              Capture/Compare 2 output Polarity.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC2E</name>
              <description>
              Capture/Compare 2 output enable.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC1NP</name>
              <description>
              Capture/Compare 1 output Polarity.
              CC1 channel configured as output: CC1NP must be kept cleared in this case.
              CC1 channel configured as input: This bit is used in conjunction with CC1P to define TI1FP1/TI2FP1 polarity. refer to CC1P description.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD5</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC1P</name>
              <description>
              Capture/Compare 1 output Polarity.
              CC1 channel configured as output:
              0: OC1 active high
              1: OC1 active low
              CC1 channel configured as input: CC1NP/CC1P bits select TI1FP1 and TI2FP1 polarity for trigger or capture operations.
              00: noninverted/rising edge
              Circuit is sensitive to TIxFP1 rising edge (capture, trigger in reset, external clock or trigger mode), TIxFP1 is not inverted (trigger in gated mode, encoder mode).
              01: inverted/falling edge
              Circuit is sensitive to TIxFP1 falling edge (capture, trigger in reset, external clock or trigger mode), TIxFP1 is inverted (trigger in gated mode, encoder mode).
              10: reserved, do not use this configuration.
              11: noninverted/both edges
              Circuit is sensitive to both TIxFP1 rising and falling edges (capture, trigger in reset, external clock or trigger mode), TIxFP1 is not inverted (trigger in gated mode). This configuration must not be used for encoder mode.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC1E</name>
              <description>
              Capture/Compare 1 output enable.
              CC1 channel configured as output:
              0: Off - OC1 is not active
              1: On - OC1 signal is output on the corresponding output pin
              CC1 channel configured as input: This bit determines if a capture of the counter value can actually be done into the input capture/compare register 1 (CCR1) or not.
              0: Capture disabled
              1: Capture enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CNT</name>
          <displayName>CNT</displayName>
          <description>Counter</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>UIFCPY</name>
              <description>
              Value depends on IUFREMAP in CR1.
              If UIFREMAP = 1
              UIFCPY: UIF Copy
              This bit is a read-only copy of the UIF bit of the ISR register
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>15</bitWidth>
            </field>
            <field>
              <name>CNT</name>
              <description>
              counter value
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PSC</name>
          <displayName>PSC</displayName>
          <description>Prescaler</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>PSC</name>
              <description>
              Prescaler value
              The counter clock frequency is equal to fCLK / (PSC[15:0] + 1).
              PSC contains the value to be loaded in the active prescaler register at each update event (including when the counter is cleared through UG bit of EGR register or through trigger controller when configured in 'reset mode').
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ARR</name>
          <displayName>ARR</displayName>
          <description>Auto-reload register</description>
          <addressOffset>0x2c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>ARR</name>
              <description>
              Auto-reload value
              ARR is the value to be loaded in the actual auto-reload register.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RCR</name>
          <displayName>RCR</displayName>
          <description>Repetition counter register</description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>REP</name>
              <description>
              Repetition counter value
              These bits allow the user to set-up the update rate of the compare registers (i.e. periodic transfers from preload to active registers) when preload registers are enable, as well as the update interrupt generation rate, if this interrupt is enable.
              Each time the REP_CNT related downcounter reaches zero, an update event is generated and it restarts counting from REP value. As REP_CNT is reloaded with REP value only at the repetition update event, any write to the RCR register is not taken in account until the next repetition update event.
              It means in PWM mode (REP+1) corresponds to the number of PWM periods in edge-aligned mode.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR1</name>
          <displayName>CCR1</displayName>
          <description>Capture/Compare register 1</description>
          <addressOffset>0x34</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>CCR1</name>
              <description>
              Capture/Compare 1 value
              If channel CC1 is configured as output:
              CCR1 is the value to be loaded in the actual capture/compare 1 register (preload value).It is loaded permanently if the preload feature is not selected in the CCMR1 register (bit OC1PE). Else the preload value is copied in the active capture/compare 1 register when an update event occurs.
              The active capture/compare register contains the value to be compared to the counter CNT and signaled on OC1 output.
              If channel CC1is configured as input:
              CCR1 is the counter value transferred by the last input capture 1 event (IC1). The CCR1 register is read-only and cannot be programmed.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR2</name>
          <displayName>CCR2</displayName>
          <description>Capture/Compare register 2</description>
          <addressOffset>0x38</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>CCR2</name>
              <description>
              Capture/Compare 2 value
              If channel CC2 is configured as output:
              CCR2 is the value to be loaded in the actual capture/compare 2 register (preload value).It is loaded permanently if the preload feature is not selected in the CCMR1 register (bit OC2PE). Else the preload value is copied in the active capture/compare 2 register when an update event occurs.
              The active capture/compare register contains the value to be compared to the counter CNT and signalled on OC2 output.
              If channel CC2 is configured as input:
              CCR2 is the counter value transferred by the last input capture 2 event (IC2). The CCR2 register is read-only and cannot be programmed.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR3</name>
          <displayName>CCR3</displayName>
          <description>Capture/Compare register 3</description>
          <addressOffset>0x3c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>CCR3</name>
              <description>
              Capture/Compare value
              If channel CC3 is configured as output:
              CCR3 is the value to be loaded in the actual capture/compare 3 register (preload value).It is loaded permanently if the preload feature is not selected in the CCMR2 register (bit OC3PE). Else the preload value is copied in the active capture/compare 3 register when an update event occurs.
              The active capture/compare register contains the value to be compared to the counter CNT and signalled on OC3 output.
              If channel CC3is configured as input:
              CCR3 is the counter value transferred by the last input capture 3 event (IC3). The CCR3 register is read-only and cannot be programmed.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR4</name>
          <displayName>CCR4</displayName>
          <description>Capture/Compare register 4</description>
          <addressOffset>0x40</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>CCR4</name>
              <description>
              Capture/Compare value
              1. if CC4 channel is configured as output:
              CCR4 is the value to be loaded in the actual capture/compare 4 register (preload value).It is loaded permanently if the preload feature is not selected in the CCMR2 register (bit OC4PE). Else the preload value is copied in the active capture/compare 4 register when an update event occurs.
              The active capture/compare register contains the value to be compared to the counter CNT and signalled on OC4 output.
              2.  if CC4 channel is configured as input:
              CCR4 is the counter value transferred by the last input capture 4 event (IC4). The CCR4 register is read-only and cannot be programmed.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>BTIM3</name>
      <description></description>
      <groupName>BTIM</groupName>
      <baseAddress>0x40053000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CR1</name>
          <displayName>CR1</displayName>
          <description>TIM control register 1</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>ARPE</name>
              <description>
              Auto-reload preload enable
              0: ARR register is not buffered
              1: ARR register is buffered
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>OPM</name>
              <description>
              One-pulse mode
              0: Counter is not stopped at update event
              1: Counter stops counting at the next update event (clearing the bit CEN)
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>URS</name>
              <description>
              Update request source
              This bit is set and cleared by software to select the UEV event sources.
              0: Any of the following events generate an update interrupt or DMA request if enabled. 
              These events can be: 
                 Counter overflow
                 Setting the UG bit
                 Update generation through the slave mode controller
              1: Only counter overflow generates an update interrupt or DMA request if enabled.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UDIS</name>
              <description>
              Update disable
              This bit is set and cleared by software to enable/disable UEV event generation.
              0: UEV enabled. The Update (UEV) event is generated by one of the following events:
                 Counter overflow
                 Setting the UG bit
                 Update generation through the slave mode controller
              Buffered registers are then loaded with their preload values.
              1: UEV disabled. The Update event is not generated, shadow registers keep their value (ARR, PSC). However the counter and the prescaler are reinitialized if the UG bit is set or if a hardware reset is received from the slave mode controller.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CEN</name>
              <description>
              Counter enable
              0: Counter disabled
              1: Counter enabled
              Note: Gated mode can work only if the CEN bit has been previously set by software. However trigger mode can set the CEN bit automatically by hardware. 
              CEN is cleared automatically in one-pulse mode, when an update event occurs.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CR2</name>
          <displayName>CR2</displayName>
          <description>TIM control register 2</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>26</bitWidth>
            </field>
            <field>
              <name>MMS</name>
              <description>
              Master mode selection
              These bits allow to select the information to be sent in master mode to slave timers for synchronization (TRGO). The combination is as follows:
              00: Reset:the UG bit from the EGR register is used as trigger output (TRGO). If the reset is generated by the trigger input (slave mode controller configured in reset mode) then the signal on TRGO is delayed compared to the actual reset.
              01: Enable :the Counter enable signal, CNT_EN, is used as trigger output (TRGO). It is useful to start several timers at the same time or to control a window in which a slave timer is enabled. The Counter Enable signal is generated by a logic OR between CEN control bit and the trigger input when configured in gated mode. 
              When the Counter Enable signal is controlled by the trigger input, there is a delay on TRGO, except if the master/slave mode is selected (see the MSM bit description in SMCR register).
              10: Update:The update event is selected as trigger output (TRGO). For instance a master timer can then be used as a prescaler for a slave timer.
              11: Gating:The delayed gating trigger is selected as trigger output (TRGO). 
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SMCR</name>
          <displayName>SMCR</displayName>
          <description>TIM slave mode control register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>GM</name>
              <description>
              Gated Mode. The counter clock is enabled when the selected trigger input (TRGI) is active (according to gating trigger polarity). The counter stops (but is not reset) as soon as the trigger becomes inactive. Both start and stop of the counter are controlled. Gated mode and slave mode can be enabled simutanuously with different trigger selection.
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GTP</name>
              <description>
              Gating trigger polarity invert
              0: active at high level
              1: active at low level
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GTS</name>
              <description>
              Gating trigger selection in gated mode
              This bit-field selects the trigger input to be used to enable the counter gating.
              00: Internal Trigger 0 (ITR0)
              01: Internal Trigger 1 (ITR1) 
              10: Internal Trigger 2 (ITR2)
              11: Internal Trigger 3 (ITR3)
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SMS</name>
              <description>
              Slave mode selection
              When external signals are selected the active edge of the trigger signal (TRGI) is linked to the polarity selected on the external input.
              000: Slave mode disabled.
              001: Reset Mode - Rising edge of the selected trigger input (TRGI) reinitializes the counter and generates an update of the registers.
              010: Trigger Mode - The counter starts at a rising edge of the trigger TRGI (but it is not reset). Only the start of the counter is controlled.
              011: Combined reset + trigger mode - Rising edge of the selected trigger input (TRGI) reinitializes the counter, generates an update of the registers and starts the counter.
              100: External Clock Mode - Rising edges of the selected trigger (TRGI) clock the counter.
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>MSM</name>
              <description>
              Master/Slave mode. This bit should be asserted on master timer if synchronization if needed.
              0: No action
              1: The effect of an event on the trigger input (TRGI) is delayed to allow a perfect synchronization between the current timer and its slaves (through TRGO). It is useful if we want to synchronize several timers on a single external event.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TS</name>
              <description>
              Trigger selection
              This bit-field selects the trigger input to be used to synchronize the counter.
              00: Internal Trigger 0 (ITR0)
              01: Internal Trigger 1 (ITR1) 
              10: Internal Trigger 2 (ITR2)
              11: Internal Trigger 3 (ITR3)
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD5</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DIER</name>
          <displayName>DIER</displayName>
          <description>TIM DMA/Interrupt enable register</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>UDE</name>
              <description>
              Update DMA request enable
              0: Update DMA request disabled.
              1: Update DMA request enabled
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
            <field>
              <name>UIE</name>
              <description>
              Update interrupt enable
              0: Update interrupt disabled.
              1: Update interrupt enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SR</name>
          <displayName>SR</displayName>
          <description>TIM status register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>31</bitWidth>
            </field>
            <field>
              <name>UIF</name>
              <description>
              Update interrupt flag
              This bit is set by hardware on an update event. It is cleared by software.
              0: No update occurred
              1: Update interrupt pending. This bit is set by hardware when the registers are updated:
              At overflow and if UDIS=0 in the CR1 register.
              When CNT is reinitialized by software using the UG bit in EGR register, if URS=0 and UDIS=0 in the CR1 register.
              When CNT is reinitialized by a trigger event (refer to the synchro control register description), if URS=0 and UDIS=0 in the CR1 register.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>EGR</name>
          <displayName>EGR</displayName>
          <description>Event generation register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>31</bitWidth>
            </field>
            <field>
              <name>UG</name>
              <description>
              Update generation
              This bit can be set by software, it is automatically cleared by hardware.
              0: No action
              1: Re-initialize the counter and generates an update of the registers. Note that the prescaler counter is cleared too (anyway the prescaler ratio is not affected). The counter is cleared if the center-aligned mode is selected or if DIR=0 (upcounting), else it takes the auto-reload value (ARR) if DIR=1 (downcounting).
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD1</name>
          <displayName>RSVD1</displayName>
          <description></description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>CNT</name>
          <displayName>CNT</displayName>
          <description>Counter</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>CNT</name>
              <description>
              counter value
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PSC</name>
          <displayName>PSC</displayName>
          <description>Prescaler</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>PSC</name>
              <description>
              Prescaler value
              The counter clock frequency is equal to fCLK / (PSC[15:0] + 1).
              PSC contains the value to be loaded in the active prescaler register at each update event (including when the counter is cleared through UG bit of EGR register or through trigger controller when configured in "reset mode").
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ARR</name>
          <displayName>ARR</displayName>
          <description>Auto-reload register</description>
          <addressOffset>0x2c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ARR</name>
              <description>
              Auto-reload value
              ARR is the value to be loaded in the actual auto-reload register. The counter is blocked while the auto-reload value is null.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>BTIM4</name>
      <description></description>
      <groupName>BTIM</groupName>
      <baseAddress>0x40054000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CR1</name>
          <displayName>CR1</displayName>
          <description>TIM control register 1</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>ARPE</name>
              <description>
              Auto-reload preload enable
              0: ARR register is not buffered
              1: ARR register is buffered
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>OPM</name>
              <description>
              One-pulse mode
              0: Counter is not stopped at update event
              1: Counter stops counting at the next update event (clearing the bit CEN)
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>URS</name>
              <description>
              Update request source
              This bit is set and cleared by software to select the UEV event sources.
              0: Any of the following events generate an update interrupt or DMA request if enabled. 
              These events can be: 
                 Counter overflow
                 Setting the UG bit
                 Update generation through the slave mode controller
              1: Only counter overflow generates an update interrupt or DMA request if enabled.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UDIS</name>
              <description>
              Update disable
              This bit is set and cleared by software to enable/disable UEV event generation.
              0: UEV enabled. The Update (UEV) event is generated by one of the following events:
                 Counter overflow
                 Setting the UG bit
                 Update generation through the slave mode controller
              Buffered registers are then loaded with their preload values.
              1: UEV disabled. The Update event is not generated, shadow registers keep their value (ARR, PSC). However the counter and the prescaler are reinitialized if the UG bit is set or if a hardware reset is received from the slave mode controller.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CEN</name>
              <description>
              Counter enable
              0: Counter disabled
              1: Counter enabled
              Note: Gated mode can work only if the CEN bit has been previously set by software. However trigger mode can set the CEN bit automatically by hardware. 
              CEN is cleared automatically in one-pulse mode, when an update event occurs.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CR2</name>
          <displayName>CR2</displayName>
          <description>TIM control register 2</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>26</bitWidth>
            </field>
            <field>
              <name>MMS</name>
              <description>
              Master mode selection
              These bits allow to select the information to be sent in master mode to slave timers for synchronization (TRGO). The combination is as follows:
              00: Reset:the UG bit from the EGR register is used as trigger output (TRGO). If the reset is generated by the trigger input (slave mode controller configured in reset mode) then the signal on TRGO is delayed compared to the actual reset.
              01: Enable :the Counter enable signal, CNT_EN, is used as trigger output (TRGO). It is useful to start several timers at the same time or to control a window in which a slave timer is enabled. The Counter Enable signal is generated by a logic OR between CEN control bit and the trigger input when configured in gated mode. 
              When the Counter Enable signal is controlled by the trigger input, there is a delay on TRGO, except if the master/slave mode is selected (see the MSM bit description in SMCR register).
              10: Update:The update event is selected as trigger output (TRGO). For instance a master timer can then be used as a prescaler for a slave timer.
              11: Gating:The delayed gating trigger is selected as trigger output (TRGO). 
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SMCR</name>
          <displayName>SMCR</displayName>
          <description>TIM slave mode control register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>GM</name>
              <description>
              Gated Mode. The counter clock is enabled when the selected trigger input (TRGI) is active (according to gating trigger polarity). The counter stops (but is not reset) as soon as the trigger becomes inactive. Both start and stop of the counter are controlled. Gated mode and slave mode can be enabled simutanuously with different trigger selection.
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GTP</name>
              <description>
              Gating trigger polarity invert
              0: active at high level
              1: active at low level
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GTS</name>
              <description>
              Gating trigger selection in gated mode
              This bit-field selects the trigger input to be used to enable the counter gating.
              00: Internal Trigger 0 (ITR0)
              01: Internal Trigger 1 (ITR1) 
              10: Internal Trigger 2 (ITR2)
              11: Internal Trigger 3 (ITR3)
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SMS</name>
              <description>
              Slave mode selection
              When external signals are selected the active edge of the trigger signal (TRGI) is linked to the polarity selected on the external input.
              000: Slave mode disabled.
              001: Reset Mode - Rising edge of the selected trigger input (TRGI) reinitializes the counter and generates an update of the registers.
              010: Trigger Mode - The counter starts at a rising edge of the trigger TRGI (but it is not reset). Only the start of the counter is controlled.
              011: Combined reset + trigger mode - Rising edge of the selected trigger input (TRGI) reinitializes the counter, generates an update of the registers and starts the counter.
              100: External Clock Mode - Rising edges of the selected trigger (TRGI) clock the counter.
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>MSM</name>
              <description>
              Master/Slave mode. This bit should be asserted on master timer if synchronization if needed.
              0: No action
              1: The effect of an event on the trigger input (TRGI) is delayed to allow a perfect synchronization between the current timer and its slaves (through TRGO). It is useful if we want to synchronize several timers on a single external event.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TS</name>
              <description>
              Trigger selection
              This bit-field selects the trigger input to be used to synchronize the counter.
              00: Internal Trigger 0 (ITR0)
              01: Internal Trigger 1 (ITR1) 
              10: Internal Trigger 2 (ITR2)
              11: Internal Trigger 3 (ITR3)
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD5</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DIER</name>
          <displayName>DIER</displayName>
          <description>TIM DMA/Interrupt enable register</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>UDE</name>
              <description>
              Update DMA request enable
              0: Update DMA request disabled.
              1: Update DMA request enabled
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
            <field>
              <name>UIE</name>
              <description>
              Update interrupt enable
              0: Update interrupt disabled.
              1: Update interrupt enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SR</name>
          <displayName>SR</displayName>
          <description>TIM status register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>31</bitWidth>
            </field>
            <field>
              <name>UIF</name>
              <description>
              Update interrupt flag
              This bit is set by hardware on an update event. It is cleared by software.
              0: No update occurred
              1: Update interrupt pending. This bit is set by hardware when the registers are updated:
              At overflow and if UDIS=0 in the CR1 register.
              When CNT is reinitialized by software using the UG bit in EGR register, if URS=0 and UDIS=0 in the CR1 register.
              When CNT is reinitialized by a trigger event (refer to the synchro control register description), if URS=0 and UDIS=0 in the CR1 register.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>EGR</name>
          <displayName>EGR</displayName>
          <description>Event generation register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>31</bitWidth>
            </field>
            <field>
              <name>UG</name>
              <description>
              Update generation
              This bit can be set by software, it is automatically cleared by hardware.
              0: No action
              1: Re-initialize the counter and generates an update of the registers. Note that the prescaler counter is cleared too (anyway the prescaler ratio is not affected). The counter is cleared if the center-aligned mode is selected or if DIR=0 (upcounting), else it takes the auto-reload value (ARR) if DIR=1 (downcounting).
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD1</name>
          <displayName>RSVD1</displayName>
          <description></description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>CNT</name>
          <displayName>CNT</displayName>
          <description>Counter</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>CNT</name>
              <description>
              counter value
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PSC</name>
          <displayName>PSC</displayName>
          <description>Prescaler</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>PSC</name>
              <description>
              Prescaler value
              The counter clock frequency is equal to fCLK / (PSC[15:0] + 1).
              PSC contains the value to be loaded in the active prescaler register at each update event (including when the counter is cleared through UG bit of EGR register or through trigger controller when configured in "reset mode").
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ARR</name>
          <displayName>ARR</displayName>
          <description>Auto-reload register</description>
          <addressOffset>0x2c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ARR</name>
              <description>
              Auto-reload value
              ARR is the value to be loaded in the actual auto-reload register. The counter is blocked while the auto-reload value is null.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>WDT2</name>
      <description></description>
      <groupName>WDT</groupName>
      <baseAddress>0x40055000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>WDT_CVR0</name>
          <displayName>WDT_CVR0</displayName>
          <description>WatchDog Counter Value 0</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>COUNT_VALUE_0</name>
              <description>
              Count Value for 1st TimeOut
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_CVR1</name>
          <displayName>WDT_CVR1</displayName>
          <description>WatchDog Counter Value 1</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>COUNT_VALUE_1</name>
              <description>
              Count Value for 2nd TimeOut
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_CR</name>
          <displayName>WDT_CR</displayName>
          <description>WatchDog Control Register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>27</bitWidth>
            </field>
            <field>
              <name>RESPONSE_MODE</name>
              <description>
              0:reset only, 1:interrupt and reset
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RESET_LENGTH</name>
              <description>
              reset pulse length in number of wdt clock cycles
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_CCR</name>
          <displayName>WDT_CCR</displayName>
          <description>WatchDog Counter Control Register</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>COUNTER_CONTROL</name>
              <description>
              SinglePulse /Write 8'h76 to restart, write8'h34 to stop, else do nothing
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_ICR</name>
          <displayName>WDT_ICR</displayName>
          <description>WatchDog Interrupt Clear Register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>31</bitWidth>
            </field>
            <field>
              <name>INT_CLR</name>
              <description>
              SinglePulse /A pulse to clear interrupt
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_SR</name>
          <displayName>WDT_SR</displayName>
          <description>WatchDog Status Register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>30</bitWidth>
            </field>
            <field>
              <name>WDT_ACTIVE</name>
              <description>
              Watchdog runs when 1, else 0
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>INT_ASSERT</name>
              <description>
              Interrupt assert when 1
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_WP</name>
          <displayName>WDT_WP</displayName>
          <description>WatchDog Write Protect Register</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>WRPT_ST</name>
              <description>
              1 indicates write protect is active
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>WRPT</name>
              <description>
              write 0x58ab99fc generate write_protect, write 0x51ff8621 to release
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>31</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>GPADC</name>
      <description></description>
      <groupName>GPADC</groupName>
      <baseAddress>0x40056000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>ADC_CFG_REG1</name>
          <displayName>ADC_CFG_REG1</displayName>
          <description>ADC Analog Config Register 1</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x04714A44</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>ANAU_GPADC_CMM</name>
              <description>
              Tune CDAC CM voltage 375mV range (increasing) / 25mV step, 8: for 0.5V Vcm,in
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>ANAU_GPADC_CMPCL</name>
              <description>
              Tune ADC comparator CL= 3: 40f, range: 10fF (0) ~ 80fF (7) / 10fF step
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>ANAU_GPADC_VSP</name>
              <description>
              Set comparator input CM in sampling phase, 0.539V (0) / 0.578V (1) / 0.642V (2) / 0.784V (3)
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>ANAU_GPADC_LDOCORE_EN</name>
              <description>
              Enable LDORF for ADC
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ANAU_GPADC_LDOREF_EN</name>
              <description>
              Enable LDORF for ADC VREF
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ANAU_GPADC_LDOCORE_SEL</name>
              <description>
              Set reference voltage for LDOCORE, range = 0.35V(0) ~ 0.65V(15), step = 20mV
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>ANAU_GPADC_LDOVREF_SEL</name>
              <description>
              Set reference voltage for LDOREF, range = 0.35V(0) ~ 0.65V(15), step = 20mV
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>ANAU_GPADC_SEL_PCH</name>
              <description>
              Select P-side input channel for GPADC, 0 for channel 0, 7 for channel 7, effective when force on
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>ANAU_GPADC_SEL_NCH</name>
              <description>
              Select N-side input channel for GPADC, 0 for channel 0, 7 for channel 7, effective when force on
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>ANAU_GPADC_ATTN3X</name>
              <description>
              Attenuate input voltage by 3 for GPADC
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ANAU_GPADC_MUTE</name>
              <description>
              Short GPADC P & N input to CMREF, i.e., VREF/2
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ANAU_GPADC_SE</name>
              <description>
              Set GPADC in single-ended mode, signal range at P-input: 0 ~ VREF
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ADC_SLOT0_REG</name>
          <displayName>ADC_SLOT0_REG</displayName>
          <description>ADC Slot0 Config Register </description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00020801</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>18</bitWidth>
            </field>
            <field>
              <name>NCHNL_SEL</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>PCHNL_SEL</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
            <field>
              <name>SLOT_EN</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ADC_SLOT1_REG</name>
          <displayName>ADC_SLOT1_REG</displayName>
          <description>ADC Slot1 Config Register </description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00020801</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>18</bitWidth>
            </field>
            <field>
              <name>NCHNL_SEL</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>PCHNL_SEL</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
            <field>
              <name>SLOT_EN</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ADC_SLOT2_REG</name>
          <displayName>ADC_SLOT2_REG</displayName>
          <description>ADC Slot2 Config Register </description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00020801</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>18</bitWidth>
            </field>
            <field>
              <name>NCHNL_SEL</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>PCHNL_SEL</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
            <field>
              <name>SLOT_EN</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ADC_SLOT3_REG</name>
          <displayName>ADC_SLOT3_REG</displayName>
          <description>ADC Slot3 Config Register </description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00020801</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>18</bitWidth>
            </field>
            <field>
              <name>NCHNL_SEL</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>PCHNL_SEL</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
            <field>
              <name>SLOT_EN</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ADC_SLOT4_REG</name>
          <displayName>ADC_SLOT4_REG</displayName>
          <description>ADC Slot4 Config Register </description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00020801</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>18</bitWidth>
            </field>
            <field>
              <name>NCHNL_SEL</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>PCHNL_SEL</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
            <field>
              <name>SLOT_EN</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ADC_SLOT5_REG</name>
          <displayName>ADC_SLOT5_REG</displayName>
          <description>ADC Slot5 Config Register </description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00020801</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>18</bitWidth>
            </field>
            <field>
              <name>NCHNL_SEL</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>PCHNL_SEL</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
            <field>
              <name>SLOT_EN</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ADC_SLOT6_REG</name>
          <displayName>ADC_SLOT6_REG</displayName>
          <description>ADC Slot6 Config Register </description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00020801</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>18</bitWidth>
            </field>
            <field>
              <name>NCHNL_SEL</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>PCHNL_SEL</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
            <field>
              <name>SLOT_EN</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ADC_SLOT7_REG</name>
          <displayName>ADC_SLOT7_REG</displayName>
          <description>ADC Slot7 Config Register </description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00020801</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>18</bitWidth>
            </field>
            <field>
              <name>NCHNL_SEL</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>PCHNL_SEL</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
            <field>
              <name>SLOT_EN</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ADC_RDATA0</name>
          <displayName>ADC_RDATA0</displayName>
          <description>ADC Read Data0</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>SLOT1_RDATA</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>SLOT0_RDATA</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ADC_RDATA1</name>
          <displayName>ADC_RDATA1</displayName>
          <description>ADC Read Data1</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>SLOT3_RDATA</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>SLOT2_RDATA</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ADC_RDATA2</name>
          <displayName>ADC_RDATA2</displayName>
          <description>ADC Read Data2</description>
          <addressOffset>0x2c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>SLOT5_RDATA</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>SLOT4_RDATA</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ADC_RDATA3</name>
          <displayName>ADC_RDATA3</displayName>
          <description>ADC Read Data3</description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>SLOT7_RDATA</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>SLOT6_RDATA</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ADC_DMA_RDATA</name>
          <displayName>ADC_DMA_RDATA</displayName>
          <description>ADC Read Data For DMA</description>
          <addressOffset>0x34</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>DMA_RDATA_RAW</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>DMA_RDATA</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ADC_CTRL_REG</name>
          <displayName>ADC_CTRL_REG</displayName>
          <description>ADC Control Register</description>
          <addressOffset>0x38</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000130</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
            <field>
              <name>DMA_DATA_SEL</name>
              <description>
              0: combined data 1: raw data
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TIMER_TRIG_TYP</name>
              <description>
              0: pulse no edge detect needed  1: level,need edge detect
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TIMER_TRIG_SRC_SEL</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>FRC_EN_ADC</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CHNL_SEL_FRC_EN</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TIMER_TRIG_EN</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMA_EN</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ADC_CLK_DIV</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>INIT_TIME</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>ADC_STOP</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ADC_START</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ADC_OP_MODE</name>
              <description>
              0: finite 1: inifinite
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD1</name>
          <displayName>RSVD1</displayName>
          <description></description>
          <addressOffset>0x3C</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>GPADC_IRQ</name>
          <displayName>GPADC_IRQ</displayName>
          <description>GPADC IRQ Register</description>
          <addressOffset>0x40</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>28</bitWidth>
            </field>
            <field>
              <name>GPADC_ISR</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GPADC_IRSR</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GPADC_IMR</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GPADC_ICR</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>SDADC</name>
      <description></description>
      <groupName>SDADC</groupName>
      <baseAddress>0x40057000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CFG0</name>
          <displayName>CFG0</displayName>
          <description></description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>13</bitWidth>
            </field>
            <field>
              <name>PPU_LV</name>
              <description>
              reference generate pre-power-up
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HSUP_LV</name>
              <description>
              supply votage 0x0:1.8v 0x1: 3.3v
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DC_TR_LV</name>
              <description>
              DCTR
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>SDADC_DATA_RDY</name>
              <description>
              1 indicates sample adc data done once
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DSAMPLE_MODE</name>
              <description>
              1: sample adc data on a maximum of five channels in non-contious mode; 0:  sample adc data on only one channel in non-contious mode
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CLK_INV_LV</name>
              <description>
              inverse clk to folter or not 0x0:no 0x1:yes
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CONTIN_LV</name>
              <description>
              continous sample or not 0x0:no 0x1:yes
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LDO_SEL_LV</name>
              <description>
              ldo voltage selection
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>FCK_SEL_LV</name>
              <description>
              ADC clock dividing selection
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RUN_LV</name>
              <description>
              start sdadc sample in continous mode
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CLRLEN_LV</name>
              <description>
              length of clear pulse
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>PU_LV</name>
              <description>
              power up
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CFG1</name>
          <displayName>CFG1</displayName>
          <description></description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CHOP3_NUM_LV</name>
              <description>
              chopping weight controlling of 3rd stage
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
            <field>
              <name>CHOP2_NUM_LV</name>
              <description>
              chopping weight controlling of 2nd stage
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
            <field>
              <name>CHOP1_NUM_LV</name>
              <description>
              chopping weight controlling of 1st stage
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
            <field>
              <name>CHOP_STOP_EN_LV</name>
              <description>
              chopping weight controlling enable
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FCHOP_SIG_SEL_LV</name>
              <description>
              siganal path chopping frequency
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>CHOP_EN_LV</name>
              <description>
              chopping enable
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CFG2</name>
          <displayName>CFG2</displayName>
          <description></description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>FCHOP_REF_SEL_LV</name>
              <description>
              reference buffer chopping frequency
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>CHOP_REF_NUM_LV</name>
              <description>
              chopping weight controlling of reference buffer
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
            <field>
              <name>SE_DIFF_SEL_LV</name>
              <description>
              single ended or differencial input 0x0: single end  0x1:differencial
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DEM_EN_LV</name>
              <description>
              DEM enable of gain controlling circuits
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GAIN_DENO_LV</name>
              <description>
              denominator of gain
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>GAIN_NUME_LV</name>
              <description>
              numerator of gain
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>SAMPLE_NUM_LV</name>
              <description>
              number of sample
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CFG3</name>
          <displayName>CFG3</displayName>
          <description></description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
            <field>
              <name>REFBUF_CHOP_MX_LV</name>
              <description>
              reference buffer chopping mixed with dout 0x0: no 0x1:yes
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>REFBUF_AZ_LV</name>
              <description>
              reference buffer autozero 0x0: no 0x1: yes
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>AMP2_BM_LV</name>
              <description>
              bias mode of 2nd and 3rd opamp
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>REFBUF_BM_LV</name>
              <description>
              bias mode of reference buffer
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>AMP1_BM_LV</name>
              <description>
              bias mode of first opamp
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>REFBUF_BP_LV</name>
              <description>
              reference buffer bypass 0x0: no 0x1:yes
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>INT_VREF_SET_LV</name>
              <description>
              set internal reference voltage
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>VREF_SEL_LV</name>
              <description>
              reference source selection
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>SEL_NCH_LV</name>
              <description>
              Select N-side input channel for SDMADC, 0 for channel 0 , 4 for channel 4
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>SEL_PCH_LV</name>
              <description>
              Select P-side input channel for SDMADC, 0 for channel 0 , 4 for channel 4
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CAL</name>
          <displayName>CAL</displayName>
          <description></description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>OSCAL_RDY_LV</name>
              <description>
              1 indicates calibration done once
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OS_SET2_LV</name>
              <description>
              offset code for rebuf
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>OS_SET1_LV</name>
              <description>
              offset code for 1st opamp
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>OSCAL_RST_LV</name>
              <description>
              reset for offset calibration 0x0: reset 0x1: release
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OSCAL_EN_LV</name>
              <description>
              offset calibration enable 0x0: no 0x1: 1st opamp 0x2: rebuffer 0x3: 2nd opamp 0x4:3rd opamp
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TRIG</name>
          <displayName>TRIG</displayName>
          <description></description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>26</bitWidth>
            </field>
            <field>
              <name>ADC_START</name>
              <description>
              trigger sdadc sample in non-continous mode once
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GPIO_TRIG_EN</name>
              <description>
              enable gpio postive edge to trigger sdadc sample in non-continous mode
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TIMER_TRIG_SRC_SEL</name>
              <description>
              timer trigger source select
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>TIMER_TRIG_EN</name>
              <description>
              enable timer trigger source select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CH0_CFG</name>
          <displayName>CH0_CFG</displayName>
          <description></description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>SHIFT_NUM</name>
              <description>
              channel  0 sample times (= 2^shift_num)
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>SEL_NCH</name>
              <description>
              channel 0 selection N-side input
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>SEL_PCH</name>
              <description>
              channel 0 selection P-side input
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>EN</name>
              <description>
              enable channel 0 sample
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CH1_CFG</name>
          <displayName>CH1_CFG</displayName>
          <description></description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>SHIFT_NUM</name>
              <description>
              channel  1 sample times (= 2^shift_num)
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>SEL_NCH</name>
              <description>
              channel 1 selection N-side input
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>SEL_PCH</name>
              <description>
              channel 1 selection P-side input
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>EN</name>
              <description>
              enable channel 1 sample
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CH2_CFG</name>
          <displayName>CH2_CFG</displayName>
          <description></description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>SHIFT_NUM</name>
              <description>
              channel 2 sample times (= 2^shift_num)
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>SEL_NCH</name>
              <description>
              channel 2 selection N-side input
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>SEL_PCH</name>
              <description>
              channel 2 selection P-side input
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>EN</name>
              <description>
              enable channel 2 sample
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CH3_CFG</name>
          <displayName>CH3_CFG</displayName>
          <description></description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>SHIFT_NUM</name>
              <description>
              channel  3 sample times (= 2^shift_num)
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>SEL_NCH</name>
              <description>
              channel 3 selection N-side input
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>SEL_PCH</name>
              <description>
              channel 3 selection P-side input
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>EN</name>
              <description>
              enable channel 3 sample
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CH4_CFG</name>
          <displayName>CH4_CFG</displayName>
          <description></description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>SHIFT_NUM</name>
              <description>
              channel  4 sample times (= 2^shift_num)
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>SEL_NCH</name>
              <description>
              channel 4 selection N-side input
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>SEL_PCH</name>
              <description>
              channel 4 selection P-side input
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>EN</name>
              <description>
              enable channel 4 sample
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CH0_DOUT</name>
          <displayName>CH0_DOUT</displayName>
          <description></description>
          <addressOffset>0x2c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>DATA</name>
              <description>
              channel 0 average value
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CH1_DOUT</name>
          <displayName>CH1_DOUT</displayName>
          <description></description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>DATA</name>
              <description>
              channel 1 average value
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CH2_DOUT</name>
          <displayName>CH2_DOUT</displayName>
          <description></description>
          <addressOffset>0x34</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>DATA</name>
              <description>
              channel 2 average value
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CH3_DOUT</name>
          <displayName>CH3_DOUT</displayName>
          <description></description>
          <addressOffset>0x38</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>DATA</name>
              <description>
              channel 3 average value
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CH4_DOUT</name>
          <displayName>CH4_DOUT</displayName>
          <description></description>
          <addressOffset>0x3c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>DATA</name>
              <description>
              channel 4 average value
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SINGLE_DOUT</name>
          <displayName>SINGLE_DOUT</displayName>
          <description></description>
          <addressOffset>0x40</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>DATA</name>
              <description>
              sample date when contin_lv is 0 and dsample_mode is 0 
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SINC_CFG</name>
          <displayName>SINC_CFG</displayName>
          <description></description>
          <addressOffset>0x44</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>SINC_ORDER_SEL</name>
              <description>
              1:select four differentiators in sinc filter; 0:select three differentiators in sinc filter
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SINC_RATE</name>
              <description>
              dowmsampling rate of  sinc filter
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>COMP_CFG0</name>
          <displayName>COMP_CFG0</displayName>
          <description></description>
          <addressOffset>0x48</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>19</bitWidth>
            </field>
            <field>
              <name>COMP_COEFF0</name>
              <description>
              coefficient 0 of compensating filter
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
            <field>
              <name>COMP_BYPASS</name>
              <description>
              1: bypass compensating filter ; 0: enable compensating filter
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>COMP_CFG1</name>
          <displayName>COMP_CFG1</displayName>
          <description></description>
          <addressOffset>0x4c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>COMP_COEFF2</name>
              <description>
              coefficient 2 of compensating filter
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
            <field>
              <name>COMP_COEFF1</name>
              <description>
              coefficient 1 of compensating filter
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD2</name>
          <displayName>RSVD2</displayName>
          <description></description>
          <addressOffset>0x50</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>LPF_CFG6</name>
          <displayName>LPF_CFG6</displayName>
          <description></description>
          <addressOffset>0x68</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>18</bitWidth>
            </field>
            <field>
              <name>LPF_BYPASS</name>
              <description>
              1:bypass low-pass filter ; 0: enable low-pass filter
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LPF_DS</name>
              <description>
              1:downsampling rate of low pass filter is two;0:No downsampling of low pass filter
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DMA_CFG</name>
          <displayName>DMA_CFG</displayName>
          <description></description>
          <addressOffset>0x6c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>31</bitWidth>
            </field>
            <field>
              <name>RX_DMA_MSK</name>
              <description>
              1:disable sdadc dma request; 0: enable sdadc dma request
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD1</name>
          <displayName>RSVD1</displayName>
          <description></description>
          <addressOffset>0x70</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>FIFO_ST</name>
          <displayName>FIFO_ST</displayName>
          <description></description>
          <addressOffset>0x74</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>31</bitWidth>
            </field>
            <field>
              <name>EMPTY</name>
              <description>
              1 indicates sdadc fifo is empty
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>INT_ST</name>
          <displayName>INT_ST</displayName>
          <description></description>
          <addressOffset>0x78</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>30</bitWidth>
            </field>
            <field>
              <name>DSAMPLE</name>
              <description>
              1 indicates sdadc sample done in non-continous mode and as one of irq source at same time
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>
              1 indicates sdadc fifo has already overflowed and as one of irq source at same time 
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>INT_MSK</name>
          <displayName>INT_MSK</displayName>
          <description></description>
          <addressOffset>0x7c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>30</bitWidth>
            </field>
            <field>
              <name>DSAMPLE</name>
              <description>
              1:disable sdadc sample done irq to system; 0: enable sdadc sample done irq to system
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>
              1:disable sdadc fifo overflow irq to system; 0: enable sdadc fifo overflow irq to system
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>INT_CLR</name>
          <displayName>INT_CLR</displayName>
          <description></description>
          <addressOffset>0x80</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>31</bitWidth>
            </field>
            <field>
              <name>INT_CLR</name>
              <description>
              clear sdadc irq
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>FSM_ST</name>
          <displayName>FSM_ST</displayName>
          <description></description>
          <addressOffset>0x84</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>31</bitWidth>
            </field>
            <field>
              <name>ACTIVE</name>
              <description>
              1 indicates sdadc non-continous mode is running
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>TSEN</name>
      <description></description>
      <groupName>TSEN</groupName>
      <baseAddress>0x4005a000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>TSEN_CTRL_REG</name>
          <displayName>TSEN_CTRL_REG</displayName>
          <description>TSEN Analog Control Register </description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x04714A44</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>14</bitWidth>
            </field>
            <field>
              <name>ANAU_TSEN_CLK_DIV</name>
              <description>
              gen tsen clk by divide pclk by anau_tsen_clk_div
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>ANAU_TSEN_EN</name>
              <description>
              Enable tsen digital module
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ANAU_TSEN_RDY</name>
              <description>
              tsen ready
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ANAU_TSEN_SER_PAR_SEL</name>
              <description>
              serial-parallel output selection
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ANAU_TSEN_SGN_EN</name>
              <description>
              signature-mode enable
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ANAU_TSEN_FCK_SEL</name>
              <description>
              select internal clock frequency
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>ANAU_TSEN_IG_VBE</name>
              <description>
              bias current selection to tune vba
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>ANAU_TSEN_RUN</name>
              <description>
              enable tsen run
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ANAU_TSEN_RSTB</name>
              <description>
              resetb for tsen
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ANAU_TSEN_PU</name>
              <description>
              power up tsen
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TSEN_RDATA</name>
          <displayName>TSEN_RDATA</displayName>
          <description>Tsen Read Data</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>TSEN_RDATA</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TSEN_IRQ</name>
          <displayName>TSEN_IRQ</displayName>
          <description>Tsen IRQ Register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>28</bitWidth>
            </field>
            <field>
              <name>TSEN_ISR</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TSEN_IRSR</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TSEN_IMR</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TSEN_ICR</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD1</name>
          <displayName>RSVD1</displayName>
          <description></description>
          <addressOffset>0xC</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>ANAU_ANA_TP</name>
          <displayName>ANAU_ANA_TP</displayName>
          <description>Tsen IRQ Register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>31</bitWidth>
            </field>
            <field>
              <name>ANAU_IARY_EN</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BGR</name>
          <displayName>BGR</displayName>
          <description>Bandgap registers</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000CC0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>VREF12</name>
              <description>
              select VREF 1.2V
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>VREF06</name>
              <description>
              select VREF 0.6V
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>EN</name>
              <description>
              Bandgap enable
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PTC2</name>
      <description></description>
      <groupName>PTC</groupName>
      <baseAddress>0x4005b000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>ISR</name>
          <displayName>ISR</displayName>
          <description>interrupt status register</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>TEIF8</name>
              <description>
              transfer error flag for task 8
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIF7</name>
              <description>
              transfer error flag for task 7
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIF6</name>
              <description>
              transfer error flag for task 6
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIF5</name>
              <description>
              transfer error flag for task 5
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIF4</name>
              <description>
              transfer error flag for task 4
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIF3</name>
              <description>
              transfer error flag for task 3
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIF2</name>
              <description>
              transfer error flag for task 2
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIF1</name>
              <description>
              transfer error flag for task 1
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>TCIF8</name>
              <description>
              task complete interrupt flag for task 8
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIF7</name>
              <description>
              task complete interrupt flag for task 7
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIF6</name>
              <description>
              task complete interrupt flag for task 6
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIF5</name>
              <description>
              task complete interrupt flag for task 5
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIF4</name>
              <description>
              task complete interrupt flag for task 4
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIF3</name>
              <description>
              task complete interrupt flag for task 3
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIF2</name>
              <description>
              task complete interrupt flag for task 2
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIF1</name>
              <description>
              task complete interrupt flag for task 1
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ICR</name>
          <displayName>ICR</displayName>
          <description>interrupt clear register</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>15</bitWidth>
            </field>
            <field>
              <name>CTEIF</name>
              <description>
              clear transfer error flag
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>CTCIF8</name>
              <description>
              clear task complete interrupt flag for task 8
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTCIF7</name>
              <description>
              clear task complete interrupt flag for task 7
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTCIF6</name>
              <description>
              clear task complete interrupt flag for task 6
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTCIF5</name>
              <description>
              clear task complete interrupt flag for task 5
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTCIF4</name>
              <description>
              clear task complete interrupt flag for task 4
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTCIF3</name>
              <description>
              clear task complete interrupt flag for task 3
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTCIF2</name>
              <description>
              clear task complete interrupt flag for task 2
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTCIF1</name>
              <description>
              clear task complete interrupt flag for task 1
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IER</name>
          <displayName>IER</displayName>
          <description>interrupt enable register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>15</bitWidth>
            </field>
            <field>
              <name>TEIE</name>
              <description>
              enable transfer error flag
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>TCIE8</name>
              <description>
              enable task complete interrupt for task 8
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIE7</name>
              <description>
              enable task complete interrupt for task 7
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIE6</name>
              <description>
              enable task complete interrupt for task 6
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIE5</name>
              <description>
              enable task complete interrupt for task 5
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIE4</name>
              <description>
              enable task complete interrupt for task 4
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIE3</name>
              <description>
              enable task complete interrupt for task 3
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIE2</name>
              <description>
              enable task complete interrupt for task 2
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIE1</name>
              <description>
              enable task complete interrupt for task 1
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TCR1</name>
          <displayName>TCR1</displayName>
          <description>task 1 control register</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>13</bitWidth>
            </field>
            <field>
              <name>OP</name>
              <description>
              task operation
              3'b000: direct write data
              3'b100: read then XOR with data and write back
              3'b101: read then OR with data and write back
              3'b110: read then AND with data and write back
              3'b111: read then add with data and write back
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>TRIGSEL</name>
              <description>
              select trigger source
              0: task will not be triggered
              others: task will be triggered by selected source
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TAR1</name>
          <displayName>TAR1</displayName>
          <description>task 1 address register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ADDR</name>
              <description>
              peripheral address to access to
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TDR1</name>
          <displayName>TDR1</displayName>
          <description>task 1 data register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              data value for task operation
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TCR2</name>
          <displayName>TCR2</displayName>
          <description></description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>13</bitWidth>
            </field>
            <field>
              <name>OP</name>
              <description>
              task operation
              3'b000: direct write data
              3'b100: read then XOR with data and write back
              3'b101: read then OR with data and write back
              3'b110: read then AND with data and write back
              3'b111: read then add with data and write back
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>TRIGSEL</name>
              <description>
              select trigger source
              0: task will not be triggered
              others: task will be triggered by selected source
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TAR2</name>
          <displayName>TAR2</displayName>
          <description></description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ADDR</name>
              <description>
              peripheral address to access to
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TDR2</name>
          <displayName>TDR2</displayName>
          <description></description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              data value for task operation
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TCR3</name>
          <displayName>TCR3</displayName>
          <description></description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>13</bitWidth>
            </field>
            <field>
              <name>OP</name>
              <description>
              task operation
              3'b000: direct write data
              3'b100: read then XOR with data and write back
              3'b101: read then OR with data and write back
              3'b110: read then AND with data and write back
              3'b111: read then add with data and write back
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>TRIGSEL</name>
              <description>
              select trigger source
              0: task will not be triggered
              others: task will be triggered by selected source
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TAR3</name>
          <displayName>TAR3</displayName>
          <description></description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ADDR</name>
              <description>
              peripheral address to access to
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TDR3</name>
          <displayName>TDR3</displayName>
          <description></description>
          <addressOffset>0x2c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              data value for task operation
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TCR4</name>
          <displayName>TCR4</displayName>
          <description></description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>13</bitWidth>
            </field>
            <field>
              <name>OP</name>
              <description>
              task operation
              3'b000: direct write data
              3'b100: read then XOR with data and write back
              3'b101: read then OR with data and write back
              3'b110: read then AND with data and write back
              3'b111: read then add with data and write back
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>TRIGSEL</name>
              <description>
              select trigger source
              0: task will not be triggered
              others: task will be triggered by selected source
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TAR4</name>
          <displayName>TAR4</displayName>
          <description></description>
          <addressOffset>0x34</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ADDR</name>
              <description>
              peripheral address to access to
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TDR4</name>
          <displayName>TDR4</displayName>
          <description></description>
          <addressOffset>0x38</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              data value for task operation
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TCR5</name>
          <displayName>TCR5</displayName>
          <description></description>
          <addressOffset>0x3c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>13</bitWidth>
            </field>
            <field>
              <name>OP</name>
              <description>
              task operation
              3'b000: direct write data
              3'b100: read then XOR with data and write back
              3'b101: read then OR with data and write back
              3'b110: read then AND with data and write back
              3'b111: read then add with data and write back
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>TRIGSEL</name>
              <description>
              select trigger source
              0: task will not be triggered
              others: task will be triggered by selected source
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TAR5</name>
          <displayName>TAR5</displayName>
          <description></description>
          <addressOffset>0x40</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ADDR</name>
              <description>
              peripheral address to access to
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TDR5</name>
          <displayName>TDR5</displayName>
          <description></description>
          <addressOffset>0x44</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              data value for task operation
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TCR6</name>
          <displayName>TCR6</displayName>
          <description></description>
          <addressOffset>0x48</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>13</bitWidth>
            </field>
            <field>
              <name>OP</name>
              <description>
              task operation
              3'b000: direct write data
              3'b100: read then XOR with data and write back
              3'b101: read then OR with data and write back
              3'b110: read then AND with data and write back
              3'b111: read then add with data and write back
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>TRIGSEL</name>
              <description>
              select trigger source
              0: task will not be triggered
              others: task will be triggered by selected source
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TAR6</name>
          <displayName>TAR6</displayName>
          <description></description>
          <addressOffset>0x4c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ADDR</name>
              <description>
              peripheral address to access to
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TDR6</name>
          <displayName>TDR6</displayName>
          <description></description>
          <addressOffset>0x50</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              data value for task operation
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TCR7</name>
          <displayName>TCR7</displayName>
          <description></description>
          <addressOffset>0x54</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>13</bitWidth>
            </field>
            <field>
              <name>OP</name>
              <description>
              task operation
              3'b000: direct write data
              3'b100: read then XOR with data and write back
              3'b101: read then OR with data and write back
              3'b110: read then AND with data and write back
              3'b111: read then add with data and write back
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>TRIGSEL</name>
              <description>
              select trigger source
              0: task will not be triggered
              others: task will be triggered by selected source
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TAR7</name>
          <displayName>TAR7</displayName>
          <description></description>
          <addressOffset>0x58</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ADDR</name>
              <description>
              peripheral address to access to
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TDR7</name>
          <displayName>TDR7</displayName>
          <description></description>
          <addressOffset>0x5c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              data value for task operation
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TCR8</name>
          <displayName>TCR8</displayName>
          <description></description>
          <addressOffset>0x60</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>13</bitWidth>
            </field>
            <field>
              <name>OP</name>
              <description>
              task operation
              3'b000: direct write data
              3'b100: read then XOR with data and write back
              3'b101: read then OR with data and write back
              3'b110: read then AND with data and write back
              3'b111: read then add with data and write back
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>TRIGSEL</name>
              <description>
              select trigger source
              0: task will not be triggered
              others: task will be triggered by selected source
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TAR8</name>
          <displayName>TAR8</displayName>
          <description></description>
          <addressOffset>0x64</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ADDR</name>
              <description>
              peripheral address to access to
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TDR8</name>
          <displayName>TDR8</displayName>
          <description></description>
          <addressOffset>0x68</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              data value for task operation
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD1</name>
          <displayName>RSVD1</displayName>
          <description></description>
          <addressOffset>0x6C</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>MEM1</name>
          <displayName>MEM1</displayName>
          <description>temporary memory 1</description>
          <addressOffset>0x70</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              memory to store temporary variables
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>MEM2</name>
          <displayName>MEM2</displayName>
          <description>temporary memory 2</description>
          <addressOffset>0x74</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              memory to store temporary variables
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>MEM3</name>
          <displayName>MEM3</displayName>
          <description>temporary memory 3</description>
          <addressOffset>0x78</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              memory to store temporary variables
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>MEM4</name>
          <displayName>MEM4</displayName>
          <description>temporary memory 4</description>
          <addressOffset>0x7c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              memory to store temporary variables
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>GPIO31_0</name>
          <displayName>GPIO31_0</displayName>
          <description></description>
          <addressOffset>0x80</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>SELD</name>
              <description>
              select trigger D of GPIO 31~0
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>SELC</name>
              <description>
              select trigger C of GPIO 31~0
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>SELB</name>
              <description>
              select trigger B of GPIO 31~0
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>SELA</name>
              <description>
              select trigger A of GPIO 31~0
              0: select GPIO 0
              1: select GPIO 1
              ......
              31: select GPIO 31
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>GPIO63_32</name>
          <displayName>GPIO63_32</displayName>
          <description></description>
          <addressOffset>0x84</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>SELD</name>
              <description>
              select trigger D of GPIO 63~32
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>SELC</name>
              <description>
              select trigger C of GPIO 63~32
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>SELB</name>
              <description>
              select trigger B of GPIO 63~32
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>SELA</name>
              <description>
              select trigger A of GPIO 63~32
              0: select GPIO 32
              1: select GPIO 33
              ......
              31: select GPIO 63
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>GPIO95_64</name>
          <displayName>GPIO95_64</displayName>
          <description></description>
          <addressOffset>0x88</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>SELD</name>
              <description>
              select trigger D of GPIO 95~64
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>SELC</name>
              <description>
              select trigger C of GPIO 95~64
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>SELB</name>
              <description>
              select trigger B of GPIO 95~64
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>SELA</name>
              <description>
              select trigger A of GPIO 95~64
              0: select GPIO 64
              1: select GPIO 65
              ......
              31: select GPIO 95
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>LCDC2</name>
      <description></description>
      <groupName>LCDC</groupName>
      <baseAddress>0x4005c000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>COMMAND</name>
          <displayName>COMMAND</displayName>
          <description></description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>30</bitWidth>
            </field>
            <field>
              <name>RESET</name>
              <description>
              1: reset the whole graphics   0: release the reset
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>START</name>
              <description>
              write 1 to trigger the lcd interface block
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS</name>
          <displayName>STATUS</displayName>
          <description></description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>29</bitWidth>
            </field>
            <field>
              <name>JDI_PAR_RUN</name>
              <description>
              JDI parallel interface is running
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DPI_RUN</name>
              <description>
              DPI interface is running
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LCD_BUSY</name>
              <description>
              LCS controll busy flag
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IRQ</name>
          <displayName>IRQ</displayName>
          <description></description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
            <field>
              <name>JDI_PAR_UDR_RAW_STAT</name>
              <description>
              raw_status of jdi parallel interface under run interrupt
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>JDI_PARL_INTR_RAW_STAT</name>
              <description>
              raw_status of jdi parallel interface line interrupt
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DPI_UDR_RAW_STAT</name>
              <description>
              raw status of dpi under run interrupt
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DPIL_INTR_RAW_STAT</name>
              <description>
              raw status of dpi line interrupt
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ICB_OF_RAW_STAT</name>
              <description>
              raw status of icb overflow interrupt
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EOF_RAW_STAT</name>
              <description>
              raw status of end of frame interrupt
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
            <field>
              <name>JDI_PAR_UDR_STAT</name>
              <description>
              jdi parallel interface under run interrupt, masked by mask register
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>JDI_PARL_INTR_STAT</name>
              <description>
              jdi parallel interface line interrupt, masked by mask register
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DPI_UDR_STAT</name>
              <description>
              dpi under run interrupt, masked by mask register
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DPIL_INTR_STAT</name>
              <description>
              dpi line interrupt, masked by mask register
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ICB_OF_STAT</name>
              <description>
              icb overflow interrupt, masked by mask register
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EOF_STAT</name>
              <description>
              end of frame interrupt, masked by mask register
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SETTING</name>
          <displayName>SETTING</displayName>
          <description></description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>AUTO_GATE_EN</name>
              <description>
              auto clock gating enable
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>JDI_PAR_UDR_MASK</name>
              <description>
              jdi parallel interface under run interrupt mask, 0: mask the interrupt
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>JDI_PARL_INTR_MASK</name>
              <description>
              jdi parallel interface line interrupt, 0: mask the interrupt
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DPI_UDR_MASK</name>
              <description>
              dpi under run interrupt mask, 0: mask the interrupt
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DPIL_INTR_MASK</name>
              <description>
              dpi line interrupt, 0: mask the interrupt
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ICB_OF_MASK</name>
              <description>
              icb overflow interrupt mask, 0: mask the interrupt
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EOF_MASK</name>
              <description>
              end of frame interrupt mask, 0: mask the interrupt
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CANVAS_TL_POS</name>
          <displayName>CANVAS_TL_POS</displayName>
          <description></description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>Y0</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>X0</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CANVAS_BR_POS</name>
          <displayName>CANVAS_BR_POS</displayName>
          <description></description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>Y1</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>X1</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CANVAS_BG</name>
          <displayName>CANVAS_BG</displayName>
          <description></description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>RED</name>
              <description>
              Red color
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>GREEN</name>
              <description>
              green color
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>BLUE</name>
              <description>
              blue color
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>LAYER0_CONFIG</name>
          <displayName>LAYER0_CONFIG</displayName>
          <description></description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>ACTIVE</name>
              <description>
              layer active flag
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LINE_FETCH_MODE</name>
              <description>
              line fetch mode
              0: address skip every single line
              1: address skip every two line
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PREFETCH_EN</name>
              <description>
              preload 64 bytes extra data when reading pixel from memory
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>WIDTH</name>
              <description>
              source image width(including padding), unit is bytes
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>13</bitWidth>
            </field>
            <field>
              <name>FILTER_EN</name>
              <description>
              layer color filter enable
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ALPHA</name>
              <description>
              layer alpha value
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>ALPHA_SEL</name>
              <description>
              alpha selection
              1'b0: select alpha according to image format
              1'b1: select layer alpha
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FORMAT</name>
              <description>
              overlay layer input format
              3'h0: RGB565
              3'h1: RGB888
              3'h2: ARGB8888
              3'h3: ARGB8565
              3'h4: RGB332
              others: reserved
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>LAYER0_TL_POS</name>
          <displayName>LAYER0_TL_POS</displayName>
          <description></description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>Y0</name>
              <description>
              Coordingate Y-value
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>X0</name>
              <description>
              Coordinate X-value
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>LAYER0_BR_POS</name>
          <displayName>LAYER0_BR_POS</displayName>
          <description></description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>Y1</name>
              <description>
              Coordingate Y-value
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>X1</name>
              <description>
              Coordinate X-value
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>LAYER0_FILTER</name>
          <displayName>LAYER0_FILTER</displayName>
          <description></description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>FILTER_MASK</name>
              <description>
              layer color filter mask
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>FILTER_R</name>
              <description>
              filter r color
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>FILTER_G</name>
              <description>
              filter g color
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>FILTER_B</name>
              <description>
              filter b color
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>LAYER0_SRC</name>
          <displayName>LAYER0_SRC</displayName>
          <description></description>
          <addressOffset>0x2c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ADDR</name>
              <description>
              source image RGB data address[31:0]. For RGB565 format, address should be aligned to halfword. For ARGB8888 format, address should be aligned to word.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>LAYER0_DECOMP</name>
          <displayName>LAYER0_DECOMP</displayName>
          <description></description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
            <field>
              <name>COL_SIZE</name>
              <description>
              number of colums in a line of original image
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
            <field>
              <name>TARGET_WORDS</name>
              <description>
              size of a single channel data before decompression. Unit is half word. Each line has 3 channels. So for each line, the compressed data size is target_words * 3 * 2 bytes.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
            <field>
              <name>ENABLE</name>
              <description>
              decompression enable
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>LAYER0_DECOMP_CFG0</name>
          <displayName>LAYER0_DECOMP_CFG0</displayName>
          <description></description>
          <addressOffset>0x34</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x01055982</resetValue>
          <fields>
            <field>
              <name>CFG0_RESERVED</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
            <field>
              <name>LOSSLESS_QIDX2</name>
              <description>
              condition to decrease qidx
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>LOSSLESS_QIDX1</name>
              <description>
              up level for adjusted qidx value for low quality block
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>USE_LOSSLESS_QIDX</name>
              <description>
              condition to increase qidx
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>EXTRA_THRESHOLD</name>
              <description>
              the threshold to distinguish high/low quality block
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>EXTRA_HIGH</name>
              <description>
              extra bit for high quality bit
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>LAYER0_DECOMP_CFG1</name>
          <displayName>LAYER0_DECOMP_CFG1</displayName>
          <description></description>
          <addressOffset>0x38</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x80023307</resetValue>
          <fields>
            <field>
              <name>EXTRA_LOW</name>
              <description>
              extra bit for low quality block
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>BLOCK_MIN_QIDX</name>
              <description>
              minimum qidx for block mode
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>LINE_MIN_QIDX</name>
              <description>
              minimum qidx for line mode
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>FAILOVER_BITS_B</name>
              <description>
              failover compression mode target bits(Blue)
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>FAILOVER_BITS_G</name>
              <description>
              failover compression mode target bits(Green)
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>FAILOVER_BITS_R</name>
              <description>
              failover compression mode target bits(Red)
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>CFG1_RESERVED</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>DITHER</name>
              <description>
              dithering function
              0: off
              1: on
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BLOCK_WIDTH</name>
              <description>
              block_size in pixel unit.
              0: 16 pixels
              1: 32 pixels
              Small block size will cause more blocks and more bits to store block information.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>LAYER0_DECOMP_STAT</name>
          <displayName>LAYER0_DECOMP_STAT</displayName>
          <description></description>
          <addressOffset>0x3c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>26</bitWidth>
            </field>
            <field>
              <name>BUF_MAX_DEPTH</name>
              <description>
              buf max usage
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>LAYER1_CONFIG</name>
          <displayName>LAYER1_CONFIG</displayName>
          <description></description>
          <addressOffset>0x40</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>ACTIVE</name>
              <description>
              layer active flag
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LINE_FETCH_MODE</name>
              <description>
              line fetch mode
              0: address skip every single line
              1: address skip every two line
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PREFETCH_EN</name>
              <description>
              preload 64 bytes extra data when reading pixel from memory
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>WIDTH</name>
              <description>
              source image width(including padding), unit is bytes
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>13</bitWidth>
            </field>
            <field>
              <name>FILTER_EN</name>
              <description>
              layer color filter enable
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ALPHA</name>
              <description>
              layer alpha value
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>ALPHA_SEL</name>
              <description>
              alpha selection
              1'b0: select alpha according to image format
              1'b1: select layer alpha
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FORMAT</name>
              <description>
              overlay layer input format
              3'h0: RGB565
              3'h1: RGB888
              3'h2: ARGB8888
              3'h3: ARGB8565
              3'h4: RGB332
              others: reserved
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>LAYER1_TL_POS</name>
          <displayName>LAYER1_TL_POS</displayName>
          <description></description>
          <addressOffset>0x44</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>Y0</name>
              <description>
              Coordingate Y-value
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>X0</name>
              <description>
              Coordinate X-value
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>LAYER1_BR_POS</name>
          <displayName>LAYER1_BR_POS</displayName>
          <description></description>
          <addressOffset>0x48</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>Y1</name>
              <description>
              Coordingate Y-value
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>X1</name>
              <description>
              Coordinate X-value
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>LAYER1_FILTER</name>
          <displayName>LAYER1_FILTER</displayName>
          <description></description>
          <addressOffset>0x4c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>FILTER_MASK</name>
              <description>
              layer color filter mask
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>FILTER_R</name>
              <description>
              filter r color
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>FILTER_G</name>
              <description>
              filter g color
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>FILTER_B</name>
              <description>
              filter b color
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>LAYER1_SRC</name>
          <displayName>LAYER1_SRC</displayName>
          <description></description>
          <addressOffset>0x50</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ADDR</name>
              <description>
              source image RGB data address[31:0]. For RGB565 format, address should be aligned to halfword. For ARGB8888 format, address should be aligned to word.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD1</name>
          <displayName>RSVD1</displayName>
          <description></description>
          <addressOffset>0x54</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>LCD_CONF</name>
          <displayName>LCD_CONF</displayName>
          <description></description>
          <addressOffset>0x60</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>15</bitWidth>
            </field>
            <field>
              <name>JDI_SER_FORMAT</name>
              <description>
              JDI serial format
              2'b00: 3-bit mode
              2'b01: 4-bit mode
              2'b10: 1-bit mode
              2'b11: reserved
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>DPI_LCD_FORMAT</name>
              <description>
              DPI LCD format
              3'b000: 16-bit conf1
              3'b001: 16-bit conf2
              3'b010: 16-bit conf3
              3'b011: 18-bit conf1
              3'b100: 18-bit conf2
              3'b101: 24-bit
              others: Reserved
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>SPI_LCD_FORMAT</name>
              <description>
              SPI LCD format
              2'b00: 8-bit RGB 3:3:2
              2'b01: 16-bit RGB 5:6:5
              2'b10: 24-bit RGB 8:8:8
              2'b11: Reserved
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>AHB_FORMAT</name>
              <description>
              AHB LCD/RAM output format:
              0: RGB565
              1: RGB888
              2: ARGB8888
              3: RGB332
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>LCD_FORMAT</name>
              <description>
              LCD output format:
              3'b000: 8-bit RGB 3:3:2
              3'b001: 16-bit RGB 5:6:5 over 8-bit bus, 2 cycles/pixel
              3'b010: 12-bit RGB 4:4:4
              3'b011: 16-bit RGB 5:6:5
              3'b100: 18-bit RGB 6:6:6
              3'b101: 24-bit RGB 8:8:8
              3'b110: 24-bit RGB 8:8:8 over 16-bit bus, 1.5 cycles/pixel
              3'b111: 24-bit RGB 8:8:8 over 8-bit bus, 3cycles/pixel
              others: Reserved
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>LCD_INTF_SEL</name>
              <description>
              3'b000: 8080 DBI Type B
              3'b001: SPI interface
              3'b010: DSI interface
              3'b011: DPI interface
              3'b100: JDI serial interface
              3'b101: JDI parallel interface
              3'b110: 8080 DBI Type A
              others: reserved
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>TARGET_LCD</name>
              <description>
              The Data can be sent to four destinations:
              2'b00: LCD panel 0
              2'b01: LCD panel 1
              2'b10: AHB LCD
              2'b11: AHB RAM
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>LCD_IF_CONF</name>
          <displayName>LCD_IF_CONF</displayName>
          <description></description>
          <addressOffset>0x64</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
            <field>
              <name>DO_DLY_SET</name>
              <description>
              if this bit is set to 1,  LCD data output will be delayed for 1 lcdc clock cycle
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LCD_RSTB</name>
              <description>
              LCD RSTB pin, direct to output
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RD_POL</name>
              <description>
              LCD RD pin polarity. RD is 0 for write operation, 1 for idle if polarity bit is set as 0. RD bit definition is opposite if polarity bit is set as 1.
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>WR_POL</name>
              <description>
              LCD WR pin polarity. WR is 0 for write operation, 1 for idle if polarity bit is set as 0. WR bit definition is opposite if polarity bit is set as 1.
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RS_POL</name>
              <description>
              LCD RS pin polarity. RS is 1 for data access, 0 for command access if polarity bit is set as 0. RS bit definition is opposite if polarity bit is set as 1.
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CS1_POL</name>
              <description>
              LCD0 CS pin polarity. CS is 0 for LCD chip select if polarity bit is set as 0. CS bit definition is opposite if polarity bit is set as 1.
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CS0_POL</name>
              <description>
              LCD1 CS pin polarity. CS is 0 for LCD chip select if polarity bit is set as 0. CS bit definition is opposite if polarity bit is set as 1.
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PWH</name>
              <description>
              inactive cycles of LCD_WR/LCD_RD for consecutive write/read operation
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>PWL</name>
              <description>
              active cycles of LCD_WR/LCD_RD
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>TAH</name>
              <description>
              hold cycles, delay from LCD_WR/LCD_RD inactive to LCD_CS inactive
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>TAS</name>
              <description>
              setup cycles, delay from LCD_CS active to LCD_WR/LCD_RD active
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>LCD_MEM</name>
          <displayName>LCD_MEM</displayName>
          <description></description>
          <addressOffset>0x68</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ADDR</name>
              <description>
              address for AHB LCD/AHB RAM
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>LCD_O_WIDTH</name>
          <displayName>LCD_O_WIDTH</displayName>
          <description></description>
          <addressOffset>0x6c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>22</bitWidth>
            </field>
            <field>
              <name>OFFSET</name>
              <description>
              AHB RAM address offset for each line
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>LCD_SINGLE</name>
          <displayName>LCD_SINGLE</displayName>
          <description></description>
          <addressOffset>0x70</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>28</bitWidth>
            </field>
            <field>
              <name>LCD_BUSY</name>
              <description>
              LCD/SPI LCD interface is busy for single access
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RD_TRIG</name>
              <description>
              Single read operation trigger
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>WR_TRIG</name>
              <description>
              Single write operation trigger
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TYPE</name>
              <description>
              LCD access type, this bit could affect all LCD interface including SPI, parellel and AHB
              1'b0: command
              1'b1: data
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>LCD_WR</name>
          <displayName>LCD_WR</displayName>
          <description></description>
          <addressOffset>0x74</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              LCD write data
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>LCD_RD</name>
          <displayName>LCD_RD</displayName>
          <description></description>
          <addressOffset>0x78</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              LCD read data
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_IF_CONF</name>
          <displayName>SPI_IF_CONF</displayName>
          <description></description>
          <addressOffset>0x7c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SPI_CLK_INIT</name>
              <description>
              SPI CLK idle state value
              1'h0: high
              1'h1: low
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SPI_CLK_POL</name>
              <description>
              SPI CLK polarity
              1'h0: normal
              1'h1: inverted
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SPI_CS_POL</name>
              <description>
              SPI CS polarity
              0: low active
              1: high active
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SPI_CS_AUTO_DIS</name>
              <description>
              1: SPI CS is automatically disabled after data transaction
              0: SPI CS is not disabled after data transaction
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SPI_CS_NO_IDLE</name>
              <description>
              1: SPI CS is always active during data transaction
              0: SPI CS is IDLE in wait state during data transaction
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SPI_CLK_AUTO_DIS</name>
              <description>
              1: SPI clock auto disable in wait state during data transaction
              0: SPI clock is always on in wait state during data transaction
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SPI_RD_MODE</name>
              <description>
              SPI read mode:
              1'b0: normal read. Send write request before read.
              1'b1: direct read. Read data without write request.
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>WR_LEN</name>
              <description>
              SPI write data length(single access)
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RD_LEN</name>
              <description>
              SPI read data length(single access)
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>LINE</name>
              <description>
              SPI line mode
              0: 4-line
              1: 4-line with 2 data line(support RGB565 and RGB888)
              2: 4-line with 4 data line(support RGB565 and RGB888)
              3: reserved
              4: 3-line 
              5: 3-line with 2 data line(support RGB565 and RGB888)
              6: 3-line with 4 data line(support RGB565 and RGB888)
              7: reserved
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>DUMMY_CYCLE</name>
              <description>
              SPI transaction dummy cycle
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>CLK_DIV</name>
              <description>
              SPI clock divider
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>DEV_ID</name>
              <description>
              SPI device ID
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TE_CONF</name>
          <displayName>TE_CONF</displayName>
          <description></description>
          <addressOffset>0x80</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
            <field>
              <name>FMARK_SOURCE</name>
              <description>
              TE signal source
              1: use TE signal from DSI
              0: use TE signal from external pin
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FMARK_MODE</name>
              <description>
              TE signal trigger mode
              1: edge trigger
              0: pulse trigger
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>VSYNC_DET_CNT</name>
              <description>
              vsync signal detect counter, used for mode 1 to detect vsync signal
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>MODE</name>
              <description>
              0: vsync only TE mode 
              1: vsync+hsync TE mode
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FMARK_POL</name>
              <description>
              TE signal polarity
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ENABLE</name>
              <description>
              TE enable
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TE_CONF2</name>
          <displayName>TE_CONF2</displayName>
          <description></description>
          <addressOffset>0x84</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DLY_CNT</name>
              <description>
              TE delay counter
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DPI_IF_CONF1</name>
          <displayName>DPI_IF_CONF1</displayName>
          <description></description>
          <addressOffset>0x88</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>HSW</name>
              <description>
              dpi hsync width
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>VSH</name>
              <description>
              dpi vsync height
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DPI_IF_CONF2</name>
          <displayName>DPI_IF_CONF2</displayName>
          <description></description>
          <addressOffset>0x8c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>HBP</name>
              <description>
              horizontal back porch
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>VBP</name>
              <description>
              vertical back porch
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DPI_IF_CONF3</name>
          <displayName>DPI_IF_CONF3</displayName>
          <description></description>
          <addressOffset>0x90</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>HFP</name>
              <description>
              horizontal front porch
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>VFP</name>
              <description>
              vertical front porch
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DPI_IF_CONF4</name>
          <displayName>DPI_IF_CONF4</displayName>
          <description></description>
          <addressOffset>0x94</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>HAW</name>
              <description>
              horizontal active width
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>VAH</name>
              <description>
              vertical active height
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DPI_IF_CONF5</name>
          <displayName>DPI_IF_CONF5</displayName>
          <description></description>
          <addressOffset>0x98</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
            <field>
              <name>INT_LINE_NUM</name>
              <description>
              DPI interrupt line number
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
            <field>
              <name>HSPOL</name>
              <description>
              hsync polarity
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>VSPOL</name>
              <description>
              vsync polarity
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DEPOL</name>
              <description>
              de polarity
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PCLKPOL</name>
              <description>
              pixel clock polarity
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PCLK_DIV</name>
              <description>
              pixel clock divider
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DPI_CTRL</name>
          <displayName>DPI_CTRL</displayName>
          <description></description>
          <addressOffset>0x9c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>29</bitWidth>
            </field>
            <field>
              <name>DPI_SD</name>
              <description>
              dpi shutdown
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DPI_CM</name>
              <description>
              dpi color mode
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DPI_EN</name>
              <description>
              dpi interface enable
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DPI_STAT</name>
          <displayName>DPI_STAT</displayName>
          <description></description>
          <addressOffset>0xa0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>VPOS</name>
              <description>
              dpi vertical position
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>HSTAT</name>
              <description>
              horizontal status
              0: idle
              1: prep
              2: hsync
              3: hbp
              4: hact
              5: hfp
              6: wait
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>HPOS</name>
              <description>
              dpi horizontal position
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>JDI_SER_CONF1</name>
          <displayName>JDI_SER_CONF1</displayName>
          <description></description>
          <addressOffset>0xa4</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>CLK_DIV</name>
              <description>
              jdi serial clock divider
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>WR_LEN</name>
              <description>
              jdi single write bit length
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>JDI_SER_CONF2</name>
          <displayName>JDI_SER_CONF2</displayName>
          <description></description>
          <addressOffset>0xa8</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>INIT_LINE_CNT</name>
              <description>
              jdi serial init line counter
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>WR_CMD</name>
              <description>
              jdi serial data transfer write command
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>JDI_SER_CTRL</name>
          <displayName>JDI_SER_CTRL</displayName>
          <description></description>
          <addressOffset>0xac</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>30</bitWidth>
            </field>
            <field>
              <name>EXTCOMIN</name>
              <description>
              jdi serial interface extcomin control
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DISP</name>
              <description>
              jdi serial interface disp control
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>JDI_PAR_CONF1</name>
          <displayName>JDI_PAR_CONF1</displayName>
          <description></description>
          <addressOffset>0xb0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>MAX_LINE</name>
              <description>
              jdi parallel interface max line, line number start from 0
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>MAX_COL</name>
              <description>
              jdi parallel interface max column, column number start from 0
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>JDI_PAR_CONF2</name>
          <displayName>JDI_PAR_CONF2</displayName>
          <description></description>
          <addressOffset>0xb4</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ST_LINE</name>
              <description>
              jdi parallel interface start line, line number start from 0
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>END_LINE</name>
              <description>
              jdi parallel interface end line, line number start from 0
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>JDI_PAR_CONF3</name>
          <displayName>JDI_PAR_CONF3</displayName>
          <description></description>
          <addressOffset>0xb8</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ST_COL</name>
              <description>
              jdi parallel interface start column, column number start from 0
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>END_COL</name>
              <description>
              jdi parallel interface end column, column number start from 0
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>JDI_PAR_CONF4</name>
          <displayName>JDI_PAR_CONF4</displayName>
          <description></description>
          <addressOffset>0xbc</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>HCK_WIDTH</name>
              <description>
              jdi parallel interface HCK width, HSK width = lcd_ck_cycle * HCK_WIDTH
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>HST_WIDTH</name>
              <description>
              jdi parallel interface HST width, HST width = lcd_ck_cycle * HST_WIDTH
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>JDI_PAR_CONF5</name>
          <displayName>JDI_PAR_CONF5</displayName>
          <description></description>
          <addressOffset>0xc0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>VCK_WIDTH</name>
              <description>
              jdi parallel interface VCK width, VCK width = lcd_ck_cycle * VCK_WIDTH
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>VST_WIDTH</name>
              <description>
              jdi parallel interface VST width, VST width = lcd_ck_cycle * VST_WIDTH
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>JDI_PAR_CONF6</name>
          <displayName>JDI_PAR_CONF6</displayName>
          <description></description>
          <addressOffset>0xc4</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>VCK_DLY</name>
              <description>
              jdi parallel interface VST to VCK delay, VST2VCK delay = lcd_ck_cycle * VCK_DLY
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>HST_DLY</name>
              <description>
              jdi parallel interface VCK to HST delay, VCK2HST delay = lcd_ck_cycle * HST_DLY
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>JDI_PAR_CONF7</name>
          <displayName>JDI_PAR_CONF7</displayName>
          <description></description>
          <addressOffset>0xc8</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>15</bitWidth>
            </field>
            <field>
              <name>DP_MODE</name>
              <description>
              double pixel mode. Some jdi parallel screens use large pixel+small pixel structure. Set this bit to 1 to support this structure.
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HCK_DLY</name>
              <description>
              jdi parallel interface HST to HCK delay
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>JDI_PAR_CTRL</name>
          <displayName>JDI_PAR_CTRL</displayName>
          <description></description>
          <addressOffset>0xcc</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>INT_LINE_NUM</name>
              <description>
              jdi parallel interface interrupt line number, line number start from 0.
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>VSTPOL</name>
              <description>
              jdi parallel vst polarity
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>VCKPOL</name>
              <description>
              jdi parallel vck polarity
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HSTPOL</name>
              <description>
              jdi parallel hst polarity
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HCKPOL</name>
              <description>
              jdi parallel hck polarity
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ENBPOL</name>
              <description>
              jdi parallel enb polarity
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>XRST</name>
              <description>
              jdi parallel interface XRST
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>ENABLE</name>
              <description>
              jdi parallel interface enable
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>JDI_PAR_STAT</name>
          <displayName>JDI_PAR_STAT</displayName>
          <description></description>
          <addressOffset>0xd0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>VPOS</name>
              <description>
              jdi parallel vertical position
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>HPOS</name>
              <description>
              jdi parallel horizontal position
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>JDI_PAR_EX_CTRL</name>
          <displayName>JDI_PAR_EX_CTRL</displayName>
          <description></description>
          <addressOffset>0xd4</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>VCOM</name>
              <description>
              VCOM value
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FRP</name>
              <description>
              FRP value
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>XFRP</name>
              <description>
              XFRP value
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CNT_EN</name>
              <description>
              VCOM/FRP/XFRP counter enable
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>MAX_CNT</name>
              <description>
              VCOM/FRP/XFRP max counter
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>JDI_PAR_CONF8</name>
          <displayName>JDI_PAR_CONF8</displayName>
          <description></description>
          <addressOffset>0xd8</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ENB_ST_COL</name>
              <description>
              jdi parallel interface enb start column, column number start from 0
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>ENB_END_COL</name>
              <description>
              jdi parallel interface enb end column, column number start from 0
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>JDI_PAR_CONF9</name>
          <displayName>JDI_PAR_CONF9</displayName>
          <description></description>
          <addressOffset>0xdc</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ENB_ST_LINE</name>
              <description>
              jdi parallel interface enb start line, line number start from 0
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>ENB_END_LINE</name>
              <description>
              jdi parallel interface enb end line, line number start from 0
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>LPSYS_AON</name>
      <description></description>
      <groupName>LPSYS_AON</groupName>
      <baseAddress>0x40070000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>PMR</name>
          <displayName>PMR</displayName>
          <description>Power Mode Register</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>FORCE_SLEEP</name>
              <description>
              force to enter low power mode (for debug only)
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CPUWAIT</name>
              <description>
              Stall CPU out of reset. Should be cleared before LCPU run
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>28</bitWidth>
            </field>
            <field>
              <name>MODE</name>
              <description>
              Power Mode: 2'h0 - active/idle; 2'h1 - light sleep; 2'h2 - deep sleep; 2'h3 - standby
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CR</name>
          <displayName>CR</displayName>
          <description>Control Register</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>13</bitWidth>
            </field>
            <field>
              <name>GTIM_EN</name>
              <description>
              Enable global timer
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN5_MODE</name>
              <description>
              mode for wakeup PIN5 (PB48)
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>PIN4_MODE</name>
              <description>
              mode for wakeup PIN4 (PB47)
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>PIN3_MODE</name>
              <description>
              mode for wakeup PIN3 (PB46)
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>PIN2_MODE</name>
              <description>
              mode for wakeup PIN2 (PB45)
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>PIN1_MODE</name>
              <description>
              mode for wakeup PIN1 (PB44)
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>PIN0_MODE</name>
              <description>
              mode for wakeup PIN0 (PB43)
              0 - high level, 1 - low level, 2 - pos edge, 3 - neg edge, 4/5/6/7: pos or neg edge
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ACR</name>
          <displayName>ACR</displayName>
          <description>Active Mode Control register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>HXT48_RDY</name>
              <description>
              Indicate hxt48 is ready
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HRC48_RDY</name>
              <description>
              Indicate hrc48 is ready
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>15</bitWidth>
            </field>
            <field>
              <name>DS_CACHE</name>
              <description>
              for debug only
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS_DTCM</name>
              <description>
              for debug only
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS_ITCM</name>
              <description>
              for debug only
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS_RAM5</name>
              <description>
              for debug only
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS_RAM4</name>
              <description>
              for debug only
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS_RAM3</name>
              <description>
              for debug only
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS_RAM2</name>
              <description>
              for debug only
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS_RAM1</name>
              <description>
              for debug only
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS_RAM0</name>
              <description>
              for debug only
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EXTPWR_REQ</name>
              <description>
              Request power for HPSYS during Active mode
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PWR_REQ</name>
              <description>
              Request power for LPSYS during Active mode
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HXT48_REQ</name>
              <description>
              Request hxt48 in active mode
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HRC48_REQ</name>
              <description>
              Request hrc48 in active mode
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>LSCR</name>
          <displayName>LSCR</displayName>
          <description>Light Sleep Ctrl Register</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>27</bitWidth>
            </field>
            <field>
              <name>EXTPWR_REQ</name>
              <description>
              Request power for HPSYS during Light Sleep mode
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PWR_REQ</name>
              <description>
              Request power for LPSYS during Light Sleep mode
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HXT48_REQ</name>
              <description>
              Request hxt48 in Light Sleep mode
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HRC48_REQ</name>
              <description>
              Request hrc48 in Light Sleep mode
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DSCR</name>
          <displayName>DSCR</displayName>
          <description>Deep Sleep Ctrl Register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>27</bitWidth>
            </field>
            <field>
              <name>EXTPWR_REQ</name>
              <description>
              Request power for HPSYS during Deep Sleep mode
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PWR_REQ</name>
              <description>
              Request power for LPSYS during Deep Sleep mode
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HXT48_REQ</name>
              <description>
              Request hxt48 in Deep Sleep mode
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HRC48_REQ</name>
              <description>
              Request hrc48 in Deep Sleep mode
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SBCR</name>
          <displayName>SBCR</displayName>
          <description>Standby Mode Ctrl Register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>PU_DLY</name>
              <description>
              for debug only
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>PD_DTCM</name>
              <description>
              for debug only
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PD_ITCM</name>
              <description>
              for debug only
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PD_RAM5</name>
              <description>
              for debug only
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PD_RAM4</name>
              <description>
              for debug only
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PD_RAM3</name>
              <description>
              for debug only
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PD_RAM2</name>
              <description>
              for debug only
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PD_RAM1</name>
              <description>
              for debug only
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PD_RAM0</name>
              <description>
              for debug only
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EXTPWR_REQ</name>
              <description>
              Request power for HPSYS during Standby mode
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PWR_REQ</name>
              <description>
              Request power for LPSYS during Standby mode
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HXT48_REQ</name>
              <description>
              Request hxt48 in Standby mode
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HRC48_REQ</name>
              <description>
              Request hrc48 in Standby mode
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>WER</name>
          <displayName>WER</displayName>
          <description>Wakeup Enable register</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>19</bitWidth>
            </field>
            <field>
              <name>HP2LP_IRQ</name>
              <description>
              Set 1 to enable MAILBOX1 as wakeup source
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HP2LP_REQ</name>
              <description>
              Set 1 to enable HPSYS request as wakeup source
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN5</name>
              <description>
              Set 1 to enable PB48 as wakeup source
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN4</name>
              <description>
              Set 1 to enable PB47 as wakeup source
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN3</name>
              <description>
              Set 1 to enable PB46 as wakeup source
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN2</name>
              <description>
              Set 1 to enable PB45 as wakeup source
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN1</name>
              <description>
              Set 1 to enable PB44 as wakeup source
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN0</name>
              <description>
              Set 1 to enable PB43 as wakeup source
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BLE</name>
              <description>
              Set 1 to enable BLE as wakeup source
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LPCOMP2</name>
              <description>
              Set 1 to enable LPCOMP2 as wakeup source
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LPCOMP1</name>
              <description>
              Set 1 to enable LPCOMP1 as wakeup source
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LPTIM2</name>
              <description>
              Set 1 to enable LPTIM2 as wakeup source
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RTC</name>
              <description>
              Set 1 to enable RTC as wakeup source
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>WSR</name>
          <displayName>WSR</displayName>
          <description>Wakeup Status register</description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>19</bitWidth>
            </field>
            <field>
              <name>HP2LP_IRQ</name>
              <description>
              Indicates the wakeup status from MAILBOX1. Note: the status is masked by WER
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HP2LP_REQ</name>
              <description>
              Indicates the wakeup status from HPSYS request. Note: the status is masked by WER
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN5</name>
              <description>
              Indicates the wakeup status from PB48 request. Note: the status is masked by WER
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN4</name>
              <description>
              Indicates the wakeup status from PB47 request. Note: the status is masked by WER
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN3</name>
              <description>
              Indicates the wakeup status from PB46 request. Note: the status is masked by WER
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN2</name>
              <description>
              Indicates the wakeup status from PB45 request. Note: the status is masked by WER
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN1</name>
              <description>
              Indicates the wakeup status from PB44 request. Note: the status is masked by WER
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN0</name>
              <description>
              Indicates the wakeup status from PB43 request. Note: the status is masked by WER
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BLE</name>
              <description>
              Indicates the wakeup status from BLE. Note: the status is masked by WER
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LPCOMP2</name>
              <description>
              Indicates the wakeup status from LPCOMP2. Note: the status is masked by WER
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LPCOMP1</name>
              <description>
              Indicates the wakeup status from LPCOMP1. Note: the status is masked by WER
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LPTIM2</name>
              <description>
              Indicates the wakeup status from LPTIM2. Note: the status is masked by WER
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RTC</name>
              <description>
              Indicates the wakeup status from RTC. Note: the status is masked by WER
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>WCR</name>
          <displayName>WCR</displayName>
          <description>Wakeup Clear register</description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>AON</name>
              <description>
              Write 1 to clear the AON wakeup IRQ status
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>PIN5</name>
              <description>
              Write 1 to clear the PB48 wakeup source. Only valid if PIN wakeup is configured as edge trigger
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN4</name>
              <description>
              Write 1 to clear the PB47 wakeup source. Only valid if PIN wakeup is configured as edge trigger
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN3</name>
              <description>
              Write 1 to clear the PB46 wakeup source. Only valid if PIN wakeup is configured as edge trigger
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN2</name>
              <description>
              Write 1 to clear the PB45 wakeup source. Only valid if PIN wakeup is configured as edge trigger
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN1</name>
              <description>
              Write 1 to clear the PB44 wakeup source. Only valid if PIN wakeup is configured as edge trigger
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN0</name>
              <description>
              Write 1 to clear the PB43 wakeup source. Only valid if PIN wakeup is configured as edge trigger
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              Note: for RTC/LPTIM/LPCOMP/BLE, clear the wakeup status directly in the corresponding module
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ISSR</name>
          <displayName>ISSR</displayName>
          <description>Inter System Status Register</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>26</bitWidth>
            </field>
            <field>
              <name>HP_ACTIVE</name>
              <description>
              read 1 indicates HPSYS is active
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LP_ACTIVE</name>
              <description>
              write 1 to indicates LPSYS is active
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>HP2LP_REQ</name>
              <description>
              indicate HPSYS request exists
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LP2HP_REQ</name>
              <description>
              write 1 to request HPSYS to stay in active mode
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DBGMUX</name>
          <displayName>DBGMUX</displayName>
          <description>Debug Mux Register</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>PB48_SEL</name>
              <description>
              for debug only
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>PB47_SEL</name>
              <description>
              for debug only
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>PB46_SEL</name>
              <description>
              for debug only
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>PB45_SEL</name>
              <description>
              for debug only
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>PB44_SEL</name>
              <description>
              for debug only
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>PB43_SEL</name>
              <description>
              for debug only
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TARGET</name>
          <displayName>TARGET</displayName>
          <description>BLE sleep time target</description>
          <addressOffset>0x2c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>SLEEP_TARGET</name>
              <description>
              ble sleep time target in cycles of clk_lp
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>28</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ACTUAL</name>
          <displayName>ACTUAL</displayName>
          <description>BLE actual sleep time</description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>SLEEP_CNT</name>
              <description>
              ble actual sleep time in cycles of clk_lp. If not woken up by software or external interrupt, sleep_cnt counts up every low power clock cycle, until reaches sleep_target
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>28</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PRE_WKUP</name>
          <displayName>PRE_WKUP</displayName>
          <description>time before ble awake</description>
          <addressOffset>0x34</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>WKUP_TIME</name>
              <description>
              cycles of clk_lp for LPSYS ready before bt awake.
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>XTAL_TIME</name>
              <description>
              cycles of clk_lp for hxt48 ready before bt awake.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SLP_CFG</name>
          <displayName>SLP_CFG</displayName>
          <description>ble sleep configuration</description>
          <addressOffset>0x38</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>28</bitWidth>
            </field>
            <field>
              <name>XTAL_FORCE_OFF</name>
              <description>
              for debug only
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>XTAL_ALWAYS_ON</name>
              <description>
              for debug only
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SLP_CTRL</name>
          <displayName>SLP_CTRL</displayName>
          <description>ble sleep control</description>
          <addressOffset>0x3c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>25</bitWidth>
            </field>
            <field>
              <name>BLE_WKUP</name>
              <description>
              ble wakeup source. 1 means ble has not enter sleep or has enter wakeup procedure
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>XTAL_REQ</name>
              <description>
              xtal request status. 1 means ble is requiring xtal. 
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SLEEP_STATUS</name>
              <description>
              ble sleep status. 1 means ble is sleeping and sleep_cnt is counting up
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>WKUP_REQ</name>
              <description>
              software request to wakeup ble. Will be cleared automatically
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SLEEP_REQ</name>
              <description>
              ble sleep request. Will be cleared automatically
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ANACR</name>
          <displayName>ANACR</displayName>
          <description>Analog Control Register</description>
          <addressOffset>0x40</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>30</bitWidth>
            </field>
            <field>
              <name>PB_AON_ISO</name>
              <description>
              Set 1 to force off all LPSYS related analog modules
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PB_ISO</name>
              <description>
              Set 1 to force IO(PB) into retention mode
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>GTIMR</name>
          <displayName>GTIMR</displayName>
          <description>Global Timer Register</description>
          <addressOffset>0x44</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>CNT</name>
              <description>
              Global timer value
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RESERVE0</name>
          <displayName>RESERVE0</displayName>
          <description>Reserved Register 0</description>
          <addressOffset>0x48</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              for debug only
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RESERVE1</name>
          <displayName>RESERVE1</displayName>
          <description>Reserved Register 1</description>
          <addressOffset>0x4c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              for debug only
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD1</name>
          <displayName>RSVD1</displayName>
          <description></description>
          <addressOffset>0x50</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>SPR</name>
          <displayName>SPR</displayName>
          <description>Stack Pointer Register</description>
          <addressOffset>0x100</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>SP</name>
              <description>
              LCPU stack pointer address
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PCR</name>
          <displayName>PCR</displayName>
          <description>Pointer Counter Register</description>
          <addressOffset>0x104</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>PC</name>
              <description>
              LCPU PC pointer address
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>LPTIM2</name>
      <description></description>
      <groupName>LPTIM</groupName>
      <baseAddress>0x40071000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>ISR</name>
          <displayName>ISR</displayName>
          <description>LPTIM interrupt and status register</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>21</bitWidth>
            </field>
            <field>
              <name>OCWKUP</name>
              <description>
              Indicates output compare wakeup occurred
              The OCWKUP bit is set by hardware when LPTIM_CNT register value reached the LPTIM_CMP register's value. To clear OCWKUP, first  write 0 to the OCWE bit in the LPTIM_IER register to disable, then write 1 to the WKUPCLR bit in the LPTIM_ICR register. 
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OFWKUP</name>
              <description>
              Indicates overflow wakeup occurred
              OFWKUP is set by hardware when LPTIM_CNT register's value reached the LPTIM_ARR register's value and count from zero again. To clear OFWKUP, first  write 0 to the OFWE bit in the LPTIM_IER register to disable, then write 1 to the WKUPCLR bit in the LPTIM_ICR register. 
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UEWKUP</name>
              <description>
              Indicates update event wakeup occurred
              UEWKUP is set by hardware when an update event was generated (overflow occurred while repetition counter reached zero). To clear UEWKUP, first  write 0 to the UEWE bit in the LPTIM_IER register to disable, then write 1 to the WKUPCLR bit in the LPTIM_ICR register. 
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>ET</name>
              <description>
              External trigger edge event
              ET is set by hardware to inform application that a valid edge on the selected external trigger input has occurred. If the trigger is ignored because the timer has already started, then this flag is not set. ET flag can be cleared by writing 1 to the ETCLR bit in the LPTIM_ICR register.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OC</name>
              <description>
              Output compare match
              The OC bit is set by hardware to inform application that LPTIM_CNT register value reached the LPTIM_CMP register's value. OC flag can be cleared by writing 1 to the OCCLR bit in the LPTIM_ICR register.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OF</name>
              <description>
              Overflow occurred
              OF is set by hardware to inform application that LPTIM_CNT register's value reached the LPTIM_ARR register's value and count from zero again. OF flag can be cleared by writing 1 to the OFCLR bit in the LPTIM_ICR register.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UE</name>
              <description>
              LPTIM update event occurred
              UE is set by hardware to inform application that an update event was generated when overflow occurred while repetition counter reached zero. UE flag can be cleared by writing 1 to the UECLR bit in the LPTIM_ICR register. 
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ICR</name>
          <displayName>ICR</displayName>
          <description>LPTIM interrupt and status clear register</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>WKUPCLR</name>
              <description>
              wakeup status clear flag
              Writing 1 to this bit clears all wakeup status flags in the LPTIM_ISR register.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>ETCLR</name>
              <description>
              External trigger valid edge clear flag
              Writing 1 to this bit clears the ET flag in the LPTIM_ISR register
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OCCLR</name>
              <description>
              Output compare clear flag
              Writing 1 to this bit clears the OC flag in the LPTIM_ISR register
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OFCLR</name>
              <description>
              Overflow clear flag
              Writing 1 to this bit clears the OF flag in the LPTIM_ISR register
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UECLR</name>
              <description>
              Update event clear flag
              Writing 1 to this bit clear the UE flag in the LPTIM_ISR register.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IER</name>
          <displayName>IER</displayName>
          <description>LPTIM interrupt and wakeup enable register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>21</bitWidth>
            </field>
            <field>
              <name>OCWE</name>
              <description>
              Output compare Wakeup Enable
              0: Output compare wakeup disabled
              1: Output compare wakeup enabled
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OFWE</name>
              <description>
              Overflow Wakeup Enable
              0: Overflow Wakeup disabled
              1: Overflow Wakeup enabled
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UEWE</name>
              <description>
              Update event Wakeup enable
              0: Update event Wakeup disabled
              1: Update event Wakeup enabled
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>ETIE</name>
              <description>
              External trigger valid edge Interrupt Enable
              0: External trigger interrupt disabled
              1: External trigger interrupt enabled
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OCIE</name>
              <description>
              Output compare Interrupt Enable
              0: Output compare interrupt disabled
              1: Output compare interrupt enabled
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OFIE</name>
              <description>
              Overflow Interrupt Enable
              0: Overflow interrupt disabled
              1: Overflow interrupt enabled
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UEIE</name>
              <description>
              Update event interrupt enable
              0: Update event interrupt disabled
              1: Update event interrupt enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CFGR</name>
          <displayName>CFGR</displayName>
          <description>LPTIM configuration register</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>COUNTMODE</name>
              <description>
              counter mode in internal clock source mode (CKSEL=0). If CKSEL=1, this bit has no effect.
              0: the counter is incremented following each internal clock pulse
              1: the counter is incremented following each valid pulse on the external clock
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>WAVPOL</name>
              <description>
              Waveform shape polarity
              The WAVEPOL bit controls the output polarity
              0: The LPTIM output reflects the compare results between LPTIM_ARR and LPTIM_CMP registers
              1: The LPTIM output reflects the inverse of the compare results between LPTIM_ARR and LPTIM_CMP registers
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>WAVE</name>
              <description>
              Waveform shape
              The WAVE bit controls the output shape
              0: Deactivate Set-once mode
              1: Activate the Set-once mode
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TIMOUT</name>
              <description>
              Timeout enable
              The TIMOUT bit controls the Timeout feature
              0: A trigger event arriving when the timer is already started will be ignored
              1: A trigger event arriving when the timer is already started will reset and restart the LPTIM counter and the repetition counter
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TRIGEN</name>
              <description>
              Trigger enable and polarity
              The TRIGEN bits controls whether the LPTIM counter is started by an external trigger or not. If the external trigger option is selected, three configurations are possible for the trigger active edge:
              00: software trigger (counting start is initiated by software)
              01: rising edge is the active edge
              10: falling edge is the active edge
              11: both edges are active edges
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TRIGSEL</name>
              <description>
              Trigger selector
              The TRIGSEL bits select the trigger source that will serve as a trigger event for the LPTIM among the below 8 available sources:
              000: lptim_ext0
              001: lptim_ext1
              010: lptim_ext2
              011: lptim_ext3
              100: lptim_ext4
              101: lptim_ext5
              110: lptim_ext6
              111: lptim_ext7
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PRESC</name>
              <description>
              Clock prescaler
              The PRESC bits configure the prescaler division factor. It can be one among the following division factors:
              000: /1
              001: /2
              010: /4
              011: /8
              100: /16
              101: /32
              110: /64
              111: /128
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>EXTCKSEL</name>
              <description>
              External clock source selector
              0: external clock source is from lptim_in
              1: external clock source is from LPCOMP (if LPCOMP integrated)
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TRGFLT</name>
              <description>
              Configurable digital filter for trigger
              The TRGFLT value sets the number of consecutive equal samples that should be detected when a level change occurs on an internal trigger before it is considered as a valid level transition. An internal clock source must be present to use this feature
              00: any trigger active level change is considered as a valid trigger
              01: trigger active level change must be stable for at least 2 clock periods before it is considered as valid trigger.
              10: trigger active level change must be stable for at least 4 clock periods before it is considered as valid trigger.
              11: trigger active level change must be stable for at least 8 clock periods before it is considered as valid trigger.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>INTCKSEL</name>
              <description>
              Internal clock source selector
              0: internal clock source is clk_lp
              1: internal clock source is pclk2
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CKFLT</name>
              <description>
              Configurable digital filter for external clock
              The CKFLT value sets the number of consecutive equal samples that should be detected when a level change occurs on an external clock signal before it is considered as a valid level transition. An internal clock source must be present to use this feature
              00: any external clock signal level change is considered as a valid transition
              01: external clock signal level change must be stable for at least 2 clock periods before it is considered as valid transition.
              10: external clock signal level change must be stable for at least 4 clock periods before it is considered as valid transition.
              11: external clock signal level change must be stable for at least 8 clock periods before it is considered as valid transition.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>CKPOL</name>
              <description>
              Clock Polarity
              If LPTIM is clocked by an external clock source, CKPOL bits is used to configure the active edge or edges used by the counter:
              00: the rising edge is the active edge used for counting
              01: the falling edge is the active edge used for counting
              10: both edges are active edges. When both external clock signal edges are considered active ones, the LPTIM must also be clocked by an internal clock source with a frequency equal to at least four time the external clock frequency.
              11: not allowed
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>CKSEL</name>
              <description>
              Clock selector
              The CKSEL bit selects which clock source the LPTIM will use:
              0: LPTIM is clocked by internal clock source, according to INTCKSEL
              1: LPTIM is clocked by external clock source, according to EXTCKSEL
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CR</name>
          <displayName>CR</displayName>
          <description>LPTIM control register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>28</bitWidth>
            </field>
            <field>
              <name>COUNTRST</name>
              <description>
              Counter reset
              This bit is set by software and cleared by hardware. When set to 1 this bit will trigger a synchronous reset of the CNT register. Due to the synchronous nature of this reset, it only takes place after a synchronization delay.
              COUNTRST must never be set to 1 by software before it is already cleared to 0 by hardware. Software should consequently check that COUNTRST bit is already cleared to 0 before attempting to set it to 1.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CNTSTRT</name>
              <description>
              Timer start in Continuous mode
              This bit is set by software and cleared by hardware.
              In case of software start (TRIGEN[1:0] = 00), setting this bit starts the LPTIM in Continuous mode.
              If the software start is disabled (TRIGEN[1:0] different than 00), setting this bit starts the timer in Continuous mode as soon as an external trigger is detected.
              If this bit is set when a single pulse mode counting is ongoing, then the timer will not stop at the next match between ARR and CNT registers and the LPTIM counter keeps counting in Continuous mode.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SNGSTRT</name>
              <description>
              LPTIM start in Single mode
              This bit is set by software and cleared by hardware.
              In case of software start (TRIGEN[1:0] = 00), setting this bit starts the LPTIM in single pulse mode.
              If the software start is disabled (TRIGEN[1:0] different than 00), setting this bit starts the LPTIM in single pulse mode as soon as an external trigger is detected.
              If this bit is set when the LPTIM is in continuous counting mode, then the LPTIM will stop at the following match between ARR and CNT registers.
              If this bit is set simultaneously with CNTSTRT, then LPTIM will be in continuous counting mode.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ENABLE</name>
              <description>
              LPTIM enable
              The ENABLE bit is set and cleared by software. 
              0:LPTIM is disabled
              1:LPTIM is enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CMP</name>
          <displayName>CMP</displayName>
          <description>LPTIM compare register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>CMP</name>
              <description>
              Compare value
              CMP is the compare value used by the LPTIM.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ARR</name>
          <displayName>ARR</displayName>
          <description>LPTIM autoreload register</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>ARR</name>
              <description>
              Auto reload value
              ARR is the autoreload value for the LPTIM. This value must be strictly greater than the CMP[15:0] value.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CNT</name>
          <displayName>CNT</displayName>
          <description>LPTIM counter register</description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>CNT</name>
              <description>
              Counter value
              When the LPTIM is running with an asynchronous clock, reading the CNT register may return unreliable values. So in this case it is necessary to perform two consecutive read accesses and verify that the two returned values are identical.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RCR</name>
          <displayName>RCR</displayName>
          <description>LPTIM repetition register</description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>REP</name>
              <description>
              Repetition register value
              REP is the repetition value for the LPTIM.
              Read REP will return left repetition times. It should be noted that for a reliable REP register read access, two consecutive read accesses must be performed and compared. A read access can be considered reliable when the values of the two consecutive read accesses are equal.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>LPTIM3</name>
      <description></description>
      <groupName>LPTIM</groupName>
      <baseAddress>0x40072000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>ISR</name>
          <displayName>ISR</displayName>
          <description>LPTIM interrupt and status register</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>21</bitWidth>
            </field>
            <field>
              <name>OCWKUP</name>
              <description>
              Indicates output compare wakeup occurred
              The OCWKUP bit is set by hardware when LPTIM_CNT register value reached the LPTIM_CMP register's value. To clear OCWKUP, first  write 0 to the OCWE bit in the LPTIM_IER register to disable, then write 1 to the WKUPCLR bit in the LPTIM_ICR register. 
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OFWKUP</name>
              <description>
              Indicates overflow wakeup occurred
              OFWKUP is set by hardware when LPTIM_CNT register's value reached the LPTIM_ARR register's value and count from zero again. To clear OFWKUP, first  write 0 to the OFWE bit in the LPTIM_IER register to disable, then write 1 to the WKUPCLR bit in the LPTIM_ICR register. 
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UEWKUP</name>
              <description>
              Indicates update event wakeup occurred
              UEWKUP is set by hardware when an update event was generated (overflow occurred while repetition counter reached zero). To clear UEWKUP, first  write 0 to the UEWE bit in the LPTIM_IER register to disable, then write 1 to the WKUPCLR bit in the LPTIM_ICR register. 
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>ET</name>
              <description>
              External trigger edge event
              ET is set by hardware to inform application that a valid edge on the selected external trigger input has occurred. If the trigger is ignored because the timer has already started, then this flag is not set. ET flag can be cleared by writing 1 to the ETCLR bit in the LPTIM_ICR register.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OC</name>
              <description>
              Output compare match
              The OC bit is set by hardware to inform application that LPTIM_CNT register value reached the LPTIM_CMP register's value. OC flag can be cleared by writing 1 to the OCCLR bit in the LPTIM_ICR register.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OF</name>
              <description>
              Overflow occurred
              OF is set by hardware to inform application that LPTIM_CNT register's value reached the LPTIM_ARR register's value and count from zero again. OF flag can be cleared by writing 1 to the OFCLR bit in the LPTIM_ICR register.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UE</name>
              <description>
              LPTIM update event occurred
              UE is set by hardware to inform application that an update event was generated when overflow occurred while repetition counter reached zero. UE flag can be cleared by writing 1 to the UECLR bit in the LPTIM_ICR register. 
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ICR</name>
          <displayName>ICR</displayName>
          <description>LPTIM interrupt and status clear register</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>WKUPCLR</name>
              <description>
              wakeup status clear flag
              Writing 1 to this bit clears all wakeup status flags in the LPTIM_ISR register.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>ETCLR</name>
              <description>
              External trigger valid edge clear flag
              Writing 1 to this bit clears the ET flag in the LPTIM_ISR register
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OCCLR</name>
              <description>
              Output compare clear flag
              Writing 1 to this bit clears the OC flag in the LPTIM_ISR register
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OFCLR</name>
              <description>
              Overflow clear flag
              Writing 1 to this bit clears the OF flag in the LPTIM_ISR register
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UECLR</name>
              <description>
              Update event clear flag
              Writing 1 to this bit clear the UE flag in the LPTIM_ISR register.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IER</name>
          <displayName>IER</displayName>
          <description>LPTIM interrupt and wakeup enable register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>21</bitWidth>
            </field>
            <field>
              <name>OCWE</name>
              <description>
              Output compare Wakeup Enable
              0: Output compare wakeup disabled
              1: Output compare wakeup enabled
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OFWE</name>
              <description>
              Overflow Wakeup Enable
              0: Overflow Wakeup disabled
              1: Overflow Wakeup enabled
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UEWE</name>
              <description>
              Update event Wakeup enable
              0: Update event Wakeup disabled
              1: Update event Wakeup enabled
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>ETIE</name>
              <description>
              External trigger valid edge Interrupt Enable
              0: External trigger interrupt disabled
              1: External trigger interrupt enabled
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OCIE</name>
              <description>
              Output compare Interrupt Enable
              0: Output compare interrupt disabled
              1: Output compare interrupt enabled
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OFIE</name>
              <description>
              Overflow Interrupt Enable
              0: Overflow interrupt disabled
              1: Overflow interrupt enabled
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UEIE</name>
              <description>
              Update event interrupt enable
              0: Update event interrupt disabled
              1: Update event interrupt enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CFGR</name>
          <displayName>CFGR</displayName>
          <description>LPTIM configuration register</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>COUNTMODE</name>
              <description>
              counter mode in internal clock source mode (CKSEL=0). If CKSEL=1, this bit has no effect.
              0: the counter is incremented following each internal clock pulse
              1: the counter is incremented following each valid pulse on the external clock
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>WAVPOL</name>
              <description>
              Waveform shape polarity
              The WAVEPOL bit controls the output polarity
              0: The LPTIM output reflects the compare results between LPTIM_ARR and LPTIM_CMP registers
              1: The LPTIM output reflects the inverse of the compare results between LPTIM_ARR and LPTIM_CMP registers
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>WAVE</name>
              <description>
              Waveform shape
              The WAVE bit controls the output shape
              0: Deactivate Set-once mode
              1: Activate the Set-once mode
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TIMOUT</name>
              <description>
              Timeout enable
              The TIMOUT bit controls the Timeout feature
              0: A trigger event arriving when the timer is already started will be ignored
              1: A trigger event arriving when the timer is already started will reset and restart the LPTIM counter and the repetition counter
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TRIGEN</name>
              <description>
              Trigger enable and polarity
              The TRIGEN bits controls whether the LPTIM counter is started by an external trigger or not. If the external trigger option is selected, three configurations are possible for the trigger active edge:
              00: software trigger (counting start is initiated by software)
              01: rising edge is the active edge
              10: falling edge is the active edge
              11: both edges are active edges
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TRIGSEL</name>
              <description>
              Trigger selector
              The TRIGSEL bits select the trigger source that will serve as a trigger event for the LPTIM among the below 8 available sources:
              000: lptim_ext0
              001: lptim_ext1
              010: lptim_ext2
              011: lptim_ext3
              100: lptim_ext4
              101: lptim_ext5
              110: lptim_ext6
              111: lptim_ext7
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PRESC</name>
              <description>
              Clock prescaler
              The PRESC bits configure the prescaler division factor. It can be one among the following division factors:
              000: /1
              001: /2
              010: /4
              011: /8
              100: /16
              101: /32
              110: /64
              111: /128
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>EXTCKSEL</name>
              <description>
              External clock source selector
              0: external clock source is from lptim_in
              1: external clock source is from LPCOMP (if LPCOMP integrated)
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TRGFLT</name>
              <description>
              Configurable digital filter for trigger
              The TRGFLT value sets the number of consecutive equal samples that should be detected when a level change occurs on an internal trigger before it is considered as a valid level transition. An internal clock source must be present to use this feature
              00: any trigger active level change is considered as a valid trigger
              01: trigger active level change must be stable for at least 2 clock periods before it is considered as valid trigger.
              10: trigger active level change must be stable for at least 4 clock periods before it is considered as valid trigger.
              11: trigger active level change must be stable for at least 8 clock periods before it is considered as valid trigger.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>INTCKSEL</name>
              <description>
              Internal clock source selector
              0: internal clock source is clk_lp
              1: internal clock source is pclk2
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CKFLT</name>
              <description>
              Configurable digital filter for external clock
              The CKFLT value sets the number of consecutive equal samples that should be detected when a level change occurs on an external clock signal before it is considered as a valid level transition. An internal clock source must be present to use this feature
              00: any external clock signal level change is considered as a valid transition
              01: external clock signal level change must be stable for at least 2 clock periods before it is considered as valid transition.
              10: external clock signal level change must be stable for at least 4 clock periods before it is considered as valid transition.
              11: external clock signal level change must be stable for at least 8 clock periods before it is considered as valid transition.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>CKPOL</name>
              <description>
              Clock Polarity
              If LPTIM is clocked by an external clock source, CKPOL bits is used to configure the active edge or edges used by the counter:
              00: the rising edge is the active edge used for counting
              01: the falling edge is the active edge used for counting
              10: both edges are active edges. When both external clock signal edges are considered active ones, the LPTIM must also be clocked by an internal clock source with a frequency equal to at least four time the external clock frequency.
              11: not allowed
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>CKSEL</name>
              <description>
              Clock selector
              The CKSEL bit selects which clock source the LPTIM will use:
              0: LPTIM is clocked by internal clock source, according to INTCKSEL
              1: LPTIM is clocked by external clock source, according to EXTCKSEL
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CR</name>
          <displayName>CR</displayName>
          <description>LPTIM control register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>28</bitWidth>
            </field>
            <field>
              <name>COUNTRST</name>
              <description>
              Counter reset
              This bit is set by software and cleared by hardware. When set to 1 this bit will trigger a synchronous reset of the CNT register. Due to the synchronous nature of this reset, it only takes place after a synchronization delay.
              COUNTRST must never be set to 1 by software before it is already cleared to 0 by hardware. Software should consequently check that COUNTRST bit is already cleared to 0 before attempting to set it to 1.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CNTSTRT</name>
              <description>
              Timer start in Continuous mode
              This bit is set by software and cleared by hardware.
              In case of software start (TRIGEN[1:0] = 00), setting this bit starts the LPTIM in Continuous mode.
              If the software start is disabled (TRIGEN[1:0] different than 00), setting this bit starts the timer in Continuous mode as soon as an external trigger is detected.
              If this bit is set when a single pulse mode counting is ongoing, then the timer will not stop at the next match between ARR and CNT registers and the LPTIM counter keeps counting in Continuous mode.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SNGSTRT</name>
              <description>
              LPTIM start in Single mode
              This bit is set by software and cleared by hardware.
              In case of software start (TRIGEN[1:0] = 00), setting this bit starts the LPTIM in single pulse mode.
              If the software start is disabled (TRIGEN[1:0] different than 00), setting this bit starts the LPTIM in single pulse mode as soon as an external trigger is detected.
              If this bit is set when the LPTIM is in continuous counting mode, then the LPTIM will stop at the following match between ARR and CNT registers.
              If this bit is set simultaneously with CNTSTRT, then LPTIM will be in continuous counting mode.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ENABLE</name>
              <description>
              LPTIM enable
              The ENABLE bit is set and cleared by software. 
              0:LPTIM is disabled
              1:LPTIM is enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CMP</name>
          <displayName>CMP</displayName>
          <description>LPTIM compare register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>CMP</name>
              <description>
              Compare value
              CMP is the compare value used by the LPTIM.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ARR</name>
          <displayName>ARR</displayName>
          <description>LPTIM autoreload register</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>ARR</name>
              <description>
              Auto reload value
              ARR is the autoreload value for the LPTIM. This value must be strictly greater than the CMP[15:0] value.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CNT</name>
          <displayName>CNT</displayName>
          <description>LPTIM counter register</description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>CNT</name>
              <description>
              Counter value
              When the LPTIM is running with an asynchronous clock, reading the CNT register may return unreliable values. So in this case it is necessary to perform two consecutive read accesses and verify that the two returned values are identical.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RCR</name>
          <displayName>RCR</displayName>
          <description>LPTIM repetition register</description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>REP</name>
              <description>
              Repetition register value
              REP is the repetition value for the LPTIM.
              Read REP will return left repetition times. It should be noted that for a reliable REP register read access, two consecutive read accesses must be performed and compared. A read access can be considered reliable when the values of the two consecutive read accesses are equal.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PMUC</name>
      <description></description>
      <groupName>PMUC</groupName>
      <baseAddress>0x4007a000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CR</name>
          <displayName>CR</displayName>
          <description>Control Register</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
            <field>
              <name>PIN5_MODE</name>
              <description>
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>PIN4_MODE</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>PIN3_MODE</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>PIN2_MODE</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>PIN1_MODE</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>PIN0_MODE</name>
              <description>
              0 - high level, 1 - low level, 2 - pos edge, 3 - neg edge, 4/5/6/7: pos or neg edge
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>REBOOT</name>
              <description>
              Write 1 to reboot; write 0 to clear after boot up
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HIBER_EN</name>
              <description>
              Write 1 to enter hibernate mode; write 0 to clear when exit from hibernate
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SEL_LPCLK</name>
              <description>
              0 - LRC10, 1 - LXT32
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>WER</name>
          <displayName>WER</displayName>
          <description>Wakeup Enable register</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>22</bitWidth>
            </field>
            <field>
              <name>PIN5</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN4</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN3</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN2</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN1</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN0</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>IWDT</name>
              <description>
              Set 1 to enable IWDT as wakeup source
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RTC</name>
              <description>
              Set 1 to enable RTC as wakeup source
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>WSR</name>
          <displayName>WSR</displayName>
          <description>Wakeup Status register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>22</bitWidth>
            </field>
            <field>
              <name>PIN5</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN4</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN3</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN2</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN1</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN0</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>IWDT</name>
              <description>
              Indicates the wakeup status from LPTIM2. Note: the status is masked by WER
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RTC</name>
              <description>
              Indicates the wakeup status from RTC. Note: the status is masked by WER
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>WCR</name>
          <displayName>WCR</displayName>
          <description>Wakeup Clear register</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>AON</name>
              <description>
              Write 1 to clear the AON wakeup IRQ status
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>21</bitWidth>
            </field>
            <field>
              <name>PIN5</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN4</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN3</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN2</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN1</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN0</name>
              <description>
              Write 1 to clear the PIN0 wakeup source. Only valid if PIN wakeup is configured as edge trigger
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              Note: for LPTIM and LPUART, clear the wakeup status directly in the orignal module
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>VRTC_CR</name>
          <displayName>VRTC_CR</displayName>
          <description>VRTC Control Register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>19</bitWidth>
            </field>
            <field>
              <name>BOR_VT_TRIM</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>BOR_EN</name>
              <description>
              Brownout Reset Enable
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>VRTC_TRIM</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>VRTC_VBIT</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>VRET_CR</name>
          <displayName>VRET_CR</displayName>
          <description>VRET Control Register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RDY</name>
              <description>
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>DLY</name>
              <description>
              VRET_LDO power up delay in number of CLK_LP cycles
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>CAL_TRIM</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>CAL_RDY</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TRIM_RSTN</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TRIM_SEL</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TRIM</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>VBIT</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>BM</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EN</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>LRC_CR</name>
          <displayName>LRC_CR</displayName>
          <description>RC10K Control Register</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>REFRES</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CHGCAP</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>CHGCRT</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>CMPBM2</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CMPBM1</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>EN</name>
              <description>
              Enabled by default
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>LXT_CR</name>
          <displayName>LXT_CR</displayName>
          <description>XTAL32K Control Register</description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RDY</name>
              <description>
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>CAP_SEL</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BMSTART</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>BMSEL</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>AMPCTRL_ENB</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>AMP_BM</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>BM</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>RSN</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EN</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BG1_CR</name>
          <displayName>BG1_CR</displayName>
          <description>BG1 Control Register</description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>21</bitWidth>
            </field>
            <field>
              <name>BG1_DLY</name>
              <description>
              Bandgap power up delay in CLK_LP cycles
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>BG1_VREF12</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>BG1_VREF06</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>BG1_EN</name>
              <description>
              Force BG1 enable
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BG2_CR</name>
          <displayName>BG2_CR</displayName>
          <description>BG2 Control Register</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>21</bitWidth>
            </field>
            <field>
              <name>BG2_DLY</name>
              <description>
              Bandgap power up delay in CLK_LP cycles
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>BG2_VREF12</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>BG2_VREF06</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>BG2_EN</name>
              <description>
              Force BG2 enable
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BUCK1_CR</name>
          <displayName>BUCK1_CR</displayName>
          <description>BUCK1 Control Register 1</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>BUCK1_RDY</name>
              <description>
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BUCK1_ZCD_AON</name>
              <description>
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BUCK1_BM_ZCD</name>
              <description>
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>BUCK1_BM_PWMCMP</name>
              <description>
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>BUCK1_BM_COTCMP</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>BUCK1_MOT</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>BUCK1_SEL_LX22</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BUCK1_CS</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>BUCK1_CCH</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>BUCK1_ILIMIT</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>BUCK1_EN</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BUCK2_CR</name>
          <displayName>BUCK2_CR</displayName>
          <description>BUCK2 Control Register 1</description>
          <addressOffset>0x2c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>BUCK2_RDY</name>
              <description>
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BUCK2_ZCD_AON</name>
              <description>
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BUCK2_BM_ZCD</name>
              <description>
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>BUCK2_BM_PWMCMP</name>
              <description>
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>BUCK2_BM_COTCMP</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>BUCK2_MOT</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>BUCK2_SEL_LX22</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BUCK2_CS</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>BUCK2_CCH</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>BUCK2_ILIMIT</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>BUCK2_EN</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>LDOVCC1_CR</name>
          <displayName>LDOVCC1_CR</displayName>
          <description>LDOVCC1 Control Register</description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>29</bitWidth>
            </field>
            <field>
              <name>LDOVCC1_RDY</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LDOVCC1_EN_SS</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LDOVCC1_EN</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>LDOVCC2_CR</name>
          <displayName>LDOVCC2_CR</displayName>
          <description>LDOVCC2 Control Register</description>
          <addressOffset>0x34</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>29</bitWidth>
            </field>
            <field>
              <name>LDOVCC2_RDY</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LDOVCC2_EN_SS</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LDOVCC2_EN</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>LDO_CR</name>
          <displayName>LDO_CR</displayName>
          <description>LDO Control Register</description>
          <addressOffset>0x38</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>LDOBG_EN</name>
              <description>
              Force LDOBG enable
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>LPSYS_LDO_RDY</name>
              <description>
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LPSYS_LDO_DLY</name>
              <description>
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>LPSYS_LDO_VREF</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>LPSYS_LDO_EN</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HPSYS_LDO_RDY</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HPSYS_LDO_DLY</name>
              <description>
              HPSYS_LDO power up delay in CLK_LP cycles
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>HPSYS_LDO_VREF2</name>
              <description>
              Lower voltage if needed, selected by HPSYS AON
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>HPSYS_LDO_VREF</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>HPSYS_LDO_EN</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>HPSYS_SWR</name>
          <displayName>HPSYS_SWR</displayName>
          <description>HPSYS Switch Register</description>
          <addressOffset>0x3c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RDY</name>
              <description>
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>26</bitWidth>
            </field>
            <field>
              <name>NORET</name>
              <description>
              Cut off power switch entirely during standby. No retention
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DLY</name>
              <description>
              wait for N cycles before asserting RDY
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>PSW</name>
              <description>
              bit[0] - select RET_LDO; bit[1] - select HPSYS_LDO
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>LPSYS_SWR</name>
          <displayName>LPSYS_SWR</displayName>
          <description>LPSYS Switch Register</description>
          <addressOffset>0x40</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RDY</name>
              <description>
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>26</bitWidth>
            </field>
            <field>
              <name>DLY</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>PSW</name>
              <description>
              bit[0] - select RET_LDO; bit[1] - select BUCK2; bit [2] - select LPSYS_LDO
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PMU_TR</name>
          <displayName>PMU_TR</displayName>
          <description>PMU Test Register</description>
          <addressOffset>0x44</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>PMU_DC_MR</name>
              <description>
              macro select
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>PMU_DC_BR</name>
              <description>
              block select
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>PMU_DC_TR</name>
              <description>
              test point select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PMU_RSVD1</name>
          <displayName>PMU_RSVD1</displayName>
          <description>PMU Reserved Register 1</description>
          <addressOffset>0x48</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RESERVE3</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>RESERVE2</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>RESERVE1</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>RESERVE0</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PMU_RSVD2</name>
          <displayName>PMU_RSVD2</displayName>
          <description>PMU Reserved Register 2</description>
          <addressOffset>0x4c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RESERVE3</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>RESERVE2</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>RESERVE1</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>RESERVE0</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>HXT_CR1</name>
          <displayName>HXT_CR1</displayName>
          <description>HXT48 Control Register 1</description>
          <addressOffset>0x50</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>CBANK_SEL</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
            <field>
              <name>GM_EN</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LDO_FLT_RSEL</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>LDO_VREF</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>BUF_RF_STR</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>BUF_DLL_STR</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>BUF_DIG_STR</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>BUF_DLL_EN</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BUF_DIG_EN</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BUF_EN</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EN</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>HXT_CR2</name>
          <displayName>HXT_CR2</displayName>
          <description>HXT48 Control Register 2</description>
          <addressOffset>0x54</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>SLEEP_EN</name>
              <description>
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SDADC_CLKDIV2_SEL</name>
              <description>
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>SDADC_CLKDIV1_SEL</name>
              <description>
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>SDADC_CLKIN_EN</name>
              <description>
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IDAC</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
            <field>
              <name>IDAC_EN</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BUF_SEL3</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>BUF_SEL2</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>ACBUF_RSEL</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ACBUF_SEL</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>AGC_VINDC</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>AGC_VTH</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>AGC_ISTART_SEL</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>AGC_EN</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>HXT_CR3</name>
          <displayName>HXT_CR3</displayName>
          <description>HXT48 Control Register 3</description>
          <addressOffset>0x58</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>DLY</name>
              <description>
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>OPT_IDAC</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
            <field>
              <name>OPT_IDAC_EN</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OPT_CBANK_SEL</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>HRC_CR</name>
          <displayName>HRC_CR</displayName>
          <description>HRC48 Control Register</description>
          <addressOffset>0x5c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>DLY</name>
              <description>
              number of cycles for BG ready. 0 - one cycle of CLK_LP; 1 - two cycles of CLK_LP
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CT</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
            <field>
              <name>MODE24M_EN</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BM</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>LDO_VREF</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>RST</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OUT_STR</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>OUT_EN</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EN</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RC1M_CR</name>
          <displayName>RC1M_CR</displayName>
          <description>RC1M Control Register</description>
          <addressOffset>0x60</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>RINGOSC_MODE</name>
              <description>
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RINGOSC_BM</name>
              <description>
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>RINGOSC_EN</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SEL_SOURCE</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DLY</name>
              <description>
              number of cycles for BG ready. 0 - one cycle of CLK_LP; 1 - two cycles of CLK_LP
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSEL</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>CSEL</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
            <field>
              <name>BM_COMP</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>BM_CHG</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RST</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OUT_EN</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EN</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CAU_BGR</name>
          <displayName>CAU_BGR</displayName>
          <description>CAU Bandgap Register</description>
          <addressOffset>0x64</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>21</bitWidth>
            </field>
            <field>
              <name>LPBG_VREF12</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>LPBG_VREF06</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>LPBG_EN</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HPBG_EN</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HPBG_VDDPSW_EN</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CAU_TR</name>
          <displayName>CAU_TR</displayName>
          <description>CAU Test Register</description>
          <addressOffset>0x68</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>CAU_DC_MR</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>CAU_DC_BR</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>CAU_DC_TR</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CAU_RSVD</name>
          <displayName>CAU_RSVD</displayName>
          <description>CAU Reserved Register</description>
          <addressOffset>0x6c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RESERVE3</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>RESERVE2</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>RESERVE1</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>RESERVE0</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>IWDT</name>
      <description></description>
      <groupName>WDT</groupName>
      <baseAddress>0x4007c000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>WDT_CVR0</name>
          <displayName>WDT_CVR0</displayName>
          <description>WatchDog Counter Value 0</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>COUNT_VALUE_0</name>
              <description>
              Count Value for 1st TimeOut
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_CVR1</name>
          <displayName>WDT_CVR1</displayName>
          <description>WatchDog Counter Value 1</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>COUNT_VALUE_1</name>
              <description>
              Count Value for 2nd TimeOut
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_CR</name>
          <displayName>WDT_CR</displayName>
          <description>WatchDog Control Register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>27</bitWidth>
            </field>
            <field>
              <name>RESPONSE_MODE</name>
              <description>
              0:reset only, 1:interrupt and reset
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RESET_LENGTH</name>
              <description>
              reset pulse length in number of wdt clock cycles
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_CCR</name>
          <displayName>WDT_CCR</displayName>
          <description>WatchDog Counter Control Register</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>COUNTER_CONTROL</name>
              <description>
              SinglePulse /Write 8'h76 to restart, write8'h34 to stop, else do nothing
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_ICR</name>
          <displayName>WDT_ICR</displayName>
          <description>WatchDog Interrupt Clear Register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>31</bitWidth>
            </field>
            <field>
              <name>INT_CLR</name>
              <description>
              SinglePulse /A pulse to clear interrupt
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_SR</name>
          <displayName>WDT_SR</displayName>
          <description>WatchDog Status Register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>30</bitWidth>
            </field>
            <field>
              <name>WDT_ACTIVE</name>
              <description>
              Watchdog runs when 1, else 0
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>INT_ASSERT</name>
              <description>
              Interrupt assert when 1
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_WP</name>
          <displayName>WDT_WP</displayName>
          <description>WatchDog Write Protect Register</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>WRPT_ST</name>
              <description>
              1 indicates write protect is active
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>WRPT</name>
              <description>
              write 0x58ab99fc generate write_protect, write 0x51ff8621 to release
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>31</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>LPSYS_GPIO</name>
      <description></description>
      <groupName>LPSYS_GPIO</groupName>
      <baseAddress>0x50040000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>DIR0</name>
          <displayName>DIR0</displayName>
          <description>Data Input Register</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>IN</name>
              <description>
              GPIO[31:0] input value
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DOR0</name>
          <displayName>DOR0</displayName>
          <description>Data Output Register</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>OUT</name>
              <description>
              GPIO[31:0] output value if output enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DOER0</name>
          <displayName>DOER0</displayName>
          <description>Data Output Enable Register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>DOE</name>
              <description>
              GPIO[31:0] output enable
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>OESR0</name>
          <displayName>OESR0</displayName>
          <description>Data Output Enable Set Register</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>OES</name>
              <description>
              set 1 to enable output of corresponding GPIO[31:0]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>OECR0</name>
          <displayName>OECR0</displayName>
          <description>Data Output Enable Clear Register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>OEC</name>
              <description>
              set 1 to disable output of corresponding GPIO[31:0]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IER0</name>
          <displayName>IER0</displayName>
          <description>Interrupt Enable Register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>IER</name>
              <description>
              GPIO[31:0]  interrupt  enable
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IESR0</name>
          <displayName>IESR0</displayName>
          <description>Interrupt Enable Set Register</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>IES</name>
              <description>
              set 1 to enable interrupt of corresponding GPIO[31:0]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IECR0</name>
          <displayName>IECR0</displayName>
          <description>Interrupt Enable Clear Register</description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>IEC</name>
              <description>
              set 1 to disable interrupt of corresponding GPIO[31:0]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ITR0</name>
          <displayName>ITR0</displayName>
          <description>Interrupt Type Register</description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>ITR</name>
              <description>
              GPIO[31:0]  interrupt  type
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ITSR0</name>
          <displayName>ITSR0</displayName>
          <description>Interrupt Type Set Register</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>ITS</name>
              <description>
              set 1 for edge-sensitive interrupt mode of corresponding GPIO[31:0]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ITCR0</name>
          <displayName>ITCR0</displayName>
          <description>Interrupt Type Clear Register</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>ITC</name>
              <description>
              set 1 for level-sensitive interrupt mode of corresponding GPIO[31:0]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IPSR0</name>
          <displayName>IPSR0</displayName>
          <description>Interrupt Polarity Set Register</description>
          <addressOffset>0x2c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>IPS</name>
              <description>
              set 1 for rising edge in edge mode, or high level in level mode of corresponding GPIO[31:0]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IPCR0</name>
          <displayName>IPCR0</displayName>
          <description>Interrupt Polarity Clear Register</description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>IPC</name>
              <description>
              set 1 for falling edge in edge mode, or low level in level mode of corresponding GPIO[31:0]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ISR0</name>
          <displayName>ISR0</displayName>
          <description>Interrupt Status Register</description>
          <addressOffset>0x34</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>IS</name>
              <description>
              Interrupt status. Write 1 will clear interrupt status of corresponding GPIO[31:0]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DIR1</name>
          <displayName>DIR1</displayName>
          <description>Data Input Register</description>
          <addressOffset>0x38</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>15</bitWidth>
            </field>
            <field>
              <name>IN</name>
              <description>
              GPIO[48:32] input value
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DOR1</name>
          <displayName>DOR1</displayName>
          <description>Data Output Register</description>
          <addressOffset>0x3c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>15</bitWidth>
            </field>
            <field>
              <name>OUT</name>
              <description>
              GPIO[48:32]output value if output enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DOER1</name>
          <displayName>DOER1</displayName>
          <description>Data Direction Register</description>
          <addressOffset>0x40</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>15</bitWidth>
            </field>
            <field>
              <name>DOE</name>
              <description>
              GPIO[48:32] output enable
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>OESR1</name>
          <displayName>OESR1</displayName>
          <description>Data Output Enable Set Register</description>
          <addressOffset>0x44</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>15</bitWidth>
            </field>
            <field>
              <name>OES</name>
              <description>
              set 1 to enable output of corresponding GPIO[48:32]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>OECR1</name>
          <displayName>OECR1</displayName>
          <description>Data Output Enable Clear Register</description>
          <addressOffset>0x48</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>15</bitWidth>
            </field>
            <field>
              <name>OEC</name>
              <description>
              set 1 to disable output of corresponding GPIO[48:32]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IER1</name>
          <displayName>IER1</displayName>
          <description>Interrupt Enable  Register</description>
          <addressOffset>0x4c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>15</bitWidth>
            </field>
            <field>
              <name>IER</name>
              <description>
              GPIO[48:32] interrupt  enable
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IESR1</name>
          <displayName>IESR1</displayName>
          <description>Interrupt Enable Set Register</description>
          <addressOffset>0x50</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>15</bitWidth>
            </field>
            <field>
              <name>IES</name>
              <description>
              set 1 to enable interrupt of corresponding GPIO[48:32]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IECR1</name>
          <displayName>IECR1</displayName>
          <description>Interrupt Enable Clear Register</description>
          <addressOffset>0x54</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>15</bitWidth>
            </field>
            <field>
              <name>IEC</name>
              <description>
              set 1 to disable interrupt of corresponding GPIO[48:32]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ITR1</name>
          <displayName>ITR1</displayName>
          <description>Interrupt Type Register</description>
          <addressOffset>0x58</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>15</bitWidth>
            </field>
            <field>
              <name>ITR</name>
              <description>
              GPIO[48:32]  interrupt  type
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ITSR1</name>
          <displayName>ITSR1</displayName>
          <description>Interrupt Type Set Register</description>
          <addressOffset>0x5c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>15</bitWidth>
            </field>
            <field>
              <name>ITS</name>
              <description>
              set 1 for edge-sensitive interrupt mode of corresponding GPIO[48:32]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ITCR1</name>
          <displayName>ITCR1</displayName>
          <description>Interrupt Type Clear Register</description>
          <addressOffset>0x60</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>15</bitWidth>
            </field>
            <field>
              <name>ITC</name>
              <description>
              set 1 for level-sensitive interrupt mode of corresponding GPIO[48:32]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IPSR1</name>
          <displayName>IPSR1</displayName>
          <description>Interrupt Polarity Set Register</description>
          <addressOffset>0x64</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>15</bitWidth>
            </field>
            <field>
              <name>IPS</name>
              <description>
              set 1 for rising edge in edge mode, or high level in level mode of corresponding GPIO[48:32]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IPCR1</name>
          <displayName>IPCR1</displayName>
          <description>Interrupt Polarity Clear Register</description>
          <addressOffset>0x68</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>15</bitWidth>
            </field>
            <field>
              <name>IPC</name>
              <description>
              set 1 for falling edge in edge mode, or low level in level mode of corresponding GPIO[48:32]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ISR1</name>
          <displayName>ISR1</displayName>
          <description>Interrupt Status Register</description>
          <addressOffset>0x6c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>15</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Interrupt status. Write 1 will clear interrupt status of corresponding GPIO[48:32]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
  </peripherals>
</device>
