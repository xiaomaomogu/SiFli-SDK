<?xml version="1.0" encoding="utf-8" standalone="no"?>
<device schemaVersion="1.1"
xmlns:xs="http://www.w3.org/2001/XMLSchema-instance"
xs:noNamespaceSchemaLocation="CMSIS-SVD_Schema_1_1.xsd">
  <name>SF32LB56x</name>
  <version>1.0</version>
  <description>SF32LB56x</description>
  <!-- details about the cpu embedded in the device -->
  <cpu>
    <name>CM33</name>
    <revision>r0p1</revision>
    <endian>little</endian>
    <mpuPresent>true</mpuPresent>
    <fpuPresent>true</fpuPresent>
    <nvicPrioBits>3</nvicPrioBits>
    <vendorSystickConfig>false</vendorSystickConfig>
  </cpu>
  <!--Bus Interface Properties-->
  <addressUnitBits>8</addressUnitBits>
  <!--the maximum data bit width accessible within a single transfer-->
  <width>32</width>
  <!--Register Default Properties-->
  <size>0x20</size>
  <resetValue>0x0</resetValue>
  <resetMask>0xFFFFFFFF</resetMask>
  <peripherals>
    <peripheral>
      <name>HPSYS_RCC</name>
      <description></description>
      <groupName>HPSYS_RCC</groupName>
      <baseAddress>0x40000000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>RSTR1</name>
          <displayName>RSTR1</displayName>
          <description>Reset Register 1</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>PTC1</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>I2C2</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>I2C1</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PDM2</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PDM1</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>NNACC1</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EXTDMA</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SPI2</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SPI1</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BTIM2</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BTIM1</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GPTIM2</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GPTIM1</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TRNG</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CRC1</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>AES</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EFUSEC</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SYSCFG1</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>I2S1</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LCDC1</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EPIC</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EZIP1</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>USART2</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>USART1</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PINMUX1</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MAILBOX1</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMAC1</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSTR2</name>
          <displayName>RSTR2</displayName>
          <description>Reset Register 2</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>I2C4</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>AUDPRC</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>AUDCODEC</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CAN1</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SCI</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FACC1</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FFT1</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>USART3</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD5</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>ATIM1</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>I2C3</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD6</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>USBC</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SDMMC2</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SDMMC1</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MPI3</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MPI2</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MPI1</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GPIO1</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ENR1</name>
          <displayName>ENR1</displayName>
          <description>Enable Register 1</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>PTC1</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>I2C2</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>I2C1</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PDM2</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PDM1</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>NNACC1</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EXTDMA</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SPI2</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SPI1</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BTIM2</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BTIM1</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GPTIM2</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GPTIM1</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TRNG</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CRC1</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>AES</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EFUSEC</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SYSCFG1</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>I2S1</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LCDC1</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EPIC</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EZIP1</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>USART2</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>USART1</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PINMUX1</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MAILBOX1</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMAC1</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ENR2</name>
          <displayName>ENR2</displayName>
          <description>Enable Register 2</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>I2C4</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>AUDPRC</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>AUDCODEC</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CAN1</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SCI</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FACC1</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FFT1</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>USART3</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD5</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>ATIM1</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>I2C3</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD6</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>USBC</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SDMMC2</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SDMMC1</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MPI3</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MPI2</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MPI1</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GPIO1</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CSR</name>
          <displayName>CSR</displayName>
          <description>Clock Select Register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>14</bitWidth>
            </field>
            <field>
              <name>SEL_SDMMC</name>
              <description>
              select SDMMC1 function clock
              0 - clk_hpsys; 1 - reserved; 2 - clk_dll2; 3 - clk_dll3
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>SEL_USBC</name>
              <description>
              select USB source clock
              0 - clk_hpsys; 1 - clk_dll3
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>SEL_PERI</name>
              <description>
              select clk_peri_hpsys source used by USART/SPI/CAN/I2C
              0 - clk_hrc48; 1 - clk_hxt48
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>SEL_MPI3</name>
              <description>
              selet MPI3 function clock
              0 - clk_hpsys; 1 - reserved; 2 - clk_dll2; 3 - clk_dll3
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>SEL_MPI2</name>
              <description>
              selet MPI2 function clock
              0 - clk_hpsys; 1 - reserved; 2 - clk_dll2; 3 - clk_dll3
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>SEL_MPI1</name>
              <description>
              selet MPI1 function clock
              0 - clk_hpsys; 1 - reserved; 2 - clk_dll2; 3 - clk_dll3
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SEL_SYS_LP</name>
              <description>
              select clk_hpsys source
              0 - selected by SEL_SYS; 1 - clk_lp
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SEL_SYS</name>
              <description>
              select clk_hpsys source
              0 - clk_hrc48; 1 - clk_hxt48; 2 - reserved; 3 - clk_dll1
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CFGR</name>
          <displayName>CFGR</displayName>
          <description>Clock Configuration Register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
            <field>
              <name>PDIV2</name>
              <description>
              pclk2_hpsys = hclk_hpsys / (2^PDIV2), by default divided by 128
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PDIV1</name>
              <description>
              pclk_hpsys = hclk_hpsys / (2^PDIV1), by default divided by 2
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>HDIV</name>
              <description>
              hclk_hpsys = clk_hpsys / HDIV
              if HDIV=0, hclk_hpsys = clk_hpsys
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>USBCR</name>
          <displayName>USBCR</displayName>
          <description>USBC Register</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>29</bitWidth>
            </field>
            <field>
              <name>DIV</name>
              <description>
              USB function clock is USB source clock divided by DIV. After divider, USB function clock must be 60MHz.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DLL1CR</name>
          <displayName>DLL1CR</displayName>
          <description>DLL1 Control Register</description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>READY</name>
              <description>
              0: dll not ready
              1: dll ready
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LOCK_DLY</name>
              <description>
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>PU_DLY</name>
              <description>
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>DTEST_TR</name>
              <description>
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>DTEST_EN</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BYPASS</name>
              <description>
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>VST_SEL</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PRCHG_EXT</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PRCHG_EN</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MCU_PRCHG</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MCU_PRCHG_EN</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OUT_DIV2_EN</name>
              <description>
              0: dll output not divided
              1: dll output divided by 2
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IN_DIV2_EN</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LDO_VREF</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>MODE48M_EN</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>XTALIN_EN</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>STG</name>
              <description>
              DLL lock freqency is decided by STG.
              DLL output frequency is (STG+1)*24MHz
              e.g. STG=9,DLL output is 240M
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>SW</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EN</name>
              <description>
              0: dll disabled
              1: dll enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DLL2CR</name>
          <displayName>DLL2CR</displayName>
          <description>DLL2 Control Register</description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>READY</name>
              <description>
              0: dll not ready
              1: dll ready
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LOCK_DLY</name>
              <description>
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>PU_DLY</name>
              <description>
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>DTEST_TR</name>
              <description>
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>DTEST_EN</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BYPASS</name>
              <description>
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>VST_SEL</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PRCHG_EXT</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PRCHG_EN</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MCU_PRCHG</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MCU_PRCHG_EN</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OUT_DIV2_EN</name>
              <description>
              0: dll output not divided
              1: dll output divided by 2
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IN_DIV2_EN</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LDO_VREF</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>MODE48M_EN</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>XTALIN_EN</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>STG</name>
              <description>
              DLL lock freqency is decided by STG.
              DLL output frequency is (STG+1)*24MHz
              e.g. STG=9,DLL output is 240M
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>SW</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EN</name>
              <description>
              0: dll disabled
              1: dll enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DLL3CR</name>
          <displayName>DLL3CR</displayName>
          <description>DLL3 Control Register</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>READY</name>
              <description>
              0: dll not ready
              1: dll ready
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LOCK_DLY</name>
              <description>
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>PU_DLY</name>
              <description>
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>DTEST_TR</name>
              <description>
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>DTEST_EN</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BYPASS</name>
              <description>
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>VST_SEL</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PRCHG_EXT</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PRCHG_EN</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MCU_PRCHG</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MCU_PRCHG_EN</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OUT_DIV2_EN</name>
              <description>
              0: dll output not divided
              1: dll output divided by 2
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IN_DIV2_EN</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LDO_VREF</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>MODE48M_EN</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>XTALIN_EN</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>STG</name>
              <description>
              DLL lock freqency is decided by STG.
              DLL output frequency is (STG+1)*24MHz
              e.g. STG=9,DLL output is 240M
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>SW</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EN</name>
              <description>
              0: dll disabled
              1: dll enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>HRCCAL1</name>
          <displayName>HRCCAL1</displayName>
          <description>HRC Calibration Register 1</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>CAL_DONE</name>
              <description>
              Calibration done.
              After a new calibration started, results should be processed only when cal_done asserted.
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CAL_EN</name>
              <description>
              Calibration enble. 
              Set to 0 to clear result, then set to 1 to start a new calibration
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>14</bitWidth>
            </field>
            <field>
              <name>CAL_LENGTH</name>
              <description>
              Target clk_hxt48 cycles during calibration
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>HRCCAL2</name>
          <displayName>HRCCAL2</displayName>
          <description>HRC Calibration Register 2</description>
          <addressOffset>0x2c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>HXT_CNT</name>
              <description>
              Total clk_hxt48 cycles during calibration
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>HRC_CNT</name>
              <description>
              Total clk_hrc48 cycles during calibration
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DBGCLKR</name>
          <displayName>DBGCLKR</displayName>
          <description>Debug Clock Register</description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>DLL3_OUT_STR</name>
              <description>
              for debug only
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>DLL3_CG_EN</name>
              <description>
              for debug only
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DLL3_OUT_RSTB</name>
              <description>
              for debug only
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DLL3_LOOP_EN</name>
              <description>
              for debug only
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DLL3_OUT_EN</name>
              <description>
              for debug only
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DLL3_LDO_EN</name>
              <description>
              for debug only
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DLL3_DBG</name>
              <description>
              for debug only
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DLL2_OUT_STR</name>
              <description>
              for debug only
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>DLL2_CG_EN</name>
              <description>
              for debug only
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DLL2_OUT_RSTB</name>
              <description>
              for debug only
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DLL2_LOOP_EN</name>
              <description>
              for debug only
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DLL2_OUT_EN</name>
              <description>
              for debug only
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DLL2_LDO_EN</name>
              <description>
              for debug only
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DLL2_DBG</name>
              <description>
              for debug only
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DLL1_OUT_STR</name>
              <description>
              for debug only
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>DLL1_CG_EN</name>
              <description>
              for debug only
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DLL1_OUT_RSTB</name>
              <description>
              for debug only
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DLL1_LOOP_EN</name>
              <description>
              for debug only
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DLL1_OUT_EN</name>
              <description>
              for debug only
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DLL1_LDO_EN</name>
              <description>
              for debug only
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DLL1_DBG</name>
              <description>
              for debug only
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CLK_EN</name>
              <description>
              for debug only
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CLK_SEL</name>
              <description>
              for debug only
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DBGR</name>
          <displayName>DBGR</displayName>
          <description>Debug Register</description>
          <addressOffset>0x34</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>28</bitWidth>
            </field>
            <field>
              <name>FORCE_GPIO</name>
              <description>
              for debug only
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FORCE_BUS</name>
              <description>
              for debug only
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SYSCLK_SWLP</name>
              <description>
              for debug only
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SYSCLK_AON</name>
              <description>
              for debug only
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DWCFGR</name>
          <displayName>DWCFGR</displayName>
          <description>Deep WFI mode Clock Configuration Register</description>
          <addressOffset>0x38</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>DLL3_OUT_RSTB</name>
              <description>
              for debug only
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DLL3_OUT_EN</name>
              <description>
              for debug only
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DLL2_OUT_RSTB</name>
              <description>
              for debug only
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DLL2_OUT_EN</name>
              <description>
              for debug only
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DLL1_OUT_RSTB</name>
              <description>
              for debug only
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DLL1_OUT_EN</name>
              <description>
              for debug only
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>SEL_SYS_LP</name>
              <description>
              select clk_hpsys source during deep WFI
              0 - selected by SEL_SYS; 1 - clk_lp
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SEL_SYS</name>
              <description>
              select clk_hpsys source during deep WFI
              0 - clk_hrc48; 1 - clk_hxt48; 2 - reserved; 3 - clk_dll1
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>DIV_EN</name>
              <description>
              enable PDIV1, PDIV2 and HDIV reconfiguration during deep WFI
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PDIV2</name>
              <description>
              pclk2_hpsys = hclk_hpsys / (2^PDIV2)  during deep WFI
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PDIV1</name>
              <description>
              pclk_hpsys = hclk_hpsys / (2^PDIV1)  during deep WFI
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>HDIV</name>
              <description>
              hclk_hpsys = clk_hpsys / HDIV  during deep WFI
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>DMAC1</name>
      <description></description>
      <groupName>DMAC</groupName>
      <baseAddress>0x40001000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>ISR</name>
          <displayName>ISR</displayName>
          <description></description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>TEIF8</name>
              <description>
              channel transfer error flag
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HTIF8</name>
              <description>
              channel half transfer flag
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIF8</name>
              <description>
              channel transfer complete flag
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GIF8</name>
              <description>
              channel global interrupt flag
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIF7</name>
              <description>
              channel transfer error flag
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HTIF7</name>
              <description>
              channel half transfer flag
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIF7</name>
              <description>
              channel transfer complete flag
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GIF7</name>
              <description>
              channel global interrupt flag
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIF6</name>
              <description>
              channel transfer error flag
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HTIF6</name>
              <description>
              channel half transfer flag
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIF6</name>
              <description>
              channel transfer complete flag
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GIF6</name>
              <description>
              channel global interrupt flag
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIF5</name>
              <description>
              channel transfer error flag
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HTIF5</name>
              <description>
              channel half transfer flag
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIF5</name>
              <description>
              channel transfer complete flag
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GIF5</name>
              <description>
              channel global interrupt flag
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIF4</name>
              <description>
              channel transfer error flag
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HTIF4</name>
              <description>
              channel half transfer flag
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIF4</name>
              <description>
              channel transfer complete flag
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GIF4</name>
              <description>
              channel global interrupt flag
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIF3</name>
              <description>
              channel transfer error flag
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HTIF3</name>
              <description>
              channel half transfer flag
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIF3</name>
              <description>
              channel transfer complete flag
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GIF3</name>
              <description>
              channel global interrupt flag
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIF2</name>
              <description>
              channel transfer error flag
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HTIF2</name>
              <description>
              channel half transfer flag
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIF2</name>
              <description>
              channel transfer complete flag
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GIF2</name>
              <description>
              channel global interrupt flag
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIF1</name>
              <description>
              channel transfer error flag. Set when bus error detected. Cleared when write 1 to CTEIF or CGIF.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HTIF1</name>
              <description>
              channel half transfer flag. Set when half NDT are transferred. Cleared when write 1 to CHTIF or CGIF.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIF1</name>
              <description>
              channel transfer complete flag. Set when all NDT are transferred.  Cleared when write 1 to CTCIF or CGIF.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GIF1</name>
              <description>
              channel global interrupt flag. Set when any of TEIF/HTIF/TCIF asserted. Cleared when TEIF/HTIF/TCIF all cleared.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IFCR</name>
          <displayName>IFCR</displayName>
          <description></description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>CTEIF8</name>
              <description>
              CTEIF, transfer error flag clear
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CHTIF8</name>
              <description>
              CHTIF, half transfer flag clear
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTCIF8</name>
              <description>
              CTCIF, transfer complete flag clear
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CGIF8</name>
              <description>
              CGIF,  global interrupt flag clear
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTEIF7</name>
              <description>
              CTEIF, transfer error flag clear
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CHTIF7</name>
              <description>
              CHTIF, half transfer flag clear
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTCIF7</name>
              <description>
              CTCIF, transfer complete flag clear
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CGIF7</name>
              <description>
              CGIF,  global interrupt flag clear
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTEIF6</name>
              <description>
              CTEIF, transfer error flag clear
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CHTIF6</name>
              <description>
              CHTIF, half transfer flag clear
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTCIF6</name>
              <description>
              CTCIF, transfer complete flag clear
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CGIF6</name>
              <description>
              CGIF,  global interrupt flag clear
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTEIF5</name>
              <description>
              CTEIF, transfer error flag clear
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CHTIF5</name>
              <description>
              CHTIF, half transfer flag clear
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTCIF5</name>
              <description>
              CTCIF, transfer complete flag clear
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CGIF5</name>
              <description>
              CGIF,  global interrupt flag clear
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTEIF4</name>
              <description>
              CTEIF, transfer error flag clear
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CHTIF4</name>
              <description>
              CHTIF, half transfer flag clear
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTCIF4</name>
              <description>
              CTCIF, transfer complete flag clear
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CGIF4</name>
              <description>
              CGIF,  global interrupt flag clear
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTEIF3</name>
              <description>
              CTEIF, transfer error flag clear
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CHTIF3</name>
              <description>
              CHTIF, half transfer flag clear
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTCIF3</name>
              <description>
              CTCIF, transfer complete flag clear
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CGIF3</name>
              <description>
              CGIF,  global interrupt flag clear
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTEIF2</name>
              <description>
              CTEIF, transfer error flag clear
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CHTIF2</name>
              <description>
              CHTIF, half transfer flag clear
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTCIF2</name>
              <description>
              CTCIF, transfer complete flag clear
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CGIF2</name>
              <description>
              CGIF,  global interrupt flag clear
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTEIF1</name>
              <description>
              CTEIF, transfer error flag clear. Write 1 to clear TEIF.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CHTIF1</name>
              <description>
              CHTIF, half transfer flag clear. Write 1 to clear HTIF.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTCIF1</name>
              <description>
              CTCIF, transfer complete flag clear. Write 1 to clear TCIF.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CGIF1</name>
              <description>
              CGIF,  global interrupt flag clear. Write 1 to clear all TEIF/HTIF/TCIF.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR1</name>
          <displayName>CCR1</displayName>
          <description></description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
            <field>
              <name>MEM2MEM</name>
              <description>
              memory-to-memory mode
              0: disabled
              1: enabled
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PL</name>
              <description>
              priority level
              00: low
              01: medium
              10: high
              11: very high
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>MSIZE</name>
              <description>
              memory size
              Defines the data size of each DMA transfer to the identified memory.
              In memory-to-memory mode, this field identifies the memory source if DIR = 1 and the memory destination if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.
              00: 8 bits
              01: 16 bits
              10: 32 bits
              11: reserved
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>PSIZE</name>
              <description>
              peripheral size
              Defines the data size of each DMA transfer to the identified peripheral.
              In memory-to-memory mode, this field identifies the memory destination if DIR = 1 and the memory source if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR = 1 and the peripheral source if DIR = 0.
              00: 8 bits
              01: 16 bits
              10: 32 bits
              11: reserved
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>MINC</name>
              <description>
              memory increment mode
              Defines the increment mode for each DMA transfer to the identified memory.
              In memory-to-memory mode, this field identifies the memory source if DIR = 1 and the memory destination if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.
              0: disabled
              1: enabled
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PINC</name>
              <description>
              peripheral increment mode
              Defines the increment mode for each DMA transfer to the identified peripheral.
              n memory-to-memory mode, this field identifies the memory destination if DIR = 1 and the 
              memory source if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR = 1 and 
              the peripheral source if DIR = 0.
              0: disabled
              1: enabled
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CIRC</name>
              <description>
              circular mode
              0: disabled
              1: enabled
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DIR</name>
              <description>
              data transfer direction
              This bit must be set only in memory-to-peripheral and peripheral-to-memory modes.
              0: read from peripheral
                 Source attributes are defined by PSIZE and PINC, plus the CPARx register. This is still valid in a memory-to-memory mode.
                 Destination attributes are defined by MSIZE and MINC, plus the CM0ARx register. This is still valid in a peripheral-to-peripheral mode.
              1: read from memory
                 Destination attributes are defined by PSIZE and PINC, plus the CPARx register. This is still valid in a memory-to-memory mode.
                 Source attributes are defined by MSIZE and MINC, plus the CM0ARx register. This is still valid in a peripheral-to-peripheral mode.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIE</name>
              <description>
              transfer error interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HTIE</name>
              <description>
              half transfer interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIE</name>
              <description>
              transfer complete interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EN</name>
              <description>
              channel enable
              When a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the ISR register is cleared (by setting the CTEIFx bit of the IFCR register).
              0: disabled
              1: enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CNDTR1</name>
          <displayName>CNDTR1</displayName>
          <description></description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>NDT</name>
              <description>
              number of data to transfer (0 to 2^16 - 1)
              This field is updated by hardware when the channel is enabled:
                 It is decremented after each single DMA 'read followed by write' transfer, indicating the remaining amount of data items to transfer.
                 It is kept at zero when the programmed amount of data to transfer is reached, if the channel is not in circular mode (CIRC = 0 in the CCRx register).
                 It is reloaded automatically by the previously programmed value, when the transfer is complete, if the channel is in circular mode (CIRC = 1).
              If this field is zero, no transfer can be served whatever the channel status (enabled or not).
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CPAR1</name>
          <displayName>CPAR1</displayName>
          <description></description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>PA</name>
              <description>
              peripheral address
              It contains the base address of the peripheral data register from/to which the data will be read/written.
              In memory-to-memory mode, this register identifies the memory destination address if DIR = 1 and the memory source address if DIR = 0.
              In peripheral-to-peripheral mode, this register identifies the peripheral destination address DIR = 1 and the peripheral source address if DIR = 0.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0AR1</name>
          <displayName>CM0AR1</displayName>
          <description></description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>MA</name>
              <description>
              memory address
              It contains the base address of the memory from/to which the data will be read/written.
              In memory-to-memory mode, this register identifies the memory source address if DIR = 1 and the memory destination address if DIR = 0.
              In peripheral-to-peripheral mode, this register identifies the peripheral source address DIR = 1 and the peripheral destination address if DIR = 0.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CBSR1</name>
          <displayName>CBSR1</displayName>
          <description></description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>BS</name>
              <description>
              burst size in non-m2m mode
              When BS>1, DMA will transfer for BS times for each request if left NDT is larger than BS, or else transfer for left NDT times.
              When BS=0 or 1, DMA will always do single transfer for each request.
              In memory-to-memory mode, BS is ignored.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR2</name>
          <displayName>CCR2</displayName>
          <description></description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
            <field>
              <name>MEM2MEM</name>
              <description>
              memory-to-memory mode
              0: disabled
              1: enabled
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PL</name>
              <description>
              priority level
              00: low
              01: medium
              10: high
              11: very high
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>MSIZE</name>
              <description>
              memory size
              Defines the data size of each DMA transfer to the identified memory.
              In memory-to-memory mode, this field identifies the memory source if DIR = 1 and the memory destination if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.
              00: 8 bits
              01: 16 bits
              10: 32 bits
              11: reserved
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>PSIZE</name>
              <description>
              peripheral size
              Defines the data size of each DMA transfer to the identified peripheral.
              In memory-to-memory mode, this field identifies the memory destination if DIR = 1 and the memory source if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR = 1 and the peripheral source if DIR = 0.
              00: 8 bits
              01: 16 bits
              10: 32 bits
              11: reserved
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>MINC</name>
              <description>
              memory increment mode
              Defines the increment mode for each DMA transfer to the identified memory.
              In memory-to-memory mode, this field identifies the memory source if DIR = 1 and the memory destination if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.
              0: disabled
              1: enabled
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PINC</name>
              <description>
              peripheral increment mode
              Defines the increment mode for each DMA transfer to the identified peripheral.
              n memory-to-memory mode, this field identifies the memory destination if DIR = 1 and the 
              memory source if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR = 1 and 
              the peripheral source if DIR = 0.
              0: disabled
              1: enabled
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CIRC</name>
              <description>
              circular mode
              0: disabled
              1: enabled
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DIR</name>
              <description>
              data transfer direction
              This bit must be set only in memory-to-peripheral and peripheral-to-memory modes.
              0: read from peripheral
                 Source attributes are defined by PSIZE and PINC, plus the CPARx register. This is still valid in a memory-to-memory mode.
                 Destination attributes are defined by MSIZE and MINC, plus the CM0ARx register. This is still valid in a peripheral-to-peripheral mode.
              1: read from memory
                 Destination attributes are defined by PSIZE and PINC, plus the CPARx register. This is still valid in a memory-to-memory mode.
                 Source attributes are defined by MSIZE and MINC, plus the CM0ARx register. This is still valid in a peripheral-to-peripheral mode.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIE</name>
              <description>
              transfer error interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HTIE</name>
              <description>
              half transfer interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIE</name>
              <description>
              transfer complete interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EN</name>
              <description>
              channel enable
              When a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the ISR register is cleared (by setting the CTEIFx bit of the IFCR register).
              0: disabled
              1: enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CNDTR2</name>
          <displayName>CNDTR2</displayName>
          <description></description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>NDT</name>
              <description>
              number of data to transfer (0 to 2^16 - 1)
              This field is updated by hardware when the channel is enabled:
                 It is decremented after each single DMA 'read followed by write' transfer, indicating the remaining amount of data items to transfer.
                 It is kept at zero when the programmed amount of data to transfer is reached, if the channel is not in circular mode (CIRC = 0 in the CCRx register).
                 It is reloaded automatically by the previously programmed value, when the transfer is complete, if the channel is in circular mode (CIRC = 1).
              If this field is zero, no transfer can be served whatever the channel status (enabled or not).
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CPAR2</name>
          <displayName>CPAR2</displayName>
          <description></description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>PA</name>
              <description>
              peripheral address
              It contains the base address of the peripheral data register from/to which the data will be read/written.
              In memory-to-memory mode, this register identifies the memory destination address if DIR = 1 and the memory source address if DIR = 0.
              In peripheral-to-peripheral mode, this register identifies the peripheral destination address DIR = 1 and the peripheral source address if DIR = 0.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0AR2</name>
          <displayName>CM0AR2</displayName>
          <description></description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>MA</name>
              <description>
              peripheral address
              It contains the base address of the memory from/to which the data will be read/written.
              In memory-to-memory mode, this register identifies the memory source address if DIR = 1 and the memory destination address if DIR = 0.
              In peripheral-to-peripheral mode, this register identifies the peripheral source address DIR = 1 and the peripheral destination address if DIR = 0.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CBSR2</name>
          <displayName>CBSR2</displayName>
          <description></description>
          <addressOffset>0x2c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>BS</name>
              <description>
              burst size in non-m2m mode
              When BS>1, DMA will transfer for BS times for each request if left NDT is larger than BS, or else transfer for left NDT times.
              When BS=0 or 1, DMA will always do single transfer for each request.
              In memory-to-memory mode, BS is ignored.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR3</name>
          <displayName>CCR3</displayName>
          <description></description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
            <field>
              <name>MEM2MEM</name>
              <description>
              memory-to-memory mode
              0: disabled
              1: enabled
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PL</name>
              <description>
              priority level
              00: low
              01: medium
              10: high
              11: very high
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>MSIZE</name>
              <description>
              memory size
              Defines the data size of each DMA transfer to the identified memory.
              In memory-to-memory mode, this field identifies the memory source if DIR = 1 and the memory destination if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.
              00: 8 bits
              01: 16 bits
              10: 32 bits
              11: reserved
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>PSIZE</name>
              <description>
              peripheral size
              Defines the data size of each DMA transfer to the identified peripheral.
              In memory-to-memory mode, this field identifies the memory destination if DIR = 1 and the memory source if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR = 1 and the peripheral source if DIR = 0.
              00: 8 bits
              01: 16 bits
              10: 32 bits
              11: reserved
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>MINC</name>
              <description>
              memory increment mode
              Defines the increment mode for each DMA transfer to the identified memory.
              In memory-to-memory mode, this field identifies the memory source if DIR = 1 and the memory destination if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.
              0: disabled
              1: enabled
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PINC</name>
              <description>
              peripheral increment mode
              Defines the increment mode for each DMA transfer to the identified peripheral.
              n memory-to-memory mode, this field identifies the memory destination if DIR = 1 and the 
              memory source if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR = 1 and 
              the peripheral source if DIR = 0.
              0: disabled
              1: enabled
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CIRC</name>
              <description>
              circular mode
              0: disabled
              1: enabled
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DIR</name>
              <description>
              data transfer direction
              This bit must be set only in memory-to-peripheral and peripheral-to-memory modes.
              0: read from peripheral
                 Source attributes are defined by PSIZE and PINC, plus the CPARx register. This is still valid in a memory-to-memory mode.
                 Destination attributes are defined by MSIZE and MINC, plus the CM0ARx register. This is still valid in a peripheral-to-peripheral mode.
              1: read from memory
                 Destination attributes are defined by PSIZE and PINC, plus the CPARx register. This is still valid in a memory-to-memory mode.
                 Source attributes are defined by MSIZE and MINC, plus the CM0ARx register. This is still valid in a peripheral-to-peripheral mode.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIE</name>
              <description>
              transfer error interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HTIE</name>
              <description>
              half transfer interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIE</name>
              <description>
              transfer complete interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EN</name>
              <description>
              channel enable
              When a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the ISR register is cleared (by setting the CTEIFx bit of the IFCR register).
              0: disabled
              1: enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CNDTR3</name>
          <displayName>CNDTR3</displayName>
          <description></description>
          <addressOffset>0x34</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>NDT</name>
              <description>
              number of data to transfer (0 to 2^16 - 1)
              This field is updated by hardware when the channel is enabled:
                 It is decremented after each single DMA 'read followed by write' transfer, indicating the remaining amount of data items to transfer.
                 It is kept at zero when the programmed amount of data to transfer is reached, if the channel is not in circular mode (CIRC = 0 in the CCRx register).
                 It is reloaded automatically by the previously programmed value, when the transfer is complete, if the channel is in circular mode (CIRC = 1).
              If this field is zero, no transfer can be served whatever the channel status (enabled or not).
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CPAR3</name>
          <displayName>CPAR3</displayName>
          <description></description>
          <addressOffset>0x38</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>PA</name>
              <description>
              peripheral address
              It contains the base address of the peripheral data register from/to which the data will be read/written.
              In memory-to-memory mode, this register identifies the memory destination address if DIR = 1 and the memory source address if DIR = 0.
              In peripheral-to-peripheral mode, this register identifies the peripheral destination address DIR = 1 and the peripheral source address if DIR = 0.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0AR3</name>
          <displayName>CM0AR3</displayName>
          <description></description>
          <addressOffset>0x3c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>MA</name>
              <description>
              peripheral address
              It contains the base address of the memory from/to which the data will be read/written.
              In memory-to-memory mode, this register identifies the memory source address if DIR = 1 and the memory destination address if DIR = 0.
              In peripheral-to-peripheral mode, this register identifies the peripheral source address DIR = 1 and the peripheral destination address if DIR = 0.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CBSR3</name>
          <displayName>CBSR3</displayName>
          <description></description>
          <addressOffset>0x40</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>BS</name>
              <description>
              burst size in non-m2m mode
              When BS>1, DMA will transfer for BS times for each request if left NDT is larger than BS, or else transfer for left NDT times.
              When BS=0 or 1, DMA will always do single transfer for each request.
              In memory-to-memory mode, BS is ignored.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR4</name>
          <displayName>CCR4</displayName>
          <description></description>
          <addressOffset>0x44</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
            <field>
              <name>MEM2MEM</name>
              <description>
              memory-to-memory mode
              0: disabled
              1: enabled
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PL</name>
              <description>
              priority level
              00: low
              01: medium
              10: high
              11: very high
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>MSIZE</name>
              <description>
              memory size
              Defines the data size of each DMA transfer to the identified memory.
              In memory-to-memory mode, this field identifies the memory source if DIR = 1 and the memory destination if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.
              00: 8 bits
              01: 16 bits
              10: 32 bits
              11: reserved
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>PSIZE</name>
              <description>
              peripheral size
              Defines the data size of each DMA transfer to the identified peripheral.
              In memory-to-memory mode, this field identifies the memory destination if DIR = 1 and the memory source if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR = 1 and the peripheral source if DIR = 0.
              00: 8 bits
              01: 16 bits
              10: 32 bits
              11: reserved
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>MINC</name>
              <description>
              memory increment mode
              Defines the increment mode for each DMA transfer to the identified memory.
              In memory-to-memory mode, this field identifies the memory source if DIR = 1 and the memory destination if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.
              0: disabled
              1: enabled
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PINC</name>
              <description>
              peripheral increment mode
              Defines the increment mode for each DMA transfer to the identified peripheral.
              n memory-to-memory mode, this field identifies the memory destination if DIR = 1 and the 
              memory source if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR = 1 and 
              the peripheral source if DIR = 0.
              0: disabled
              1: enabled
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CIRC</name>
              <description>
              circular mode
              0: disabled
              1: enabled
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DIR</name>
              <description>
              data transfer direction
              This bit must be set only in memory-to-peripheral and peripheral-to-memory modes.
              0: read from peripheral
                 Source attributes are defined by PSIZE and PINC, plus the CPARx register. This is still valid in a memory-to-memory mode.
                 Destination attributes are defined by MSIZE and MINC, plus the CM0ARx register. This is still valid in a peripheral-to-peripheral mode.
              1: read from memory
                 Destination attributes are defined by PSIZE and PINC, plus the CPARx register. This is still valid in a memory-to-memory mode.
                 Source attributes are defined by MSIZE and MINC, plus the CM0ARx register. This is still valid in a peripheral-to-peripheral mode.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIE</name>
              <description>
              transfer error interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HTIE</name>
              <description>
              half transfer interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIE</name>
              <description>
              transfer complete interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EN</name>
              <description>
              channel enable
              When a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the ISR register is cleared (by setting the CTEIFx bit of the IFCR register).
              0: disabled
              1: enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CNDTR4</name>
          <displayName>CNDTR4</displayName>
          <description></description>
          <addressOffset>0x48</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>NDT</name>
              <description>
              number of data to transfer (0 to 2^16 - 1)
              This field is updated by hardware when the channel is enabled:
                 It is decremented after each single DMA 'read followed by write' transfer, indicating the remaining amount of data items to transfer.
                 It is kept at zero when the programmed amount of data to transfer is reached, if the channel is not in circular mode (CIRC = 0 in the CCRx register).
                 It is reloaded automatically by the previously programmed value, when the transfer is complete, if the channel is in circular mode (CIRC = 1).
              If this field is zero, no transfer can be served whatever the channel status (enabled or not).
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CPAR4</name>
          <displayName>CPAR4</displayName>
          <description></description>
          <addressOffset>0x4c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>PA</name>
              <description>
              peripheral address
              It contains the base address of the peripheral data register from/to which the data will be read/written.
              In memory-to-memory mode, this register identifies the memory destination address if DIR = 1 and the memory source address if DIR = 0.
              In peripheral-to-peripheral mode, this register identifies the peripheral destination address DIR = 1 and the peripheral source address if DIR = 0.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0AR4</name>
          <displayName>CM0AR4</displayName>
          <description></description>
          <addressOffset>0x50</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>MA</name>
              <description>
              peripheral address
              It contains the base address of the memory from/to which the data will be read/written.
              In memory-to-memory mode, this register identifies the memory source address if DIR = 1 and the memory destination address if DIR = 0.
              In peripheral-to-peripheral mode, this register identifies the peripheral source address DIR = 1 and the peripheral destination address if DIR = 0.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CBSR4</name>
          <displayName>CBSR4</displayName>
          <description></description>
          <addressOffset>0x54</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>BS</name>
              <description>
              burst size in non-m2m mode
              When BS>1, DMA will transfer for BS times for each request if left NDT is larger than BS, or else transfer for left NDT times.
              When BS=0 or 1, DMA will always do single transfer for each request.
              In memory-to-memory mode, BS is ignored.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR5</name>
          <displayName>CCR5</displayName>
          <description></description>
          <addressOffset>0x58</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
            <field>
              <name>MEM2MEM</name>
              <description>
              memory-to-memory mode
              0: disabled
              1: enabled
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PL</name>
              <description>
              priority level
              00: low
              01: medium
              10: high
              11: very high
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>MSIZE</name>
              <description>
              memory size
              Defines the data size of each DMA transfer to the identified memory.
              In memory-to-memory mode, this field identifies the memory source if DIR = 1 and the memory destination if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.
              00: 8 bits
              01: 16 bits
              10: 32 bits
              11: reserved
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>PSIZE</name>
              <description>
              peripheral size
              Defines the data size of each DMA transfer to the identified peripheral.
              In memory-to-memory mode, this field identifies the memory destination if DIR = 1 and the memory source if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR = 1 and the peripheral source if DIR = 0.
              00: 8 bits
              01: 16 bits
              10: 32 bits
              11: reserved
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>MINC</name>
              <description>
              memory increment mode
              Defines the increment mode for each DMA transfer to the identified memory.
              In memory-to-memory mode, this field identifies the memory source if DIR = 1 and the memory destination if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.
              0: disabled
              1: enabled
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PINC</name>
              <description>
              peripheral increment mode
              Defines the increment mode for each DMA transfer to the identified peripheral.
              n memory-to-memory mode, this field identifies the memory destination if DIR = 1 and the 
              memory source if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR = 1 and 
              the peripheral source if DIR = 0.
              0: disabled
              1: enabled
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CIRC</name>
              <description>
              circular mode
              0: disabled
              1: enabled
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DIR</name>
              <description>
              data transfer direction
              This bit must be set only in memory-to-peripheral and peripheral-to-memory modes.
              0: read from peripheral
                 Source attributes are defined by PSIZE and PINC, plus the CPARx register. This is still valid in a memory-to-memory mode.
                 Destination attributes are defined by MSIZE and MINC, plus the CM0ARx register. This is still valid in a peripheral-to-peripheral mode.
              1: read from memory
                 Destination attributes are defined by PSIZE and PINC, plus the CPARx register. This is still valid in a memory-to-memory mode.
                 Source attributes are defined by MSIZE and MINC, plus the CM0ARx register. This is still valid in a peripheral-to-peripheral mode.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIE</name>
              <description>
              transfer error interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HTIE</name>
              <description>
              half transfer interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIE</name>
              <description>
              transfer complete interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EN</name>
              <description>
              channel enable
              When a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the ISR register is cleared (by setting the CTEIFx bit of the IFCR register).
              0: disabled
              1: enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CNDTR5</name>
          <displayName>CNDTR5</displayName>
          <description></description>
          <addressOffset>0x5c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>NDT</name>
              <description>
              number of data to transfer (0 to 2^16 - 1)
              This field is updated by hardware when the channel is enabled:
                 It is decremented after each single DMA 'read followed by write' transfer, indicating the remaining amount of data items to transfer.
                 It is kept at zero when the programmed amount of data to transfer is reached, if the channel is not in circular mode (CIRC = 0 in the CCRx register).
                 It is reloaded automatically by the previously programmed value, when the transfer is complete, if the channel is in circular mode (CIRC = 1).
              If this field is zero, no transfer can be served whatever the channel status (enabled or not).
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CPAR5</name>
          <displayName>CPAR5</displayName>
          <description></description>
          <addressOffset>0x60</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>PA</name>
              <description>
              peripheral address
              It contains the base address of the peripheral data register from/to which the data will be read/written.
              In memory-to-memory mode, this register identifies the memory destination address if DIR = 1 and the memory source address if DIR = 0.
              In peripheral-to-peripheral mode, this register identifies the peripheral destination address DIR = 1 and the peripheral source address if DIR = 0.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0AR5</name>
          <displayName>CM0AR5</displayName>
          <description></description>
          <addressOffset>0x64</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>MA</name>
              <description>
              peripheral address
              It contains the base address of the memory from/to which the data will be read/written.
              In memory-to-memory mode, this register identifies the memory source address if DIR = 1 and the memory destination address if DIR = 0.
              In peripheral-to-peripheral mode, this register identifies the peripheral source address DIR = 1 and the peripheral destination address if DIR = 0.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CBSR5</name>
          <displayName>CBSR5</displayName>
          <description></description>
          <addressOffset>0x68</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>BS</name>
              <description>
              burst size in non-m2m mode
              When BS>1, DMA will transfer for BS times for each request if left NDT is larger than BS, or else transfer for left NDT times.
              When BS=0 or 1, DMA will always do single transfer for each request.
              In memory-to-memory mode, BS is ignored.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR6</name>
          <displayName>CCR6</displayName>
          <description></description>
          <addressOffset>0x6c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
            <field>
              <name>MEM2MEM</name>
              <description>
              memory-to-memory mode
              0: disabled
              1: enabled
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PL</name>
              <description>
              priority level
              00: low
              01: medium
              10: high
              11: very high
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>MSIZE</name>
              <description>
              memory size
              Defines the data size of each DMA transfer to the identified memory.
              In memory-to-memory mode, this field identifies the memory source if DIR = 1 and the memory destination if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.
              00: 8 bits
              01: 16 bits
              10: 32 bits
              11: reserved
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>PSIZE</name>
              <description>
              peripheral size
              Defines the data size of each DMA transfer to the identified peripheral.
              In memory-to-memory mode, this field identifies the memory destination if DIR = 1 and the memory source if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR = 1 and the peripheral source if DIR = 0.
              00: 8 bits
              01: 16 bits
              10: 32 bits
              11: reserved
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>MINC</name>
              <description>
              memory increment mode
              Defines the increment mode for each DMA transfer to the identified memory.
              In memory-to-memory mode, this field identifies the memory source if DIR = 1 and the memory destination if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.
              0: disabled
              1: enabled
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PINC</name>
              <description>
              peripheral increment mode
              Defines the increment mode for each DMA transfer to the identified peripheral.
              n memory-to-memory mode, this field identifies the memory destination if DIR = 1 and the 
              memory source if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR = 1 and 
              the peripheral source if DIR = 0.
              0: disabled
              1: enabled
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CIRC</name>
              <description>
              circular mode
              0: disabled
              1: enabled
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DIR</name>
              <description>
              data transfer direction
              This bit must be set only in memory-to-peripheral and peripheral-to-memory modes.
              0: read from peripheral
                 Source attributes are defined by PSIZE and PINC, plus the CPARx register. This is still valid in a memory-to-memory mode.
                 Destination attributes are defined by MSIZE and MINC, plus the CM0ARx register. This is still valid in a peripheral-to-peripheral mode.
              1: read from memory
                 Destination attributes are defined by PSIZE and PINC, plus the CPARx register. This is still valid in a memory-to-memory mode.
                 Source attributes are defined by MSIZE and MINC, plus the CM0ARx register. This is still valid in a peripheral-to-peripheral mode.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIE</name>
              <description>
              transfer error interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HTIE</name>
              <description>
              half transfer interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIE</name>
              <description>
              transfer complete interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EN</name>
              <description>
              channel enable
              When a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the ISR register is cleared (by setting the CTEIFx bit of the IFCR register).
              0: disabled
              1: enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CNDTR6</name>
          <displayName>CNDTR6</displayName>
          <description></description>
          <addressOffset>0x70</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>NDT</name>
              <description>
              number of data to transfer (0 to 2^16 - 1)
              This field is updated by hardware when the channel is enabled:
                 It is decremented after each single DMA 'read followed by write' transfer, indicating the remaining amount of data items to transfer.
                 It is kept at zero when the programmed amount of data to transfer is reached, if the channel is not in circular mode (CIRC = 0 in the CCRx register).
                 It is reloaded automatically by the previously programmed value, when the transfer is complete, if the channel is in circular mode (CIRC = 1).
              If this field is zero, no transfer can be served whatever the channel status (enabled or not).
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CPAR6</name>
          <displayName>CPAR6</displayName>
          <description></description>
          <addressOffset>0x74</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>PA</name>
              <description>
              peripheral address
              It contains the base address of the peripheral data register from/to which the data will be read/written.
              In memory-to-memory mode, this register identifies the memory destination address if DIR = 1 and the memory source address if DIR = 0.
              In peripheral-to-peripheral mode, this register identifies the peripheral destination address DIR = 1 and the peripheral source address if DIR = 0.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0AR6</name>
          <displayName>CM0AR6</displayName>
          <description></description>
          <addressOffset>0x78</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>MA</name>
              <description>
              peripheral address
              It contains the base address of the memory from/to which the data will be read/written.
              In memory-to-memory mode, this register identifies the memory source address if DIR = 1 and the memory destination address if DIR = 0.
              In peripheral-to-peripheral mode, this register identifies the peripheral source address DIR = 1 and the peripheral destination address if DIR = 0.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CBSR6</name>
          <displayName>CBSR6</displayName>
          <description></description>
          <addressOffset>0x7c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>BS</name>
              <description>
              burst size in non-m2m mode
              When BS>1, DMA will transfer for BS times for each request if left NDT is larger than BS, or else transfer for left NDT times.
              When BS=0 or 1, DMA will always do single transfer for each request.
              In memory-to-memory mode, BS is ignored.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR7</name>
          <displayName>CCR7</displayName>
          <description></description>
          <addressOffset>0x80</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
            <field>
              <name>MEM2MEM</name>
              <description>
              memory-to-memory mode
              0: disabled
              1: enabled
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PL</name>
              <description>
              priority level
              00: low
              01: medium
              10: high
              11: very high
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>MSIZE</name>
              <description>
              memory size
              Defines the data size of each DMA transfer to the identified memory.
              In memory-to-memory mode, this field identifies the memory source if DIR = 1 and the memory destination if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.
              00: 8 bits
              01: 16 bits
              10: 32 bits
              11: reserved
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>PSIZE</name>
              <description>
              peripheral size
              Defines the data size of each DMA transfer to the identified peripheral.
              In memory-to-memory mode, this field identifies the memory destination if DIR = 1 and the memory source if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR = 1 and the peripheral source if DIR = 0.
              00: 8 bits
              01: 16 bits
              10: 32 bits
              11: reserved
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>MINC</name>
              <description>
              memory increment mode
              Defines the increment mode for each DMA transfer to the identified memory.
              In memory-to-memory mode, this field identifies the memory source if DIR = 1 and the memory destination if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.
              0: disabled
              1: enabled
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PINC</name>
              <description>
              peripheral increment mode
              Defines the increment mode for each DMA transfer to the identified peripheral.
              n memory-to-memory mode, this field identifies the memory destination if DIR = 1 and the 
              memory source if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR = 1 and 
              the peripheral source if DIR = 0.
              0: disabled
              1: enabled
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CIRC</name>
              <description>
              circular mode
              0: disabled
              1: enabled
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DIR</name>
              <description>
              data transfer direction
              This bit must be set only in memory-to-peripheral and peripheral-to-memory modes.
              0: read from peripheral
                 Source attributes are defined by PSIZE and PINC, plus the CPARx register. This is still valid in a memory-to-memory mode.
                 Destination attributes are defined by MSIZE and MINC, plus the CM0ARx register. This is still valid in a peripheral-to-peripheral mode.
              1: read from memory
                 Destination attributes are defined by PSIZE and PINC, plus the CPARx register. This is still valid in a memory-to-memory mode.
                 Source attributes are defined by MSIZE and MINC, plus the CM0ARx register. This is still valid in a peripheral-to-peripheral mode.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIE</name>
              <description>
              transfer error interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HTIE</name>
              <description>
              half transfer interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIE</name>
              <description>
              transfer complete interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EN</name>
              <description>
              channel enable
              When a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the ISR register is cleared (by setting the CTEIFx bit of the IFCR register).
              0: disabled
              1: enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CNDTR7</name>
          <displayName>CNDTR7</displayName>
          <description></description>
          <addressOffset>0x84</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>NDT</name>
              <description>
              number of data to transfer (0 to 2^16 - 1)
              This field is updated by hardware when the channel is enabled:
                 It is decremented after each single DMA 'read followed by write' transfer, indicating the remaining amount of data items to transfer.
                 It is kept at zero when the programmed amount of data to transfer is reached, if the channel is not in circular mode (CIRC = 0 in the CCRx register).
                 It is reloaded automatically by the previously programmed value, when the transfer is complete, if the channel is in circular mode (CIRC = 1).
              If this field is zero, no transfer can be served whatever the channel status (enabled or not).
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CPAR7</name>
          <displayName>CPAR7</displayName>
          <description></description>
          <addressOffset>0x88</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>PA</name>
              <description>
              peripheral address
              It contains the base address of the peripheral data register from/to which the data will be read/written.
              In memory-to-memory mode, this register identifies the memory destination address if DIR = 1 and the memory source address if DIR = 0.
              In peripheral-to-peripheral mode, this register identifies the peripheral destination address DIR = 1 and the peripheral source address if DIR = 0.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0AR7</name>
          <displayName>CM0AR7</displayName>
          <description></description>
          <addressOffset>0x8c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>MA</name>
              <description>
              peripheral address
              It contains the base address of the memory from/to which the data will be read/written.
              In memory-to-memory mode, this register identifies the memory source address if DIR = 1 and the memory destination address if DIR = 0.
              In peripheral-to-peripheral mode, this register identifies the peripheral source address DIR = 1 and the peripheral destination address if DIR = 0.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CBSR7</name>
          <displayName>CBSR7</displayName>
          <description></description>
          <addressOffset>0x90</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>BS</name>
              <description>
              burst size in non memory-to-memory mode
              When BS>1, DMA will transfer for BS times for each request if left NDT is larger than BS, or else transfer for left NDT times.
              When BS=0 or 1, DMA will always do single transfer for each request.
              In memory-to-memory mode, BS is ignored.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR8</name>
          <displayName>CCR8</displayName>
          <description></description>
          <addressOffset>0x94</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
            <field>
              <name>MEM2MEM</name>
              <description>
              memory-to-memory mode
              0: disabled
              1: enabled
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PL</name>
              <description>
              priority level
              00: low
              01: medium
              10: high
              11: very high
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>MSIZE</name>
              <description>
              memory size
              Defines the data size of each DMA transfer to the identified memory.
              In memory-to-memory mode, this field identifies the memory source if DIR = 1 and the memory destination if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.
              00: 8 bits
              01: 16 bits
              10: 32 bits
              11: reserved
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>PSIZE</name>
              <description>
              peripheral size
              Defines the data size of each DMA transfer to the identified peripheral.
              In memory-to-memory mode, this field identifies the memory destination if DIR = 1 and the memory source if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR = 1 and the peripheral source if DIR = 0.
              00: 8 bits
              01: 16 bits
              10: 32 bits
              11: reserved
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>MINC</name>
              <description>
              memory increment mode
              Defines the increment mode for each DMA transfer to the identified memory.
              In memory-to-memory mode, this field identifies the memory source if DIR = 1 and the memory destination if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.
              0: disabled
              1: enabled
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PINC</name>
              <description>
              peripheral increment mode
              Defines the increment mode for each DMA transfer to the identified peripheral.
              n memory-to-memory mode, this field identifies the memory destination if DIR = 1 and the 
              memory source if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR = 1 and 
              the peripheral source if DIR = 0.
              0: disabled
              1: enabled
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CIRC</name>
              <description>
              circular mode
              0: disabled
              1: enabled
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DIR</name>
              <description>
              data transfer direction
              This bit must be set only in memory-to-peripheral and peripheral-to-memory modes.
              0: read from peripheral
                 Source attributes are defined by PSIZE and PINC, plus the CPARx register. This is still valid in a memory-to-memory mode.
                 Destination attributes are defined by MSIZE and MINC, plus the CM0ARx register. This is still valid in a peripheral-to-peripheral mode.
              1: read from memory
                 Destination attributes are defined by PSIZE and PINC, plus the CPARx register. This is still valid in a memory-to-memory mode.
                 Source attributes are defined by MSIZE and MINC, plus the CM0ARx register. This is still valid in a peripheral-to-peripheral mode.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIE</name>
              <description>
              transfer error interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HTIE</name>
              <description>
              half transfer interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIE</name>
              <description>
              transfer complete interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EN</name>
              <description>
              channel enable
              When a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the ISR register is cleared (by setting the CTEIFx bit of the IFCR register).
              0: disabled
              1: enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CNDTR8</name>
          <displayName>CNDTR8</displayName>
          <description></description>
          <addressOffset>0x98</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>NDT</name>
              <description>
              number of data to transfer (0 to 2^16 - 1)
              This field is updated by hardware when the channel is enabled:
                 It is decremented after each single DMA 'read followed by write' transfer, indicating the remaining amount of data items to transfer.
                 It is kept at zero when the programmed amount of data to transfer is reached, if the channel is not in circular mode (CIRC = 0 in the CCRx register).
                 It is reloaded automatically by the previously programmed value, when the transfer is complete, if the channel is in circular mode (CIRC = 1).
              If this field is zero, no transfer can be served whatever the channel status (enabled or not).
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CPAR8</name>
          <displayName>CPAR8</displayName>
          <description></description>
          <addressOffset>0x9c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>PA</name>
              <description>
              peripheral address
              It contains the base address of the peripheral data register from/to which the data will be read/written.
              In memory-to-memory mode, this register identifies the memory destination address if DIR = 1 and the memory source address if DIR = 0.
              In peripheral-to-peripheral mode, this register identifies the peripheral destination address DIR = 1 and the peripheral source address if DIR = 0.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0AR8</name>
          <displayName>CM0AR8</displayName>
          <description></description>
          <addressOffset>0xa0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>MA</name>
              <description>
              peripheral address
              It contains the base address of the memory from/to which the data will be read/written.
              In memory-to-memory mode, this register identifies the memory source address if DIR = 1 and the memory destination address if DIR = 0.
              In peripheral-to-peripheral mode, this register identifies the peripheral source address DIR = 1 and the peripheral destination address if DIR = 0.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CBSR8</name>
          <displayName>CBSR8</displayName>
          <description></description>
          <addressOffset>0xa4</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>BS</name>
              <description>
              burst size in non-m2m mode
              When BS>1, DMA will transfer for BS times for each request if left NDT is larger than BS, or else transfer for left NDT times.
              When BS=0 or 1, DMA will always do single transfer for each request.
              In memory-to-memory mode, BS is ignored.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CSELR1</name>
          <displayName>CSELR1</displayName>
          <description></description>
          <addressOffset>0xa8</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>C4S</name>
              <description>
              DMA channel 4 selection
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>C3S</name>
              <description>
              DMA channel 3 selection
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>C2S</name>
              <description>
              DMA channel 2 selection
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>C1S</name>
              <description>
              DMA channel 1 selection
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CSELR2</name>
          <displayName>CSELR2</displayName>
          <description></description>
          <addressOffset>0xac</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>C8S</name>
              <description>
              DMA channel 8 selection
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>C7S</name>
              <description>
              DMA channel 7 selection
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>C6S</name>
              <description>
              DMA channel 6 selection
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>C5S</name>
              <description>
              DMA channel 5 selection
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>HPSYS_PINMUX</name>
      <description></description>
      <groupName>HPSYS_PINMUX</groupName>
      <baseAddress>0x40003000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>PAD_SA00</name>
          <displayName>PAD_SA00</displayName>
          <description></description>
          <addressOffset>0x0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_SA01</name>
          <displayName>PAD_SA01</displayName>
          <description></description>
          <addressOffset>0x4</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_SA02</name>
          <displayName>PAD_SA02</displayName>
          <description></description>
          <addressOffset>0x8</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_SA03</name>
          <displayName>PAD_SA03</displayName>
          <description></description>
          <addressOffset>0xc</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_SA04</name>
          <displayName>PAD_SA04</displayName>
          <description></description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_SA05</name>
          <displayName>PAD_SA05</displayName>
          <description></description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_SA06</name>
          <displayName>PAD_SA06</displayName>
          <description></description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_SA07</name>
          <displayName>PAD_SA07</displayName>
          <description></description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_SA08</name>
          <displayName>PAD_SA08</displayName>
          <description></description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_SA09</name>
          <displayName>PAD_SA09</displayName>
          <description></description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_SA10</name>
          <displayName>PAD_SA10</displayName>
          <description></description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_SA11</name>
          <displayName>PAD_SA11</displayName>
          <description></description>
          <addressOffset>0x2c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_SA12</name>
          <displayName>PAD_SA12</displayName>
          <description></description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_SB00</name>
          <displayName>PAD_SB00</displayName>
          <description></description>
          <addressOffset>0x34</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_SB01</name>
          <displayName>PAD_SB01</displayName>
          <description></description>
          <addressOffset>0x38</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_SB02</name>
          <displayName>PAD_SB02</displayName>
          <description></description>
          <addressOffset>0x3c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_SB03</name>
          <displayName>PAD_SB03</displayName>
          <description></description>
          <addressOffset>0x40</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_SB04</name>
          <displayName>PAD_SB04</displayName>
          <description></description>
          <addressOffset>0x44</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_SB05</name>
          <displayName>PAD_SB05</displayName>
          <description></description>
          <addressOffset>0x48</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_SB06</name>
          <displayName>PAD_SB06</displayName>
          <description></description>
          <addressOffset>0x4c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_SB07</name>
          <displayName>PAD_SB07</displayName>
          <description></description>
          <addressOffset>0x50</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_SB08</name>
          <displayName>PAD_SB08</displayName>
          <description></description>
          <addressOffset>0x54</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_SB09</name>
          <displayName>PAD_SB09</displayName>
          <description></description>
          <addressOffset>0x58</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_SB10</name>
          <displayName>PAD_SB10</displayName>
          <description></description>
          <addressOffset>0x5c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_SB11</name>
          <displayName>PAD_SB11</displayName>
          <description></description>
          <addressOffset>0x60</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_SB12</name>
          <displayName>PAD_SB12</displayName>
          <description></description>
          <addressOffset>0x64</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA00</name>
          <displayName>PAD_PA00</displayName>
          <description></description>
          <addressOffset>0x68</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA01</name>
          <displayName>PAD_PA01</displayName>
          <description></description>
          <addressOffset>0x6c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA02</name>
          <displayName>PAD_PA02</displayName>
          <description></description>
          <addressOffset>0x70</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA03</name>
          <displayName>PAD_PA03</displayName>
          <description></description>
          <addressOffset>0x74</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA04</name>
          <displayName>PAD_PA04</displayName>
          <description></description>
          <addressOffset>0x78</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA05</name>
          <displayName>PAD_PA05</displayName>
          <description></description>
          <addressOffset>0x7c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA06</name>
          <displayName>PAD_PA06</displayName>
          <description></description>
          <addressOffset>0x80</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA07</name>
          <displayName>PAD_PA07</displayName>
          <description></description>
          <addressOffset>0x84</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA08</name>
          <displayName>PAD_PA08</displayName>
          <description></description>
          <addressOffset>0x88</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA09</name>
          <displayName>PAD_PA09</displayName>
          <description></description>
          <addressOffset>0x8c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA10</name>
          <displayName>PAD_PA10</displayName>
          <description></description>
          <addressOffset>0x90</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA11</name>
          <displayName>PAD_PA11</displayName>
          <description></description>
          <addressOffset>0x94</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA12</name>
          <displayName>PAD_PA12</displayName>
          <description></description>
          <addressOffset>0x98</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA13</name>
          <displayName>PAD_PA13</displayName>
          <description></description>
          <addressOffset>0x9c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA14</name>
          <displayName>PAD_PA14</displayName>
          <description></description>
          <addressOffset>0xa0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA15</name>
          <displayName>PAD_PA15</displayName>
          <description></description>
          <addressOffset>0xa4</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA16</name>
          <displayName>PAD_PA16</displayName>
          <description></description>
          <addressOffset>0xa8</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA17</name>
          <displayName>PAD_PA17</displayName>
          <description></description>
          <addressOffset>0xac</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS</name>
              <description>
              Drive Select. Logic LOW selects 4mA drive,logic HIGH selects 20mA drive
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MODE</name>
              <description>
              Mode Select. Logic LOW enables GPIO mode,logic HIGH enables I2C mode
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA18</name>
          <displayName>PAD_PA18</displayName>
          <description></description>
          <addressOffset>0xb0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS</name>
              <description>
              Drive Select. Logic LOW selects 4mA drive,logic HIGH selects 20mA drive
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MODE</name>
              <description>
              Mode Select. Logic LOW enables GPIO mode,logic HIGH enables I2C mode
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA19</name>
          <displayName>PAD_PA19</displayName>
          <description></description>
          <addressOffset>0xb4</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA20</name>
          <displayName>PAD_PA20</displayName>
          <description></description>
          <addressOffset>0xb8</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA21</name>
          <displayName>PAD_PA21</displayName>
          <description></description>
          <addressOffset>0xbc</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA22</name>
          <displayName>PAD_PA22</displayName>
          <description></description>
          <addressOffset>0xc0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA23</name>
          <displayName>PAD_PA23</displayName>
          <description></description>
          <addressOffset>0xc4</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA24</name>
          <displayName>PAD_PA24</displayName>
          <description></description>
          <addressOffset>0xc8</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA25</name>
          <displayName>PAD_PA25</displayName>
          <description></description>
          <addressOffset>0xcc</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA26</name>
          <displayName>PAD_PA26</displayName>
          <description></description>
          <addressOffset>0xd0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA27</name>
          <displayName>PAD_PA27</displayName>
          <description></description>
          <addressOffset>0xd4</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA28</name>
          <displayName>PAD_PA28</displayName>
          <description></description>
          <addressOffset>0xd8</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA29</name>
          <displayName>PAD_PA29</displayName>
          <description></description>
          <addressOffset>0xdc</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA30</name>
          <displayName>PAD_PA30</displayName>
          <description></description>
          <addressOffset>0xe0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA31</name>
          <displayName>PAD_PA31</displayName>
          <description></description>
          <addressOffset>0xe4</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA32</name>
          <displayName>PAD_PA32</displayName>
          <description></description>
          <addressOffset>0xe8</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA33</name>
          <displayName>PAD_PA33</displayName>
          <description></description>
          <addressOffset>0xec</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA34</name>
          <displayName>PAD_PA34</displayName>
          <description></description>
          <addressOffset>0xf0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA35</name>
          <displayName>PAD_PA35</displayName>
          <description></description>
          <addressOffset>0xf4</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA36</name>
          <displayName>PAD_PA36</displayName>
          <description></description>
          <addressOffset>0xf8</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA37</name>
          <displayName>PAD_PA37</displayName>
          <description></description>
          <addressOffset>0xfc</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA38</name>
          <displayName>PAD_PA38</displayName>
          <description></description>
          <addressOffset>0x100</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA39</name>
          <displayName>PAD_PA39</displayName>
          <description></description>
          <addressOffset>0x104</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA40</name>
          <displayName>PAD_PA40</displayName>
          <description></description>
          <addressOffset>0x108</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA41</name>
          <displayName>PAD_PA41</displayName>
          <description></description>
          <addressOffset>0x10c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA42</name>
          <displayName>PAD_PA42</displayName>
          <description></description>
          <addressOffset>0x110</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA43</name>
          <displayName>PAD_PA43</displayName>
          <description></description>
          <addressOffset>0x114</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA44</name>
          <displayName>PAD_PA44</displayName>
          <description></description>
          <addressOffset>0x118</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA45</name>
          <displayName>PAD_PA45</displayName>
          <description></description>
          <addressOffset>0x11c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA46</name>
          <displayName>PAD_PA46</displayName>
          <description></description>
          <addressOffset>0x120</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA47</name>
          <displayName>PAD_PA47</displayName>
          <description></description>
          <addressOffset>0x124</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA48</name>
          <displayName>PAD_PA48</displayName>
          <description></description>
          <addressOffset>0x128</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS</name>
              <description>
              Drive Select. Logic LOW selects 4mA drive,logic HIGH selects 20mA drive
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MODE</name>
              <description>
              Mode Select. Logic LOW enables GPIO mode,logic HIGH enables I2C mode
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA49</name>
          <displayName>PAD_PA49</displayName>
          <description></description>
          <addressOffset>0x12c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS</name>
              <description>
              Drive Select. Logic LOW selects 4mA drive,logic HIGH selects 20mA drive
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MODE</name>
              <description>
              Mode Select. Logic LOW enables GPIO mode,logic HIGH enables I2C mode
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA50</name>
          <displayName>PAD_PA50</displayName>
          <description></description>
          <addressOffset>0x130</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA51</name>
          <displayName>PAD_PA51</displayName>
          <description></description>
          <addressOffset>0x134</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA52</name>
          <displayName>PAD_PA52</displayName>
          <description></description>
          <addressOffset>0x138</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA53</name>
          <displayName>PAD_PA53</displayName>
          <description></description>
          <addressOffset>0x13c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA54</name>
          <displayName>PAD_PA54</displayName>
          <description></description>
          <addressOffset>0x140</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA55</name>
          <displayName>PAD_PA55</displayName>
          <description></description>
          <addressOffset>0x144</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA56</name>
          <displayName>PAD_PA56</displayName>
          <description></description>
          <addressOffset>0x148</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA57</name>
          <displayName>PAD_PA57</displayName>
          <description></description>
          <addressOffset>0x14c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA58</name>
          <displayName>PAD_PA58</displayName>
          <description></description>
          <addressOffset>0x150</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA59</name>
          <displayName>PAD_PA59</displayName>
          <description></description>
          <addressOffset>0x154</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA60</name>
          <displayName>PAD_PA60</displayName>
          <description></description>
          <addressOffset>0x158</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA61</name>
          <displayName>PAD_PA61</displayName>
          <description></description>
          <addressOffset>0x15c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA62</name>
          <displayName>PAD_PA62</displayName>
          <description></description>
          <addressOffset>0x160</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA63</name>
          <displayName>PAD_PA63</displayName>
          <description></description>
          <addressOffset>0x164</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA64</name>
          <displayName>PAD_PA64</displayName>
          <description></description>
          <addressOffset>0x168</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA65</name>
          <displayName>PAD_PA65</displayName>
          <description></description>
          <addressOffset>0x16c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA66</name>
          <displayName>PAD_PA66</displayName>
          <description></description>
          <addressOffset>0x170</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA67</name>
          <displayName>PAD_PA67</displayName>
          <description></description>
          <addressOffset>0x174</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA68</name>
          <displayName>PAD_PA68</displayName>
          <description></description>
          <addressOffset>0x178</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA69</name>
          <displayName>PAD_PA69</displayName>
          <description></description>
          <addressOffset>0x17c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA70</name>
          <displayName>PAD_PA70</displayName>
          <description></description>
          <addressOffset>0x180</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA71</name>
          <displayName>PAD_PA71</displayName>
          <description></description>
          <addressOffset>0x184</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA72</name>
          <displayName>PAD_PA72</displayName>
          <description></description>
          <addressOffset>0x188</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA73</name>
          <displayName>PAD_PA73</displayName>
          <description></description>
          <addressOffset>0x18c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA74</name>
          <displayName>PAD_PA74</displayName>
          <description></description>
          <addressOffset>0x190</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA75</name>
          <displayName>PAD_PA75</displayName>
          <description></description>
          <addressOffset>0x194</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA76</name>
          <displayName>PAD_PA76</displayName>
          <description></description>
          <addressOffset>0x198</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA77</name>
          <displayName>PAD_PA77</displayName>
          <description></description>
          <addressOffset>0x19c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PA78</name>
          <displayName>PAD_PA78</displayName>
          <description></description>
          <addressOffset>0x1a0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>USART1</name>
      <description></description>
      <groupName>USART</groupName>
      <baseAddress>0x40004000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CR1</name>
          <displayName>CR1</displayName>
          <description>Control Register 1</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>M</name>
              <description>
              Mode bit indicates the length of the packet, including data bits and parity. Stop bits not included.
              0: 6 bits (e.g. 6 data bits + no parity bit)
              1: 7 bits (e.g. 6 data bits + 1 parity bit)
              2: 8 bits (e.g. 7 data bits + 1 parity bit, or 6 data bits + 2 parity bits)
              3: 9 bits (e.g. 8 data bits + 1 parity bit, or 7 data bits + 2 parity bits)
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>RSVD5</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>OVER8</name>
              <description>
              Oversampling mode
              0: Oversampling by 16
              1: Oversampling by 8
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD6</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD7</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD8</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PCE</name>
              <description>
              Parity check enable. If enabled, parity bit is inserted at the MSB position 
              0: parity check disabled
              1: parity check enabled
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Parity select
              0: even parity
              1: odd parity
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PEIE</name>
              <description>
              Parity error interrupt enable
              0: interrupt disabled
              1: interrupt is generated whenever PE=1 in the ISR register
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TXEIE</name>
              <description>
              Tx empty interrupt enable
              0: interrupt disabled
              1: interrupt is generated whenver TXE=1 in the ISR register
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIE</name>
              <description>
              Transfer compelete interrupt enable
              0: interrupt disabled
              1: interrupt is generated whenever TC=1 in the ISR register
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RXNEIE</name>
              <description>
              Rx not empty interrupt enable
              0: interrupt disabled
              1: interrupt is generated whenever RXNE=1 in the ISR register
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IDLEIE</name>
              <description>
              Idle line interrupt enable
              0: interrupt disabled
              1: interrupt is generated whenever IDLE=1 in the ISR  register
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TE</name>
              <description>
              Transmitter enable
              0: transmitter is disabled
              1: transmitter is enabled
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RE</name>
              <description>
              Receiver enable
              0: receiver is disabled
              1: receiver is enabled
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD9</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UE</name>
              <description>
              USART enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CR2</name>
          <displayName>CR2</displayName>
          <description>Control Register 2</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD5</name>
              <description>
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD6</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD7</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD8</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD9</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD10</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>STOP</name>
              <description>
              Stop bits
              0/1: 1 stop bit
              2/3: 2 stop bits
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD11</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD12</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD13</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD14</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD15</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD16</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD17</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD18</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD19</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CR3</name>
          <displayName>CR3</displayName>
          <description>Control Register 3</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD5</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD6</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD7</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD8</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD9</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD10</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OVRDIS</name>
              <description>
              Overrun disable
              0: overrun error flag (ORE) will be set if new data received but previous data not read. New data will not overwrite the content in RDR register.
              1: overrun disabled. If new data is received before previous data is read, the new data will overwrite the content in RDR register and ORE flag remains unset.
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ONEBIT</name>
              <description>
              One bit sampling mode
              0: 3-bit sampling mode, the sampling value is determined by the voted result out of 3 bits
              1: 1-bit sampling mode
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTSIE</name>
              <description>
              CTS interrupt enable
              0: interrupt disabled
              1: interrupt is generated whenever CTSIF=1 in the ISR register
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTSE</name>
              <description>
              CTS enable
              0: CTS hardware flow control disabled
              1: CTS hardware flow control enabled, data is transmitted only when CTS input is asserted low
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RTSE</name>
              <description>
              RTS enable
              0: RTS hardware flow control disabled
              1: RTS hardware flow control enabled, RTS output is asserted low when new data can be received
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMAT</name>
              <description>
              Transmitter DMA enable
              0: DMA mode disabled for transmission
              1: DMA mode enabled for transmission
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMAR</name>
              <description>
              Receiver DMA enable
              0: DMA mode disabled for reception
              1: DMA mode enabled for reception
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD11</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD12</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD13</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD14</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD15</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EIE</name>
              <description>
              Error interrupt enable
              0: interrupt disabled
              1: interrupt is generated whenever FE=1 or ORE=1 or NF=1 in the ISR register
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BRR</name>
          <displayName>BRR</displayName>
          <description>Baud Rate Register</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>INT</name>
              <description>
              Integer part of baud rate prescaler
              If OVER8 = 0, Baud Rate = 48000000 / (INT + FRAC/16) / 16
              If OVER8 = 1, Baud Rate = 48000000 / (INT + FRAC/16) / 8
              For example:
              OVER=0, INT=3, FRAC=0, Baud Rate = 48000000/(3+0)/16 = 1Mbps
              OVER=0, INT=3, FRAC=4, Baud Rate = 48000000/(3+4/16)/16 = 923077 = 921600 + 1.6
              OVER=1, INT=52, FRAC=1, Baud Rate = 48000000/(52+1/16)/8 = 115246 = 115200 + 0.4
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
            <field>
              <name>FRAC</name>
              <description>
              Fractional part of baud rate prescaler
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD1</name>
          <displayName>RSVD1</displayName>
          <description></description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>RQR</name>
          <displayName>RQR</displayName>
          <description>Request Register</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>27</bitWidth>
            </field>
            <field>
              <name>TXFRQ</name>
              <description>
              Tx data flush requestReserved-Do not modify
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RXFRQ</name>
              <description>
              Rx data flush request. Write 1 to clear the RXNE flag and discard the current data in RDR
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ISR</name>
          <displayName>ISR</displayName>
          <description>Interrupt and Status Register</description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x020000C0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD5</name>
              <description>
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD6</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD7</name>
              <description>
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD8</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD9</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD10</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD11</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD12</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD13</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD14</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD15</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTS</name>
              <description>
              CTS input. Read this bit to get the raw status of the CTS line.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTSIF</name>
              <description>
              CTS interrupt flag. This bit is set by hardware whenever CTS input toggles.
              0: no change on the CTS line
              1: there is a change on the CTS line
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD16</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TXE</name>
              <description>
              Tx data empty
              0: data is ready in TDR
              1: data is already transferred to shift register, i.e. transmission is in progress or complete
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TC</name>
              <description>
              transmission complete. This bit is set by hardware if the transmission is complete
              0: transmission is not complete
              1: transmission is complete
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RXNE</name>
              <description>
              Rx data not empty. This bit is set by hardware when the received data is transferred into RDR register.
              0: data is not received
              1: data is ready in RDR to be read
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IDLE</name>
              <description>
              Idle line detected
              0: no idle line is detected
              1: idle line is detected
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ORE</name>
              <description>
              Overrun error. When new data is received but Rx buffer is not empty (i.e. previous data is not read yet), ORE is asserted and current RDR content is not lost. This feature can be disabled by set CR3_OVRDIS to 1.
              0: no overrun error
              1: overrun error is detected
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>NF</name>
              <description>
              Noise flag. Noise means the samping values in the 3-bit sampling mode are not the same.
              0: no noise is detected
              1: noise is detected
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FE</name>
              <description>
              Framing error. This bit is set by hardware when stop bit is not correctly received
              0: no framing error is detected
              1: framing error is detected
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Parity error. This bit is set when a parity error is detected in the received packet.
              0: no parity error
              1: parity error detected
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ICR</name>
          <displayName>ICR</displayName>
          <description>Interrupt flag Clear Register</description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD5</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>RSVD6</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD7</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD8</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTSCF</name>
              <description>
              CTS clear flag. Writing 1 to this bit clears the CTSIF flag in the ISR register.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD9</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD10</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCCF</name>
              <description>
              Transmission complete clear flag. Writing 1 to this bit clears the TC flag in the ISR register.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD11</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IDLECF</name>
              <description>
              Idle line detected clear flag. Writing 1 to this bit clears the IDLECF flag in the ISR register.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ORECF</name>
              <description>
              Overrun error clear flag. Writing 1 to this bit clears the ORE flag in the ISR register.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>NCF</name>
              <description>
              Noise detected clear flag. Writing 1 to this bit clears the NF flag in the ISR register.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FECF</name>
              <description>
              Framing error clear flag. Writing 1 to this bit clears the FE flag in the ISR register.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PECF</name>
              <description>
              Parity error clear flag. Wriring 1 to this bit clears the PE flag in the ISR register.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RDR</name>
          <displayName>RDR</displayName>
          <description>Receive Data Register</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>RDR</name>
              <description>
              Received data
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TDR</name>
          <displayName>TDR</displayName>
          <description>Transmit Data Register</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>TDR</name>
              <description>
              Transmit data
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>MISCR</name>
          <displayName>MISCR</displayName>
          <description>Miscellaneous Register</description>
          <addressOffset>0x2c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>AUTOCAL</name>
              <description>
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>RTSBIT</name>
              <description>
              assert RTS ahead of the frame completion (in number of bits)Reserved-Do not modify
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>SMPLINI</name>
              <description>
              initial sample count, count down from this value to zero to reach the middle of the start bit in RxReserved-Do not modify
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DRDR</name>
          <displayName>DRDR</displayName>
          <description>Debug Receive Data Register</description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              DbgUART is still a preliminary version in this project. 
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DTDR</name>
          <displayName>DTDR</displayName>
          <description>Debug Receive Data Register</description>
          <addressOffset>0x34</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>EXR</name>
          <displayName>EXR</displayName>
          <description>Mutual Exclusive Register</description>
          <addressOffset>0x38</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>27</bitWidth>
            </field>
            <field>
              <name>ID</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>BUSY</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>USART2</name>
      <description></description>
      <groupName>USART</groupName>
      <baseAddress>0x40005000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CR1</name>
          <displayName>CR1</displayName>
          <description>Control Register 1</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>M</name>
              <description>
              Mode bit indicates the length of the packet, including data bits and parity. Stop bits not included.
              0: 6 bits (e.g. 6 data bits + no parity bit)
              1: 7 bits (e.g. 6 data bits + 1 parity bit)
              2: 8 bits (e.g. 7 data bits + 1 parity bit, or 6 data bits + 2 parity bits)
              3: 9 bits (e.g. 8 data bits + 1 parity bit, or 7 data bits + 2 parity bits)
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>RSVD5</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>OVER8</name>
              <description>
              Oversampling mode
              0: Oversampling by 16
              1: Oversampling by 8
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD6</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD7</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD8</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PCE</name>
              <description>
              Parity check enable. If enabled, parity bit is inserted at the MSB position 
              0: parity check disabled
              1: parity check enabled
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Parity select
              0: even parity
              1: odd parity
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PEIE</name>
              <description>
              Parity error interrupt enable
              0: interrupt disabled
              1: interrupt is generated whenever PE=1 in the ISR register
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TXEIE</name>
              <description>
              Tx empty interrupt enable
              0: interrupt disabled
              1: interrupt is generated whenver TXE=1 in the ISR register
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIE</name>
              <description>
              Transfer compelete interrupt enable
              0: interrupt disabled
              1: interrupt is generated whenever TC=1 in the ISR register
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RXNEIE</name>
              <description>
              Rx not empty interrupt enable
              0: interrupt disabled
              1: interrupt is generated whenever RXNE=1 in the ISR register
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IDLEIE</name>
              <description>
              Idle line interrupt enable
              0: interrupt disabled
              1: interrupt is generated whenever IDLE=1 in the ISR  register
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TE</name>
              <description>
              Transmitter enable
              0: transmitter is disabled
              1: transmitter is enabled
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RE</name>
              <description>
              Receiver enable
              0: receiver is disabled
              1: receiver is enabled
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD9</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UE</name>
              <description>
              USART enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CR2</name>
          <displayName>CR2</displayName>
          <description>Control Register 2</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD5</name>
              <description>
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD6</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD7</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD8</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD9</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD10</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>STOP</name>
              <description>
              Stop bits
              0/1: 1 stop bit
              2/3: 2 stop bits
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD11</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD12</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD13</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD14</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD15</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD16</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD17</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD18</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD19</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CR3</name>
          <displayName>CR3</displayName>
          <description>Control Register 3</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD5</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD6</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD7</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD8</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD9</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD10</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OVRDIS</name>
              <description>
              Overrun disable
              0: overrun error flag (ORE) will be set if new data received but previous data not read. New data will not overwrite the content in RDR register.
              1: overrun disabled. If new data is received before previous data is read, the new data will overwrite the content in RDR register and ORE flag remains unset.
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ONEBIT</name>
              <description>
              One bit sampling mode
              0: 3-bit sampling mode, the sampling value is determined by the voted result out of 3 bits
              1: 1-bit sampling mode
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTSIE</name>
              <description>
              CTS interrupt enable
              0: interrupt disabled
              1: interrupt is generated whenever CTSIF=1 in the ISR register
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTSE</name>
              <description>
              CTS enable
              0: CTS hardware flow control disabled
              1: CTS hardware flow control enabled, data is transmitted only when CTS input is asserted low
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RTSE</name>
              <description>
              RTS enable
              0: RTS hardware flow control disabled
              1: RTS hardware flow control enabled, RTS output is asserted low when new data can be received
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMAT</name>
              <description>
              Transmitter DMA enable
              0: DMA mode disabled for transmission
              1: DMA mode enabled for transmission
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMAR</name>
              <description>
              Receiver DMA enable
              0: DMA mode disabled for reception
              1: DMA mode enabled for reception
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD11</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD12</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD13</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD14</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD15</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EIE</name>
              <description>
              Error interrupt enable
              0: interrupt disabled
              1: interrupt is generated whenever FE=1 or ORE=1 or NF=1 in the ISR register
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BRR</name>
          <displayName>BRR</displayName>
          <description>Baud Rate Register</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>INT</name>
              <description>
              Integer part of baud rate prescaler
              If OVER8 = 0, Baud Rate = 48000000 / (INT + FRAC/16) / 16
              If OVER8 = 1, Baud Rate = 48000000 / (INT + FRAC/16) / 8
              For example:
              OVER=0, INT=3, FRAC=0, Baud Rate = 48000000/(3+0)/16 = 1Mbps
              OVER=0, INT=3, FRAC=4, Baud Rate = 48000000/(3+4/16)/16 = 923077 = 921600 + 1.6
              OVER=1, INT=52, FRAC=1, Baud Rate = 48000000/(52+1/16)/8 = 115246 = 115200 + 0.4
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
            <field>
              <name>FRAC</name>
              <description>
              Fractional part of baud rate prescaler
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD1</name>
          <displayName>RSVD1</displayName>
          <description></description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>RQR</name>
          <displayName>RQR</displayName>
          <description>Request Register</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>27</bitWidth>
            </field>
            <field>
              <name>TXFRQ</name>
              <description>
              Tx data flush requestReserved-Do not modify
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RXFRQ</name>
              <description>
              Rx data flush request. Write 1 to clear the RXNE flag and discard the current data in RDR
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ISR</name>
          <displayName>ISR</displayName>
          <description>Interrupt and Status Register</description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x020000C0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD5</name>
              <description>
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD6</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD7</name>
              <description>
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD8</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD9</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD10</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD11</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD12</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD13</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD14</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD15</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTS</name>
              <description>
              CTS input. Read this bit to get the raw status of the CTS line.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTSIF</name>
              <description>
              CTS interrupt flag. This bit is set by hardware whenever CTS input toggles.
              0: no change on the CTS line
              1: there is a change on the CTS line
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD16</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TXE</name>
              <description>
              Tx data empty
              0: data is ready in TDR
              1: data is already transferred to shift register, i.e. transmission is in progress or complete
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TC</name>
              <description>
              transmission complete. This bit is set by hardware if the transmission is complete
              0: transmission is not complete
              1: transmission is complete
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RXNE</name>
              <description>
              Rx data not empty. This bit is set by hardware when the received data is transferred into RDR register.
              0: data is not received
              1: data is ready in RDR to be read
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IDLE</name>
              <description>
              Idle line detected
              0: no idle line is detected
              1: idle line is detected
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ORE</name>
              <description>
              Overrun error. When new data is received but Rx buffer is not empty (i.e. previous data is not read yet), ORE is asserted and current RDR content is not lost. This feature can be disabled by set CR3_OVRDIS to 1.
              0: no overrun error
              1: overrun error is detected
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>NF</name>
              <description>
              Noise flag. Noise means the samping values in the 3-bit sampling mode are not the same.
              0: no noise is detected
              1: noise is detected
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FE</name>
              <description>
              Framing error. This bit is set by hardware when stop bit is not correctly received
              0: no framing error is detected
              1: framing error is detected
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Parity error. This bit is set when a parity error is detected in the received packet.
              0: no parity error
              1: parity error detected
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ICR</name>
          <displayName>ICR</displayName>
          <description>Interrupt flag Clear Register</description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD5</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>RSVD6</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD7</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD8</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTSCF</name>
              <description>
              CTS clear flag. Writing 1 to this bit clears the CTSIF flag in the ISR register.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD9</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD10</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCCF</name>
              <description>
              Transmission complete clear flag. Writing 1 to this bit clears the TC flag in the ISR register.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD11</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IDLECF</name>
              <description>
              Idle line detected clear flag. Writing 1 to this bit clears the IDLECF flag in the ISR register.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ORECF</name>
              <description>
              Overrun error clear flag. Writing 1 to this bit clears the ORE flag in the ISR register.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>NCF</name>
              <description>
              Noise detected clear flag. Writing 1 to this bit clears the NF flag in the ISR register.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FECF</name>
              <description>
              Framing error clear flag. Writing 1 to this bit clears the FE flag in the ISR register.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PECF</name>
              <description>
              Parity error clear flag. Wriring 1 to this bit clears the PE flag in the ISR register.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RDR</name>
          <displayName>RDR</displayName>
          <description>Receive Data Register</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>RDR</name>
              <description>
              Received data
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TDR</name>
          <displayName>TDR</displayName>
          <description>Transmit Data Register</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>TDR</name>
              <description>
              Transmit data
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>MISCR</name>
          <displayName>MISCR</displayName>
          <description>Miscellaneous Register</description>
          <addressOffset>0x2c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>AUTOCAL</name>
              <description>
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>RTSBIT</name>
              <description>
              assert RTS ahead of the frame completion (in number of bits)Reserved-Do not modify
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>SMPLINI</name>
              <description>
              initial sample count, count down from this value to zero to reach the middle of the start bit in RxReserved-Do not modify
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DRDR</name>
          <displayName>DRDR</displayName>
          <description>Debug Receive Data Register</description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              DbgUART is still a preliminary version in this project. 
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DTDR</name>
          <displayName>DTDR</displayName>
          <description>Debug Receive Data Register</description>
          <addressOffset>0x34</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>EXR</name>
          <displayName>EXR</displayName>
          <description>Mutual Exclusive Register</description>
          <addressOffset>0x38</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>27</bitWidth>
            </field>
            <field>
              <name>ID</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>BUSY</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>EZIP1</name>
      <description></description>
      <groupName>EZIP</groupName>
      <baseAddress>0x40006000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>EZIP_CTRL</name>
          <displayName>EZIP_CTRL</displayName>
          <description>ezip/aezip_frame decoder ctrl</description>
          <addressOffset>0x000</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>31</bitWidth>
            </field>
            <field>
              <name>EZIP_CTRL</name>
              <description>
              1:start or run
              0:stop or end
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SRC_ADDR</name>
          <displayName>SRC_ADDR</displayName>
          <description>ezip decoder source address</description>
          <addressOffset>0x004</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>SRC_ADDR</name>
              <description>
              ezip decoder source address
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DST_ADDR</name>
          <displayName>DST_ADDR</displayName>
          <description>ezip decoder destination address</description>
          <addressOffset>0x008</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DST_ADDR</name>
              <description>
              ezip decoder destination address(ahb_out mode)
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>EZIP_PARA</name>
          <displayName>EZIP_PARA</displayName>
          <description>ezip decoder  parameter</description>
          <addressOffset>0x00c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>26</bitWidth>
            </field>
            <field>
              <name>SPI_SEL</name>
              <description>
              0:QSPI4
              1:QSPI3
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IN_SEL</name>
              <description>
              don't support ezip type2\type4. 
              0:ahb
              1:fifo
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CACHE_EN</name>
              <description>
              no used
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MOD_SEL</name>
              <description>
              0:ezip or aezip
              1:gzip
              2:Lz4
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>OUT_SEL</name>
              <description>
              only used in ezip decoder mode. must select ahb in gzip/lz4 decoder mode.
              0:epic
              1:ahb
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CACHE_CLR</name>
          <displayName>CACHE_CLR</displayName>
          <description>ezip index cache clear</description>
          <addressOffset>0x010</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>31</bitWidth>
            </field>
            <field>
              <name>CACHE_CLR</name>
              <description>
              no used
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>START_POINT</name>
          <displayName>START_POINT</displayName>
          <description>ezip decoder start point</description>
          <addressOffset>0x014</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>START_COL</name>
              <description>
              ezip start col,count from 0
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>START_ROW</name>
              <description>
              ezip start row,count from 0
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>END_POINT</name>
          <displayName>END_POINT</displayName>
          <description>ezip decoder end point</description>
          <addressOffset>0x018</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>END_COL</name>
              <description>
              ezip end col
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>END_ROW</name>
              <description>
              ezip end row
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ROW_SIGN</name>
          <displayName>ROW_SIGN</displayName>
          <description>ezip decoder row sign</description>
          <addressOffset>0x01c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>ROW_SIGN</name>
              <description>
              arrived row sign,ezip can generate a interrupt
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>INT_EN</name>
          <displayName>INT_EN</displayName>
          <description>ezip decoder _int_en</description>
          <addressOffset>0x020</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>26</bitWidth>
            </field>
            <field>
              <name>AEZIP_INT_EN</name>
              <description>
              aezip_frame_int_en
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ETYPE_ERR_EN</name>
              <description>
              ezip_type_err_en
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BTYPE_ERR_EN</name>
              <description>
              btype_err_en
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ROW_ERR_EN</name>
              <description>
              row_err_en
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ROW_INT_EN</name>
              <description>
              row_int_en
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>END_INT_EN</name>
              <description>
              ezip_end _int_en
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>INT_STA</name>
          <displayName>INT_STA</displayName>
          <description>ezip decoder _int_sta</description>
          <addressOffset>0x024</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>26</bitWidth>
            </field>
            <field>
              <name>AEZIP_INT_STA</name>
              <description>
              aezip_end_int_sta
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ETYPE_ERR_STA</name>
              <description>
              ezip_type_err_sta
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BTYPE_ERR_STA</name>
              <description>
              btype_err_sta
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ROW_ERR_STA</name>
              <description>
              overflow height sta
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ROW_INT_STA</name>
              <description>
              arrive row sign sta
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>END_INT_STA</name>
              <description>
              ezip_end _int_sta/aezip_frame_int_sta
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>INT_MASK</name>
          <displayName>INT_MASK</displayName>
          <description>ezip decoder int mask state</description>
          <addressOffset>0x028</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>26</bitWidth>
            </field>
            <field>
              <name>AEZIP_INT_MASK</name>
              <description>
              aezip_end_int_mask sta
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ETYPE_ERR_MASK</name>
              <description>
              ezip_type_err_mask sta
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BTYPE_ERR_MASK</name>
              <description>
              btype_err_mask sta
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ROW_ERR_MASK</name>
              <description>
              overflow height mask sta
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ROW_INT_MASK</name>
              <description>
              arrive row sign mask sta
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>END_INT_MASK</name>
              <description>
              ezip_end _int mask sta/aezip_frame_int_mask_Sta
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>NAP_PARA</name>
          <displayName>NAP_PARA</displayName>
          <description>ezip decoder release bus parameter</description>
          <addressOffset>0x02c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>BURST_NUM</name>
              <description>
              ezip decoder burst number
              0000: 16
              0001: 32 
              0010: 64 
              0100: 128 
              1000: 256 
              other: 16
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>NAP_TIM</name>
              <description>
              ezip decoder release bus time
              0000: not nap
              0001: 16 cycle
              0010: 32 cycle
              0100: 64 cycle
              1000: 128 cycle
              other: not nap
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SRC_LEN</name>
          <displayName>SRC_LEN</displayName>
          <description>ezip source data length</description>
          <addressOffset>0x030</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>SRC_LEN</name>
              <description>
              source data byte length only in source data fifo mode
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>AEZIP_CTRL</name>
          <displayName>AEZIP_CTRL</displayName>
          <description>AEZIP ctrl</description>
          <addressOffset>0x034</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>31</bitWidth>
            </field>
            <field>
              <name>AEZIP_CTRL</name>
              <description>
              AEZIP ctrl
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>FRAME_START</name>
          <displayName>FRAME_START</displayName>
          <description>Aezip start number of frames</description>
          <addressOffset>0x038</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>FRAME_START</name>
              <description>
              start number of frames,count from 1
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PLAY_START</name>
          <displayName>PLAY_START</displayName>
          <description>Aezip start number of play</description>
          <addressOffset>0x03c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>PLAY_START</name>
              <description>
              start number of times to loop this AEZIP,,count from 1
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>FRAME_NUM</name>
          <displayName>FRAME_NUM</displayName>
          <description>Aezip number of frames</description>
          <addressOffset>0x040</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>FRAME_NUM</name>
              <description>
              number of frames
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PLAY_NUM</name>
          <displayName>PLAY_NUM</displayName>
          <description>Aezip number of times to loop this AEZIP</description>
          <addressOffset>0x044</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>PLAY_NUM</name>
              <description>
              number of times to loop this AEZIP,0 indicates infinite looping
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SEQ_NUM</name>
          <displayName>SEQ_NUM</displayName>
          <description>Aezip sequence  number</description>
          <addressOffset>0x048</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>SEQ_NUM</name>
              <description>
              sequence  number of the animation chunk,starting from 0
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>FRAME_AREA</name>
          <displayName>FRAME_AREA</displayName>
          <description>Aezip frame area</description>
          <addressOffset>0x04c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>FRAME_WIDTH</name>
              <description>
              AEZIP frame width
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>FRAME_HEIGHT</name>
              <description>
              AEZIP frame height
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>FRAME_OFFSET</name>
          <displayName>FRAME_OFFSET</displayName>
          <description>Aezip frame area</description>
          <addressOffset>0x050</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>OFFSET_COL</name>
              <description>
              AEZIP frame  offset col
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>OFFEST_ROW</name>
              <description>
              AEZIP frame offset row
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>FRAME_DELAY</name>
          <displayName>FRAME_DELAY</displayName>
          <description>Aezip frame delay</description>
          <addressOffset>0x054</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DELAY_NUM</name>
              <description>
              AEZIP frame  delay fraction numerator
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>DELAY_DEN</name>
              <description>
              AEZIP frame delay fraction denominator
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>FRAME_TYPE</name>
          <displayName>FRAME_TYPE</displayName>
          <description>   </description>
          <addressOffset>0x058</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>DISPOSE_OP</name>
              <description>
              AEZIP type of frame area disposal to be done after rendering this frame
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>BLEND_OP</name>
              <description>
              AEZIP type of frame area renndering for this frame
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>FRAME_SIZE</name>
          <displayName>FRAME_SIZE</displayName>
          <description>Aezip frame size</description>
          <addressOffset>0x05c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>FRAME_SIZE</name>
              <description>
              frame size
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>GREY_PARA</name>
          <displayName>GREY_PARA</displayName>
          <description>   </description>
          <addressOffset>0x060</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>GREY_PARA</name>
              <description>
              fill color parameter, when send grey data to epic . [23:16]-R,[15:8]-G,[7:0]-B
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DB_SEL</name>
          <displayName>DB_SEL</displayName>
          <description>ezip decoder debug sel</description>
          <addressOffset>0x064</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>DB_SEL</name>
              <description>
              bit[15] 0:line_first                 1:out_buf_en[1]
              bit[14] 0:rd_head3                1:out_buf_en[0]
              bit[13] 0:rd_head2                1:inbuf_empty
              bit[12] 0:rd_heas1                 1:inbuf_half_empty
              bit[11] 0:blk_restart              1: inbuf_full
              bit[10] 0:ezip_buf_end        1:ezip_pixel_end
              bit[9]   0:ezip_buf_full           1:0
              bit[8]   0:ezip_buf_empty      1:0
              bit[7]   0:dec_buf_empty         1:0
              bit[6]   0:dec_buf_full               1:para_ok
              bit[5]   0:dec_on         1:ezip_fuf_push
              bit[4]   0:ind3_on       1:copy_on
              bit[3]   0:ind2_on       1:bypass_on
              bit[2]   0:ind1_on       1:blk_clr
              bit[1]   0:ezip_on       1:para_val
              bit[0]   0:ezip_int      1:para_req
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DB_DATA0</name>
          <displayName>DB_DATA0</displayName>
          <description>ezip decoder debug data0</description>
          <addressOffset>0x068</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DB_DATA0</name>
              <description>
              bit[31:24]  bit_depth
              bit[23:16] color_type
              bit[15:0] block number
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DB_DATA1</name>
          <displayName>DB_DATA1</displayName>
          <description>ezip decoder debug data1</description>
          <addressOffset>0x06c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DB_DATA1</name>
              <description>
              bit[31:16] width
              bit[15:0] height
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DB_DATA2</name>
          <displayName>DB_DATA2</displayName>
          <description>ezip decoder debug data2</description>
          <addressOffset>0x070</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DB_DATA2</name>
              <description>
              bit[31:0] total_len
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DB_DATA3</name>
          <displayName>DB_DATA3</displayName>
          <description>ezip decoder debug data3</description>
          <addressOffset>0x074</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DB_DATA3</name>
              <description>
              bit[31:24] ezip_type
              bit[23:20] bfinal
              bit[19:16] btype
              bit[11:8] ahb_state
              bit[7:4] ctrl_state
              bir[3:0] build_stste
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DB_DATA4</name>
          <displayName>DB_DATA4</displayName>
          <description>ezip decoder debug data4</description>
          <addressOffset>0x078</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DB_DATA4</name>
              <description>
              bit[9]:ezip_buf_full
              bit[8]:ezip_buf_empty
              bit[7]:dec_buf_full
              bit[6]:dec_buf_empty
              bit[5]:bypass_on
              bit[4]:dec_on
              bit[3]:ind3_on
              bit[2]:ind2_on
              bit[1]:ind1_on
              bit[0]:ezip_on
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DB_DATA5</name>
          <displayName>DB_DATA5</displayName>
          <description>ezip decoder debug data5</description>
          <addressOffset>0x07c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DB_DATA5</name>
              <description>
              bit[31:16] width_cnt_cur
              bit[15:0] height_cnt_cur
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DB_DATA6</name>
          <displayName>DB_DATA6</displayName>
          <description>ezip decoder debug data6</description>
          <addressOffset>0x080</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DB_DATA6</name>
              <description>
              seq_num
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DB_DATA7</name>
          <displayName>DB_DATA7</displayName>
          <description>ezip decoder debug data7</description>
          <addressOffset>0x084</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DB_DATA7</name>
              <description>
              bit[31:16] frame_width_cur
              bit[15:0] frame_height_cur
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DB_DATA8</name>
          <displayName>DB_DATA8</displayName>
          <description>ezip decoder debug data8</description>
          <addressOffset>0x088</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DB_DATA8</name>
              <description>
              bit[31:16 ]frame_offsetx_cur
              bit[15:0] frame_offsety_cur
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DB_DATA9</name>
          <displayName>DB_DATA9</displayName>
          <description>ezip decoder debug data9</description>
          <addressOffset>0x08c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DB_DATA9</name>
              <description>
              bit[31:16 ]delay_num_cur
              bit[15:0] delay_den_cur
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DB_DATA10</name>
          <displayName>DB_DATA10</displayName>
          <description>ezip decoder debug data10</description>
          <addressOffset>0x090</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DB_DATA10</name>
              <description>
              bit[15:8 dispos_op_cur
              bit[7:0] blend_op_cur
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DB_DATA11</name>
          <displayName>DB_DATA11</displayName>
          <description>ezip decoder debug data11</description>
          <addressOffset>0x094</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DB_DATA11</name>
              <description>
              frame_cont_cur
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DB_DATA12</name>
          <displayName>DB_DATA12</displayName>
          <description>ezip decoder debug data12</description>
          <addressOffset>0x098</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DB_DATA12</name>
              <description>
              paly_cont_cur
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DB_DATA13</name>
          <displayName>DB_DATA13</displayName>
          <description>ezip decoder debug data13</description>
          <addressOffset>0x09c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DB_DATA13</name>
              <description>
              frame_size_cur
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>EPIC</name>
      <description></description>
      <groupName>EPIC</groupName>
      <baseAddress>0x40007000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>COMMAND</name>
          <displayName>COMMAND</displayName>
          <description></description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>30</bitWidth>
            </field>
            <field>
              <name>RESET</name>
              <description>
              1: reset the whole graphics   0: release the reset
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>START</name>
              <description>
              write 1 to trigger the lcd interface block
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS</name>
          <displayName>STATUS</displayName>
          <description></description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>27</bitWidth>
            </field>
            <field>
              <name>LCD_BUSY</name>
              <description>
              LCD controll busy flag
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>IA_BUSY</name>
              <description>
              Graphics accelerator busy flag
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>EOF_IRQ</name>
          <displayName>EOF_IRQ</displayName>
          <description></description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>14</bitWidth>
            </field>
            <field>
              <name>LINE_HIT_STATUS</name>
              <description>
              raw status of line hit interrupt
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IRQ_STATUS</name>
              <description>
              raw status of end of frame interrupt
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>14</bitWidth>
            </field>
            <field>
              <name>LINE_HIT_CAUSE</name>
              <description>
              line hit interrupt, can be masked by LINE_IRQ_MASK
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IRQ_CAUSE</name>
              <description>
              end of frame interrupt, can be masked by EOF_IRQ_MASK
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SETTING</name>
          <displayName>SETTING</displayName>
          <description></description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>LINE_IRQ_NUM</name>
              <description>
              canvas line hit interrupt line number
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>13</bitWidth>
            </field>
            <field>
              <name>AUTO_GATE_EN</name>
              <description>
              auto clock gating enable
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LINE_IRQ_MASK</name>
              <description>
              canvas line hit interrupt mask, 0: mask the interrupt
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EOF_IRQ_MASK</name>
              <description>
              end of frame interrupt mask, 0: mask the interrupt
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CANVAS_TL_POS</name>
          <displayName>CANVAS_TL_POS</displayName>
          <description>Top-Left pixel coordinate</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>Y0</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>X0</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CANVAS_BR_POS</name>
          <displayName>CANVAS_BR_POS</displayName>
          <description>Bottom-Right pixel coordinate</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>Y1</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>X1</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CANVAS_BG</name>
          <displayName>CANVAS_BG</displayName>
          <description>Background color</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>ALL_BLENDING_BYPASS</name>
              <description>
              if this bit is set, epic is in pure dma mode. No blending operation.
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BG_BLENDING_BYPASS</name>
              <description>
              if this bit is set, the layer is not blending with background. The alpha value will be reserved to output.
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RED</name>
              <description>
              Red color
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>GREEN</name>
              <description>
              green color
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>BLUE</name>
              <description>
              blue color
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>VL_CFG</name>
          <displayName>VL_CFG</displayName>
          <description></description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ALPHA_BLEND</name>
              <description>
              set 1 to enable alpha blending mode. Use layer alpha as blending factor for image with Alpha.
              Alpha_out = Layer_alpha * Image_alpha
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ACTIVE</name>
              <description>
              layer active flag
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PREFETCH_EN</name>
              <description>
              preload 64 bytes extra data when reading pixel from memory
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>WIDTH</name>
              <description>
              source image width(including padding), unit is bytes
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>13</bitWidth>
            </field>
            <field>
              <name>FILTER_EN</name>
              <description>
              layer color filter enable
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BLEND_DEPTH</name>
              <description>
              video layer blending depth
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>ALPHA</name>
              <description>
              layer alpha value
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>ALPHA_SEL</name>
              <description>
              alpha selection
              1'b0: select alpha according to image format
              1'b1: select layer alpha
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FORMAT</name>
              <description>
              video layer input format
              3'h0: RGB565
              3'h1: RGB888
              3'h2: ARGB8888
              3'h3: ARGB8565
              3'h4: A8
              3'h5: A4
              3'h6: L8
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>VL_TL_POS</name>
          <displayName>VL_TL_POS</displayName>
          <description></description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>Y0</name>
              <description>
              Coordingate Y-value
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>X0</name>
              <description>
              Coordinate X-value
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>VL_BR_POS</name>
          <displayName>VL_BR_POS</displayName>
          <description></description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>Y1</name>
              <description>
              Coordingate Y-value
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>X1</name>
              <description>
              Coordinate X-value
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>VL_EXTENTS</name>
          <displayName>VL_EXTENTS</displayName>
          <description></description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>MAX_COL</name>
              <description>
              number of pixels of each line of source image(not including padding)
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>MAX_LINE</name>
              <description>
              number of pixels of each column of source image(not including padding)
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>VL_FILTER</name>
          <displayName>VL_FILTER</displayName>
          <description></description>
          <addressOffset>0x2c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>FILTER_MASK</name>
              <description>
              layer color filter mask
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>FILTER_R</name>
              <description>
              filter r color
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>FILTER_G</name>
              <description>
              filter g color
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>FILTER_B</name>
              <description>
              filter b color
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>VL_SRC</name>
          <displayName>VL_SRC</displayName>
          <description></description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ADDR</name>
              <description>
              source image RGB data address[31:0]. For RGB565 format, address should be aligned to halfword. For ARGB8888 format, address should be aligned to word.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>VL_ROT</name>
          <displayName>VL_ROT</displayName>
          <description></description>
          <addressOffset>0x34</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>CALC_DONE</name>
              <description>
              calculation done indicator
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ROT_DEG</name>
              <description>
              rotation degree, rotation is clockwise.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
            <field>
              <name>CALC_CLR</name>
              <description>
              rot_max_col and rot_max_line calculation clear request. Write 1 to clear the result.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CALC_REQ</name>
              <description>
              rot_max_col and rot_max_line calculation request. Write 1 to trigger the calculation.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>VL_ROT_STAT</name>
          <displayName>VL_ROT_STAT</displayName>
          <description></description>
          <addressOffset>0x38</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>ROT_MAX_COL</name>
              <description>
              max column of rotated image
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>ROT_MAX_LINE</name>
              <description>
              max line of rotated image
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>VL_SCALE_RATIO_H</name>
          <displayName>VL_SCALE_RATIO_H</displayName>
          <description></description>
          <addressOffset>0x3c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>XPITCH</name>
              <description>
              x-axis rescaling ration, 10.16 fixed point number, XPITCH lt MAX_COL/(X1-X0)
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>26</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>VL_SCALE_RATIO_V</name>
          <displayName>VL_SCALE_RATIO_V</displayName>
          <description></description>
          <addressOffset>0x40</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>YPITCH</name>
              <description>
              y-axis rescaling ratio, 10.16 fixed point number, YPITCH lt MAX_LINE/(Y1-Y0)
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>26</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>VL_FILL</name>
          <displayName>VL_FILL</displayName>
          <description></description>
          <addressOffset>0x44</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>ENDIAN</name>
              <description>
              input 565 data format endian
              0: {R[4:0], G[5:3], G[2:0], B[4:0]}
              1: {G[2:0], R[4:0], B[4:0], G[5:3]}
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BG_MODE</name>
              <description>
              Not used.
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BG_R</name>
              <description>
              background r color
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>BG_G</name>
              <description>
              background g color
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>BG_B</name>
              <description>
              background b color
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>VL_MISC_CFG</name>
          <displayName>VL_MISC_CFG</displayName>
          <description></description>
          <addressOffset>0x48</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>DEG_FORCE</name>
              <description>
              force epic use external sin and cos value, quadrant is still calculated from ROT_DEG.
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SIN_FORCE_VALUE</name>
              <description>
              external absolute value of sin. U13.12 format.
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>13</bitWidth>
            </field>
            <field>
              <name>COS_FORCE_VALUE</name>
              <description>
              external absolute value of cos. U13.12 format.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>13</bitWidth>
            </field>
            <field>
              <name>MIRROR</name>
              <description>
              mirror enable
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CLUT_SEL</name>
              <description>
              VL CLUT select:
              1'h1: select pallette1
              1'h0: select pallette0
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD4</name>
          <displayName>RSVD4</displayName>
          <description></description>
          <addressOffset>0x4C</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>L0_CFG</name>
          <displayName>L0_CFG</displayName>
          <description></description>
          <addressOffset>0x50</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ALPHA_BLEND</name>
              <description>
              set 1 to enable alpha blending mode. Use layer alpha as blending factor for image with Alpha.
              Alpha_out = Layer_alpha * Image_alpha
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ACTIVE</name>
              <description>
              layer active flag
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PREFETCH_EN</name>
              <description>
              preload 64 bytes extra data when reading pixel from memory
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>WIDTH</name>
              <description>
              source image width(including padding), unit is bytes
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>13</bitWidth>
            </field>
            <field>
              <name>FILTER_EN</name>
              <description>
              layer color filter enable
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>ALPHA</name>
              <description>
              layer alpha value
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>ALPHA_SEL</name>
              <description>
              alpha selection
              1'b0: select alpha according to image format
              1'b1: select layer alpha
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FORMAT</name>
              <description>
              layer input format
              3'h0: RGB565
              3'h1: RGB888
              3'h2: ARGB8888
              3'h3: ARGB8565
              3'h4: A8
              3'h5: A4
              3'h6: L8
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>L0_TL_POS</name>
          <displayName>L0_TL_POS</displayName>
          <description></description>
          <addressOffset>0x54</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>Y0</name>
              <description>
              Coordingate Y-value
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>X0</name>
              <description>
              Coordinate X-value
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>L0_BR_POS</name>
          <displayName>L0_BR_POS</displayName>
          <description></description>
          <addressOffset>0x58</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>Y1</name>
              <description>
              Coordingate Y-value
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>X1</name>
              <description>
              Coordinate X-value
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>L0_FILTER</name>
          <displayName>L0_FILTER</displayName>
          <description></description>
          <addressOffset>0x5c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>FILTER_MASK</name>
              <description>
              layer color filter mask
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>FILTER_R</name>
              <description>
              filter r color
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>FILTER_G</name>
              <description>
              filter g color
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>FILTER_B</name>
              <description>
              filter b color
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>L0_SRC</name>
          <displayName>L0_SRC</displayName>
          <description></description>
          <addressOffset>0x60</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ADDR</name>
              <description>
              source image RGB data address[31:0]. For RGB565 format, address should be aligned to halfword. For ARGB8888 format, address should be aligned to word.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>L0_FILL</name>
          <displayName>L0_FILL</displayName>
          <description></description>
          <addressOffset>0x64</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>ENDIAN</name>
              <description>
              input 565 data format endian
              0: {R[4:0], G[5:3], G[2:0], B[4:0]}
              1: {G[2:0], R[4:0], B[4:0], G[5:3]}
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BG_MODE</name>
              <description>
              Not used.
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BG_R</name>
              <description>
              background r color
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>BG_G</name>
              <description>
              background g color
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>BG_B</name>
              <description>
              background b color
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>L0_MISC_CFG</name>
          <displayName>L0_MISC_CFG</displayName>
          <description></description>
          <addressOffset>0x68</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>31</bitWidth>
            </field>
            <field>
              <name>CLUT_SEL</name>
              <description>
              L0 CLUT select:
              1'h1: select pallette1
              1'h0: select pallette0
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD3</name>
          <displayName>RSVD3</displayName>
          <description></description>
          <addressOffset>0x6C</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>L1_CFG</name>
          <displayName>L1_CFG</displayName>
          <description></description>
          <addressOffset>0x70</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ALPHA_BLEND</name>
              <description>
              set 1 to enable alpha blending mode. Use layer alpha as blending factor for image with Alpha.
              Alpha_out = Layer_alpha * Image_alpha
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ACTIVE</name>
              <description>
              layer active flag
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PREFETCH_EN</name>
              <description>
              preload 64 bytes extra data when reading pixel from memory
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>WIDTH</name>
              <description>
              source image width(including padding), unit is bytes
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>13</bitWidth>
            </field>
            <field>
              <name>FILTER_EN</name>
              <description>
              layer color filter enable
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>ALPHA</name>
              <description>
              layer alpha value
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>ALPHA_SEL</name>
              <description>
              alpha selection
              1'b0: select alpha according to image format
              1'b1: select layer alpha
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FORMAT</name>
              <description>
              layer input format
              3'h0: RGB565
              3'h1: RGB888
              3'h2: ARGB8888
              3'h3: ARGB8565
              3'h4: A8
              3'h5: A4
              3'h6: L8
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>L1_TL_POS</name>
          <displayName>L1_TL_POS</displayName>
          <description></description>
          <addressOffset>0x74</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>Y0</name>
              <description>
              Coordingate Y-value
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>X0</name>
              <description>
              Coordinate X-value
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>L1_BR_POS</name>
          <displayName>L1_BR_POS</displayName>
          <description></description>
          <addressOffset>0x78</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>Y1</name>
              <description>
              Coordingate Y-value
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>X1</name>
              <description>
              Coordinate X-value
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>L1_FILTER</name>
          <displayName>L1_FILTER</displayName>
          <description></description>
          <addressOffset>0x7c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>FILTER_MASK</name>
              <description>
              layer color filter mask
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>FILTER_R</name>
              <description>
              filter r color
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>FILTER_G</name>
              <description>
              filter g color
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>FILTER_B</name>
              <description>
              filter b color
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>L1_SRC</name>
          <displayName>L1_SRC</displayName>
          <description></description>
          <addressOffset>0x80</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ADDR</name>
              <description>
              source image RGB data address[31:0]. For RGB565 format, address should be aligned to halfword. For ARGB8888 format, address should be aligned to word.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>L1_FILL</name>
          <displayName>L1_FILL</displayName>
          <description></description>
          <addressOffset>0x84</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>ENDIAN</name>
              <description>
              input 565 data format endian
              0: {R[4:0], G[5:3], G[2:0], B[4:0]}
              1: {G[2:0], R[4:0], B[4:0], G[5:3]}
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BG_MODE</name>
              <description>
              Not used.
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BG_R</name>
              <description>
              background r color
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>BG_G</name>
              <description>
              background g color
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>BG_B</name>
              <description>
              background b color
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>L1_MISC_CFG</name>
          <displayName>L1_MISC_CFG</displayName>
          <description></description>
          <addressOffset>0x88</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>31</bitWidth>
            </field>
            <field>
              <name>CLUT_SEL</name>
              <description>
              L1 CLUT select:
              1'h1: select pallette1
              1'h0: select pallette0
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD2</name>
          <displayName>RSVD2</displayName>
          <description></description>
          <addressOffset>0x8C</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>L2_CFG</name>
          <displayName>L2_CFG</displayName>
          <description></description>
          <addressOffset>0x90</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ALPHA_BLEND</name>
              <description>
              set 1 to enable alpha blending mode. Use layer alpha as blending factor for image with Alpha.
              Alpha_out = Layer_alpha * Image_alpha
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ACTIVE</name>
              <description>
              layer active flag
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PREFETCH_EN</name>
              <description>
              preload 64 bytes extra data when reading pixel from memory
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>WIDTH</name>
              <description>
              source image width(including padding), unit is bytes
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>13</bitWidth>
            </field>
            <field>
              <name>FILTER_EN</name>
              <description>
              layer color filter enable
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>ALPHA</name>
              <description>
              layer alpha value
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>ALPHA_SEL</name>
              <description>
              alpha selection
              1'b0: select alpha according to image format
              1'b1: select layer alpha
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FORMAT</name>
              <description>
              layer input format
              3'h0: RGB565
              3'h1: RGB888
              3'h2: ARGB8888
              3'h3: ARGB8565
              3'h4: A8
              3'h5: A4
              3'h6: L8
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>L2_TL_POS</name>
          <displayName>L2_TL_POS</displayName>
          <description></description>
          <addressOffset>0x94</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>Y0</name>
              <description>
              Coordingate Y-value
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>X0</name>
              <description>
              Coordinate X-value
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>L2_BR_POS</name>
          <displayName>L2_BR_POS</displayName>
          <description></description>
          <addressOffset>0x98</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>Y1</name>
              <description>
              Coordingate Y-value
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>X1</name>
              <description>
              Coordinate X-value
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>L2_EXTENTS</name>
          <displayName>L2_EXTENTS</displayName>
          <description></description>
          <addressOffset>0x9c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>MAX_COL</name>
              <description>
              number of pixels of each line of source image(not including padding)
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>MAX_LINE</name>
              <description>
              number of pixels of each column of source image(not including padding)
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>L2_FILTER</name>
          <displayName>L2_FILTER</displayName>
          <description></description>
          <addressOffset>0xa0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>FILTER_MASK</name>
              <description>
              layer color filter mask
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>FILTER_R</name>
              <description>
              filter r color
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>FILTER_G</name>
              <description>
              filter g color
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>FILTER_B</name>
              <description>
              filter b color
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>L2_SRC</name>
          <displayName>L2_SRC</displayName>
          <description></description>
          <addressOffset>0xa4</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ADDR</name>
              <description>
              source image RGB data address[31:0]. For RGB565 format, address should be aligned to halfword. For ARGB8888 format, address should be aligned to word.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>L2_ROT</name>
          <displayName>L2_ROT</displayName>
          <description></description>
          <addressOffset>0xa8</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>CALC_DONE</name>
              <description>
              calculation done indicator
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ROT_DEG</name>
              <description>
              rotation degree, rotation is clockwise.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
            <field>
              <name>CALC_CLR</name>
              <description>
              rot_max_col and rot_max_line calculation clear request. Write 1 to clear the result.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CALC_REQ</name>
              <description>
              rot_max_col and rot_max_line calculation request. Write 1 to trigger the calculation.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>L2_ROT_STAT</name>
          <displayName>L2_ROT_STAT</displayName>
          <description></description>
          <addressOffset>0xac</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>ROT_MAX_COL</name>
              <description>
              max column of rotated image
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>ROT_MAX_LINE</name>
              <description>
              max line of rotated image
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>L2_SCALE_RATIO_H</name>
          <displayName>L2_SCALE_RATIO_H</displayName>
          <description></description>
          <addressOffset>0xb0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>XPITCH</name>
              <description>
              x-axis rescaling ration, 10.16 fixed point number, XPITCH lt MAX_COL/(X1-X0)
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>26</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>L2_SCALE_RATIO_V</name>
          <displayName>L2_SCALE_RATIO_V</displayName>
          <description></description>
          <addressOffset>0xb4</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>YPITCH</name>
              <description>
              y-axis rescaling ratio, 10.16 fixed point number, YPITCH lt MAX_LINE/(Y1-Y0)
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>26</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>L2_FILL</name>
          <displayName>L2_FILL</displayName>
          <description></description>
          <addressOffset>0xb8</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>ENDIAN</name>
              <description>
              input 565 data format endian
              0: {R[4:0], G[5:3], G[2:0], B[4:0]}
              1: {G[2:0], R[4:0], B[4:0], G[5:3]}
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BG_MODE</name>
              <description>
              Not used.
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BG_R</name>
              <description>
              background r color
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>BG_G</name>
              <description>
              background g color
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>BG_B</name>
              <description>
              background b color
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>L2_MISC_CFG</name>
          <displayName>L2_MISC_CFG</displayName>
          <description></description>
          <addressOffset>0xbc</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>DEG_FORCE</name>
              <description>
              force epic use external sin and cos value, quadrant is still calculated from ROT_DEG.
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SIN_FORCE_VALUE</name>
              <description>
              external absolute value of sin. U13.12 format.
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>13</bitWidth>
            </field>
            <field>
              <name>COS_FORCE_VALUE</name>
              <description>
              external absolute value of cos. U13.12 format.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>13</bitWidth>
            </field>
            <field>
              <name>MIRROR</name>
              <description>
              mirror enable
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CLUT_SEL</name>
              <description>
              L2 CLUT select:
              1'h1: select pallette1
              1'h0: select pallette0
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>MASK_CFG</name>
          <displayName>MASK_CFG</displayName>
          <description></description>
          <addressOffset>0xc0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>ACTIVE</name>
              <description>
              layer active flag
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PREFETCH_EN</name>
              <description>
              preload 64 bytes extra data when reading pixel from memory
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>WIDTH</name>
              <description>
              source image width(including padding), unit is bytes
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>13</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>VL_MASK_EN</name>
              <description>
              video layer mask enable
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>L2_MASK_EN</name>
              <description>
              layer2 mask enable
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>L1_MASK_EN</name>
              <description>
              layer1 mask enable
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>L0_MASK_EN</name>
              <description>
              layer0 mask enable
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MIX_MODE</name>
              <description>
              mask mix mode
              1'h0: mult mode
              1'h1: overwrite mode
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FORMAT</name>
              <description>
              mask input format
              1'h0: A8
              1'h1: A4
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>MASK_TL_POS</name>
          <displayName>MASK_TL_POS</displayName>
          <description></description>
          <addressOffset>0xc4</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>Y0</name>
              <description>
              Coordingate Y-value
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>X0</name>
              <description>
              Coordinate X-value
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>MASK_BR_POS</name>
          <displayName>MASK_BR_POS</displayName>
          <description></description>
          <addressOffset>0xc8</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>Y1</name>
              <description>
              Coordingate Y-value
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>X1</name>
              <description>
              Coordinate X-value
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>MASK_SRC</name>
          <displayName>MASK_SRC</displayName>
          <description></description>
          <addressOffset>0xcc</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ADDR</name>
              <description>
              mask data address[31:0]. This is byte address, even for A4, this address is byte aligned.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>COENG_CFG</name>
          <displayName>COENG_CFG</displayName>
          <description></description>
          <addressOffset>0xd0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>26</bitWidth>
            </field>
            <field>
              <name>YUV_CH_SEL</name>
              <description>
              yuv engine channel select
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>YUV_EN</name>
              <description>
              yuv enable
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EZIP_CH_SEL</name>
              <description>
              ezip channel select
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>EZIP_EN</name>
              <description>
              ezip enable
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>YUV_ENG_CFG0</name>
          <displayName>YUV_ENG_CFG0</displayName>
          <description></description>
          <addressOffset>0xd4</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RANGE_SEL</name>
              <description>
              yuv input range
              1'h0: tv range
              1'h1: pc range
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FORMAT</name>
              <description>
              yuv format
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>WIDTH_Y</name>
              <description>
              yuv y vector line width, unit is bytes
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>13</bitWidth>
            </field>
            <field>
              <name>WIDTH_U</name>
              <description>
              yuv u vector line width, unit is bytes
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>13</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>YUV_ENG_CFG1</name>
          <displayName>YUV_ENG_CFG1</displayName>
          <description></description>
          <addressOffset>0xd8</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>19</bitWidth>
            </field>
            <field>
              <name>WIDTH_V</name>
              <description>
              yuv v vector line width, unit is bytes
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>13</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>Y_SRC</name>
          <displayName>Y_SRC</displayName>
          <description></description>
          <addressOffset>0xdc</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ADDR</name>
              <description>
              y vector address
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>U_SRC</name>
          <displayName>U_SRC</displayName>
          <description></description>
          <addressOffset>0xe0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ADDR</name>
              <description>
              u vector address
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>V_SRC</name>
          <displayName>V_SRC</displayName>
          <description></description>
          <addressOffset>0xe4</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ADDR</name>
              <description>
              v vector address
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>COEF0</name>
          <displayName>COEF0</displayName>
          <description></description>
          <addressOffset>0xe8</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>FY</name>
              <description>
              YUV Fy coef
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
            <field>
              <name>FUG</name>
              <description>
              YUV Fug coef
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
            <field>
              <name>FUB</name>
              <description>
              YUV Fub coef
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>COEF1</name>
          <displayName>COEF1</displayName>
          <description></description>
          <addressOffset>0xec</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
            <field>
              <name>FVR</name>
              <description>
              YUV Fvr coef
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
            <field>
              <name>FVG</name>
              <description>
              YUV Fvg coef
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DITHER_CONF</name>
          <displayName>DITHER_CONF</displayName>
          <description></description>
          <addressOffset>0xf0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>19</bitWidth>
            </field>
            <field>
              <name>LFSR_LOAD</name>
              <description>
              load lfsr init value
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LFSR_LOAD_SEL</name>
              <description>
              select lfsr
              0: none
              1: red
              2: green
              3: blue
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>W_R</name>
              <description>
              red dither width
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>W_G</name>
              <description>
              green dither width
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>W_B</name>
              <description>
              blue dither width
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>EN</name>
              <description>
              dither enable
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DITHER_LFSR</name>
          <displayName>DITHER_LFSR</displayName>
          <description></description>
          <addressOffset>0xf4</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>INIT_VAL</name>
              <description>
              lfsr init load value
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>AHB_CTRL</name>
          <displayName>AHB_CTRL</displayName>
          <description></description>
          <addressOffset>0xf8</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>29</bitWidth>
            </field>
            <field>
              <name>O_FORMAT</name>
              <description>
              AHB output format:
              2'h0: RGB565
              2'h1: RGB888
              2'h2: ARGB8888
              2'h3: ARGB8565
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>DESTINATION</name>
              <description>
              The Data can be sent to two destinations:
              2'b0: AHB RAM
              2'b1: AHB LCD
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>AHB_MEM</name>
          <displayName>AHB_MEM</displayName>
          <description></description>
          <addressOffset>0xfc</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ADDR</name>
              <description>
              AHB RAM/AHB LCD target address
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>AHB_STRIDE</name>
          <displayName>AHB_STRIDE</displayName>
          <description></description>
          <addressOffset>0x100</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>OFFSET</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DEBUG</name>
          <displayName>DEBUG</displayName>
          <description></description>
          <addressOffset>0x104</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DEBUG_INT_DATA</name>
              <description>
              4'h0: RSVD
              4'h1: OL0 debug info
              4'h2: OL1 debug info
              4'h3: OL2 debug info
              4'h4: VL debug info1
              4'h5: VL debug info2
              4'h6: ROI debug out
              4'h7: mem intfa debug out
              4'h8: mem intfb debug out
              4'h9: ahb ctrl debug out
              4'ha: ROI XX
              4'hb: ROI YY
              4'hc: EPIC_EZIP debug out
              others: RSVD
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>DEBUG_INT_SEL</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>DEBUG_OUT_SEL</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>VL_ROT_M_CFG1</name>
          <displayName>VL_ROT_M_CFG1</displayName>
          <description></description>
          <addressOffset>0x108</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>M_MODE</name>
              <description>
              rotation mode setting
              1'b0: auto mode
              1'b1: manual mode
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>M_ROT_MAX_COL</name>
              <description>
              manual mode rotation max column, unsigned value
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>M_ROT_MAX_LINE</name>
              <description>
              manual mode rotation max line, unsigned value
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>VL_ROT_M_CFG2</name>
          <displayName>VL_ROT_M_CFG2</displayName>
          <description></description>
          <addressOffset>0x10c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>M_PIVOT_Y</name>
              <description>
              manual mode pivot y, signed value, -1023~1023, -1024 is not supported
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>M_PIVOT_X</name>
              <description>
              manual mode pivot x, signed value, -1023~1023, -1024 is not supported
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>VL_ROT_M_CFG3</name>
          <displayName>VL_ROT_M_CFG3</displayName>
          <description></description>
          <addressOffset>0x110</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>M_YTL</name>
              <description>
              manual mode top left y cordinate, signed value, -1023~1023, -1024 is not supported
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>M_XTL</name>
              <description>
              manual mode top left x cordinate, signed value, -1023~1023, -1024 is not supported
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>VL_SCALE_INIT_CFG1</name>
          <displayName>VL_SCALE_INIT_CFG1</displayName>
          <description></description>
          <addressOffset>0x114</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>X_VAL</name>
              <description>
              x-axis scale initial value, 10.16 format
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>26</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>VL_SCALE_INIT_CFG2</name>
          <displayName>VL_SCALE_INIT_CFG2</displayName>
          <description></description>
          <addressOffset>0x118</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>Y_VAL</name>
              <description>
              y-axis scale initial value, 10.16 format
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>26</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>L2_ROT_M_CFG1</name>
          <displayName>L2_ROT_M_CFG1</displayName>
          <description></description>
          <addressOffset>0x11c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>M_MODE</name>
              <description>
              rotation mode setting
              1'b0: auto mode
              1'b1: manual mode
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>M_ROT_MAX_COL</name>
              <description>
              manual mode rotation max column, unsigned value
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>M_ROT_MAX_LINE</name>
              <description>
              manual mode rotation max line, unsigned value
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>L2_ROT_M_CFG2</name>
          <displayName>L2_ROT_M_CFG2</displayName>
          <description></description>
          <addressOffset>0x120</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>M_PIVOT_Y</name>
              <description>
              manual mode pivot y, signed value, -1023~1023, -1024 is not supported
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>M_PIVOT_X</name>
              <description>
              manual mode pivot x, signed value, -1023~1023, -1024 is not supported
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>L2_ROT_M_CFG3</name>
          <displayName>L2_ROT_M_CFG3</displayName>
          <description></description>
          <addressOffset>0x124</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>M_YTL</name>
              <description>
              manual mode top left y cordinate, signed value, -1023~1023, -1024 is not supported
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>M_XTL</name>
              <description>
              manual mode top left x cordinate, signed value, -1023~1023, -1024 is not supported
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>L2_SCALE_INIT_CFG1</name>
          <displayName>L2_SCALE_INIT_CFG1</displayName>
          <description></description>
          <addressOffset>0x128</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>X_VAL</name>
              <description>
              x-axis scale initial value, 10.16 format
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>26</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>L2_SCALE_INIT_CFG2</name>
          <displayName>L2_SCALE_INIT_CFG2</displayName>
          <description></description>
          <addressOffset>0x12c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>Y_VAL</name>
              <description>
              y-axis scale initial value, 10.16 format
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>26</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PERF_CNT</name>
          <displayName>PERF_CNT</displayName>
          <description></description>
          <addressOffset>0x130</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>VAL</name>
              <description>
              epic performance counter
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD1</name>
          <displayName>RSVD1</displayName>
          <description></description>
          <addressOffset>0x134</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>CANVAS_STAT</name>
          <displayName>CANVAS_STAT</displayName>
          <description></description>
          <addressOffset>0x140</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>FETCH_STAT</name>
              <description>
              fetch status
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>PREC_STAT</name>
              <description>
              prec status
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>POSTC_STAT</name>
              <description>
              postc_status
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>FIFO_CNT</name>
              <description>
              pre calc fifo count
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>Y_COR</name>
              <description>
              canvas y cordinate
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
            <field>
              <name>X_COR</name>
              <description>
              canvas x cordinate
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>EZIP_STAT</name>
          <displayName>EZIP_STAT</displayName>
          <description></description>
          <addressOffset>0x144</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RUN_STAT1</name>
              <description>
              ezip engine 1 status
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>BUF_CNT1</name>
              <description>
              ezip engine 1 buffer count
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>LINE_CNT1</name>
              <description>
              ezip engine 1 line count
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RUN_STAT0</name>
              <description>
              ezip engine 0 status
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>BUF_CNT0</name>
              <description>
              ezip engine 0 buffer count
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>LINE_CNT0</name>
              <description>
              ezip engine 0 line count
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>OL_STAT</name>
          <displayName>OL_STAT</displayName>
          <description></description>
          <addressOffset>0x148</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>PF_PR1</name>
              <description>
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>PF_DF1</name>
              <description>
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>DATA_CONV1</name>
              <description>
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>PREFETCH_READ1</name>
              <description>
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>PREFETCH_OUT1</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PREFETCH_HOLD1</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DONE_REQ1</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>PF_PR0</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>PF_DF0</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>DATA_CONV0</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>PREFETCH_READ0</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>PREFETCH_OUT0</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PREFETCH_HOLD0</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DONE_REQ0</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>OL2_STAT</name>
          <displayName>OL2_STAT</displayName>
          <description></description>
          <addressOffset>0x14c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>SC_LB0</name>
              <description>
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>SC_LB1</name>
              <description>
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>SC_FE</name>
              <description>
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>SC_BE</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>SC_OUT</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>NF_DATA_CONV</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>NF_DF</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>NF_PR</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RF_ROT</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>PREFETCH_READ</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>PREFETCH_OUT</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>VL_STAT</name>
          <displayName>VL_STAT</displayName>
          <description></description>
          <addressOffset>0x150</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>SC_LB0</name>
              <description>
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>SC_LB1</name>
              <description>
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>SC_FE</name>
              <description>
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>SC_BE</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>SC_OUT</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>NF_DATA_CONV</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>NF_DF</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>NF_PR</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RF_ROT</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>PREFETCH_READ</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>PREFETCH_OUT</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ML_STAT</name>
          <displayName>ML_STAT</displayName>
          <description></description>
          <addressOffset>0x154</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>22</bitWidth>
            </field>
            <field>
              <name>MF_PR</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>MF_DF</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>PREFETCH_READ</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>PREFETCH_OUT</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PREFETCH_HOLD</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DONE_REQ</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>MEM_IF_STAT</name>
          <displayName>MEM_IF_STAT</displayName>
          <description></description>
          <addressOffset>0x158</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>AHB_CTRL_FIFO_CNT</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>AHB_CTRL_EOL</name>
              <description>
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>AHB_CTRL</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>ARB_MAIN1</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>ARB_READ_PORT1</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>AHB1</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>ARB_MAIN0</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>ARB_READ_PORT0</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>AHB0</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>LCDC1</name>
      <description></description>
      <groupName>LCDC</groupName>
      <baseAddress>0x40008000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>COMMAND</name>
          <displayName>COMMAND</displayName>
          <description></description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>30</bitWidth>
            </field>
            <field>
              <name>RESET</name>
              <description>
              1: reset the whole graphics   0: release the reset
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>START</name>
              <description>
              write 1 to trigger the lcd interface block
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS</name>
          <displayName>STATUS</displayName>
          <description></description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>29</bitWidth>
            </field>
            <field>
              <name>JDI_PAR_RUN</name>
              <description>
              JDI parallel interface is running
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DPI_RUN</name>
              <description>
              DPI interface is running
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LCD_BUSY</name>
              <description>
              LCS controll busy flag
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IRQ</name>
          <displayName>IRQ</displayName>
          <description></description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
            <field>
              <name>LINE_DONE_RAW_STAT</name>
              <description>
              raw_status of line process done interrupt
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>JDI_PAR_UDR_RAW_STAT</name>
              <description>
              raw_status of jdi parallel interface under run interrupt
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>JDI_PARL_INTR_RAW_STAT</name>
              <description>
              raw_status of jdi parallel interface line interrupt
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DPI_UDR_RAW_STAT</name>
              <description>
              raw status of dpi under run interrupt
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DPIL_INTR_RAW_STAT</name>
              <description>
              raw status of dpi line interrupt
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ICB_OF_RAW_STAT</name>
              <description>
              raw status of icb overflow interrupt
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EOF_RAW_STAT</name>
              <description>
              raw status of end of frame interrupt
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
            <field>
              <name>LINE_DONE_STAT</name>
              <description>
              line process done interrupt, masked by mask register
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>JDI_PAR_UDR_STAT</name>
              <description>
              jdi parallel interface under run interrupt, masked by mask register
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>JDI_PARL_INTR_STAT</name>
              <description>
              jdi parallel interface line interrupt, masked by mask register
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DPI_UDR_STAT</name>
              <description>
              dpi under run interrupt, masked by mask register
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DPIL_INTR_STAT</name>
              <description>
              dpi line interrupt, masked by mask register
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ICB_OF_STAT</name>
              <description>
              icb overflow interrupt, masked by mask register
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EOF_STAT</name>
              <description>
              end of frame interrupt, masked by mask register
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SETTING</name>
          <displayName>SETTING</displayName>
          <description></description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>LINE_DONE_NUM</name>
              <description>
              line number of line process done interrupt
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
            <field>
              <name>AUTO_GATE_EN</name>
              <description>
              auto clock gating enable
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LINE_DONE_MASK</name>
              <description>
              line process done interrupt, 0: mask the interrupt
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>JDI_PAR_UDR_MASK</name>
              <description>
              jdi parallel interface under run interrupt mask, 0: mask the interrupt
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>JDI_PARL_INTR_MASK</name>
              <description>
              jdi parallel interface line interrupt, 0: mask the interrupt
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DPI_UDR_MASK</name>
              <description>
              dpi under run interrupt mask, 0: mask the interrupt
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DPIL_INTR_MASK</name>
              <description>
              dpi line interrupt, 0: mask the interrupt
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ICB_OF_MASK</name>
              <description>
              icb overflow interrupt mask, 0: mask the interrupt
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EOF_MASK</name>
              <description>
              end of frame interrupt mask, 0: mask the interrupt
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CANVAS_TL_POS</name>
          <displayName>CANVAS_TL_POS</displayName>
          <description></description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>Y0</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>X0</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CANVAS_BR_POS</name>
          <displayName>CANVAS_BR_POS</displayName>
          <description></description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>Y1</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>X1</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CANVAS_BG</name>
          <displayName>CANVAS_BG</displayName>
          <description></description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>H_MIRROR</name>
              <description>
              set 1 to do horizontal mirror for output image
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LB_BYPASS</name>
              <description>
              line buffer bypass. Set 1 to bypass line buffer.
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ALL_BLENDING_BYPASS</name>
              <description>
              if this bit is set, lcdc is in pure dma mode. No blending operation.
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BG_BLENDING_BYPASS</name>
              <description>
              if this bit is set, the layer is not blending with background. The alpha value will be reserved to output.
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RED</name>
              <description>
              Red color
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>GREEN</name>
              <description>
              green color
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>BLUE</name>
              <description>
              blue color
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>LAYER0_CONFIG</name>
          <displayName>LAYER0_CONFIG</displayName>
          <description></description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>V_MIRROR</name>
              <description>
              set 1 to do vertical mirror for the layer
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ALPHA_BLEND</name>
              <description>
              set 1 to enable alpha blending mode. Use layer alpha as blending factor for image with Alpha.
              Alpha_out = Layer_alpha * Image_alpha
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ACTIVE</name>
              <description>
              layer active flag
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LINE_FETCH_MODE</name>
              <description>
              line fetch mode
              0: address skip every single line
              1: address skip every two line
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PREFETCH_EN</name>
              <description>
              preload 64 bytes extra data when reading pixel from memory
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>WIDTH</name>
              <description>
              source image width(including padding), unit is bytes
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>13</bitWidth>
            </field>
            <field>
              <name>FILTER_EN</name>
              <description>
              layer color filter enable
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ALPHA</name>
              <description>
              layer alpha value
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>ALPHA_SEL</name>
              <description>
              alpha selection
              1'b0: select alpha according to image format
              1'b1: select layer alpha
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FORMAT</name>
              <description>
              overlay layer input format
              3'h0: RGB565
              3'h1: RGB888
              3'h2: ARGB8888
              3'h3: ARGB8565
              3'h4: RGB332
              3'h5: A8
              3'h6: L8
              others: reserved
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>LAYER0_TL_POS</name>
          <displayName>LAYER0_TL_POS</displayName>
          <description></description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>Y0</name>
              <description>
              Coordingate Y-value
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>X0</name>
              <description>
              Coordinate X-value
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>LAYER0_BR_POS</name>
          <displayName>LAYER0_BR_POS</displayName>
          <description></description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>Y1</name>
              <description>
              Coordingate Y-value
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>X1</name>
              <description>
              Coordinate X-value
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>LAYER0_FILTER</name>
          <displayName>LAYER0_FILTER</displayName>
          <description></description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>FILTER_MASK</name>
              <description>
              layer color filter mask
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>FILTER_R</name>
              <description>
              filter r color
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>FILTER_G</name>
              <description>
              filter g color
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>FILTER_B</name>
              <description>
              filter b color
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>LAYER0_SRC</name>
          <displayName>LAYER0_SRC</displayName>
          <description></description>
          <addressOffset>0x2c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ADDR</name>
              <description>
              source image RGB data address[31:0]. For RGB565 format, address should be aligned to halfword. For ARGB8888 format, address should be aligned to word.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>LAYER0_FILL</name>
          <displayName>LAYER0_FILL</displayName>
          <description></description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>ENDIAN</name>
              <description>
              input 565 data format endian
              0: {R[4:0], G[5:3], G[2:0], B[4:0]}
              1: {G[2:0], R[4:0], B[4:0], G[5:3]}
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BG_MODE</name>
              <description>
              not used
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BG_R</name>
              <description>
              background r color
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>BG_G</name>
              <description>
              background g color
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>BG_B</name>
              <description>
              background b color
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>LAYER0_DECOMP</name>
          <displayName>LAYER0_DECOMP</displayName>
          <description></description>
          <addressOffset>0x34</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>COL_SIZE</name>
              <description>
              number of colums in a line of original image, max column size is 1024
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
            <field>
              <name>TARGET_WORDS</name>
              <description>
              size of a single channel data before decompression. Unit is half word. Each line has 3 channels. So for each line, the compressed data size is target_words * 3 * 2 bytes.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
            <field>
              <name>ENABLE</name>
              <description>
              decompression enable
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>LAYER0_DECOMP_CFG0</name>
          <displayName>LAYER0_DECOMP_CFG0</displayName>
          <description></description>
          <addressOffset>0x38</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x01055982</resetValue>
          <fields>
            <field>
              <name>CFG0_RESERVED</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
            <field>
              <name>LOSSLESS_QIDX2</name>
              <description>
              condition to decrease qidx
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>LOSSLESS_QIDX1</name>
              <description>
              up level for adjusted qidx value for low quality block
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>USE_LOSSLESS_QIDX</name>
              <description>
              condition to increase qidx
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>EXTRA_THRESHOLD</name>
              <description>
              the threshold to distinguish high/low quality block
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>EXTRA_HIGH</name>
              <description>
              extra bit for high quality bit
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>LAYER0_DECOMP_CFG1</name>
          <displayName>LAYER0_DECOMP_CFG1</displayName>
          <description></description>
          <addressOffset>0x3c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x80023307</resetValue>
          <fields>
            <field>
              <name>EXTRA_LOW</name>
              <description>
              extra bit for low quality block
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>BLOCK_MIN_QIDX</name>
              <description>
              minimum qidx for block mode
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>LINE_MIN_QIDX</name>
              <description>
              minimum qidx for line mode
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>FAILOVER_BITS_B</name>
              <description>
              failover compression mode target bits(Blue)
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>FAILOVER_BITS_G</name>
              <description>
              failover compression mode target bits(Green)
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>FAILOVER_BITS_R</name>
              <description>
              failover compression mode target bits(Red)
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>CFG1_RESERVED</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>DITHER</name>
              <description>
              dithering function
              0: off
              1: on
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BLOCK_WIDTH</name>
              <description>
              block_size in pixel unit.
              0: 16 pixels
              1: 32 pixels
              Small block size will cause more blocks and more bits to store block information.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>LAYER0_DECOMP_STAT</name>
          <displayName>LAYER0_DECOMP_STAT</displayName>
          <description></description>
          <addressOffset>0x40</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>25</bitWidth>
            </field>
            <field>
              <name>BUF_MAX_DEPTH</name>
              <description>
              buf max usage
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD2</name>
          <displayName>RSVD2</displayName>
          <description></description>
          <addressOffset>0x44</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>LAYER1_CONFIG</name>
          <displayName>LAYER1_CONFIG</displayName>
          <description></description>
          <addressOffset>0x60</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>V_MIRROR</name>
              <description>
              set 1 to do vertical mirror for the layer
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ALPHA_BLEND</name>
              <description>
              set 1 to enable alpha blending mode. Use layer alpha as blending factor for image with Alpha.
              Alpha_out = Layer_alpha * Image_alpha
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ACTIVE</name>
              <description>
              layer active flag
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LINE_FETCH_MODE</name>
              <description>
              line fetch mode
              0: address skip every single line
              1: address skip every two line
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PREFETCH_EN</name>
              <description>
              preload 64 bytes extra data when reading pixel from memory
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>WIDTH</name>
              <description>
              source image width(including padding), unit is bytes
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>13</bitWidth>
            </field>
            <field>
              <name>FILTER_EN</name>
              <description>
              layer color filter enable
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ALPHA</name>
              <description>
              layer alpha value
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>ALPHA_SEL</name>
              <description>
              alpha selection
              1'b0: select alpha according to image format
              1'b1: select layer alpha
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FORMAT</name>
              <description>
              overlay layer input format
              3'h0: RGB565
              3'h1: RGB888
              3'h2: ARGB8888
              3'h3: ARGB8565
              3'h4: RGB332
              3'h5: A8
              3'h6: L8
              others: reserved
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>LAYER1_TL_POS</name>
          <displayName>LAYER1_TL_POS</displayName>
          <description></description>
          <addressOffset>0x64</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>Y0</name>
              <description>
              Coordingate Y-value
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>X0</name>
              <description>
              Coordinate X-value
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>LAYER1_BR_POS</name>
          <displayName>LAYER1_BR_POS</displayName>
          <description></description>
          <addressOffset>0x68</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>Y1</name>
              <description>
              Coordingate Y-value
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>X1</name>
              <description>
              Coordinate X-value
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>LAYER1_FILTER</name>
          <displayName>LAYER1_FILTER</displayName>
          <description></description>
          <addressOffset>0x6c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>FILTER_MASK</name>
              <description>
              layer color filter mask
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>FILTER_R</name>
              <description>
              filter r color
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>FILTER_G</name>
              <description>
              filter g color
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>FILTER_B</name>
              <description>
              filter b color
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>LAYER1_SRC</name>
          <displayName>LAYER1_SRC</displayName>
          <description></description>
          <addressOffset>0x70</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ADDR</name>
              <description>
              source image RGB data address[31:0]. For RGB565 format, address should be aligned to halfword. For ARGB8888 format, address should be aligned to word.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>LAYER1_FILL</name>
          <displayName>LAYER1_FILL</displayName>
          <description></description>
          <addressOffset>0x74</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>ENDIAN</name>
              <description>
              input 565 data format endian
              0: {R[4:0], G[5:3], G[2:0], B[4:0]}
              1: {G[2:0], R[4:0], B[4:0], G[5:3]}
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BG_MODE</name>
              <description>
              not used
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BG_R</name>
              <description>
              background r color
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>BG_G</name>
              <description>
              background g color
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>BG_B</name>
              <description>
              background b color
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DITHER_CONF</name>
          <displayName>DITHER_CONF</displayName>
          <description></description>
          <addressOffset>0x78</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>19</bitWidth>
            </field>
            <field>
              <name>LFSR_LOAD</name>
              <description>
              load lfsr init value
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LFSR_LOAD_SEL</name>
              <description>
              select lfsr
              0: none
              1: red
              2: green
              3: blue
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>W_R</name>
              <description>
              red dither width
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>W_G</name>
              <description>
              green dither width
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>W_B</name>
              <description>
              blue dither width
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>EN</name>
              <description>
              dither enable
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DITHER_LFSR</name>
          <displayName>DITHER_LFSR</displayName>
          <description></description>
          <addressOffset>0x7c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>INIT_VAL</name>
              <description>
              lfsr init load value
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>LCD_CONF</name>
          <displayName>LCD_CONF</displayName>
          <description></description>
          <addressOffset>0x80</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>13</bitWidth>
            </field>
            <field>
              <name>ENDIAN</name>
              <description>
              LCD 565 data format endian, this bit would affect SPI, DPI, DBI and AHB interface 565 format
              0: {R[4:0], G[5:3], G[2:0], B[4:0]}
              1: {G[2:0], R[4:0], B[4:0], G[5:3]}
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DIRECT_INTF_EN</name>
              <description>
              when the target LCD is AHB LCD, this bit enable the direct interface to DSI module. Direct interface has higher bandwidth and speed than AHB interface.
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>JDI_SER_FORMAT</name>
              <description>
              JDI serial format
              2'b00: 3-bit mode
              2'b01: 4-bit mode
              2'b10: 1-bit mode
              2'b11: reserved
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>DPI_LCD_FORMAT</name>
              <description>
              DPI LCD format
              3'b000: 16-bit conf1
              3'b001: 16-bit conf2
              3'b010: 16-bit conf3
              3'b011: 18-bit conf1
              3'b100: 18-bit conf2
              3'b101: 24-bit
              others: Reserved
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>SPI_LCD_FORMAT</name>
              <description>
              SPI LCD format
              2'b00: 8-bit RGB 3:3:2
              2'b01: 16-bit RGB 5:6:5
              2'b10: 24-bit RGB 8:8:8
              2'b11: Reserved
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>AHB_FORMAT</name>
              <description>
              AHB LCD/RAM output format:
              0: RGB565
              1: RGB888
              2: ARGB8888
              3: RGB332
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>LCD_FORMAT</name>
              <description>
              LCD output format:
              3'b000: 8-bit RGB 3:3:2
              3'b001: 16-bit RGB 5:6:5 over 8-bit bus, 2 cycles/pixel
              3'b010: 12-bit RGB 4:4:4
              3'b011: 16-bit RGB 5:6:5
              3'b100: 18-bit RGB 6:6:6
              3'b101: 24-bit RGB 8:8:8
              3'b110: 24-bit RGB 8:8:8 over 16-bit bus, 1.5 cycles/pixel
              3'b111: 24-bit RGB 8:8:8 over 8-bit bus, 3cycles/pixel
              others: Reserved
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>LCD_INTF_SEL</name>
              <description>
              3'b000: 8080 DBI Type B
              3'b001: SPI interface
              3'b010: DBI to DSI interface
              3'b011: DPI interface
              3'b100: JDI serial interface
              3'b101: JDI parallel interface
              3'b110: 8080 DBI Type A
              3'b111: DPI to DSI interface
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>TARGET_LCD</name>
              <description>
              The Data can be sent to four destinations:
              2'b00: LCD panel 0
              2'b01: LCD panel 1
              2'b10: AHB LCD
              2'b11: AHB RAM
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>LCD_IF_CONF</name>
          <displayName>LCD_IF_CONF</displayName>
          <description></description>
          <addressOffset>0x84</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>CTRL_DLY_SET</name>
              <description>
              if this bit is set to 1,  LCD control output will be delayed for 1 lcdc clock cycle
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DO_DLY_SET</name>
              <description>
              if this bit is set to 1,  LCD data output will be delayed for 1 lcdc clock cycle
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LCD_RSTB</name>
              <description>
              LCD RSTB pin, direct to output
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RD_POL</name>
              <description>
              LCD RD pin polarity. RD is 0 for write operation, 1 for idle if polarity bit is set as 0. RD bit definition is opposite if polarity bit is set as 1.
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>WR_POL</name>
              <description>
              LCD WR pin polarity. WR is 0 for write operation, 1 for idle if polarity bit is set as 0. WR bit definition is opposite if polarity bit is set as 1.
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RS_POL</name>
              <description>
              LCD RS pin polarity. RS is 1 for data access, 0 for command access if polarity bit is set as 0. RS bit definition is opposite if polarity bit is set as 1.
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CS1_POL</name>
              <description>
              LCD0 CS pin polarity. CS is 0 for LCD chip select if polarity bit is set as 0. CS bit definition is opposite if polarity bit is set as 1.
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CS0_POL</name>
              <description>
              LCD1 CS pin polarity. CS is 0 for LCD chip select if polarity bit is set as 0. CS bit definition is opposite if polarity bit is set as 1.
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PWH</name>
              <description>
              inactive cycles of LCD_WR/LCD_RD for consecutive write/read operation
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>PWL</name>
              <description>
              active cycles of LCD_WR/LCD_RD
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>TAH</name>
              <description>
              hold cycles, delay from LCD_WR/LCD_RD inactive to LCD_CS inactive
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>TAS</name>
              <description>
              setup cycles, delay from LCD_CS active to LCD_WR/LCD_RD active
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>LCD_MEM</name>
          <displayName>LCD_MEM</displayName>
          <description></description>
          <addressOffset>0x88</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ADDR</name>
              <description>
              address for AHB LCD/AHB RAM
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>LCD_O_WIDTH</name>
          <displayName>LCD_O_WIDTH</displayName>
          <description></description>
          <addressOffset>0x8c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>OFFSET</name>
              <description>
              AHB RAM address offset for each line
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>LCD_SINGLE</name>
          <displayName>LCD_SINGLE</displayName>
          <description></description>
          <addressOffset>0x90</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>28</bitWidth>
            </field>
            <field>
              <name>LCD_BUSY</name>
              <description>
              LCD/SPI LCD interface is busy for single access
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RD_TRIG</name>
              <description>
              Single read operation trigger
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>WR_TRIG</name>
              <description>
              Single write operation trigger
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TYPE</name>
              <description>
              LCD access type, this bit could affect all LCD interface including SPI, parellel and AHB
              1'b0: command
              1'b1: data
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>LCD_WR</name>
          <displayName>LCD_WR</displayName>
          <description></description>
          <addressOffset>0x94</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              LCD write data
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>LCD_RD</name>
          <displayName>LCD_RD</displayName>
          <description></description>
          <addressOffset>0x98</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              LCD read data
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_IF_CONF</name>
          <displayName>SPI_IF_CONF</displayName>
          <description></description>
          <addressOffset>0x9c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SPI_CLK_INIT</name>
              <description>
              SPI CLK idle state value
              1'h0: high
              1'h1: low
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SPI_CLK_POL</name>
              <description>
              SPI CLK polarity
              1'h0: normal
              1'h1: inverted
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SPI_CS_POL</name>
              <description>
              SPI CS polarity
              0: low active
              1: high active
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SPI_CS_AUTO_DIS</name>
              <description>
              1: SPI CS is automatically disabled after data transaction
              0: SPI CS is not disabled after data transaction
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SPI_CS_NO_IDLE</name>
              <description>
              1: SPI CS is always active during data transaction
              0: SPI CS is IDLE in wait state during data transaction
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SPI_CLK_AUTO_DIS</name>
              <description>
              1: SPI clock auto disable in wait state during data transaction
              0: SPI clock is always on in wait state during data transaction
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SPI_RD_MODE</name>
              <description>
              SPI read mode:
              1'b0: normal read. Send write request before read.
              1'b1: direct read. Read data without write request.
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>WR_LEN</name>
              <description>
              SPI write data length(single access)
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RD_LEN</name>
              <description>
              SPI read data length(single access)
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>LINE</name>
              <description>
              SPI line mode
              0: 4-line
              1: 4-line with 2 data line(support RGB565 and RGB888)
              2: 4-line with 4 data line(support RGB565 and RGB888)
              3: reserved
              4: 3-line 
              5: 3-line with 2 data line(support RGB565 and RGB888)
              6: 3-line with 4 data line(support RGB565 and RGB888)
              7: reserved
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>DUMMY_CYCLE</name>
              <description>
              SPI transaction dummy cycle
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>CLK_DIV</name>
              <description>
              SPI clock divider
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>WAIT_CYCLE</name>
              <description>
              SPI line wait cycle, wait cycle is after each line and is according to SPI clock. 0 refers to no wait cycle.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TE_CONF</name>
          <displayName>TE_CONF</displayName>
          <description></description>
          <addressOffset>0xa0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
            <field>
              <name>FMARK_SOURCE</name>
              <description>
              TE signal source
              1: use TE signal from DSI
              0: use TE signal from external pin
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FMARK_MODE</name>
              <description>
              TE signal trigger mode
              1: edge trigger
              0: pulse trigger
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>VSYNC_DET_CNT</name>
              <description>
              vsync signal detect counter, used for mode 1 to detect vsync signal
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>MODE</name>
              <description>
              0: vsync only TE mode 
              1: vsync+hsync TE mode
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FMARK_POL</name>
              <description>
              TE signal polarity
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ENABLE</name>
              <description>
              TE enable
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TE_CONF2</name>
          <displayName>TE_CONF2</displayName>
          <description></description>
          <addressOffset>0xa4</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DLY_CNT</name>
              <description>
              TE delay counter
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DPI_IF_CONF1</name>
          <displayName>DPI_IF_CONF1</displayName>
          <description></description>
          <addressOffset>0xa8</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>HSW</name>
              <description>
              dpi hsync width
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>VSH</name>
              <description>
              dpi vsync height
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DPI_IF_CONF2</name>
          <displayName>DPI_IF_CONF2</displayName>
          <description></description>
          <addressOffset>0xac</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>HBP</name>
              <description>
              horizontal back porch
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>VBP</name>
              <description>
              vertical back porch
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DPI_IF_CONF3</name>
          <displayName>DPI_IF_CONF3</displayName>
          <description></description>
          <addressOffset>0xb0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>HFP</name>
              <description>
              horizontal front porch
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>VFP</name>
              <description>
              vertical front porch
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DPI_IF_CONF4</name>
          <displayName>DPI_IF_CONF4</displayName>
          <description></description>
          <addressOffset>0xb4</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>HAW</name>
              <description>
              horizontal active width
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>VAH</name>
              <description>
              vertical active height
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DPI_IF_CONF5</name>
          <displayName>DPI_IF_CONF5</displayName>
          <description></description>
          <addressOffset>0xb8</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>CLK_FORCE_ON</name>
              <description>
              1: force DPI clock on
              0: DPI clock is controlled by hardware
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>INT_LINE_NUM</name>
              <description>
              DPI interrupt line number
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
            <field>
              <name>HSPOL</name>
              <description>
              hsync polarity
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>VSPOL</name>
              <description>
              vsync polarity
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DEPOL</name>
              <description>
              de polarity
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PCLKPOL</name>
              <description>
              pixel clock polarity
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PCLK_DIV</name>
              <description>
              pixel clock divider
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DPI_CTRL</name>
          <displayName>DPI_CTRL</displayName>
          <description></description>
          <addressOffset>0xbc</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>28</bitWidth>
            </field>
            <field>
              <name>DPI_UC</name>
              <description>
              dpi update config
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DPI_SD</name>
              <description>
              dpi shutdown
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DPI_CM</name>
              <description>
              dpi color mode
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DPI_EN</name>
              <description>
              dpi interface enable
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DPI_STAT</name>
          <displayName>DPI_STAT</displayName>
          <description></description>
          <addressOffset>0xc0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>VPOS</name>
              <description>
              dpi vertical position
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>HSTAT</name>
              <description>
              horizontal status
              0: idle
              1: prep
              2: hsync
              3: hbp
              4: hact
              5: hfp
              6: wait
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>HPOS</name>
              <description>
              dpi horizontal position
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>JDI_SER_CONF1</name>
          <displayName>JDI_SER_CONF1</displayName>
          <description></description>
          <addressOffset>0xc4</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>CLK_DIV</name>
              <description>
              jdi serial clock divider
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>WR_LEN</name>
              <description>
              jdi single write bit length
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>JDI_SER_CONF2</name>
          <displayName>JDI_SER_CONF2</displayName>
          <description></description>
          <addressOffset>0xc8</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>INIT_LINE_CNT</name>
              <description>
              jdi serial init line counter
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>WR_CMD</name>
              <description>
              jdi serial data transfer write command
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>JDI_SER_CTRL</name>
          <displayName>JDI_SER_CTRL</displayName>
          <description></description>
          <addressOffset>0xcc</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>30</bitWidth>
            </field>
            <field>
              <name>EXTCOMIN</name>
              <description>
              jdi serial interface extcomin control
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DISP</name>
              <description>
              jdi serial interface disp control
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>JDI_PAR_CONF1</name>
          <displayName>JDI_PAR_CONF1</displayName>
          <description></description>
          <addressOffset>0xd0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>MAX_LINE</name>
              <description>
              jdi parallel interface max line, line number start from 0
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>MAX_COL</name>
              <description>
              jdi parallel interface max column, column number start from 0
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>JDI_PAR_CONF2</name>
          <displayName>JDI_PAR_CONF2</displayName>
          <description></description>
          <addressOffset>0xd4</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ST_LINE</name>
              <description>
              jdi parallel interface start line, line number start from 0
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>END_LINE</name>
              <description>
              jdi parallel interface end line, line number start from 0
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>JDI_PAR_CONF3</name>
          <displayName>JDI_PAR_CONF3</displayName>
          <description></description>
          <addressOffset>0xd8</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ST_COL</name>
              <description>
              jdi parallel interface start column, column number start from 0
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>END_COL</name>
              <description>
              jdi parallel interface end column, column number start from 0
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>JDI_PAR_CONF4</name>
          <displayName>JDI_PAR_CONF4</displayName>
          <description></description>
          <addressOffset>0xdc</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>HCK_WIDTH</name>
              <description>
              jdi parallel interface HCK width, HSK width = lcd_ck_cycle * HCK_WIDTH
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>HST_WIDTH</name>
              <description>
              jdi parallel interface HST width, HST width = lcd_ck_cycle * HST_WIDTH
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>JDI_PAR_CONF5</name>
          <displayName>JDI_PAR_CONF5</displayName>
          <description></description>
          <addressOffset>0xe0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>VCK_WIDTH</name>
              <description>
              jdi parallel interface VCK width, VCK width = lcd_ck_cycle * VCK_WIDTH
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>VST_WIDTH</name>
              <description>
              jdi parallel interface VST width, VST width = lcd_ck_cycle * VST_WIDTH
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>JDI_PAR_CONF6</name>
          <displayName>JDI_PAR_CONF6</displayName>
          <description></description>
          <addressOffset>0xe4</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>VCK_DLY</name>
              <description>
              jdi parallel interface VST to VCK delay, VST2VCK delay = lcd_ck_cycle * VCK_DLY
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>HST_DLY</name>
              <description>
              jdi parallel interface VCK to HST delay, VCK2HST delay = lcd_ck_cycle * HST_DLY
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>JDI_PAR_CONF7</name>
          <displayName>JDI_PAR_CONF7</displayName>
          <description></description>
          <addressOffset>0xe8</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>15</bitWidth>
            </field>
            <field>
              <name>DP_MODE</name>
              <description>
              double pixel mode. Some jdi parallel screens use large pixel+small pixel structure. Set this bit to 1 to support this structure.
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HCK_DLY</name>
              <description>
              jdi parallel interface HST to HCK delay
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>JDI_PAR_CTRL</name>
          <displayName>JDI_PAR_CTRL</displayName>
          <description></description>
          <addressOffset>0xec</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>INT_LINE_NUM</name>
              <description>
              jdi parallel interface interrupt line number, line number start from 0.
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>VSTPOL</name>
              <description>
              jdi parallel vst polarity
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>VCKPOL</name>
              <description>
              jdi parallel vck polarity
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HSTPOL</name>
              <description>
              jdi parallel hst polarity
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HCKPOL</name>
              <description>
              jdi parallel hck polarity
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ENBPOL</name>
              <description>
              jdi parallel enb polarity
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>XRST</name>
              <description>
              jdi parallel interface XRST
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>ENABLE</name>
              <description>
              jdi parallel interface enable
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>JDI_PAR_STAT</name>
          <displayName>JDI_PAR_STAT</displayName>
          <description></description>
          <addressOffset>0xf0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>VPOS</name>
              <description>
              jdi parallel vertical position
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>HPOS</name>
              <description>
              jdi parallel horizontal position
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>JDI_PAR_EX_CTRL</name>
          <displayName>JDI_PAR_EX_CTRL</displayName>
          <description></description>
          <addressOffset>0xf4</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>VCOM</name>
              <description>
              VCOM value
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FRP</name>
              <description>
              FRP value
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>XFRP</name>
              <description>
              XFRP value
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CNT_EN</name>
              <description>
              VCOM/FRP/XFRP counter enable
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>MAX_CNT</name>
              <description>
              VCOM/FRP/XFRP max counter
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>JDI_PAR_CONF8</name>
          <displayName>JDI_PAR_CONF8</displayName>
          <description></description>
          <addressOffset>0xf8</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ENB_ST_COL</name>
              <description>
              jdi parallel interface enb start column, column number start from 0
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>ENB_END_COL</name>
              <description>
              jdi parallel interface enb end column, column number start from 0
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>JDI_PAR_CONF9</name>
          <displayName>JDI_PAR_CONF9</displayName>
          <description></description>
          <addressOffset>0xfc</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ENB_ST_LINE</name>
              <description>
              jdi parallel interface enb start line, line number start from 0
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>ENB_END_LINE</name>
              <description>
              jdi parallel interface enb end line, line number start from 0
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>JDI_PAR_CONF10</name>
          <displayName>JDI_PAR_CONF10</displayName>
          <description></description>
          <addressOffset>0x100</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>HC_ST_LINE</name>
              <description>
              jdi parallel interface horizontal control start line, line number start from 0
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>HC_END_LINE</name>
              <description>
              jdi parallel interface horizontal control end line, line number start from 0
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD1</name>
          <displayName>RSVD1</displayName>
          <description></description>
          <addressOffset>0x104</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>CANVAS_STAT0</name>
          <displayName>CANVAS_STAT0</displayName>
          <description></description>
          <addressOffset>0x110</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>Y_COR</name>
              <description>
              canvas y cordinate
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>X_COR</name>
              <description>
              canvas x cordinate
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CANVAS_STAT1</name>
          <displayName>CANVAS_STAT1</displayName>
          <description></description>
          <addressOffset>0x114</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>FETCH_STAT</name>
              <description>
              fetch status
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>PREC_STAT</name>
              <description>
              prec status
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>POSTC_STAT</name>
              <description>
              postc_status
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>FIFO_CNT</name>
              <description>
              pre calc fifo count
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>OL0_STAT</name>
          <displayName>OL0_STAT</displayName>
          <description></description>
          <addressOffset>0x118</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>SC_LB0</name>
              <description>
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>SC_LB1</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>SC_FE</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>SC_BE</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>SC_OUT</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>PF_PR</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>PF_DF</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>DATA_CONV</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>PREFETCH_READ</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>PREFETCH_OUT</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DONE_REQ</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>OL1_STAT</name>
          <displayName>OL1_STAT</displayName>
          <description></description>
          <addressOffset>0x11c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>21</bitWidth>
            </field>
            <field>
              <name>PF_PR</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>PF_DF</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>DATA_CONV</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>PREFETCH_READ</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>PREFETCH_OUT</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DONE_REQ</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>MEM_IF_STAT</name>
          <displayName>MEM_IF_STAT</displayName>
          <description></description>
          <addressOffset>0x120</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>22</bitWidth>
            </field>
            <field>
              <name>ARB_MAIN</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>ARB_READ_PORT</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>AHB</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PERF_CNT</name>
          <displayName>PERF_CNT</displayName>
          <description></description>
          <addressOffset>0x124</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>VAL</name>
              <description>
              lcdc performance counter
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>I2S1</name>
      <description></description>
      <groupName>I2S</groupName>
      <baseAddress>0x40009000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>RSVD41</name>
          <displayName>RSVD41</displayName>
          <description></description>
          <addressOffset>0x0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>TX_PCM_FORMAT</name>
          <displayName>TX_PCM_FORMAT</displayName>
          <description></description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000010</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>26</bitWidth>
            </field>
            <field>
              <name>TRACK_FLAG</name>
              <description>
              0: stereo
              1: mono
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DW</name>
              <description>
              tx source pcm data width N(N>=8)
              common value is 8,13,14,16,18,20,22,24
              This data width indicate the tx fifo output data width.
              When writing to tx fifo, please refer to following format:
                  Mono 8 bit: fifo_data[31:0] = {L3,L2,L1,L0}, each word contains 4 samples, so four samples need read one word
                  Stereo 8 bit: fifo_data[31:0] = { R1,L1,R0,L0 }, each word contains 2 samples, so two samples need read one word
                  Mono 13/14/16 bit: fifo_data[31:0] = {L1,L0}, each word contains 2 samples, so two samples need read one word
                  Stereo 13/14/16 bit: fifo_data[31:0] = {R0,L0}, each word contains 1 samples, so each sample need read one word
                  Mono 18/20/22/24 bit: fifo_data[31:0] = L0, each word contains 1 samples, so each sample need read one word 
                  Stereo 18/20/22/24 bit: fifo_data[31:0][0] = {L0}, fifo_data[31:0][1]={R0}, each 2 words contain 1 samples, so each sample need read two word
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD40</name>
          <displayName>RSVD40</displayName>
          <description></description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>TX_PCM_SAMPLE_CLK</name>
          <displayName>TX_PCM_SAMPLE_CLK</displayName>
          <description></description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x000000FA</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>19</bitWidth>
            </field>
            <field>
              <name>FS_DUTY</name>
              <description>
              source PCM sample clock duty cycle(with GCLK=12MHz):
              250 for 48K FS
              272 for 44.1K FS
              375 for 32K FS
              500 for 24K FS
              544 for 22.05K FS
              750 for 16K FS
              1000 for 12K FS
              1088 for 11.025K FS
              1500 for 8K FS
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>13</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD39</name>
          <displayName>RSVD39</displayName>
          <description></description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>TX_RS_SMOOTH</name>
          <displayName>TX_RS_SMOOTH</displayName>
          <description></description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>31</bitWidth>
            </field>
            <field>
              <name>EN</name>
              <description>
              0: Disable TX re-sample smooth filter
              1: Enable TX re-sample smooth filter
              This function is not implemented.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD38</name>
          <displayName>RSVD38</displayName>
          <description></description>
          <addressOffset>0x34</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>TX_PCM_CH_SEL</name>
          <displayName>TX_PCM_CH_SEL</displayName>
          <description></description>
          <addressOffset>0x40</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>28</bitWidth>
            </field>
            <field>
              <name>LEFT_CHANNEL_SEL</name>
              <description>
              TX re-sampling module setting:
              00: TX left = source left
              01: TX left = source right
              10,11: TX left = (source left + source right)/2
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RIGHT_CHANNEL_SEL</name>
              <description>
              TX re-sampling module setting:
              00: TX right = source right
              01: TX right = source left
              10,11: TX right = (source left + source right)/2
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD37</name>
          <displayName>RSVD37</displayName>
          <description></description>
          <addressOffset>0x44</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>TX_VOL_CTRL</name>
          <displayName>TX_VOL_CTRL</displayName>
          <description></description>
          <addressOffset>0x50</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0000000F</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>28</bitWidth>
            </field>
            <field>
              <name>VOL</name>
              <description>
              volume control:
              0000: +6dB,    0001: +4.5dB,
              0010: +3dB,    0011: +1.5dB,
              0100: 0dB,     0101: -1.5dB,
              0110: -3.0dB,  0111: -4.5dB,
              1000: -6.0dB,  1001: -7.5dB,
              1010: -9dB,    1011: -10.5dB,
              1100: -12dB,   1101: -13.5dB,
              1110: -15dB,   1111: mute
              Note:
              1) +1.5db = 20log(1+1/4-1/16+1/1024)
              2) -1.5dB = 20log(1-1/8-1/32-1/512-1/2048)
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD36</name>
          <displayName>RSVD36</displayName>
          <description></description>
          <addressOffset>0x54</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>TX_LR_BAL_CTRL</name>
          <displayName>TX_LR_BAL_CTRL</displayName>
          <description></description>
          <addressOffset>0x60</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>26</bitWidth>
            </field>
            <field>
              <name>EN</name>
              <description>
              LR balance enable:
              00: both left and right in full volume
              10: left channel balance volume adjustment enable
              01: right channel balance volume adjustment enable
              11: reserved, still kepp left and right in full volume
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>BAL_VOL</name>
              <description>
              Balance volume control:
              0000: Reserved,  0001: -1.5dB,
              0010: -3.0dB,  0011: -4.5dB,
              0100: -6.0dB,  0101: -7.5dB,
              0110: -9.0dB,  0111: -10.5dB,
              1000: -12dB,   1001: -13.5dB,
              1010: -15dB,   1011: -16.5dB,
              1100: -18dB,   1101: -19.5dB,
              1110: -21dB,   1111: mute
              Note:
                1) bit[5:0] = 101111 for left mute
                2) bit[5:0] = 011111 for right mute
                3) bit[5:4] = 00 or 11, bit[3:0] is don't care
                4) +1.5db = 20log(1+1/4-1/16+1/1024)
                5) -1.5dB = 20log(1-1/8-1/32-1/512-1/2048)
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD35</name>
          <displayName>RSVD35</displayName>
          <description></description>
          <addressOffset>0x64</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>AUDIO_TX_LRCK_DIV</name>
          <displayName>AUDIO_TX_LRCK_DIV</displayName>
          <description></description>
          <addressOffset>0x70</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x007D007D</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>DUTY_HIGH</name>
              <description>
              TX LRCK duty cycle high:
              125 for 48K FS
              136 for 44.1K FS
              185 for 32K FS
              250 for 24K FS
              272 for 22.05K FS
              375 for 16K FS
              500 for 12K FS
              544 for 11.025K FS
              750 for 8K FS      
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>DUTY_LOW</name>
              <description>
              TX LRCK duty cycle low:
              125 for 48K FS
              136 for 44.1K FS
              190 for 32K FS
              250 for 24K FS
              272 for 22.05K FS
              375 for 16K FS
              500 for 12K FS
              544 for 11.025K FS
              750 for 8K FS
              Note:
              1)duty_cycle = 12M/FS
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD34</name>
          <displayName>RSVD34</displayName>
          <description></description>
          <addressOffset>0x74</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>AUDIO_TX_BCLK_DIV</name>
          <displayName>AUDIO_TX_BCLK_DIV</displayName>
          <description></description>
          <addressOffset>0x80</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>26</bitWidth>
            </field>
            <field>
              <name>DUTY</name>
              <description>
              TX serial bit clock duty cycle
              5 for 48K FS
              4 for 44.1K FS
              5 for 32KFS
              10 for 24K FS
              8 for 22.05K FS
              15 for 16K FS
              20 for 12K FS
              16 for 11.025K FS
              30 for 8KFs
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD33</name>
          <displayName>RSVD33</displayName>
          <description></description>
          <addressOffset>0x84</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>AUDIO_TX_FORMAT</name>
          <displayName>AUDIO_TX_FORMAT</displayName>
          <description></description>
          <addressOffset>0x90</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>27</bitWidth>
            </field>
            <field>
              <name>PCM_DATA_WIDTH</name>
              <description>
              I2S out pcm data width
              M >= 16,
              common value: 16, 18, 20, 22, 24
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD32</name>
          <displayName>RSVD32</displayName>
          <description></description>
          <addressOffset>0x94</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>AUDIO_SERIAL_TIMING</name>
          <displayName>AUDIO_SERIAL_TIMING</displayName>
          <description></description>
          <addressOffset>0xa0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>28</bitWidth>
            </field>
            <field>
              <name>LRCK_POL</name>
              <description>
              TX LRCK polarity control.
              0: disable TX_LRCK inventor
              1: enable TX_LRCK inventor
              for standard I2S, set tx_lrck_pol to low
              for Left/Right Justified, set tx_lrck_pol to hgih
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SLAVE_EN</name>
              <description>
              audio code transmit mode select.
              0: master mode, 1: slave mode
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TIMING</name>
              <description>
              00: I2S mode
              01: Left justified
              10: right justified
              11: reserved
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD31</name>
          <displayName>RSVD31</displayName>
          <description></description>
          <addressOffset>0xA4</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>AUDIO_TX_FUNC_EN</name>
          <displayName>AUDIO_TX_FUNC_EN</displayName>
          <description></description>
          <addressOffset>0xb0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>30</bitWidth>
            </field>
            <field>
              <name>TX_INTF_SEL</name>
              <description>
              1: select external tx interface  0: select internal apb tx interface
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TX_EN</name>
              <description>
              1: enable 0:disable
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD30</name>
          <displayName>RSVD30</displayName>
          <description></description>
          <addressOffset>0xB4</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>AUDIO_TX_PAUSE</name>
          <displayName>AUDIO_TX_PAUSE</displayName>
          <description></description>
          <addressOffset>0xc0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>31</bitWidth>
            </field>
            <field>
              <name>TX_PAUSE</name>
              <description>
              TX pause control when tx_enable = 1.
              1: pause
              0: TX work
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD29</name>
          <displayName>RSVD29</displayName>
          <description></description>
          <addressOffset>0xC4</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>AUDIO_I2S_SL_MERGE</name>
          <displayName>AUDIO_I2S_SL_MERGE</displayName>
          <description></description>
          <addressOffset>0xc8</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>31</bitWidth>
            </field>
            <field>
              <name>SLAVE_TIMING_MERGE</name>
              <description>
              when work as an I2S slave, and external I2S master TX/RX share an only BCLK/LRCK, we need set this bit high.
              0: I2S slave use separated timing control port. TX_BCLK_IN/TX_LRCK_IN and RX_BCLK/RX_LRCK_IN are separated.
              1: I2S slave use the same BCLK/LRCK, the TX_BCLK_IN/TX_LRCK also is used for RX controller.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD28</name>
          <displayName>RSVD28</displayName>
          <description></description>
          <addressOffset>0xCC</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>AUDIO_RX_FUNC_EN</name>
          <displayName>AUDIO_RX_FUNC_EN</displayName>
          <description></description>
          <addressOffset>0x100</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>30</bitWidth>
            </field>
            <field>
              <name>RX_INTF_SEL</name>
              <description>
              1: select external rx interface  0: select internal apb rx interface
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RX_EN</name>
              <description>
              1: enable  0: disable
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD27</name>
          <displayName>RSVD27</displayName>
          <description></description>
          <addressOffset>0x104</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>AUDIO_RX_PAUSE</name>
          <displayName>AUDIO_RX_PAUSE</displayName>
          <description></description>
          <addressOffset>0x110</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>31</bitWidth>
            </field>
            <field>
              <name>RX_PAUSE</name>
              <description>
              RX pause control when rx_enable = 1.
              1: pause
              0: RX work
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD26</name>
          <displayName>RSVD26</displayName>
          <description></description>
          <addressOffset>0x114</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>AUDIO_RX_SERIAL_TIMING</name>
          <displayName>AUDIO_RX_SERIAL_TIMING</displayName>
          <description></description>
          <addressOffset>0x120</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00040000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>28</bitWidth>
            </field>
            <field>
              <name>LRCK_POL</name>
              <description>
              RX LRCK polarity control.
              0: disable RX_LRCK inventor
              1: enable RX_LRCK inventor
              for standard I2S, set tx_lrck_pol to low
              for Left/Right Justified, set tx_lrck_pol to hgih
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SLAVE_EN</name>
              <description>
              audio code receiver mode select.
              0: master mode, 1: slave mode
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TIMING</name>
              <description>
              00: I2S
              01: Left justified
              10: right justified
              11: reserved
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD25</name>
          <displayName>RSVD25</displayName>
          <description></description>
          <addressOffset>0x124</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>AUDIO_RX_PCM_DW</name>
          <displayName>AUDIO_RX_PCM_DW</displayName>
          <description></description>
          <addressOffset>0x130</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000010</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>27</bitWidth>
            </field>
            <field>
              <name>PCM_DATA_WIDTH</name>
              <description>
              For I2S and left justified mode, M can be 8,13,14,16
              For right justified mode, M can be 8, 13, 14, 16, 18, 20, 22, 24
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD24</name>
          <displayName>RSVD24</displayName>
          <description></description>
          <addressOffset>0x134</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>AUDIO_RX_LRCK_DIV</name>
          <displayName>AUDIO_RX_LRCK_DIV</displayName>
          <description></description>
          <addressOffset>0x140</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x007D007D</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>DUTY_HIGH</name>
              <description>
              RX LRCK duty cycle high:
              125 for 48K FS
              136 for 44.1K FS
              185 for 32K FS
              250 for 24K FS
              272 for 22.05K FS
              375 for 16K FS
              500 for 12K FS
              544 for 11.025K FS
              750 for 8K FS      
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>DUTY_LOW</name>
              <description>
              RX LRCK duty cycle low:
              125 for 48K FS
              136 for 44.1K FS
              190 for 32K FS
              250 for 24K FS
              272 for 22.05K FS
              375 for 16K FS
              500 for 12K FS
              544 for 11.025K FS
              750 for 8K FS
              Note:
              1)duty_cycle = 12M/FS
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD23</name>
          <displayName>RSVD23</displayName>
          <description></description>
          <addressOffset>0x144</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>AUDIO_RX_BCLK_DIV</name>
          <displayName>AUDIO_RX_BCLK_DIV</displayName>
          <description></description>
          <addressOffset>0x150</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000005</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>22</bitWidth>
            </field>
            <field>
              <name>DUTY</name>
              <description>
              RX serial bit clock duty cycle
              5 for 48K FS
              4 for 44.1K FS
              5 for 32KFS
              10 for 24K FS
              8 for 22.05K FS
              15 for 16K FS
              20 for 12K FS
              16 for 11.025K FS
              30 for 8KFs
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD22</name>
          <displayName>RSVD22</displayName>
          <description></description>
          <addressOffset>0x154</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>RECORD_DATA_SEL</name>
          <displayName>RECORD_DATA_SEL</displayName>
          <description></description>
          <addressOffset>0x160</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>31</bitWidth>
            </field>
            <field>
              <name>RS_DATA_SEL</name>
              <description>
              0: I2S audio recording  1: BT recording
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD21</name>
          <displayName>RSVD21</displayName>
          <description></description>
          <addressOffset>0x164</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>RX_RE_SAMPLE_CLK_DIV</name>
          <displayName>RX_RE_SAMPLE_CLK_DIV</displayName>
          <description></description>
          <addressOffset>0x170</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0000007D</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>19</bitWidth>
            </field>
            <field>
              <name>RS_DUTY</name>
              <description>
              source PCM sample clock duty cycle:
              250 for 48K FS
              272 for 44.1K FS
              375 for 32K FS
              500 for 24K FS
              544 for 22.05K FS
              750 for 16K FS
              1000 for 12K FS
              1088 for 11.025K FS
              1500 for 8K FS
              Note:
              1)duty_cycle = 12M/FS      
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>13</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD20</name>
          <displayName>RSVD20</displayName>
          <description></description>
          <addressOffset>0x174</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>RX_RE_SAMPLE</name>
          <displayName>RX_RE_SAMPLE</displayName>
          <description></description>
          <addressOffset>0x180</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>31</bitWidth>
            </field>
            <field>
              <name>SMOOTH_EN</name>
              <description>
              0: Disable RX re-sample smooth filter
              1: Enable RX re-sample smooth filter
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD19</name>
          <displayName>RSVD19</displayName>
          <description></description>
          <addressOffset>0x184</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>RECORD_FORMAT</name>
          <displayName>RECORD_FORMAT</displayName>
          <description></description>
          <addressOffset>0x190</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>30</bitWidth>
            </field>
            <field>
              <name>TRACK</name>
              <description>
              1: mono recording, 0: stereo recording
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DW</name>
              <description>
              0: 8bit 1: 16bit
              RX fifo data format:
                  Mono 8 bit (unsigned): RX FIFO_DIN[31:0] = {L3,L2,L1,L0}, each four samples need one FIFO write operation
                  Stereo 8 bit (unsigned): RX_FIFO_DIN[31:0] = {R1,L1,R0,L0}, each tow samples need one FIFO write operation
                  Mono 16 bit (Signed 2's complement): RX_FIFO_DIN[31:0] = {L1,L0}, each two samples need one FIFO write operation
                  Stereo 16 bit (Signed 2's complement): RX_FIFO_DIN[31:0] = {R0,L0}, each sample need one FIFO write operation
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD18</name>
          <displayName>RSVD18</displayName>
          <description></description>
          <addressOffset>0x194</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>RX_CH_SEL</name>
          <displayName>RX_CH_SEL</displayName>
          <description></description>
          <addressOffset>0x1a0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>28</bitWidth>
            </field>
            <field>
              <name>LEFT_CHANNEL_SEL</name>
              <description>
              RX re-sampling module setting:
              00: RD left = RX left
              01: RD left = RX right
              10,11: RD left = (RX left + RX right)/2
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RIGHT_CHANNEL_SEL</name>
              <description>
              RX re-sampling module setting:
              00: RD right = RX right
              01: RD right = RX left
              10,11: RD right = (RX left + RX right)/2
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD17</name>
          <displayName>RSVD17</displayName>
          <description></description>
          <addressOffset>0x1A4</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>BT_PHONE_CTRL</name>
          <displayName>BT_PHONE_CTRL</displayName>
          <description></description>
          <addressOffset>0x200</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>26</bitWidth>
            </field>
            <field>
              <name>BB_I2S_BPS_TO_CDC</name>
              <description>
              bypass baseband I2S interface to audio codec i2s interface
              0: no bypass, 1: bypass
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BT_PCM_IF_BPS</name>
              <description>
              bypass baseband PCM signals to BT VCI master:
              0: no bypass, 1: bypass
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BT_PATH_SEL</name>
              <description>
               BT path select
              0: digital path, 1: analog path
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BT_MIX_SMOOTH_FILTER_EN</name>
              <description>
              0: disable the smooth filter for background mixer
              1: enable the smooth filer for background mixer
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BT_BACK_MIX_EN</name>
              <description>
               background mixer enable
              0: disable, 1: enable
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BT_PH_EN</name>
              <description>
              BT phone enable
              0: disable, 1: enable
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD16</name>
          <displayName>RSVD16</displayName>
          <description></description>
          <addressOffset>0x204</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>BB_PCM_FORMAT</name>
          <displayName>BB_PCM_FORMAT</displayName>
          <description></description>
          <addressOffset>0x210</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>21</bitWidth>
            </field>
            <field>
              <name>PCM_CLK_POL</name>
              <description>
              input BB pcm clock polarity:
              0: rising edge for data transmitting, falling edge for data receiving
              1: rising edge for data receiving, falling edge for data transmitting
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>I2S_LRCK_POL</name>
              <description>
              0: no bb_i2s_lrck input inventor
              1: enable bb_i2s_lrck input inventor
              for standard I2S, set tx_lrck_pol to low
              for Left/Right Justified, set tx_lrck_pol to high
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PCM_LSB_FLAG</name>
              <description>
              Serial PCM data bit sequence.
              0: MSB first, 1: LSB first
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PCM_SYNC_FLAG</name>
              <description>
              0: short sync, 1: long sync
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PCM_TIM_SEL</name>
              <description>
              00: I2S timing, 01: Left Justified
              10: Right Justified, 11: PCM timing
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>PCM_DW</name>
              <description>
              Baseband Master PCM data width (>=8)
              Common value: 8, 13,14, 16, 18, 20, 22, 24.
              for I2S/Left Justified/Right Kistified timing, bb_pcm_dw >=16
              For PCM timing, only 8, 13, 14, 16 configure value is available.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD15</name>
          <displayName>RSVD15</displayName>
          <description></description>
          <addressOffset>0x214</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>BT_PCM_DW</name>
          <displayName>BT_PCM_DW</displayName>
          <description></description>
          <addressOffset>0x220</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000010</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>27</bitWidth>
            </field>
            <field>
              <name>DW</name>
              <description>
              BT PCM master data width (>= 8),
              common value: 8, 13,14, 16
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD14</name>
          <displayName>RSVD14</displayName>
          <description></description>
          <addressOffset>0x224</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>BT_PCM_TIMING</name>
          <displayName>BT_PCM_TIMING</displayName>
          <description></description>
          <addressOffset>0x230</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>29</bitWidth>
            </field>
            <field>
              <name>CLK_POL</name>
              <description>
              BT PCM master output pcm clock polarity:
              0: rising edge for data transmitting, falling edge for data receiving
              1: rising edge for data receiving, falling edge for data transmitting
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SYNC_FLAG</name>
              <description>
              0: short sync, 1: long sync
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LSB_FLAG</name>
              <description>
              Serial PCM data bit sequence.
              0: MSB first, 1: LSB first
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD13</name>
          <displayName>RSVD13</displayName>
          <description></description>
          <addressOffset>0x234</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>BT_PCM_CLK_DUTY</name>
          <displayName>BT_PCM_CLK_DUTY</displayName>
          <description></description>
          <addressOffset>0x240</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>22</bitWidth>
            </field>
            <field>
              <name>CLK_DUTY</name>
              <description>
              BT_PCM_CLK duty cycle
               lte  (GCLK/(bt_pcm_sync*bt_pcm_dw))
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD12</name>
          <displayName>RSVD12</displayName>
          <description></description>
          <addressOffset>0x244</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>BT_PCM_SYNC_DUTY</name>
          <displayName>BT_PCM_SYNC_DUTY</displayName>
          <description></description>
          <addressOffset>0x250</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>26</bitWidth>
            </field>
            <field>
              <name>SYNC_DUTY</name>
              <description>
              PCM_SYNC duty cycle  (bt_pcm_sync frequency =  bt_pclk_clk/bt_pcm_sync_duty)
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD11</name>
          <displayName>RSVD11</displayName>
          <description></description>
          <addressOffset>0x254</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>BT_VOL_CTRL</name>
          <displayName>BT_VOL_CTRL</displayName>
          <description></description>
          <addressOffset>0x260</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>28</bitWidth>
            </field>
            <field>
              <name>VOL_ADJ_EN</name>
              <description>
              BT volume adjust enable
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>VOL</name>
              <description>
              BT master volume
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD10</name>
          <displayName>RSVD10</displayName>
          <description></description>
          <addressOffset>0x264</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>INT_MASK</name>
          <displayName>INT_MASK</displayName>
          <description></description>
          <addressOffset>0x300</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000003</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>30</bitWidth>
            </field>
            <field>
              <name>TX_FIFO_INT_MASK</name>
              <description>
              Interrupt mask for TX FIFO pop underflow, high active
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RX_FIFO_INT_MASK</name>
              <description>
              Interrupt mask for RX FIFO push overflow, high active
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD9</name>
          <displayName>RSVD9</displayName>
          <description></description>
          <addressOffset>0x304</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>INT_STATUS</name>
          <displayName>INT_STATUS</displayName>
          <description></description>
          <addressOffset>0x310</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>30</bitWidth>
            </field>
            <field>
              <name>TX_FIFO_UNDERFLOW</name>
              <description>
              TX FIFO pop underflow
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RX_FIFO_OVERFLOW</name>
              <description>
              RX FIFO push overflow
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD8</name>
          <displayName>RSVD8</displayName>
          <description></description>
          <addressOffset>0x314</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>TX_DMA_ENTRY</name>
          <displayName>TX_DMA_ENTRY</displayName>
          <description></description>
          <addressOffset>0x400</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>TX_DMA_ENTRY</name>
              <description>
              TX DMA entry
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD7</name>
          <displayName>RSVD7</displayName>
          <description></description>
          <addressOffset>0x404</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>RX_DMA_ENTRY</name>
          <displayName>RX_DMA_ENTRY</displayName>
          <description></description>
          <addressOffset>0x440</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RX_DMA_ENTRY</name>
              <description>
              RX DMA entry
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD6</name>
          <displayName>RSVD6</displayName>
          <description></description>
          <addressOffset>0x444</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>DMA_MASK</name>
          <displayName>DMA_MASK</displayName>
          <description></description>
          <addressOffset>0x480</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000003</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>30</bitWidth>
            </field>
            <field>
              <name>TX_DMA_MASK</name>
              <description>
              TX DMA mask enable:1: mask0: do not mask
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RX_DMA_MASK</name>
              <description>
              RX DMA mask enable:1: mask0: do not mask
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD5</name>
          <displayName>RSVD5</displayName>
          <description></description>
          <addressOffset>0x484</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>DEBUG_LOOP</name>
          <displayName>DEBUG_LOOP</displayName>
          <description></description>
          <addressOffset>0x500</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>SP_CLK_DIV</name>
              <description>
              sp clock divider value
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
            <field>
              <name>SP_CLK_DIV_UPDATE</name>
              <description>
              update sp clock divider
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>SP_CLK_SEL</name>
              <description>
              clock select
              0: xtal clock
              1: pll clock
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>AD2DA_LOOP_BACK</name>
              <description>
              RX-->TX Loop debug control:
              0: disable
              1: enable, internally connect RX Resampled PCM to TX Resample PCM input
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DA2AD_LOOP_BACK</name>
              <description>
              TX-->RX Loop debug control:
              0: disable
              1: enable, internally connect TX SDTO to RX SDTI
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD4</name>
          <displayName>RSVD4</displayName>
          <description></description>
          <addressOffset>0x504</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>FIFO_STATUS</name>
          <displayName>FIFO_STATUS</displayName>
          <description></description>
          <addressOffset>0x600</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>FIFO_STATUS_OUT</name>
              <description>
              FIFO Status output:
               Bit [7:0] = {tx_full,tx_empty,tx_almost_full,tx_almost_empty,rx_full,rx_empty,rx_almost_full,rx_almost_empty}
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD3</name>
          <displayName>RSVD3</displayName>
          <description></description>
          <addressOffset>0x604</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>TX_EQUALIZER_EN</name>
          <displayName>TX_EQUALIZER_EN</displayName>
          <description></description>
          <addressOffset>0x700</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>31</bitWidth>
            </field>
            <field>
              <name>TX_EQUALIZER_EN</name>
              <description>
              0: Disable TX equalizer
              1: Enable TX equalizer
              equalizer is not implemented
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD2</name>
          <displayName>RSVD2</displayName>
          <description></description>
          <addressOffset>0x704</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>TX_EQUALIZER_GAIN1</name>
          <displayName>TX_EQUALIZER_GAIN1</displayName>
          <description></description>
          <addressOffset>0x710</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>BAND6_GAIN</name>
              <description>
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>BAND5_GAIN</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>BAND4_GAIN</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>BAND3_GAIN</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>BAND2_GAIN</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>BAND1_GAIN</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD1</name>
          <displayName>RSVD1</displayName>
          <description></description>
          <addressOffset>0x714</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>TX_EQUALIZER_GAIN2</name>
          <displayName>TX_EQUALIZER_GAIN2</displayName>
          <description></description>
          <addressOffset>0x720</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
            <field>
              <name>BAND10_GAIN</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>BAND9_GAIN</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>BAND8_GAIN</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>BAND7_GAIN</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>HPSYS_CFG</name>
      <description></description>
      <groupName>HPSYS_CFG</groupName>
      <baseAddress>0x4000b000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>BMR</name>
          <displayName>BMR</displayName>
          <description>Boot Mode Register</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>31</bitWidth>
            </field>
            <field>
              <name>BOOT_MODE</name>
              <description>
              0 - normal, 1 - download mode
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IDR</name>
          <displayName>IDR</displayName>
          <description>ID Register</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>SID</name>
              <description>
              Series ID
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>CID</name>
              <description>
              Chip ID
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>PID</name>
              <description>
              Package ID
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>REVID</name>
              <description>
              Revision ID
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SCR</name>
          <displayName>SCR</displayName>
          <description>Security Control Register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>31</bitWidth>
            </field>
            <field>
              <name>FKEY_MODE</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>USBCR</name>
          <displayName>USBCR</displayName>
          <description>USB Control register</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD1</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>RSVD0</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>DC_TR</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>DC_TE</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TX_RTUNE</name>
              <description>
              TX outp impedance tuning
              0 = 50 Ohm, 1 = 46 Ohm, 2 = 43 Ohm, 3 = 40 Ohm, 4 = 37.5 Ohm, 5 = 35 Ohm, 6 = 33 Ohm, 7 = 31.5 Ohm
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DP_EN</name>
              <description>
              0:disable dp pull up or pull down 1:enable dp pull or pull down
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DM_PD</name>
              <description>
              enable DM 15k Ohm pull down resistor 
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LDO_LP_EN</name>
              <description>
              2.5V LDO low power mode enable. 0 = 240 uA, 1 = 50 uA
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LDO_VSEL</name>
              <description>
              2.5V LDO output voltage setting
              0 = 2.40 V, 1 = 2.47 V, 2 = 2.53 V, 3 = 2.60 V, 4 = 2.60 V, 5 = 2.67 V, 6 = 2.73 V, 7 = 2.8 V
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>USB_EN</name>
              <description>
              USB PHY enable, turn on power swith, power up LDO and bias 
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>MCR</name>
          <displayName>MCR</displayName>
          <description>Memory Control register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>FORCE_ON</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
            <field>
              <name>PD_OTHER</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>PD_RAM3</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PD_RAM2</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PD_RAM1</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PD_RAM0</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PD_CACHE</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PD_ITCM</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PD_ROM</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ULPMCR</name>
          <displayName>ULPMCR</displayName>
          <description>ULP Memory Control register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>FORCE_ON</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>18</bitWidth>
            </field>
            <field>
              <name>WPULSE</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>WA</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RA</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RME</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RM</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RTC_TR</name>
          <displayName>RTC_TR</displayName>
          <description>Mirrored RTC Time Register</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>PM</name>
              <description>
              AM/PM notation
              0: AM
              1: PM
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HT</name>
              <description>
              Hour tens in BCD format
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>HU</name>
              <description>
              Hour units in BCD format
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>MNT</name>
              <description>
              Minute tens in BCD format
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>MNU</name>
              <description>
              Minute units in BCD format
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>ST</name>
              <description>
              Second tens in BCD format
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>SU</name>
              <description>
              Second units in BCD format
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SS</name>
              <description>
              Sub-second counter
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RTC_DR</name>
          <displayName>RTC_DR</displayName>
          <description>Mirrored RTC Date Register</description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>ERR</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>CB</name>
              <description>
              Century flag
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>YT</name>
              <description>
              Year tens in BCD format
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>YU</name>
              <description>
              Year units in BCD format
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>WD</name>
              <description>
              Week day units
              000: forbidden
              001: Monday
              ...
              111: Sunday
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>MT</name>
              <description>
              Month tens in BCD format
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MU</name>
              <description>
              Month units in BCD format
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>DT</name>
              <description>
              Date tens in BCD format
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>DU</name>
              <description>
              Date units in BCD format
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DBGR</name>
          <displayName>DBGR</displayName>
          <description>Debug Select Register</description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LP2HP_NMIF</name>
              <description>
              LP2HP NMI interrupt flag
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LP2HP_NMIE</name>
              <description>
              LP2HP NMI interrupt enable
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HP2LP_NMI</name>
              <description>
              set 1 to send NMI interrupt to LCPU
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CLK_EN</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CLK_SEL</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>BITEN_H</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>BITEN_L</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>SEL_H</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>SEL_L</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CAU2_CR</name>
          <displayName>CAU2_CR</displayName>
          <description>CAU2 Control Register</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>19</bitWidth>
            </field>
            <field>
              <name>DC_MR</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>DC_BR</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>DC_TR</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>HPBG_EN</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HPBG_VDDPSW_EN</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CAU2_RSVD1</name>
          <displayName>CAU2_RSVD1</displayName>
          <description>CAU2 RSVD Register1</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>RESERVE2</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>RESERVE1</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>RESERVE0</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CAU2_RSVD2</name>
          <displayName>CAU2_RSVD2</displayName>
          <description>CAU2 RSVD Register2</description>
          <addressOffset>0x2c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>RESERVE5</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>RESERVE4</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>RESERVE3</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD2</name>
          <displayName>RSVD2</displayName>
          <description></description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>SYS_RSVD</name>
          <displayName>SYS_RSVD</displayName>
          <description>HPSYS RSVD Register</description>
          <addressOffset>0x38</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RESERVE3</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>RESERVE2</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>RESERVE1</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>RESERVE0</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>LPIRQ</name>
          <displayName>LPIRQ</displayName>
          <description>Interrupt Selection for LCPU</description>
          <addressOffset>0x3c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>IF3</name>
              <description>
              hp2lp3 interrupt status. Write 1 to clear.
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SEL3</name>
              <description>
              select hp2lp3 interrupt source
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>IF2</name>
              <description>
              hp2lp2 interrupt status. Write 1 to clear.
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SEL2</name>
              <description>
              select hp2lp2 interrupt source
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>IF1</name>
              <description>
              hp2lp1 interrupt status. Write 1 to clear.
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SEL1</name>
              <description>
              select hp2lp1 interrupt source
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>IF0</name>
              <description>
              hp2lp0 interrupt status. Write 1 to clear.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SEL0</name>
              <description>
              select hp2lp0 interrupt source
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD1</name>
          <displayName>RSVD1</displayName>
          <description></description>
          <addressOffset>0x40</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>SYSCR</name>
          <displayName>SYSCR</displayName>
          <description>System Configure Register</description>
          <addressOffset>0x5c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>27</bitWidth>
            </field>
            <field>
              <name>SDNAND</name>
              <description>
              0: MPI3 AHB space is allocated to MPI3
              1: MPI3 AHB space is allocated to SDMMC2
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>REMAP</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HEXOKAYS</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HEXOKAYC</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>WDT1_REBOOT</name>
              <description>
              If set to 1, WDT1 reset will reboot the whole chip
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C1_PINR</name>
          <displayName>I2C1_PINR</displayName>
          <description>I2C1 Pin Register</description>
          <addressOffset>0x60</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
            <field>
              <name>SDA_PIN</name>
              <description>
              Connect function pin to selected IO(PA). 
              0 to 78 for PA00 to PA78.
              Other values for floating.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SCL_PIN</name>
              <description>
              Connect function pin to selected IO(PA). 
              0 to 78 for PA00 to PA78.
              Other values for floating.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C2_PINR</name>
          <displayName>I2C2_PINR</displayName>
          <description>I2C2 Pin Register</description>
          <addressOffset>0x64</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
            <field>
              <name>SDA_PIN</name>
              <description>
              Connect function pin to selected IO(PA). 
              0 to 78 for PA00 to PA78.
              Other values for floating.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SCL_PIN</name>
              <description>
              Connect function pin to selected IO(PA). 
              0 to 78 for PA00 to PA78.
              Other values for floating.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C3_PINR</name>
          <displayName>I2C3_PINR</displayName>
          <description>I2C3 Pin Register</description>
          <addressOffset>0x68</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
            <field>
              <name>SDA_PIN</name>
              <description>
              Connect function pin to selected IO(PA). 
              0 to 78 for PA00 to PA78.
              Other values for floating.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SCL_PIN</name>
              <description>
              Connect function pin to selected IO(PA). 
              0 to 78 for PA00 to PA78.
              Other values for floating.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C4_PINR</name>
          <displayName>I2C4_PINR</displayName>
          <description>I2C4 Pin Register</description>
          <addressOffset>0x6c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
            <field>
              <name>SDA_PIN</name>
              <description>
              Connect function pin to selected IO(PA). 
              0 to 78 for PA00 to PA78.
              Other values for floating.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SCL_PIN</name>
              <description>
              Connect function pin to selected IO(PA). 
              0 to 78 for PA00 to PA78.
              Other values for floating.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>USART1_PINR</name>
          <displayName>USART1_PINR</displayName>
          <description>USART1 Pin Register</description>
          <addressOffset>0x70</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTS_PIN</name>
              <description>
              Connect function pin to selected IO(PA). 
              0 to 78 for PA00 to PA78.
              Other values for floating.
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RTS_PIN</name>
              <description>
              Connect function pin to selected IO(PA). 
              0 to 78 for PA00 to PA78.
              Other values for floating.
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RXD_PIN</name>
              <description>
              Connect function pin to selected IO(PA). 
              0 to 78 for PA00 to PA78.
              Other values for floating.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TXD_PIN</name>
              <description>
              Connect function pin to selected IO(PA). 
              0 to 78 for PA00 to PA78.
              Other values for floating.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>USART2_PINR</name>
          <displayName>USART2_PINR</displayName>
          <description>USART2 Pin Register</description>
          <addressOffset>0x74</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTS_PIN</name>
              <description>
              Connect function pin to selected IO(PA). 
              0 to 78 for PA00 to PA78.
              Other values for floating.
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RTS_PIN</name>
              <description>
              Connect function pin to selected IO(PA). 
              0 to 78 for PA00 to PA78.
              Other values for floating.
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RXD_PIN</name>
              <description>
              Connect function pin to selected IO(PA). 
              0 to 78 for PA00 to PA78.
              Other values for floating.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TXD_PIN</name>
              <description>
              Connect function pin to selected IO(PA). 
              0 to 78 for PA00 to PA78.
              Other values for floating.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>USART3_PINR</name>
          <displayName>USART3_PINR</displayName>
          <description>USART3 Pin Register</description>
          <addressOffset>0x78</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTS_PIN</name>
              <description>
              Connect function pin to selected IO(PA). 
              0 to 78 for PA00 to PA78.
              Other values for floating.
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RTS_PIN</name>
              <description>
              Connect function pin to selected IO(PA). 
              0 to 78 for PA00 to PA78.
              Other values for floating.
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RXD_PIN</name>
              <description>
              Connect function pin to selected IO(PA). 
              0 to 78 for PA00 to PA78.
              Other values for floating.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TXD_PIN</name>
              <description>
              Connect function pin to selected IO(PA). 
              0 to 78 for PA00 to PA78.
              Other values for floating.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>GPTIM1_PINR</name>
          <displayName>GPTIM1_PINR</displayName>
          <description>GPTIM1 Pin Register</description>
          <addressOffset>0x7c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CH4_PIN</name>
              <description>
              Connect function pin to selected IO(PA). 
              0 to 78 for PA00 to PA78.
              Other values for floating.
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CH3_PIN</name>
              <description>
              Connect function pin to selected IO(PA). 
              0 to 78 for PA00 to PA78.
              Other values for floating.
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CH2_PIN</name>
              <description>
              Connect function pin to selected IO(PA). 
              0 to 78 for PA00 to PA78.
              Other values for floating.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CH1_PIN</name>
              <description>
              Connect function pin to selected IO(PA). 
              0 to 78 for PA00 to PA78.
              Other values for floating.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>GPTIM2_PINR</name>
          <displayName>GPTIM2_PINR</displayName>
          <description>GPTIM2 Pin Register</description>
          <addressOffset>0x80</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CH4_PIN</name>
              <description>
              Connect function pin to selected IO(PA). 
              0 to 78 for PA00 to PA78.
              Other values for floating.
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CH3_PIN</name>
              <description>
              Connect function pin to selected IO(PA). 
              0 to 78 for PA00 to PA78.
              Other values for floating.
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CH2_PIN</name>
              <description>
              Connect function pin to selected IO(PA). 
              0 to 78 for PA00 to PA78.
              Other values for floating.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CH1_PIN</name>
              <description>
              Connect function pin to selected IO(PA). 
              0 to 78 for PA00 to PA78.
              Other values for floating.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ETR_PINR</name>
          <displayName>ETR_PINR</displayName>
          <description>GPTIM ETR Pin Register</description>
          <addressOffset>0x84</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
            <field>
              <name>ETR2_PIN</name>
              <description>
              Connect GPTIM2_ETR to selected IO(PA). 
              0 to 44 for PA00 to PA44.
              Other values for floating.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ETR1_PIN</name>
              <description>
              Connect GPTIM1_ETR to selected IO(PA). 
              0 to 44 for PA00 to PA44.
              Other values for floating.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>LPTIM1_PINR</name>
          <displayName>LPTIM1_PINR</displayName>
          <description>LPTIM1 Pin Register</description>
          <addressOffset>0x88</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
            <field>
              <name>ETR_PIN</name>
              <description>
              Connect function pin to selected IO(PA). 
              0 to 78 for PA00 to PA78.
              Other values for floating.
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OUT_PIN</name>
              <description>
              Connect function pin to selected IO(PA). 
              0 to 78 for PA00 to PA78.
              Other values for floating.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IN_PIN</name>
              <description>
              Connect function pin to selected IO(PA). 
              0 to 78 for PA00 to PA78.
              Other values for floating.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>EFUSEC</name>
      <description></description>
      <groupName>EFUSEC</groupName>
      <baseAddress>0x4000c000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CR</name>
          <displayName>CR</displayName>
          <description>Control Register</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>27</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Interrupt enable
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BANKSEL</name>
              <description>
              Bank select
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>MODE</name>
              <description>
              0 - READ, 1 - PGM
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EN</name>
              <description>
              Write 1 to enable PGM/READ. Self clear
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TIMR</name>
          <displayName>TIMR</displayName>
          <description>Timer Register</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
            <field>
              <name>TCKHP</name>
              <description>
              SCLK high period for PGM. Recommended value  ~10us
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
            <field>
              <name>THPCK</name>
              <description>
              SCLK to CSB hold time into PGM mode. Recommended value > 20ns
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>THRCK</name>
              <description>
              SCLK to CSB hold time into READ mode. Recmmended value > 500ns
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SR</name>
          <displayName>SR</displayName>
          <description>Status Register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>31</bitWidth>
            </field>
            <field>
              <name>DONE</name>
              <description>
              Indicates PGM/READ done. Write 1 to clear
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVDR</name>
          <displayName>RSVDR</displayName>
          <description>Reserved Register</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PGM_DATA0</name>
          <displayName>PGM_DATA0</displayName>
          <description>Program Data0</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PGM_DATA1</name>
          <displayName>PGM_DATA1</displayName>
          <description>Program Data1</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PGM_DATA2</name>
          <displayName>PGM_DATA2</displayName>
          <description>Program Data2</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PGM_DATA3</name>
          <displayName>PGM_DATA3</displayName>
          <description>Program Data3</description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PGM_DATA4</name>
          <displayName>PGM_DATA4</displayName>
          <description>Program Data4</description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PGM_DATA5</name>
          <displayName>PGM_DATA5</displayName>
          <description>Program Data5</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PGM_DATA6</name>
          <displayName>PGM_DATA6</displayName>
          <description>Program Data6</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PGM_DATA7</name>
          <displayName>PGM_DATA7</displayName>
          <description>Program Data7</description>
          <addressOffset>0x2c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BANK0_DATA0</name>
          <displayName>BANK0_DATA0</displayName>
          <description>Bank0 Data0</description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BANK0_DATA1</name>
          <displayName>BANK0_DATA1</displayName>
          <description>Bank0 Data1</description>
          <addressOffset>0x34</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BANK0_DATA2</name>
          <displayName>BANK0_DATA2</displayName>
          <description>Bank0 Data2</description>
          <addressOffset>0x38</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BANK0_DATA3</name>
          <displayName>BANK0_DATA3</displayName>
          <description>Bank0 Data3</description>
          <addressOffset>0x3c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BANK0_DATA4</name>
          <displayName>BANK0_DATA4</displayName>
          <description>Bank0 Data4</description>
          <addressOffset>0x40</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BANK0_DATA5</name>
          <displayName>BANK0_DATA5</displayName>
          <description>Bank0 Data5</description>
          <addressOffset>0x44</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BANK0_DATA6</name>
          <displayName>BANK0_DATA6</displayName>
          <description>Bank0 Data6</description>
          <addressOffset>0x48</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BANK0_DATA7</name>
          <displayName>BANK0_DATA7</displayName>
          <description>Bank0 Data7</description>
          <addressOffset>0x4c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BANK1_DATA0</name>
          <displayName>BANK1_DATA0</displayName>
          <description>Bank1 Data0</description>
          <addressOffset>0x50</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BANK1_DATA1</name>
          <displayName>BANK1_DATA1</displayName>
          <description>Bank1 Data1</description>
          <addressOffset>0x54</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BANK1_DATA2</name>
          <displayName>BANK1_DATA2</displayName>
          <description>Bank1 Data2</description>
          <addressOffset>0x58</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BANK1_DATA3</name>
          <displayName>BANK1_DATA3</displayName>
          <description>Bank1 Data3</description>
          <addressOffset>0x5c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BANK1_DATA4</name>
          <displayName>BANK1_DATA4</displayName>
          <description>Bank1 Data4</description>
          <addressOffset>0x60</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BANK1_DATA5</name>
          <displayName>BANK1_DATA5</displayName>
          <description>Bank1 Data5</description>
          <addressOffset>0x64</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BANK1_DATA6</name>
          <displayName>BANK1_DATA6</displayName>
          <description>Bank1 Data6</description>
          <addressOffset>0x68</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BANK1_DATA7</name>
          <displayName>BANK1_DATA7</displayName>
          <description>Bank1 Data7</description>
          <addressOffset>0x6c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BANK2_DATA0</name>
          <displayName>BANK2_DATA0</displayName>
          <description>Bank2 Data0</description>
          <addressOffset>0x70</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BANK2_DATA1</name>
          <displayName>BANK2_DATA1</displayName>
          <description>Bank2 Data1</description>
          <addressOffset>0x74</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BANK2_DATA2</name>
          <displayName>BANK2_DATA2</displayName>
          <description>Bank2 Data2</description>
          <addressOffset>0x78</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BANK2_DATA3</name>
          <displayName>BANK2_DATA3</displayName>
          <description>Bank2 Data3</description>
          <addressOffset>0x7c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BANK2_DATA4</name>
          <displayName>BANK2_DATA4</displayName>
          <description>Bank2 Data4</description>
          <addressOffset>0x80</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BANK2_DATA5</name>
          <displayName>BANK2_DATA5</displayName>
          <description>Bank2 Data5</description>
          <addressOffset>0x84</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BANK2_DATA6</name>
          <displayName>BANK2_DATA6</displayName>
          <description>Bank2 Data6</description>
          <addressOffset>0x88</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BANK2_DATA7</name>
          <displayName>BANK2_DATA7</displayName>
          <description>Bank2 Data7</description>
          <addressOffset>0x8c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BANK3_DATA0</name>
          <displayName>BANK3_DATA0</displayName>
          <description>Bank3 Data0</description>
          <addressOffset>0x90</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BANK3_DATA1</name>
          <displayName>BANK3_DATA1</displayName>
          <description>Bank3 Data1</description>
          <addressOffset>0x94</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BANK3_DATA2</name>
          <displayName>BANK3_DATA2</displayName>
          <description>Bank3 Data2</description>
          <addressOffset>0x98</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BANK3_DATA3</name>
          <displayName>BANK3_DATA3</displayName>
          <description>Bank3 Data3</description>
          <addressOffset>0x9c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BANK3_DATA4</name>
          <displayName>BANK3_DATA4</displayName>
          <description>Bank3 Data4</description>
          <addressOffset>0xa0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BANK3_DATA5</name>
          <displayName>BANK3_DATA5</displayName>
          <description>Bank3 Data5</description>
          <addressOffset>0xa4</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BANK3_DATA6</name>
          <displayName>BANK3_DATA6</displayName>
          <description>Bank3 Data6</description>
          <addressOffset>0xa8</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BANK3_DATA7</name>
          <displayName>BANK3_DATA7</displayName>
          <description>Bank3 Data7</description>
          <addressOffset>0xac</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ANACR</name>
          <displayName>ANACR</displayName>
          <description>Bank3 Data7</description>
          <addressOffset>0xb0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RESERVE1</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>RESERVE0</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>LDO_DC_TR</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>LDO_MODE</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LDO_VREF_SEL</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>LDO_EN</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DB_SEL</name>
          <displayName>DB_SEL</displayName>
          <description>debug signal select</description>
          <addressOffset>0xb4</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DB_SEL</name>
              <description>
              debug signal select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>AES</name>
      <description></description>
      <groupName>AES</groupName>
      <baseAddress>0x4000d000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>COMMAND</name>
          <displayName>COMMAND</displayName>
          <description></description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>27</bitWidth>
            </field>
            <field>
              <name>AUTO_GATE</name>
              <description>
              auto clock gating
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HASH_RESET</name>
              <description>
              HASH_ACC soft reset, 1'h1: reset the HASH_ACC block
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HASH_START</name>
              <description>
              write 1 to trigger the HASH_ACC block
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>AES_ACC_RESET</name>
              <description>
              AES_ACC soft reset, 1'h1: reset the AES_ACC block
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>START</name>
              <description>
              write 1 to trigger the AES_ACC block
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS</name>
          <displayName>STATUS</displayName>
          <description></description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>29</bitWidth>
            </field>
            <field>
              <name>HASH_BUSY</name>
              <description>
              HASH_ACC block is busy
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FLASH_KEY_VALID</name>
              <description>
              flash key valid indicator
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BUSY</name>
              <description>
              AES_ACC block is busy
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IRQ</name>
          <displayName>IRQ</displayName>
          <description></description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
            <field>
              <name>HASH_PAD_ERR_RAW_STAT</name>
              <description>
              HASH_ACC padding error raw status
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HASH_BUS_ERR_RAW_STAT</name>
              <description>
              HASH_ACC bus error raw status
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HASH_DONE_RAW_STAT</name>
              <description>
              HASH_ACC done raw status
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SETUP_ERR_RAW_STAT</name>
              <description>
              AES_ACC setup error raw status
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BUS_ERR_RAW_STAT</name>
              <description>
              AES_ACC bus error raw status
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DONE_RAW_STAT</name>
              <description>
              AES_ACC done raw status
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
            <field>
              <name>HASH_PAD_ERR_STAT</name>
              <description>
              HASH_ACC padding error status
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HASH_BUS_ERR_STAT</name>
              <description>
              HASH_ACC bus error status
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HASH_DONE_STAT</name>
              <description>
              HASH_ACC done status
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SETUP_ERR_STAT</name>
              <description>
              AES_ACC setup error status
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BUS_ERR_STAT</name>
              <description>
              AES_ACC bus error status
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DONE_STAT</name>
              <description>
              AES_ACC done status
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SETTING</name>
          <displayName>SETTING</displayName>
          <description></description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>26</bitWidth>
            </field>
            <field>
              <name>HASH_PAD_ERR_MASK</name>
              <description>
              HASH_ACC padding error interrupt mask, 0: mask the interrupt
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HASH_BUS_ERR_MASK</name>
              <description>
              HASH_ACC bus error interrpt mask, 0: mask the interrupt
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HASH_DONE_MASK</name>
              <description>
              HASH_ACC done interrupt mask, 0: mask the interrupt
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SETUP_ERR_IRQ_MASK</name>
              <description>
              AES_ACC setup error interrupt mask, 0: mask the interrupt
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BUS_ERR_IRQ_MASK</name>
              <description>
              AES_ACC bus error interrupt mask, 0: mask the interrupt
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DONE_IRQ_MASK</name>
              <description>
              AES_ACC done interrupt mask, 0: mask the interrupt
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>AES_SETTING</name>
          <displayName>AES_SETTING</displayName>
          <description></description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>AES_BYPASS</name>
              <description>
              1'h0: normal operation
              1'h1: bypass
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>AES_OP_MODE</name>
              <description>
              1'h0: decryption
              1'h1: encryption
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ALGO_STANDARD</name>
              <description>
              1'h0: AES
              1'h1: SM4
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>KEY_SEL</name>
              <description>
              1'h0: select key from AES_ACC key registers
              1'h1: use internal root key
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>AES_LENGTH</name>
              <description>
              AES Length:
              2'h0: 128-bit
              2'h1: 192-bit
              2'h2: 256-bit
              2'h3: Reserved
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>AES_MODE</name>
              <description>
              AES Mode:
              3'h0: ECB
              3'h1: CTR
              3'h2: CBC
              Others: Reserved
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DMA_IN</name>
          <displayName>DMA_IN</displayName>
          <description></description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ADDR</name>
              <description>
              AES_ACC input data address
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DMA_OUT</name>
          <displayName>DMA_OUT</displayName>
          <description></description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ADDR</name>
              <description>
              AES_ACC output data address
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DMA_DATA</name>
          <displayName>DMA_DATA</displayName>
          <description></description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>SIZE</name>
              <description>
              AES_ACC data block size, AES_ACC only support block aligned transaction. Each block contains 16 bytes.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>28</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IV_W0</name>
          <displayName>IV_W0</displayName>
          <description></description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              Initial Vector Word0
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IV_W1</name>
          <displayName>IV_W1</displayName>
          <description></description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              Initial Vector Word1
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IV_W2</name>
          <displayName>IV_W2</displayName>
          <description></description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              Initial Vector Word2
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IV_W3</name>
          <displayName>IV_W3</displayName>
          <description></description>
          <addressOffset>0x2c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              Initial Vector Word3
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>EXT_KEY_W0</name>
          <displayName>EXT_KEY_W0</displayName>
          <description></description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              External Key Word0
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>EXT_KEY_W1</name>
          <displayName>EXT_KEY_W1</displayName>
          <description></description>
          <addressOffset>0x34</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              External Key Word1
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>EXT_KEY_W2</name>
          <displayName>EXT_KEY_W2</displayName>
          <description></description>
          <addressOffset>0x38</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              External Key Word2
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>EXT_KEY_W3</name>
          <displayName>EXT_KEY_W3</displayName>
          <description></description>
          <addressOffset>0x3c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              External Key Word3
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>EXT_KEY_W4</name>
          <displayName>EXT_KEY_W4</displayName>
          <description></description>
          <addressOffset>0x40</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              External Key Word4
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>EXT_KEY_W5</name>
          <displayName>EXT_KEY_W5</displayName>
          <description></description>
          <addressOffset>0x44</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              External Key Word5
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>EXT_KEY_W6</name>
          <displayName>EXT_KEY_W6</displayName>
          <description></description>
          <addressOffset>0x48</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              External Key Word6
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>EXT_KEY_W7</name>
          <displayName>EXT_KEY_W7</displayName>
          <description></description>
          <addressOffset>0x4c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              External Key Word7
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>HASH_SETTING</name>
          <displayName>HASH_SETTING</displayName>
          <description></description>
          <addressOffset>0x50</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>HASH_LEN_LOAD</name>
              <description>
              write 1 to load hash length
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HASH_IV_LOAD</name>
              <description>
              write 1 to load hash iv
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RESULT_ENDIAN</name>
              <description>
              hash result endian setting: 
              1'h0: little endian
              1'h1: big endian
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DFT_IV_SEL</name>
              <description>
              HASH default iv select.
              1'h0: default iv according to hash mode
              1'h1: default iv from HASH_IV_H* registers
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BYTE_SWAP</name>
              <description>
              HASH byte swap option. Set 1 to swap byte order when read data from memory.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DO_PADDING</name>
              <description>
              HASH padding enable.
              Set 1 to do padding after data transfer.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HASH_MODE</name>
              <description>
              HASH Mode:
              3'h0: SHA-1
              3'h1: SHA-224
              3'h2: SHA-256
              3'h3: SM3
              Others: Reserved
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>HASH_DMA_IN</name>
          <displayName>HASH_DMA_IN</displayName>
          <description></description>
          <addressOffset>0x54</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ADDR</name>
              <description>
              input data address
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>HASH_DMA_DATA</name>
          <displayName>HASH_DMA_DATA</displayName>
          <description></description>
          <addressOffset>0x58</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>SIZE</name>
              <description>
              HASH input data byte size.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>HASH_IV_H0</name>
          <displayName>HASH_IV_H0</displayName>
          <description></description>
          <addressOffset>0x5c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              HASH IV H0
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>HASH_IV_H1</name>
          <displayName>HASH_IV_H1</displayName>
          <description></description>
          <addressOffset>0x60</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              HASH IV H1
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>HASH_IV_H2</name>
          <displayName>HASH_IV_H2</displayName>
          <description></description>
          <addressOffset>0x64</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              HASH IV H2
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>HASH_IV_H3</name>
          <displayName>HASH_IV_H3</displayName>
          <description></description>
          <addressOffset>0x68</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              HASH IV H3
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>HASH_IV_H4</name>
          <displayName>HASH_IV_H4</displayName>
          <description></description>
          <addressOffset>0x6c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              HASH IV H4
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>HASH_IV_H5</name>
          <displayName>HASH_IV_H5</displayName>
          <description></description>
          <addressOffset>0x70</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              HASH IV H5
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>HASH_IV_H6</name>
          <displayName>HASH_IV_H6</displayName>
          <description></description>
          <addressOffset>0x74</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              HASH IV H6
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>HASH_IV_H7</name>
          <displayName>HASH_IV_H7</displayName>
          <description></description>
          <addressOffset>0x78</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              HASH IV H7
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>HASH_RESULT_H0</name>
          <displayName>HASH_RESULT_H0</displayName>
          <description></description>
          <addressOffset>0x7c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              HASH result H0
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>HASH_RESULT_H1</name>
          <displayName>HASH_RESULT_H1</displayName>
          <description></description>
          <addressOffset>0x80</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              HASH result H1
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>HASH_RESULT_H2</name>
          <displayName>HASH_RESULT_H2</displayName>
          <description></description>
          <addressOffset>0x84</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              HASH result H2
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>HASH_RESULT_H3</name>
          <displayName>HASH_RESULT_H3</displayName>
          <description></description>
          <addressOffset>0x88</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              HASH result H3
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>HASH_RESULT_H4</name>
          <displayName>HASH_RESULT_H4</displayName>
          <description></description>
          <addressOffset>0x8c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              HASH result H4
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>HASH_RESULT_H5</name>
          <displayName>HASH_RESULT_H5</displayName>
          <description></description>
          <addressOffset>0x90</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              HASH result H5
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>HASH_RESULT_H6</name>
          <displayName>HASH_RESULT_H6</displayName>
          <description></description>
          <addressOffset>0x94</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              HASH result H6
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>HASH_RESULT_H7</name>
          <displayName>HASH_RESULT_H7</displayName>
          <description></description>
          <addressOffset>0x98</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              HASH result H7
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>HASH_LEN_L</name>
          <displayName>HASH_LEN_L</displayName>
          <description></description>
          <addressOffset>0x9c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              HASH load length l
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>HASH_LEN_H</name>
          <displayName>HASH_LEN_H</displayName>
          <description></description>
          <addressOffset>0xa0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>DATA</name>
              <description>
              HASH load length h
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>29</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>HASH_RESULT_LEN_L</name>
          <displayName>HASH_RESULT_LEN_L</displayName>
          <description></description>
          <addressOffset>0xa4</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              HASH result length l
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>HASH_RESULT_LEN_H</name>
          <displayName>HASH_RESULT_LEN_H</displayName>
          <description></description>
          <addressOffset>0xa8</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>DATA</name>
              <description>
              HASH result length h
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>29</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>TRNG</name>
      <description></description>
      <groupName>TRNG</groupName>
      <baseAddress>0x4000f000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTRL</name>
          <displayName>CTRL</displayName>
          <description></description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>27</bitWidth>
            </field>
            <field>
              <name>GEN_RAND_NUM_SUSPEND</name>
              <description>
              Set 1 to suspend random number generation and update. Set 0 to recover the process.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GEN_RAND_NUM_STOP</name>
              <description>
              Set 1 to stop random number generation and update. This will reset the random number generation engine. After release the stop bit, user should write 1 to gen_rand_num_start to trigger the random number engine.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GEN_SEED_STOP</name>
              <description>
              Set 1 to stop random seed generation. This will reset the random seed generation engine. After release the stop bit, user should write 1 to gen_seed_start to trigger the random seed engine.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GEN_RAND_NUM_START</name>
              <description>
              write 1 to trigger the random number generation engine
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GEN_SEED_START</name>
              <description>
              write 1 to trigger the random seed generation engine
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>STAT</name>
          <displayName>STAT</displayName>
          <description></description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>28</bitWidth>
            </field>
            <field>
              <name>RAND_NUM_VALID</name>
              <description>
              random number valid flag
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RAND_NUM_GEN_BUSY</name>
              <description>
              random number engine busy flag
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SEED_VALID</name>
              <description>
              random seed valid flag
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SEED_GEN_BUSY</name>
              <description>
              random seed engine busy flag
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CFG</name>
          <displayName>CFG</displayName>
          <description></description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>REJECT_THRESHOLD</name>
              <description>
              random seed internal VN corrector check threshold
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>USE_EXT_SEED</name>
              <description>
              set 1 to use external seed to generate random number
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>AUTO_CLOCK_ENABLE</name>
              <description>
              auto clock gating enable
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IRQ</name>
          <displayName>IRQ</displayName>
          <description></description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00070000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>13</bitWidth>
            </field>
            <field>
              <name>PRNG_LOCKUP_MSK</name>
              <description>
              prng lockup interrupt mask
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RAND_NUM_AVAIL_MSK</name>
              <description>
              random number available interrupt mask
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SEED_GEN_DONE_MSK</name>
              <description>
              random seed generation done interrupt mask
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>13</bitWidth>
            </field>
            <field>
              <name>PRNG_LOCKUP</name>
              <description>
              prng lockup raw interrupt
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RAND_NUM_AVAIL</name>
              <description>
              random number available raw interrupt
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SEED_GEN_DONE</name>
              <description>
              random seed generation done raw interrupt
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RAND_SEED0</name>
          <displayName>RAND_SEED0</displayName>
          <description></description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>VAL</name>
              <description>
              random seed value0. If using external random seed, write value to this register will update the random seed in use.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RAND_SEED1</name>
          <displayName>RAND_SEED1</displayName>
          <description></description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>VAL</name>
              <description>
              random seed value1. If using external random seed, write value to this register will update the random seed in use.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RAND_SEED2</name>
          <displayName>RAND_SEED2</displayName>
          <description></description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>VAL</name>
              <description>
              random seed value2. If using external random seed, write value to this register will update the random seed in use.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RAND_SEED3</name>
          <displayName>RAND_SEED3</displayName>
          <description></description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>VAL</name>
              <description>
              random seed value3. If using external random seed, write value to this register will update the random seed in use.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RAND_SEED4</name>
          <displayName>RAND_SEED4</displayName>
          <description></description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>VAL</name>
              <description>
              random seed value4. If using external random seed, write value to this register will update the random seed in use.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RAND_SEED5</name>
          <displayName>RAND_SEED5</displayName>
          <description></description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>VAL</name>
              <description>
              random seed value5. If using external random seed, write value to this register will update the random seed in use.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RAND_SEED6</name>
          <displayName>RAND_SEED6</displayName>
          <description></description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>VAL</name>
              <description>
              random seed value6. If using external random seed, write value to this register will update the random seed in use.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RAND_SEED7</name>
          <displayName>RAND_SEED7</displayName>
          <description></description>
          <addressOffset>0x2c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>VAL</name>
              <description>
              random seed value7. If using external random seed, write value to this register will update the random seed in use.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RAND_NUM0</name>
          <displayName>RAND_NUM0</displayName>
          <description></description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>VAL</name>
              <description>
              random number value0
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RAND_NUM1</name>
          <displayName>RAND_NUM1</displayName>
          <description></description>
          <addressOffset>0x34</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>VAL</name>
              <description>
              random number value1
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RAND_NUM2</name>
          <displayName>RAND_NUM2</displayName>
          <description></description>
          <addressOffset>0x38</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>VAL</name>
              <description>
              random number value2
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RAND_NUM3</name>
          <displayName>RAND_NUM3</displayName>
          <description></description>
          <addressOffset>0x3c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>VAL</name>
              <description>
              random number value3
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RAND_NUM4</name>
          <displayName>RAND_NUM4</displayName>
          <description></description>
          <addressOffset>0x40</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>VAL</name>
              <description>
              random number value4
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RAND_NUM5</name>
          <displayName>RAND_NUM5</displayName>
          <description></description>
          <addressOffset>0x44</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>VAL</name>
              <description>
              random number value5
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RAND_NUM6</name>
          <displayName>RAND_NUM6</displayName>
          <description></description>
          <addressOffset>0x48</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>VAL</name>
              <description>
              random number value6
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RAND_NUM7</name>
          <displayName>RAND_NUM7</displayName>
          <description></description>
          <addressOffset>0x4c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>VAL</name>
              <description>
              random number value7
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CAL_CFG</name>
          <displayName>CAL_CFG</displayName>
          <description></description>
          <addressOffset>0x50</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>LENGTH</name>
              <description>
              calibration length
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
            <field>
              <name>DONE</name>
              <description>
              calibration done
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ENABLE</name>
              <description>
              calibration enable
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OSC_CLK_SEL</name>
              <description>
              osc clock select
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>OSC_CLK_FORCE_ON</name>
              <description>
              osc force enable
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CAL_RESULT</name>
          <displayName>CAL_RESULT</displayName>
          <description></description>
          <addressOffset>0x54</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>OSC_CNT</name>
              <description>
              osc clock calibration counter result
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>PCLK_CNT</name>
              <description>
              pclk calibration counter result
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>GPTIM1</name>
      <description></description>
      <groupName>GPTIM</groupName>
      <baseAddress>0x40010000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CR1</name>
          <displayName>CR1</displayName>
          <description>TIM control register 1</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>UIFREMAP</name>
              <description>
              UIF status bit remapping
              0: No remapping. UIF status bit is not copied to CNT register bit 31
              1: Remapping enabled. UIF status bit is copied to CNT register bit 31
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>ARPE</name>
              <description>
              Auto-reload preload enable
              0: ARR register is not buffered
              1: ARR register is buffered
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CMS</name>
              <description>
              Center-aligned mode selection
              00: Edge-aligned mode. The counter counts up or down depending on the direction bit (DIR).
              01: Center-aligned mode 1. The counter counts up and down alternatively. Output compare interrupt flags of channels configured in output (CCxS=00 in CCMRx register) are set only when the counter is counting down.
              10: Center-aligned mode 2. The counter counts up and down alternatively. Output compare interrupt flags of channels configured in output (CCxS=00 in CCMRx register) are set only when the counter is counting up.
              11: Center-aligned mode 3. The counter counts up and down alternatively. Output compare interrupt flags of channels configured in output (CCxS=00 in CCMRx register) are set both when the counter is counting up or down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>DIR</name>
              <description>
              Direction
              0: Counter used as upcounter
              1: Counter used as downcounter
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OPM</name>
              <description>
              One-pulse mode
              0: Counter is not stopped at update event
              1: Counter stops counting at the next update event (clearing the bit CEN)
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>URS</name>
              <description>
              Update request source
              This bit is set and cleared by software to select the UEV event sources.
              0: Any of the following events generate an update interrupt or DMA request if enabled. 
              These events can be: 
                 Counter overflow/underflow
                 Setting the UG bit
                 Update generation through the slave mode controller
              1: Only counter overflow/underflow generates an update interrupt or DMA request if enabled.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UDIS</name>
              <description>
              Update disable
              This bit is set and cleared by software to enable/disable UEV event generation.
              0: UEV enabled. The Update (UEV) event is generated by one of the following events:
                 Counter overflow/underflow
                 Setting the UG bit
                 Update generation through the slave mode controller
              Buffered registers are then loaded with their preload values.
              1: UEV disabled. The Update event is not generated, shadow registers keep their value (ARR, PSC, CCRx). However the counter and the prescaler are reinitialized if the UG bit is set or if a hardware reset is received from the slave mode controller.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CEN</name>
              <description>
              Counter enable
              0: Counter disabled
              1: Counter enabled
              Note: External clock, gated mode and encoder mode can work only if the CEN bit has been previously set by software. However trigger mode can set the CEN bit automatically by hardware. 
              CEN is cleared automatically in one-pulse mode, when an update event occurs.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CR2</name>
          <displayName>CR2</displayName>
          <description>TIM control register 2</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>TI1S</name>
              <description>
              TI1 selection
              0: The CH1 pin is connected to TI1 input
              1: The CH1, CH2 and CH3 pins are connected to the TI1 input (XOR combination) 
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MMS</name>
              <description>
              Master mode selection
              These bits allow to select the information to be sent in master mode to slave timers for synchronization (TRGO). The combination is as follows:
              000: Reset - the UG bit from the EGR register is used as trigger output (TRGO). If the reset is generated by the trigger input (slave mode controller configured in reset mode) then the signal on TRGO is delayed compared to the actual reset.
              001: Enable - the Counter enable signal is used as trigger output (TRGO). It is useful to start several timers at the same time or to control a window in which a slave timer is enabled. The Counter Enable signal is generated by a logic OR between CEN control bit and the trigger input when configured in gated mode. 
              When the Counter Enable signal is controlled by the trigger input, there is a delay on TRGO, except if the master/slave mode is selected.
              010: Update - The update event is selected as trigger output (TRGO). For instance a master timer can then be used as a prescaler for a slave timer.
              011: Compare Pulse - The trigger output send a positive pulse when the CC1IF flag is to be set (even if it was already high), as soon as a capture or a compare match occurred. (TRGO)
              100: Compare - OC1REF signal is used as trigger output (TRGO)
              101: Compare - OC2REF signal is used as trigger output (TRGO)
              110: Compare - OC3REF signal is used as trigger output (TRGO)
              111: Compare - OC4REF signal is used as trigger output (TRGO)
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>CCDS</name>
              <description>
              Capture/compare DMA selection
              0: CCx DMA request sent when CCx event occurs
              1: CCx DMA requests sent when update event occurs
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SMCR</name>
          <displayName>SMCR</displayName>
          <description>TIM slave mode control register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
            <field>
              <name>SMS</name>
              <description>
              Slave mode selection
              When external signals are selected the active edge of the trigger signal (TRGI) is linked to the polarity selected on the external input.
              0000: Slave mode disabled.
              0001: Encoder mode 1 - Counter counts up/down on TI1FP1 edge depending on TI2FP2 level.
              0010: Encoder mode 2 - Counter counts up/down on TI2FP2 edge depending on TI1FP1 level.
              0011: Encoder mode 3 - Counter counts up/down on both TI1FP1 and TI2FP2 edges depending on the level of the other input.
              0100: Reset Mode - Rising edge of the selected trigger input (TRGI) reinitializes the counter and generates an update of the registers.
              0101: Gated Mode - The counter clock is enabled when the trigger input (TRGI) is high. The counter stops (but is not reset) as soon as the trigger becomes low. Both start and stop of the counter are controlled.
              0110: Trigger Mode - The counter starts at a rising edge of the trigger TRGI (but it is not reset). Only the start of the counter is controlled.
              0111: External Clock Mode 1 - Rising edges of the selected trigger (TRGI) clock the counter.
              1000: Combined reset + trigger mode - Rising edge of the selected trigger input (TRGI) reinitializes the counter, generates an update of the registers and starts the counter.
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>ETP</name>
              <description>
              External trigger polarity
              0: ETR is non-inverted, active at high level or rising edge
              1: ETR is inverted, active at low level or falling edge
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ECE</name>
              <description>
              External clock enable
              This bit enables External clock mode 2.
              0: External clock mode 2 disabled
              1: External clock mode 2 enabled. The counter is clocked by any active edge on the ETRF signal.
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ETPS</name>
              <description>
              External trigger prescaler
              External trigger signal ETRP frequency must be at most 1/4 of CK_INT frequency. A prescaler can be enabled to reduce ETRP frequency. It is useful when inputting fast external clocks.
              00: Prescaler OFF
              01: ETRP frequency divided by 2
              10: ETRP frequency divided by 4
              11: ETRP frequency divided by 8
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>ETF</name>
              <description>
              External trigger filter
              This bit-field then defines the frequency used to sample ETRP signal and the length of the digital filter applied to ETRP. The digital filter is made of an event counter in which N 
              consecutive events are needed to validate a transition on the output:
              0000: No filter
              0001:   fSAMPLING=fCLK, N=2
              0010:   fSAMPLING=fCLK, N=4
              0011:   fSAMPLING=fCLK, N=8
              0100:   fSAMPLING=fCLK/2, N=6
              0101:   fSAMPLING=fCLK/2, N=8
              0110:   fSAMPLING=fCLK/4, N=6
              0111:   fSAMPLING=fCLK/4, N=8
              1000:   fSAMPLING=fCLK/8, N=6
              1001:   fSAMPLING=fCLK/8, N=8
              1010:   fSAMPLING=fCLK/16, N=5
              1011:   fSAMPLING=fCLK/16, N=6
              1100:   fSAMPLING=fCLK/16, N=8
              1101:   fSAMPLING=fCLK/32, N=5
              1110:   fSAMPLING=fCLK/32, N=6
              1111:   fSAMPLING=fCLK/32, N=8
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>MSM</name>
              <description>
              Master/Slave mode
              0: No action
              1: The effect of an event on the trigger input (TRGI) is delayed to allow a perfect synchronization between the current timer and its slaves (through TRGO). It is useful if we want to synchronize several timers on a single external event.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TS</name>
              <description>
              Trigger selection
              This bit-field selects the trigger input to be used to synchronize the counter.
              000: Internal Trigger 0 (ITR0)
              001: Internal Trigger 1 (ITR1) 
              010: Internal Trigger 2 (ITR2)
              011: Internal Trigger 3 (ITR3)
              100: TI1 Edge Detector (TI1F_ED)
              101: Filtered Timer Input 1 (TI1FP1)
              110: Filtered Timer Input 2 (TI2FP2)
              111: External Trigger input (ETRF)
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DIER</name>
          <displayName>DIER</displayName>
          <description>TIM DMA/Interrupt enable register</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
            <field>
              <name>TDE</name>
              <description>
              Trigger DMA request enable
              0: Trigger DMA request disabled.
              1: Trigger DMA request enabled.
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC4DE</name>
              <description>
              Capture/Compare 4 DMA request enable
              0: CC4 DMA request disabled.
              1: CC4 DMA request enabled
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC3DE</name>
              <description>
              Capture/Compare 3 DMA request enable
              0: CC3 DMA request disabled.
              1: CC3 DMA request enabled.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC2DE</name>
              <description>
              Capture/Compare 2 DMA request enable
              0: CC2 DMA request disabled.
              1: CC2 DMA request enabled.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC1DE</name>
              <description>
              Capture/Compare 1 DMA request enable
              0: CC1 DMA request disabled.
              1: CC1 DMA request enabled.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UDE</name>
              <description>
              Update DMA request enable
              0: Update DMA request disabled.
              1: Update DMA request enabled
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TIE</name>
              <description>
              Trigger interrupt enable
              0: Trigger interrupt disabled.
              1: Trigger interrupt enabled
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC4IE</name>
              <description>
              Capture/Compare 4 interrupt enable
              0: CC4 interrupt disabled.
              1: CC4 interrupt enabled
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC3IE</name>
              <description>
              Capture/Compare 3 interrupt enable
              0: CC3 interrupt disabled.
              1: CC3 interrupt enabled
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC2IE</name>
              <description>
              Capture/Compare 2 interrupt enable
              0: CC2 interrupt disabled.
              1: CC2 interrupt enabled.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC1IE</name>
              <description>
              Capture/Compare 1 interrupt enable
              0: CC1 interrupt disabled.
              1: CC1 interrupt enabled
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UIE</name>
              <description>
              Update interrupt enable
              0: Update interrupt disabled.
              1: Update interrupt enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SR</name>
          <displayName>SR</displayName>
          <description>TIM status register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>19</bitWidth>
            </field>
            <field>
              <name>CC4OF</name>
              <description>
              Capture/Compare 4 overcapture flag
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC3OF</name>
              <description>
              Capture/Compare 3 overcapture flag
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC2OF</name>
              <description>
              Capture/Compare 2 overcapture flag
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC1OF</name>
              <description>
              Capture/Compare 1 overcapture flag
              This flag is set by hardware only when the corresponding channel is configured in input capture mode. It is cleared by software by writing it to '0'.
              0: No overcapture has been detected.
              1: The counter value has been captured in CCR1 register while CC1IF flag was already set
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>TIF</name>
              <description>
              Trigger interrupt flag
              This flag is set by hardware on trigger event (active edge detected on TRGI input when the slave mode controller is enabled in all modes but gated mode). It is set when the counter starts or stops when gated mode is selected. It is cleared by software.
              0: No trigger event occurred.
              1: Trigger interrupt pending.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC4IF</name>
              <description>
              Capture/Compare 4 interrupt flag
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC3IF</name>
              <description>
              Capture/Compare 3 interrupt flag
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC2IF</name>
              <description>
              Capture/Compare 2 interrupt flag
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC1IF</name>
              <description>
              Capture/Compare 1 interrupt flag
              If channel CC1 is configured as output: This flag is set by hardware when the counter matches the compare value. It is cleared by software.
              0: No match.
              1: The content of the counter CNT has matched the content of the CCR1 register.
              If channel CC1 is configured as input: This bit is set by hardware on a capture. It is cleared by software or by reading the CCR1 register.
              0: No input capture occurred.
              1: The counter value has been captured in CCR1 register (An edge has been detected on IC1 which matches the selected polarity).
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UIF</name>
              <description>
              Update interrupt flag
              This bit is set by hardware on an update event. It is cleared by software.
              0: No update occurred
              1: Update interrupt pending. This bit is set by hardware when the registers are updated:
              At overflow or underflow and if UDIS=0 in the CR1 register.
              When CNT is reinitialized by software using the UG bit in EGR register, if URS=0 and UDIS=0 in the CR1 register.
              When CNT is reinitialized by a trigger event, if URS=0 and UDIS=0 in the CR1 register.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>EGR</name>
          <displayName>EGR</displayName>
          <description>Event generation register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>25</bitWidth>
            </field>
            <field>
              <name>TG</name>
              <description>
              Trigger generation
              This bit is set by software in order to generate an event, it is automatically cleared by hardware.
              0: No action
              1: The TIF flag is set in SR register. Related interrupt or DMA transfer can occur if enabled.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC4G</name>
              <description>
              Capture/compare 4 generation
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC3G</name>
              <description>
              Capture/compare 3 generation
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC2G</name>
              <description>
              Capture/compare 2 generation
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC1G</name>
              <description>
              Capture/compare 1 generation
              This bit is set by software in order to generate an event, it is automatically cleared by hardware.
              0: No action
              1: A capture/compare event is generated on channel 1:
              If channel CC1 is configured as output:
              CC1IF flag is set, Corresponding interrupt or DMA request is sent if enabled.
              If channel CC1 is configured as input:
              The current value of the counter is captured in CCR1 register. The CC1IF flag is set, the corresponding interrupt or DMA request is sent if enabled. The CC1OF flag is set if the CC1IF flag was already high.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UG</name>
              <description>
              Update generation
              This bit can be set by software, it is automatically cleared by hardware.
              0: No action
              1: Re-initialize the counter and generates an update of the registers. Note that the prescaler counter is cleared too (anyway the prescaler ratio is not affected). The counter is cleared if the center-aligned mode is selected or if DIR=0 (upcounting), else it takes the auto-reload value (ARR) if DIR=1 (downcounting).
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCMR1</name>
          <displayName>CCMR1</displayName>
          <description>TIM capture/compare mode register 1</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>OC2M</name>
              <description>
              Output compare 2 mode
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>OC2PE</name>
              <description>
              Output compare 2 preload enable
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>OC2CE</name>
              <description>
              Output compare 2 clear enable
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OC1M</name>
              <description>
              Output compare 1 mode
              These bits define the behavior of the output reference signal OC1REF from which OC1 and OC1N are derived. OC1REF is active high whereas OC1 and OC1N active level depends on CC1P and CC1NP bits.
              0000: Frozen - The comparison between the output compare register CCR1 and the counter CNT has no effect on the outputs.(this mode is used to generate a timing base).
              0001: Set channel 1 to active level on match. OC1REF signal is forced high when the counter CNT matches the capture/compare register 1 (CCR1).
              0010: Set channel 1 to inactive level on match. OC1REF signal is forced low when the counter CNT matches the capture/compare register 1 (CCR1).
              0011: Toggle - OC1REF toggles when CNT=CCR1.
              0100: Force inactive level - OC1REF is forced low.
              0101: Force active level - OC1REF is forced high.
              0110: PWM mode 1 - In upcounting, channel 1 is active as long as CNTltCCR1 else inactive. In downcounting, channel 1 is inactive (OC1REF='0) as long as CNT>CCR1 else active (OC1REF=1).
              0111: PWM mode 2 - In upcounting, channel 1 is inactive as long as CNTltCCR1 else active. In downcounting, channel 1 is active as long as CNT>CCR1 else inactive.
              1000: Retriggerable OPM mode 1 - In up-counting mode, the channel is active until a trigger event is detected (on TRGI signal). Then, a comparison is performed as in PWM mode 1 and the channels becomes inactive again at the next update. In down-counting mode, the channel is inactive until a trigger event is detected (on TRGI signal). Then, a comparison is performed as in PWM mode 1 and the channels becomes inactive again at the next update.
              1001: Retriggerable OPM mode 2 - In up-counting mode, the channel is inactive until a trigger event is detected (on TRGI signal). Then, a comparison is performed as in PWM mode 2 and the channels becomes inactive again at the next update. In down-counting mode, the channel is active until a trigger event is detected (on TRGI signal). Then, a comparison is performed as in PWM mode 1 and the channels becomes active again at the next update.
              1010: Reserved,
              1011: Reserved,
              1100: Combined PWM mode 1 - OC1REF has the same behavior as in PWM mode 1. OC1REFC is the logical OR between OC1REF and OC2REF.
              1101: Combined PWM mode 2 - OC1REF has the same behavior as in PWM mode 2. OC1REFC is the logical AND between OC1REF and OC2REF.
              1110: Asymmetric PWM mode 1 - OC1REF has the same behavior as in PWM mode 1. OC1REFC outputs OC1REF when the counter is counting up, OC2REF when it is counting down.
              1111: Asymmetric PWM mode 2 - OC1REF has the same behavior as in PWM mode 2. OC1REFC outputs OC1REF when the counter is counting up, OC2REF when it is counting down.
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>OC1PE</name>
              <description>
              Output compare 1 preload enable
              0: Preload register on CCR1 disabled. CCR1 can be written at anytime, the new value is taken in account immediately.
              1: Preload register on CCR1 enabled. Read/Write operations access the preload register. CCR1 preload value is loaded in the active register at each update event.
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>OC1CE</name>
              <description>
              Output compare 1 clear enable
              0: OC1Ref is not affected by the ETRF input
              1: OC1Ref is cleared as soon as a High level is detected on ETRF input
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IC2F</name>
              <description>
              Input capture 2 filter
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>IC2PSC</name>
              <description>
              Input capture 2 prescaler
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>CC2S</name>
              <description>
              Capture/Compare 2 selection
              This bit-field defines the direction of the channel (input/output) as well as the used input. 
              00: CC2 channel is configured as output
              01: CC2 channel is configured as input, IC2 is mapped on TI2
              10: CC2 channel is configured as input, IC2 is mapped on TI1
              11: CC2 channel is configured as input, IC2 is mapped on TRC. This mode is working only if an internal trigger input is selected through the TS bit (SMCR register)
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>IC1F</name>
              <description>
              Input capture 1 filter
              This bit-field defines the frequency used to sample TI1 input and the length of the digital filter applied to TI1. The digital filter is made of an event counter in which N consecutive events are needed to validate a transition on the output:
              0000: No filter, sampling is done at fCLK
              0001: fSAMPLING=fCLK, N=2
              0010: fSAMPLING=fCLK, N=4
              0011: fSAMPLING=fCLK, N=8
              0100: fSAMPLING=fCLK/2, N=6
              0101: fSAMPLING=fCLK/2, N=8
              0110: fSAMPLING=fCLK/4, N=6
              0111: fSAMPLING=fCLK/4, N=8
              1000: fSAMPLING=fCLK/8, N=6
              1001: fSAMPLING=fCLK/8, N=8
              1010: fSAMPLING=fCLK/16, N=5
              1011: fSAMPLING=fCLK/16, N=6
              1100: fSAMPLING=fCLK/16, N=8
              1101: fSAMPLING=fCLK/32, N=5
              1110: fSAMPLING=fCLK/32, N=6
              1111: fSAMPLING=fCLK/32, N=8
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>IC1PSC</name>
              <description>
              Input capture 1 prescaler
              This bit-field defines the ratio of the prescaler acting on CC1 input (IC1). The prescaler is reset as soon as CC1E=0.
              00: no prescaler, capture is done each time an edge is detected on the capture input
              01: capture is done once every 2 events
              10: capture is done once every 4 events
              11: capture is done once every 8 events
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>CC1S</name>
              <description>
              Capture/Compare 1 selection
              This bit-field defines the direction of the channel (input/output) as well as the used input. 
              00: CC1 channel is configured as output
              01: CC1 channel is configured as input, IC1 is mapped on TI1
              10: CC1 channel is configured as input, IC1 is mapped on TI2
              11: CC1 channel is configured as input, IC1 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (SMCR register)
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCMR2</name>
          <displayName>CCMR2</displayName>
          <description>TIM capture/compare mode register 2</description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>OC4M</name>
              <description>
              Output compare 4 mode
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>OC4PE</name>
              <description>
              Output compare 4 preload enable
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>OC4CE</name>
              <description>
              Output compare 4 clear enable
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OC3M</name>
              <description>
              Output compare 3 mode
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>OC3PE</name>
              <description>
              Output compare 3 preload enable
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>OC3CE</name>
              <description>
              Output compare 3 clear enable
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IC4F</name>
              <description>
              Input capture 4 filter
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>IC4PSC</name>
              <description>
              Input capture 4 prescaler
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>CC4S</name>
              <description>
              Capture/Compare 4 selection
              This bit-field defines the direction of the channel (input/output) as well as the used input. 
              00: CC4 channel is configured as output
              01: CC4 channel is configured as input, IC4 is mapped on TI4
              10: CC4 channel is configured as input, IC4 is mapped on TI3
              11: CC4 channel is configured as input, IC4 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (SMCR register)
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>IC3F</name>
              <description>
              Input capture 3 filter
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>IC3PSC</name>
              <description>
              Input capture 3 prescaler
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>CC3S</name>
              <description>
              Capture/Compare 3 selection
              This bit-field defines the direction of the channel (input/output) as well as the used input. 
              00: CC3 channel is configured as output
              01: CC3 channel is configured as input, IC3 is mapped on TI3
              10: CC3 channel is configured as input, IC3 is mapped on TI4
              11: CC3 channel is configured as input, IC3 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (SMCR register)
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCER</name>
          <displayName>CCER</displayName>
          <description>Capture/Compare enable register</description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>CC4NP</name>
              <description>
              Capture/Compare 4 output Polarity.
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC4P</name>
              <description>
              Capture/Compare 4 output Polarity.
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC4E</name>
              <description>
              Capture/Compare 4 output enable.
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC3NP</name>
              <description>
              Capture/Compare 3 output Polarity.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC3P</name>
              <description>
              Capture/Compare 3 output Polarity.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC3E</name>
              <description>
              Capture/Compare 3 output enable.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC2NP</name>
              <description>
              Capture/Compare 2 output Polarity.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC2P</name>
              <description>
              Capture/Compare 2 output Polarity.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC2E</name>
              <description>
              Capture/Compare 2 output enable.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC1NP</name>
              <description>
              Capture/Compare 1 output Polarity.
              CC1 channel configured as output: CC1NP must be kept cleared in this case.
              CC1 channel configured as input: This bit is used in conjunction with CC1P to define TI1FP1/TI2FP1 polarity. refer to CC1P description.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD5</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC1P</name>
              <description>
              Capture/Compare 1 output Polarity.
              CC1 channel configured as output:
              0: OC1 active high
              1: OC1 active low
              CC1 channel configured as input: CC1NP/CC1P bits select TI1FP1 and TI2FP1 polarity for trigger or capture operations.
              00: noninverted/rising edge
              Circuit is sensitive to TIxFP1 rising edge (capture, trigger in reset, external clock or trigger mode), TIxFP1 is not inverted (trigger in gated mode, encoder mode).
              01: inverted/falling edge
              Circuit is sensitive to TIxFP1 falling edge (capture, trigger in reset, external clock or trigger mode), TIxFP1 is inverted (trigger in gated mode, encoder mode).
              10: reserved, do not use this configuration.
              11: noninverted/both edges
              Circuit is sensitive to both TIxFP1 rising and falling edges (capture, trigger in reset, external clock or trigger mode), TIxFP1 is not inverted (trigger in gated mode). This configuration must not be used for encoder mode.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC1E</name>
              <description>
              Capture/Compare 1 output enable.
              CC1 channel configured as output:
              0: Off - OC1 is not active
              1: On - OC1 signal is output on the corresponding output pin
              CC1 channel configured as input: This bit determines if a capture of the counter value can actually be done into the input capture/compare register 1 (CCR1) or not.
              0: Capture disabled
              1: Capture enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CNT</name>
          <displayName>CNT</displayName>
          <description>Counter</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>UIFCPY</name>
              <description>
              Value depends on IUFREMAP in CR1.
              If UIFREMAP = 1
              UIFCPY: UIF Copy
              This bit is a read-only copy of the UIF bit of the ISR register
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>15</bitWidth>
            </field>
            <field>
              <name>CNT</name>
              <description>
              counter value
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PSC</name>
          <displayName>PSC</displayName>
          <description>Prescaler</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>PSC</name>
              <description>
              Prescaler value
              The counter clock frequency is equal to fCLK / (PSC[15:0] + 1).
              PSC contains the value to be loaded in the active prescaler register at each update event (including when the counter is cleared through UG bit of EGR register or through trigger controller when configured in 'reset mode').
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ARR</name>
          <displayName>ARR</displayName>
          <description>Auto-reload register</description>
          <addressOffset>0x2c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>ARR</name>
              <description>
              Auto-reload value
              ARR is the value to be loaded in the actual auto-reload register.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RCR</name>
          <displayName>RCR</displayName>
          <description>Repetition counter register</description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>REP</name>
              <description>
              Repetition counter value
              These bits allow the user to set-up the update rate of the compare registers (i.e. periodic transfers from preload to active registers) when preload registers are enable, as well as the update interrupt generation rate, if this interrupt is enable.
              Each time the REP_CNT related downcounter reaches zero, an update event is generated and it restarts counting from REP value. As REP_CNT is reloaded with REP value only at the repetition update event, any write to the RCR register is not taken in account until the next repetition update event.
              It means in PWM mode (REP+1) corresponds to the number of PWM periods in edge-aligned mode.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR1</name>
          <displayName>CCR1</displayName>
          <description>Capture/Compare register 1</description>
          <addressOffset>0x34</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>CCR1</name>
              <description>
              Capture/Compare 1 value
              If channel CC1 is configured as output:
              CCR1 is the value to be loaded in the actual capture/compare 1 register (preload value).It is loaded permanently if the preload feature is not selected in the CCMR1 register (bit OC1PE). Else the preload value is copied in the active capture/compare 1 register when an update event occurs.
              The active capture/compare register contains the value to be compared to the counter CNT and signaled on OC1 output.
              If channel CC1is configured as input:
              CCR1 is the counter value transferred by the last input capture 1 event (IC1). The CCR1 register is read-only and cannot be programmed.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR2</name>
          <displayName>CCR2</displayName>
          <description>Capture/Compare register 2</description>
          <addressOffset>0x38</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>CCR2</name>
              <description>
              Capture/Compare 2 value
              If channel CC2 is configured as output:
              CCR2 is the value to be loaded in the actual capture/compare 2 register (preload value).It is loaded permanently if the preload feature is not selected in the CCMR1 register (bit OC2PE). Else the preload value is copied in the active capture/compare 2 register when an update event occurs.
              The active capture/compare register contains the value to be compared to the counter CNT and signalled on OC2 output.
              If channel CC2 is configured as input:
              CCR2 is the counter value transferred by the last input capture 2 event (IC2). The CCR2 register is read-only and cannot be programmed.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR3</name>
          <displayName>CCR3</displayName>
          <description>Capture/Compare register 3</description>
          <addressOffset>0x3c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>CCR3</name>
              <description>
              Capture/Compare value
              If channel CC3 is configured as output:
              CCR3 is the value to be loaded in the actual capture/compare 3 register (preload value).It is loaded permanently if the preload feature is not selected in the CCMR2 register (bit OC3PE). Else the preload value is copied in the active capture/compare 3 register when an update event occurs.
              The active capture/compare register contains the value to be compared to the counter CNT and signalled on OC3 output.
              If channel CC3is configured as input:
              CCR3 is the counter value transferred by the last input capture 3 event (IC3). The CCR3 register is read-only and cannot be programmed.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR4</name>
          <displayName>CCR4</displayName>
          <description>Capture/Compare register 4</description>
          <addressOffset>0x40</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>CCR4</name>
              <description>
              Capture/Compare value
              1. if CC4 channel is configured as output:
              CCR4 is the value to be loaded in the actual capture/compare 4 register (preload value).It is loaded permanently if the preload feature is not selected in the CCMR2 register (bit OC4PE). Else the preload value is copied in the active capture/compare 4 register when an update event occurs.
              The active capture/compare register contains the value to be compared to the counter CNT and signalled on OC4 output.
              2.  if CC4 channel is configured as input:
              CCR4 is the counter value transferred by the last input capture 4 event (IC4). The CCR4 register is read-only and cannot be programmed.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>GPTIM2</name>
      <description></description>
      <groupName>GPTIM</groupName>
      <baseAddress>0x40011000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CR1</name>
          <displayName>CR1</displayName>
          <description>TIM control register 1</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>UIFREMAP</name>
              <description>
              UIF status bit remapping
              0: No remapping. UIF status bit is not copied to CNT register bit 31
              1: Remapping enabled. UIF status bit is copied to CNT register bit 31
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>ARPE</name>
              <description>
              Auto-reload preload enable
              0: ARR register is not buffered
              1: ARR register is buffered
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CMS</name>
              <description>
              Center-aligned mode selection
              00: Edge-aligned mode. The counter counts up or down depending on the direction bit (DIR).
              01: Center-aligned mode 1. The counter counts up and down alternatively. Output compare interrupt flags of channels configured in output (CCxS=00 in CCMRx register) are set only when the counter is counting down.
              10: Center-aligned mode 2. The counter counts up and down alternatively. Output compare interrupt flags of channels configured in output (CCxS=00 in CCMRx register) are set only when the counter is counting up.
              11: Center-aligned mode 3. The counter counts up and down alternatively. Output compare interrupt flags of channels configured in output (CCxS=00 in CCMRx register) are set both when the counter is counting up or down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>DIR</name>
              <description>
              Direction
              0: Counter used as upcounter
              1: Counter used as downcounter
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OPM</name>
              <description>
              One-pulse mode
              0: Counter is not stopped at update event
              1: Counter stops counting at the next update event (clearing the bit CEN)
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>URS</name>
              <description>
              Update request source
              This bit is set and cleared by software to select the UEV event sources.
              0: Any of the following events generate an update interrupt or DMA request if enabled. 
              These events can be: 
                 Counter overflow/underflow
                 Setting the UG bit
                 Update generation through the slave mode controller
              1: Only counter overflow/underflow generates an update interrupt or DMA request if enabled.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UDIS</name>
              <description>
              Update disable
              This bit is set and cleared by software to enable/disable UEV event generation.
              0: UEV enabled. The Update (UEV) event is generated by one of the following events:
                 Counter overflow/underflow
                 Setting the UG bit
                 Update generation through the slave mode controller
              Buffered registers are then loaded with their preload values.
              1: UEV disabled. The Update event is not generated, shadow registers keep their value (ARR, PSC, CCRx). However the counter and the prescaler are reinitialized if the UG bit is set or if a hardware reset is received from the slave mode controller.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CEN</name>
              <description>
              Counter enable
              0: Counter disabled
              1: Counter enabled
              Note: External clock, gated mode and encoder mode can work only if the CEN bit has been previously set by software. However trigger mode can set the CEN bit automatically by hardware. 
              CEN is cleared automatically in one-pulse mode, when an update event occurs.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CR2</name>
          <displayName>CR2</displayName>
          <description>TIM control register 2</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>TI1S</name>
              <description>
              TI1 selection
              0: The CH1 pin is connected to TI1 input
              1: The CH1, CH2 and CH3 pins are connected to the TI1 input (XOR combination) 
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MMS</name>
              <description>
              Master mode selection
              These bits allow to select the information to be sent in master mode to slave timers for synchronization (TRGO). The combination is as follows:
              000: Reset - the UG bit from the EGR register is used as trigger output (TRGO). If the reset is generated by the trigger input (slave mode controller configured in reset mode) then the signal on TRGO is delayed compared to the actual reset.
              001: Enable - the Counter enable signal is used as trigger output (TRGO). It is useful to start several timers at the same time or to control a window in which a slave timer is enabled. The Counter Enable signal is generated by a logic OR between CEN control bit and the trigger input when configured in gated mode. 
              When the Counter Enable signal is controlled by the trigger input, there is a delay on TRGO, except if the master/slave mode is selected.
              010: Update - The update event is selected as trigger output (TRGO). For instance a master timer can then be used as a prescaler for a slave timer.
              011: Compare Pulse - The trigger output send a positive pulse when the CC1IF flag is to be set (even if it was already high), as soon as a capture or a compare match occurred. (TRGO)
              100: Compare - OC1REF signal is used as trigger output (TRGO)
              101: Compare - OC2REF signal is used as trigger output (TRGO)
              110: Compare - OC3REF signal is used as trigger output (TRGO)
              111: Compare - OC4REF signal is used as trigger output (TRGO)
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>CCDS</name>
              <description>
              Capture/compare DMA selection
              0: CCx DMA request sent when CCx event occurs
              1: CCx DMA requests sent when update event occurs
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SMCR</name>
          <displayName>SMCR</displayName>
          <description>TIM slave mode control register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
            <field>
              <name>SMS</name>
              <description>
              Slave mode selection
              When external signals are selected the active edge of the trigger signal (TRGI) is linked to the polarity selected on the external input.
              0000: Slave mode disabled.
              0001: Encoder mode 1 - Counter counts up/down on TI1FP1 edge depending on TI2FP2 level.
              0010: Encoder mode 2 - Counter counts up/down on TI2FP2 edge depending on TI1FP1 level.
              0011: Encoder mode 3 - Counter counts up/down on both TI1FP1 and TI2FP2 edges depending on the level of the other input.
              0100: Reset Mode - Rising edge of the selected trigger input (TRGI) reinitializes the counter and generates an update of the registers.
              0101: Gated Mode - The counter clock is enabled when the trigger input (TRGI) is high. The counter stops (but is not reset) as soon as the trigger becomes low. Both start and stop of the counter are controlled.
              0110: Trigger Mode - The counter starts at a rising edge of the trigger TRGI (but it is not reset). Only the start of the counter is controlled.
              0111: External Clock Mode 1 - Rising edges of the selected trigger (TRGI) clock the counter.
              1000: Combined reset + trigger mode - Rising edge of the selected trigger input (TRGI) reinitializes the counter, generates an update of the registers and starts the counter.
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>ETP</name>
              <description>
              External trigger polarity
              0: ETR is non-inverted, active at high level or rising edge
              1: ETR is inverted, active at low level or falling edge
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ECE</name>
              <description>
              External clock enable
              This bit enables External clock mode 2.
              0: External clock mode 2 disabled
              1: External clock mode 2 enabled. The counter is clocked by any active edge on the ETRF signal.
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ETPS</name>
              <description>
              External trigger prescaler
              External trigger signal ETRP frequency must be at most 1/4 of CK_INT frequency. A prescaler can be enabled to reduce ETRP frequency. It is useful when inputting fast external clocks.
              00: Prescaler OFF
              01: ETRP frequency divided by 2
              10: ETRP frequency divided by 4
              11: ETRP frequency divided by 8
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>ETF</name>
              <description>
              External trigger filter
              This bit-field then defines the frequency used to sample ETRP signal and the length of the digital filter applied to ETRP. The digital filter is made of an event counter in which N 
              consecutive events are needed to validate a transition on the output:
              0000: No filter
              0001:   fSAMPLING=fCLK, N=2
              0010:   fSAMPLING=fCLK, N=4
              0011:   fSAMPLING=fCLK, N=8
              0100:   fSAMPLING=fCLK/2, N=6
              0101:   fSAMPLING=fCLK/2, N=8
              0110:   fSAMPLING=fCLK/4, N=6
              0111:   fSAMPLING=fCLK/4, N=8
              1000:   fSAMPLING=fCLK/8, N=6
              1001:   fSAMPLING=fCLK/8, N=8
              1010:   fSAMPLING=fCLK/16, N=5
              1011:   fSAMPLING=fCLK/16, N=6
              1100:   fSAMPLING=fCLK/16, N=8
              1101:   fSAMPLING=fCLK/32, N=5
              1110:   fSAMPLING=fCLK/32, N=6
              1111:   fSAMPLING=fCLK/32, N=8
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>MSM</name>
              <description>
              Master/Slave mode
              0: No action
              1: The effect of an event on the trigger input (TRGI) is delayed to allow a perfect synchronization between the current timer and its slaves (through TRGO). It is useful if we want to synchronize several timers on a single external event.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TS</name>
              <description>
              Trigger selection
              This bit-field selects the trigger input to be used to synchronize the counter.
              000: Internal Trigger 0 (ITR0)
              001: Internal Trigger 1 (ITR1) 
              010: Internal Trigger 2 (ITR2)
              011: Internal Trigger 3 (ITR3)
              100: TI1 Edge Detector (TI1F_ED)
              101: Filtered Timer Input 1 (TI1FP1)
              110: Filtered Timer Input 2 (TI2FP2)
              111: External Trigger input (ETRF)
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DIER</name>
          <displayName>DIER</displayName>
          <description>TIM DMA/Interrupt enable register</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
            <field>
              <name>TDE</name>
              <description>
              Trigger DMA request enable
              0: Trigger DMA request disabled.
              1: Trigger DMA request enabled.
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC4DE</name>
              <description>
              Capture/Compare 4 DMA request enable
              0: CC4 DMA request disabled.
              1: CC4 DMA request enabled
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC3DE</name>
              <description>
              Capture/Compare 3 DMA request enable
              0: CC3 DMA request disabled.
              1: CC3 DMA request enabled.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC2DE</name>
              <description>
              Capture/Compare 2 DMA request enable
              0: CC2 DMA request disabled.
              1: CC2 DMA request enabled.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC1DE</name>
              <description>
              Capture/Compare 1 DMA request enable
              0: CC1 DMA request disabled.
              1: CC1 DMA request enabled.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UDE</name>
              <description>
              Update DMA request enable
              0: Update DMA request disabled.
              1: Update DMA request enabled
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TIE</name>
              <description>
              Trigger interrupt enable
              0: Trigger interrupt disabled.
              1: Trigger interrupt enabled
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC4IE</name>
              <description>
              Capture/Compare 4 interrupt enable
              0: CC4 interrupt disabled.
              1: CC4 interrupt enabled
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC3IE</name>
              <description>
              Capture/Compare 3 interrupt enable
              0: CC3 interrupt disabled.
              1: CC3 interrupt enabled
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC2IE</name>
              <description>
              Capture/Compare 2 interrupt enable
              0: CC2 interrupt disabled.
              1: CC2 interrupt enabled.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC1IE</name>
              <description>
              Capture/Compare 1 interrupt enable
              0: CC1 interrupt disabled.
              1: CC1 interrupt enabled
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UIE</name>
              <description>
              Update interrupt enable
              0: Update interrupt disabled.
              1: Update interrupt enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SR</name>
          <displayName>SR</displayName>
          <description>TIM status register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>19</bitWidth>
            </field>
            <field>
              <name>CC4OF</name>
              <description>
              Capture/Compare 4 overcapture flag
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC3OF</name>
              <description>
              Capture/Compare 3 overcapture flag
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC2OF</name>
              <description>
              Capture/Compare 2 overcapture flag
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC1OF</name>
              <description>
              Capture/Compare 1 overcapture flag
              This flag is set by hardware only when the corresponding channel is configured in input capture mode. It is cleared by software by writing it to '0'.
              0: No overcapture has been detected.
              1: The counter value has been captured in CCR1 register while CC1IF flag was already set
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>TIF</name>
              <description>
              Trigger interrupt flag
              This flag is set by hardware on trigger event (active edge detected on TRGI input when the slave mode controller is enabled in all modes but gated mode). It is set when the counter starts or stops when gated mode is selected. It is cleared by software.
              0: No trigger event occurred.
              1: Trigger interrupt pending.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC4IF</name>
              <description>
              Capture/Compare 4 interrupt flag
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC3IF</name>
              <description>
              Capture/Compare 3 interrupt flag
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC2IF</name>
              <description>
              Capture/Compare 2 interrupt flag
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC1IF</name>
              <description>
              Capture/Compare 1 interrupt flag
              If channel CC1 is configured as output: This flag is set by hardware when the counter matches the compare value. It is cleared by software.
              0: No match.
              1: The content of the counter CNT has matched the content of the CCR1 register.
              If channel CC1 is configured as input: This bit is set by hardware on a capture. It is cleared by software or by reading the CCR1 register.
              0: No input capture occurred.
              1: The counter value has been captured in CCR1 register (An edge has been detected on IC1 which matches the selected polarity).
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UIF</name>
              <description>
              Update interrupt flag
              This bit is set by hardware on an update event. It is cleared by software.
              0: No update occurred
              1: Update interrupt pending. This bit is set by hardware when the registers are updated:
              At overflow or underflow and if UDIS=0 in the CR1 register.
              When CNT is reinitialized by software using the UG bit in EGR register, if URS=0 and UDIS=0 in the CR1 register.
              When CNT is reinitialized by a trigger event, if URS=0 and UDIS=0 in the CR1 register.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>EGR</name>
          <displayName>EGR</displayName>
          <description>Event generation register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>25</bitWidth>
            </field>
            <field>
              <name>TG</name>
              <description>
              Trigger generation
              This bit is set by software in order to generate an event, it is automatically cleared by hardware.
              0: No action
              1: The TIF flag is set in SR register. Related interrupt or DMA transfer can occur if enabled.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC4G</name>
              <description>
              Capture/compare 4 generation
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC3G</name>
              <description>
              Capture/compare 3 generation
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC2G</name>
              <description>
              Capture/compare 2 generation
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC1G</name>
              <description>
              Capture/compare 1 generation
              This bit is set by software in order to generate an event, it is automatically cleared by hardware.
              0: No action
              1: A capture/compare event is generated on channel 1:
              If channel CC1 is configured as output:
              CC1IF flag is set, Corresponding interrupt or DMA request is sent if enabled.
              If channel CC1 is configured as input:
              The current value of the counter is captured in CCR1 register. The CC1IF flag is set, the corresponding interrupt or DMA request is sent if enabled. The CC1OF flag is set if the CC1IF flag was already high.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UG</name>
              <description>
              Update generation
              This bit can be set by software, it is automatically cleared by hardware.
              0: No action
              1: Re-initialize the counter and generates an update of the registers. Note that the prescaler counter is cleared too (anyway the prescaler ratio is not affected). The counter is cleared if the center-aligned mode is selected or if DIR=0 (upcounting), else it takes the auto-reload value (ARR) if DIR=1 (downcounting).
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCMR1</name>
          <displayName>CCMR1</displayName>
          <description>TIM capture/compare mode register 1</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>OC2M</name>
              <description>
              Output compare 2 mode
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>OC2PE</name>
              <description>
              Output compare 2 preload enable
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>OC2CE</name>
              <description>
              Output compare 2 clear enable
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OC1M</name>
              <description>
              Output compare 1 mode
              These bits define the behavior of the output reference signal OC1REF from which OC1 and OC1N are derived. OC1REF is active high whereas OC1 and OC1N active level depends on CC1P and CC1NP bits.
              0000: Frozen - The comparison between the output compare register CCR1 and the counter CNT has no effect on the outputs.(this mode is used to generate a timing base).
              0001: Set channel 1 to active level on match. OC1REF signal is forced high when the counter CNT matches the capture/compare register 1 (CCR1).
              0010: Set channel 1 to inactive level on match. OC1REF signal is forced low when the counter CNT matches the capture/compare register 1 (CCR1).
              0011: Toggle - OC1REF toggles when CNT=CCR1.
              0100: Force inactive level - OC1REF is forced low.
              0101: Force active level - OC1REF is forced high.
              0110: PWM mode 1 - In upcounting, channel 1 is active as long as CNTltCCR1 else inactive. In downcounting, channel 1 is inactive (OC1REF='0) as long as CNT>CCR1 else active (OC1REF=1).
              0111: PWM mode 2 - In upcounting, channel 1 is inactive as long as CNTltCCR1 else active. In downcounting, channel 1 is active as long as CNT>CCR1 else inactive.
              1000: Retriggerable OPM mode 1 - In up-counting mode, the channel is active until a trigger event is detected (on TRGI signal). Then, a comparison is performed as in PWM mode 1 and the channels becomes inactive again at the next update. In down-counting mode, the channel is inactive until a trigger event is detected (on TRGI signal). Then, a comparison is performed as in PWM mode 1 and the channels becomes inactive again at the next update.
              1001: Retriggerable OPM mode 2 - In up-counting mode, the channel is inactive until a trigger event is detected (on TRGI signal). Then, a comparison is performed as in PWM mode 2 and the channels becomes inactive again at the next update. In down-counting mode, the channel is active until a trigger event is detected (on TRGI signal). Then, a comparison is performed as in PWM mode 1 and the channels becomes active again at the next update.
              1010: Reserved,
              1011: Reserved,
              1100: Combined PWM mode 1 - OC1REF has the same behavior as in PWM mode 1. OC1REFC is the logical OR between OC1REF and OC2REF.
              1101: Combined PWM mode 2 - OC1REF has the same behavior as in PWM mode 2. OC1REFC is the logical AND between OC1REF and OC2REF.
              1110: Asymmetric PWM mode 1 - OC1REF has the same behavior as in PWM mode 1. OC1REFC outputs OC1REF when the counter is counting up, OC2REF when it is counting down.
              1111: Asymmetric PWM mode 2 - OC1REF has the same behavior as in PWM mode 2. OC1REFC outputs OC1REF when the counter is counting up, OC2REF when it is counting down.
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>OC1PE</name>
              <description>
              Output compare 1 preload enable
              0: Preload register on CCR1 disabled. CCR1 can be written at anytime, the new value is taken in account immediately.
              1: Preload register on CCR1 enabled. Read/Write operations access the preload register. CCR1 preload value is loaded in the active register at each update event.
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>OC1CE</name>
              <description>
              Output compare 1 clear enable
              0: OC1Ref is not affected by the ETRF input
              1: OC1Ref is cleared as soon as a High level is detected on ETRF input
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IC2F</name>
              <description>
              Input capture 2 filter
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>IC2PSC</name>
              <description>
              Input capture 2 prescaler
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>CC2S</name>
              <description>
              Capture/Compare 2 selection
              This bit-field defines the direction of the channel (input/output) as well as the used input. 
              00: CC2 channel is configured as output
              01: CC2 channel is configured as input, IC2 is mapped on TI2
              10: CC2 channel is configured as input, IC2 is mapped on TI1
              11: CC2 channel is configured as input, IC2 is mapped on TRC. This mode is working only if an internal trigger input is selected through the TS bit (SMCR register)
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>IC1F</name>
              <description>
              Input capture 1 filter
              This bit-field defines the frequency used to sample TI1 input and the length of the digital filter applied to TI1. The digital filter is made of an event counter in which N consecutive events are needed to validate a transition on the output:
              0000: No filter, sampling is done at fCLK
              0001: fSAMPLING=fCLK, N=2
              0010: fSAMPLING=fCLK, N=4
              0011: fSAMPLING=fCLK, N=8
              0100: fSAMPLING=fCLK/2, N=6
              0101: fSAMPLING=fCLK/2, N=8
              0110: fSAMPLING=fCLK/4, N=6
              0111: fSAMPLING=fCLK/4, N=8
              1000: fSAMPLING=fCLK/8, N=6
              1001: fSAMPLING=fCLK/8, N=8
              1010: fSAMPLING=fCLK/16, N=5
              1011: fSAMPLING=fCLK/16, N=6
              1100: fSAMPLING=fCLK/16, N=8
              1101: fSAMPLING=fCLK/32, N=5
              1110: fSAMPLING=fCLK/32, N=6
              1111: fSAMPLING=fCLK/32, N=8
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>IC1PSC</name>
              <description>
              Input capture 1 prescaler
              This bit-field defines the ratio of the prescaler acting on CC1 input (IC1). The prescaler is reset as soon as CC1E=0.
              00: no prescaler, capture is done each time an edge is detected on the capture input
              01: capture is done once every 2 events
              10: capture is done once every 4 events
              11: capture is done once every 8 events
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>CC1S</name>
              <description>
              Capture/Compare 1 selection
              This bit-field defines the direction of the channel (input/output) as well as the used input. 
              00: CC1 channel is configured as output
              01: CC1 channel is configured as input, IC1 is mapped on TI1
              10: CC1 channel is configured as input, IC1 is mapped on TI2
              11: CC1 channel is configured as input, IC1 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (SMCR register)
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCMR2</name>
          <displayName>CCMR2</displayName>
          <description>TIM capture/compare mode register 2</description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>OC4M</name>
              <description>
              Output compare 4 mode
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>OC4PE</name>
              <description>
              Output compare 4 preload enable
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>OC4CE</name>
              <description>
              Output compare 4 clear enable
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OC3M</name>
              <description>
              Output compare 3 mode
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>OC3PE</name>
              <description>
              Output compare 3 preload enable
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>OC3CE</name>
              <description>
              Output compare 3 clear enable
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IC4F</name>
              <description>
              Input capture 4 filter
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>IC4PSC</name>
              <description>
              Input capture 4 prescaler
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>CC4S</name>
              <description>
              Capture/Compare 4 selection
              This bit-field defines the direction of the channel (input/output) as well as the used input. 
              00: CC4 channel is configured as output
              01: CC4 channel is configured as input, IC4 is mapped on TI4
              10: CC4 channel is configured as input, IC4 is mapped on TI3
              11: CC4 channel is configured as input, IC4 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (SMCR register)
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>IC3F</name>
              <description>
              Input capture 3 filter
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>IC3PSC</name>
              <description>
              Input capture 3 prescaler
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>CC3S</name>
              <description>
              Capture/Compare 3 selection
              This bit-field defines the direction of the channel (input/output) as well as the used input. 
              00: CC3 channel is configured as output
              01: CC3 channel is configured as input, IC3 is mapped on TI3
              10: CC3 channel is configured as input, IC3 is mapped on TI4
              11: CC3 channel is configured as input, IC3 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (SMCR register)
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCER</name>
          <displayName>CCER</displayName>
          <description>Capture/Compare enable register</description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>CC4NP</name>
              <description>
              Capture/Compare 4 output Polarity.
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC4P</name>
              <description>
              Capture/Compare 4 output Polarity.
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC4E</name>
              <description>
              Capture/Compare 4 output enable.
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC3NP</name>
              <description>
              Capture/Compare 3 output Polarity.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC3P</name>
              <description>
              Capture/Compare 3 output Polarity.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC3E</name>
              <description>
              Capture/Compare 3 output enable.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC2NP</name>
              <description>
              Capture/Compare 2 output Polarity.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC2P</name>
              <description>
              Capture/Compare 2 output Polarity.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC2E</name>
              <description>
              Capture/Compare 2 output enable.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC1NP</name>
              <description>
              Capture/Compare 1 output Polarity.
              CC1 channel configured as output: CC1NP must be kept cleared in this case.
              CC1 channel configured as input: This bit is used in conjunction with CC1P to define TI1FP1/TI2FP1 polarity. refer to CC1P description.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD5</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC1P</name>
              <description>
              Capture/Compare 1 output Polarity.
              CC1 channel configured as output:
              0: OC1 active high
              1: OC1 active low
              CC1 channel configured as input: CC1NP/CC1P bits select TI1FP1 and TI2FP1 polarity for trigger or capture operations.
              00: noninverted/rising edge
              Circuit is sensitive to TIxFP1 rising edge (capture, trigger in reset, external clock or trigger mode), TIxFP1 is not inverted (trigger in gated mode, encoder mode).
              01: inverted/falling edge
              Circuit is sensitive to TIxFP1 falling edge (capture, trigger in reset, external clock or trigger mode), TIxFP1 is inverted (trigger in gated mode, encoder mode).
              10: reserved, do not use this configuration.
              11: noninverted/both edges
              Circuit is sensitive to both TIxFP1 rising and falling edges (capture, trigger in reset, external clock or trigger mode), TIxFP1 is not inverted (trigger in gated mode). This configuration must not be used for encoder mode.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC1E</name>
              <description>
              Capture/Compare 1 output enable.
              CC1 channel configured as output:
              0: Off - OC1 is not active
              1: On - OC1 signal is output on the corresponding output pin
              CC1 channel configured as input: This bit determines if a capture of the counter value can actually be done into the input capture/compare register 1 (CCR1) or not.
              0: Capture disabled
              1: Capture enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CNT</name>
          <displayName>CNT</displayName>
          <description>Counter</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>UIFCPY</name>
              <description>
              Value depends on IUFREMAP in CR1.
              If UIFREMAP = 1
              UIFCPY: UIF Copy
              This bit is a read-only copy of the UIF bit of the ISR register
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>15</bitWidth>
            </field>
            <field>
              <name>CNT</name>
              <description>
              counter value
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PSC</name>
          <displayName>PSC</displayName>
          <description>Prescaler</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>PSC</name>
              <description>
              Prescaler value
              The counter clock frequency is equal to fCLK / (PSC[15:0] + 1).
              PSC contains the value to be loaded in the active prescaler register at each update event (including when the counter is cleared through UG bit of EGR register or through trigger controller when configured in 'reset mode').
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ARR</name>
          <displayName>ARR</displayName>
          <description>Auto-reload register</description>
          <addressOffset>0x2c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>ARR</name>
              <description>
              Auto-reload value
              ARR is the value to be loaded in the actual auto-reload register.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RCR</name>
          <displayName>RCR</displayName>
          <description>Repetition counter register</description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>REP</name>
              <description>
              Repetition counter value
              These bits allow the user to set-up the update rate of the compare registers (i.e. periodic transfers from preload to active registers) when preload registers are enable, as well as the update interrupt generation rate, if this interrupt is enable.
              Each time the REP_CNT related downcounter reaches zero, an update event is generated and it restarts counting from REP value. As REP_CNT is reloaded with REP value only at the repetition update event, any write to the RCR register is not taken in account until the next repetition update event.
              It means in PWM mode (REP+1) corresponds to the number of PWM periods in edge-aligned mode.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR1</name>
          <displayName>CCR1</displayName>
          <description>Capture/Compare register 1</description>
          <addressOffset>0x34</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>CCR1</name>
              <description>
              Capture/Compare 1 value
              If channel CC1 is configured as output:
              CCR1 is the value to be loaded in the actual capture/compare 1 register (preload value).It is loaded permanently if the preload feature is not selected in the CCMR1 register (bit OC1PE). Else the preload value is copied in the active capture/compare 1 register when an update event occurs.
              The active capture/compare register contains the value to be compared to the counter CNT and signaled on OC1 output.
              If channel CC1is configured as input:
              CCR1 is the counter value transferred by the last input capture 1 event (IC1). The CCR1 register is read-only and cannot be programmed.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR2</name>
          <displayName>CCR2</displayName>
          <description>Capture/Compare register 2</description>
          <addressOffset>0x38</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>CCR2</name>
              <description>
              Capture/Compare 2 value
              If channel CC2 is configured as output:
              CCR2 is the value to be loaded in the actual capture/compare 2 register (preload value).It is loaded permanently if the preload feature is not selected in the CCMR1 register (bit OC2PE). Else the preload value is copied in the active capture/compare 2 register when an update event occurs.
              The active capture/compare register contains the value to be compared to the counter CNT and signalled on OC2 output.
              If channel CC2 is configured as input:
              CCR2 is the counter value transferred by the last input capture 2 event (IC2). The CCR2 register is read-only and cannot be programmed.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR3</name>
          <displayName>CCR3</displayName>
          <description>Capture/Compare register 3</description>
          <addressOffset>0x3c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>CCR3</name>
              <description>
              Capture/Compare value
              If channel CC3 is configured as output:
              CCR3 is the value to be loaded in the actual capture/compare 3 register (preload value).It is loaded permanently if the preload feature is not selected in the CCMR2 register (bit OC3PE). Else the preload value is copied in the active capture/compare 3 register when an update event occurs.
              The active capture/compare register contains the value to be compared to the counter CNT and signalled on OC3 output.
              If channel CC3is configured as input:
              CCR3 is the counter value transferred by the last input capture 3 event (IC3). The CCR3 register is read-only and cannot be programmed.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR4</name>
          <displayName>CCR4</displayName>
          <description>Capture/Compare register 4</description>
          <addressOffset>0x40</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>CCR4</name>
              <description>
              Capture/Compare value
              1. if CC4 channel is configured as output:
              CCR4 is the value to be loaded in the actual capture/compare 4 register (preload value).It is loaded permanently if the preload feature is not selected in the CCMR2 register (bit OC4PE). Else the preload value is copied in the active capture/compare 4 register when an update event occurs.
              The active capture/compare register contains the value to be compared to the counter CNT and signalled on OC4 output.
              2.  if CC4 channel is configured as input:
              CCR4 is the counter value transferred by the last input capture 4 event (IC4). The CCR4 register is read-only and cannot be programmed.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>BTIM1</name>
      <description></description>
      <groupName>BTIM</groupName>
      <baseAddress>0x40012000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CR1</name>
          <displayName>CR1</displayName>
          <description>TIM control register 1</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>ARPE</name>
              <description>
              Auto-reload preload enable
              0: ARR register is not buffered
              1: ARR register is buffered
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>OPM</name>
              <description>
              One-pulse mode
              0: Counter is not stopped at update event
              1: Counter stops counting at the next update event (clearing the bit CEN)
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>URS</name>
              <description>
              Update request source
              This bit is set and cleared by software to select the UEV event sources.
              0: Any of the following events generate an update interrupt or DMA request if enabled. 
              These events can be: 
                 Counter overflow
                 Setting the UG bit
                 Update generation through the slave mode controller
              1: Only counter overflow generates an update interrupt or DMA request if enabled.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UDIS</name>
              <description>
              Update disable
              This bit is set and cleared by software to enable/disable UEV event generation.
              0: UEV enabled. The Update (UEV) event is generated by one of the following events:
                 Counter overflow
                 Setting the UG bit
                 Update generation through the slave mode controller
              Buffered registers are then loaded with their preload values.
              1: UEV disabled. The Update event is not generated, shadow registers keep their value (ARR, PSC). However the counter and the prescaler are reinitialized if the UG bit is set or if a hardware reset is received from the slave mode controller.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CEN</name>
              <description>
              Counter enable
              0: Counter disabled
              1: Counter enabled
              Note: Gated mode can work only if the CEN bit has been previously set by software. However trigger mode can set the CEN bit automatically by hardware. 
              CEN is cleared automatically in one-pulse mode, when an update event occurs.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CR2</name>
          <displayName>CR2</displayName>
          <description>TIM control register 2</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>26</bitWidth>
            </field>
            <field>
              <name>MMS</name>
              <description>
              Master mode selection
              These bits allow to select the information to be sent in master mode to slave timers for synchronization (TRGO). The combination is as follows:
              00: Reset:the UG bit from the EGR register is used as trigger output (TRGO). If the reset is generated by the trigger input (slave mode controller configured in reset mode) then the signal on TRGO is delayed compared to the actual reset.
              01: Enable :the Counter enable signal, CNT_EN, is used as trigger output (TRGO). It is useful to start several timers at the same time or to control a window in which a slave timer is enabled. The Counter Enable signal is generated by a logic OR between CEN control bit and the trigger input when configured in gated mode. 
              When the Counter Enable signal is controlled by the trigger input, there is a delay on TRGO, except if the master/slave mode is selected (see the MSM bit description in SMCR register).
              10: Update:The update event is selected as trigger output (TRGO). For instance a master timer can then be used as a prescaler for a slave timer.
              11: Gating:The delayed gating trigger is selected as trigger output (TRGO). 
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SMCR</name>
          <displayName>SMCR</displayName>
          <description>TIM slave mode control register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>GM</name>
              <description>
              Gated Mode. The counter clock is enabled when the selected trigger input (TRGI) is active (according to gating trigger polarity). The counter stops (but is not reset) as soon as the trigger becomes inactive. Both start and stop of the counter are controlled. Gated mode and slave mode can be enabled simutanuously with different trigger selection.
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GTP</name>
              <description>
              Gating trigger polarity invert
              0: active at high level
              1: active at low level
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GTS</name>
              <description>
              Gating trigger selection in gated mode
              This bit-field selects the trigger input to be used to enable the counter gating.
              00: Internal Trigger 0 (ITR0)
              01: Internal Trigger 1 (ITR1) 
              10: Internal Trigger 2 (ITR2)
              11: Internal Trigger 3 (ITR3)
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SMS</name>
              <description>
              Slave mode selection
              When external signals are selected the active edge of the trigger signal (TRGI) is linked to the polarity selected on the external input.
              000: Slave mode disabled.
              001: Reset Mode - Rising edge of the selected trigger input (TRGI) reinitializes the counter and generates an update of the registers.
              010: Trigger Mode - The counter starts at a rising edge of the trigger TRGI (but it is not reset). Only the start of the counter is controlled.
              011: Combined reset + trigger mode - Rising edge of the selected trigger input (TRGI) reinitializes the counter, generates an update of the registers and starts the counter.
              100: External Clock Mode - Rising edges of the selected trigger (TRGI) clock the counter.
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>MSM</name>
              <description>
              Master/Slave mode. This bit should be asserted on master timer if synchronization if needed.
              0: No action
              1: The effect of an event on the trigger input (TRGI) is delayed to allow a perfect synchronization between the current timer and its slaves (through TRGO). It is useful if we want to synchronize several timers on a single external event.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TS</name>
              <description>
              Trigger selection
              This bit-field selects the trigger input to be used to synchronize the counter.
              00: Internal Trigger 0 (ITR0)
              01: Internal Trigger 1 (ITR1) 
              10: Internal Trigger 2 (ITR2)
              11: Internal Trigger 3 (ITR3)
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD5</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DIER</name>
          <displayName>DIER</displayName>
          <description>TIM DMA/Interrupt enable register</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>UDE</name>
              <description>
              Update DMA request enable
              0: Update DMA request disabled.
              1: Update DMA request enabled
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
            <field>
              <name>UIE</name>
              <description>
              Update interrupt enable
              0: Update interrupt disabled.
              1: Update interrupt enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SR</name>
          <displayName>SR</displayName>
          <description>TIM status register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>31</bitWidth>
            </field>
            <field>
              <name>UIF</name>
              <description>
              Update interrupt flag
              This bit is set by hardware on an update event. It is cleared by software.
              0: No update occurred
              1: Update interrupt pending. This bit is set by hardware when the registers are updated:
              At overflow and if UDIS=0 in the CR1 register.
              When CNT is reinitialized by software using the UG bit in EGR register, if URS=0 and UDIS=0 in the CR1 register.
              When CNT is reinitialized by a trigger event (refer to the synchro control register description), if URS=0 and UDIS=0 in the CR1 register.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>EGR</name>
          <displayName>EGR</displayName>
          <description>Event generation register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>31</bitWidth>
            </field>
            <field>
              <name>UG</name>
              <description>
              Update generation
              This bit can be set by software, it is automatically cleared by hardware.
              0: No action
              1: Re-initialize the counter and generates an update of the registers. Note that the prescaler counter is cleared too (anyway the prescaler ratio is not affected). The counter is cleared if the center-aligned mode is selected or if DIR=0 (upcounting), else it takes the auto-reload value (ARR) if DIR=1 (downcounting).
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD1</name>
          <displayName>RSVD1</displayName>
          <description></description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>CNT</name>
          <displayName>CNT</displayName>
          <description>Counter</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>CNT</name>
              <description>
              counter value
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PSC</name>
          <displayName>PSC</displayName>
          <description>Prescaler</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>PSC</name>
              <description>
              Prescaler value
              The counter clock frequency is equal to fCLK / (PSC[15:0] + 1).
              PSC contains the value to be loaded in the active prescaler register at each update event (including when the counter is cleared through UG bit of EGR register or through trigger controller when configured in "reset mode").
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ARR</name>
          <displayName>ARR</displayName>
          <description>Auto-reload register</description>
          <addressOffset>0x2c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ARR</name>
              <description>
              Auto-reload value
              ARR is the value to be loaded in the actual auto-reload register. The counter is blocked while the auto-reload value is null.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>BTIM2</name>
      <description></description>
      <groupName>BTIM</groupName>
      <baseAddress>0x40013000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CR1</name>
          <displayName>CR1</displayName>
          <description>TIM control register 1</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>ARPE</name>
              <description>
              Auto-reload preload enable
              0: ARR register is not buffered
              1: ARR register is buffered
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>OPM</name>
              <description>
              One-pulse mode
              0: Counter is not stopped at update event
              1: Counter stops counting at the next update event (clearing the bit CEN)
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>URS</name>
              <description>
              Update request source
              This bit is set and cleared by software to select the UEV event sources.
              0: Any of the following events generate an update interrupt or DMA request if enabled. 
              These events can be: 
                 Counter overflow
                 Setting the UG bit
                 Update generation through the slave mode controller
              1: Only counter overflow generates an update interrupt or DMA request if enabled.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UDIS</name>
              <description>
              Update disable
              This bit is set and cleared by software to enable/disable UEV event generation.
              0: UEV enabled. The Update (UEV) event is generated by one of the following events:
                 Counter overflow
                 Setting the UG bit
                 Update generation through the slave mode controller
              Buffered registers are then loaded with their preload values.
              1: UEV disabled. The Update event is not generated, shadow registers keep their value (ARR, PSC). However the counter and the prescaler are reinitialized if the UG bit is set or if a hardware reset is received from the slave mode controller.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CEN</name>
              <description>
              Counter enable
              0: Counter disabled
              1: Counter enabled
              Note: Gated mode can work only if the CEN bit has been previously set by software. However trigger mode can set the CEN bit automatically by hardware. 
              CEN is cleared automatically in one-pulse mode, when an update event occurs.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CR2</name>
          <displayName>CR2</displayName>
          <description>TIM control register 2</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>26</bitWidth>
            </field>
            <field>
              <name>MMS</name>
              <description>
              Master mode selection
              These bits allow to select the information to be sent in master mode to slave timers for synchronization (TRGO). The combination is as follows:
              00: Reset:the UG bit from the EGR register is used as trigger output (TRGO). If the reset is generated by the trigger input (slave mode controller configured in reset mode) then the signal on TRGO is delayed compared to the actual reset.
              01: Enable :the Counter enable signal, CNT_EN, is used as trigger output (TRGO). It is useful to start several timers at the same time or to control a window in which a slave timer is enabled. The Counter Enable signal is generated by a logic OR between CEN control bit and the trigger input when configured in gated mode. 
              When the Counter Enable signal is controlled by the trigger input, there is a delay on TRGO, except if the master/slave mode is selected (see the MSM bit description in SMCR register).
              10: Update:The update event is selected as trigger output (TRGO). For instance a master timer can then be used as a prescaler for a slave timer.
              11: Gating:The delayed gating trigger is selected as trigger output (TRGO). 
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SMCR</name>
          <displayName>SMCR</displayName>
          <description>TIM slave mode control register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>GM</name>
              <description>
              Gated Mode. The counter clock is enabled when the selected trigger input (TRGI) is active (according to gating trigger polarity). The counter stops (but is not reset) as soon as the trigger becomes inactive. Both start and stop of the counter are controlled. Gated mode and slave mode can be enabled simutanuously with different trigger selection.
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GTP</name>
              <description>
              Gating trigger polarity invert
              0: active at high level
              1: active at low level
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GTS</name>
              <description>
              Gating trigger selection in gated mode
              This bit-field selects the trigger input to be used to enable the counter gating.
              00: Internal Trigger 0 (ITR0)
              01: Internal Trigger 1 (ITR1) 
              10: Internal Trigger 2 (ITR2)
              11: Internal Trigger 3 (ITR3)
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SMS</name>
              <description>
              Slave mode selection
              When external signals are selected the active edge of the trigger signal (TRGI) is linked to the polarity selected on the external input.
              000: Slave mode disabled.
              001: Reset Mode - Rising edge of the selected trigger input (TRGI) reinitializes the counter and generates an update of the registers.
              010: Trigger Mode - The counter starts at a rising edge of the trigger TRGI (but it is not reset). Only the start of the counter is controlled.
              011: Combined reset + trigger mode - Rising edge of the selected trigger input (TRGI) reinitializes the counter, generates an update of the registers and starts the counter.
              100: External Clock Mode - Rising edges of the selected trigger (TRGI) clock the counter.
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>MSM</name>
              <description>
              Master/Slave mode. This bit should be asserted on master timer if synchronization if needed.
              0: No action
              1: The effect of an event on the trigger input (TRGI) is delayed to allow a perfect synchronization between the current timer and its slaves (through TRGO). It is useful if we want to synchronize several timers on a single external event.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TS</name>
              <description>
              Trigger selection
              This bit-field selects the trigger input to be used to synchronize the counter.
              00: Internal Trigger 0 (ITR0)
              01: Internal Trigger 1 (ITR1) 
              10: Internal Trigger 2 (ITR2)
              11: Internal Trigger 3 (ITR3)
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD5</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DIER</name>
          <displayName>DIER</displayName>
          <description>TIM DMA/Interrupt enable register</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>UDE</name>
              <description>
              Update DMA request enable
              0: Update DMA request disabled.
              1: Update DMA request enabled
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
            <field>
              <name>UIE</name>
              <description>
              Update interrupt enable
              0: Update interrupt disabled.
              1: Update interrupt enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SR</name>
          <displayName>SR</displayName>
          <description>TIM status register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>31</bitWidth>
            </field>
            <field>
              <name>UIF</name>
              <description>
              Update interrupt flag
              This bit is set by hardware on an update event. It is cleared by software.
              0: No update occurred
              1: Update interrupt pending. This bit is set by hardware when the registers are updated:
              At overflow and if UDIS=0 in the CR1 register.
              When CNT is reinitialized by software using the UG bit in EGR register, if URS=0 and UDIS=0 in the CR1 register.
              When CNT is reinitialized by a trigger event (refer to the synchro control register description), if URS=0 and UDIS=0 in the CR1 register.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>EGR</name>
          <displayName>EGR</displayName>
          <description>Event generation register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>31</bitWidth>
            </field>
            <field>
              <name>UG</name>
              <description>
              Update generation
              This bit can be set by software, it is automatically cleared by hardware.
              0: No action
              1: Re-initialize the counter and generates an update of the registers. Note that the prescaler counter is cleared too (anyway the prescaler ratio is not affected). The counter is cleared if the center-aligned mode is selected or if DIR=0 (upcounting), else it takes the auto-reload value (ARR) if DIR=1 (downcounting).
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD1</name>
          <displayName>RSVD1</displayName>
          <description></description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>CNT</name>
          <displayName>CNT</displayName>
          <description>Counter</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>CNT</name>
              <description>
              counter value
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PSC</name>
          <displayName>PSC</displayName>
          <description>Prescaler</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>PSC</name>
              <description>
              Prescaler value
              The counter clock frequency is equal to fCLK / (PSC[15:0] + 1).
              PSC contains the value to be loaded in the active prescaler register at each update event (including when the counter is cleared through UG bit of EGR register or through trigger controller when configured in "reset mode").
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ARR</name>
          <displayName>ARR</displayName>
          <description>Auto-reload register</description>
          <addressOffset>0x2c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ARR</name>
              <description>
              Auto-reload value
              ARR is the value to be loaded in the actual auto-reload register. The counter is blocked while the auto-reload value is null.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>WDT1</name>
      <description></description>
      <groupName>WDT</groupName>
      <baseAddress>0x40014000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>WDT_CVR0</name>
          <displayName>WDT_CVR0</displayName>
          <description>WatchDog Counter Value 0</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>COUNT_VALUE_0</name>
              <description>
              Count Value for 1st TimeOut
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_CVR1</name>
          <displayName>WDT_CVR1</displayName>
          <description>WatchDog Counter Value 1</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>COUNT_VALUE_1</name>
              <description>
              Count Value for 2nd TimeOut
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_CR</name>
          <displayName>WDT_CR</displayName>
          <description>WatchDog Control Register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>27</bitWidth>
            </field>
            <field>
              <name>RESPONSE_MODE</name>
              <description>
              0:reset only, 1:interrupt and reset
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RESET_LENGTH</name>
              <description>
              reset pulse length in number of wdt clock cycles
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_CCR</name>
          <displayName>WDT_CCR</displayName>
          <description>WatchDog Counter Control Register</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>COUNTER_CONTROL</name>
              <description>
              SinglePulse /Write 8'h76 to restart, write8'h34 to stop, else do nothing
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_ICR</name>
          <displayName>WDT_ICR</displayName>
          <description>WatchDog Interrupt Clear Register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>31</bitWidth>
            </field>
            <field>
              <name>INT_CLR</name>
              <description>
              SinglePulse /A pulse to clear interrupt
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_SR</name>
          <displayName>WDT_SR</displayName>
          <description>WatchDog Status Register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>30</bitWidth>
            </field>
            <field>
              <name>WDT_ACTIVE</name>
              <description>
              Watchdog runs when 1, else 0
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>INT_ASSERT</name>
              <description>
              Interrupt assert when 1
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_WP</name>
          <displayName>WDT_WP</displayName>
          <description>WatchDog Write Protect Register</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>WRPT_ST</name>
              <description>
              1 indicates write protect is active
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>WRPT</name>
              <description>
              write 0x58ab99fc generate write_protect, write 0x51ff8621 to release
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>31</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_FG</name>
          <displayName>WDT_FG</displayName>
          <description>WatchDog Flag Register</description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>28</bitWidth>
            </field>
            <field>
              <name>SYNC_FG</name>
              <description>
              1 indicates one transition from system clk to wdt clk has complicated
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SYNC_FG_CLR</name>
              <description>
              SinglePulse/A pulse to clear sync flag
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RST_FG</name>
              <description>
              1 indicates wdt has already reset system
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RST_FG_CLR</name>
              <description>
              SinglePulse/A pulse to clear reset flag
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>SPI1</name>
      <description></description>
      <groupName>SPI</groupName>
      <baseAddress>0x40015000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>TOP_CTRL</name>
          <displayName>TOP_CTRL</displayName>
          <description>Top Control Register</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>13</bitWidth>
            </field>
            <field>
              <name>TTELP</name>
              <description>
              SPI_DO Three-state Enable On Last Phase (can be set only when TI-SSP)
              0: SPI_DO is three-stated 1/2 clock cycle after the beginning of the LSB 
              1: SPI_DO output signal is three-stated on the clock edge that ends the LSB
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TTE</name>
              <description>
              SPI_DO Three-State Enable 
              0: SPI_DO output signal is not three-stated 
              1: SPI_DO is three-stated when not transmitting data
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IFS</name>
              <description>
              Invert Frame Signal 
              0: SPI_CS polarity is as defined in protocol
              1: SPI_CS will be inverted from normal-SPI_CS
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HOLD_FRAME_LOW</name>
              <description>
              Hold Frame Low Control 
              0:After this field is set to 1 and the SPI controller is operating in master mode,the output frame signal SPI_CS will be determined by control FSM.
              1:After this field is set to 1 and the SPI controller is operating in master mode, the output frame signal SPI_CS will hold low. 
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TRAIL</name>
              <description>
              Trailing Byte 
              0: Trailing bytes are handled by CPU 
              1: Trailing bytes are handled by DMA bursts
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              Reserved
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SPH</name>
              <description>
              Motorola SPI SPI_CLK phase setting 
              0: SPI_CLK is inactive until one cycle after the start of a frame and active until 1/2 cycle before the end of a frame 
              1: SPI_CLK is inactive until 1/2 cycle after the start of a frame and active until one cycle before the end of a frame
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SPO</name>
              <description>
              Motorola SPI SPI_CLK Polarity Setting 
              0: The inactive or idle state of SPI_CLK is low 
              1: The inactive or idle state of SPI_CLK is high
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DSS</name>
              <description>
              SPI controller Work data size,  register bits value 0~31 indicated data size 1~32 bits,  usually use data size 8bits, 16bits, 24bits, 32bits
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>SFRMDIR</name>
              <description>
              SPI_CS Direction 
              0: Master mode, SPI controller drives SPI_CS 
              1: Slave mode, SPI controller receives SPI_CS
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SCLKDIR</name>
              <description>
              SPI_CLK Direction 
              0: Master mode, SPI controller drives SPI_CLK 
              1: Slave mode, SPI controller receives SPI_CLK
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FRF</name>
              <description>
              Frame Format 
              0x0: Motorola* Serial Peripheral Interface (SPI)  
              0x1: Texas Instruments* Synchronous Serial Protocol (SSP) 
              0x2: National Semiconductor Microwire* 
              0x3: RSVD 
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>SSE</name>
              <description>
              SPI controller Enable 
              0: SPI controller is disabled  
              1: SPI controller is enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>FIFO_CTRL</name>
          <displayName>FIFO_CTRL</displayName>
          <description>FIFO Control Register</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>14</bitWidth>
            </field>
            <field>
              <name>RXFIFO_AUTO_FULL_CTRL</name>
              <description>
              Rx FIFO Auto Full Control: After this field is set to 1 and the SPI controller is operating in master mode, the controller FSM returns to IDLE state and stops the SPI_CLK. 
              When Rx FIFO is full, the controller FSM continues transferring data after the RxFIFO is not full. 
              This field is used to avoid an RxFIFO overrun issue. 
              1: Enable Rx FIFO auto full control
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FPCKE</name>
              <description>
              FIFO Packing Enable 
              0: FIFO packing mode disabled 
              1: FIFO packing mode enabled
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TXFIFO_WR_ENDIAN</name>
              <description>
              apb_pwdata Write to TxFIFO Endian 
              0x0: txfifo_wdata[31:0] = apb_pwdata[31:0] 
              0x1: fifo_wdata[31:0] = {apb_pwdata[15:0], apb_pwdata[31:16]} 
              0x2: txfifo_wdata[31:0] = {apb_pwdata[7:0], apb_pwdata[15:8], apb_pwdata[23:16], apb_pwdata[31:24]} 
              0x3: txfifo_wdata[31:0] = {apb_pwdata[23:16], apb_pwdata[31:24], apb_pwdata[7:0], apb_pwdata[15:8]}
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RXFIFO_RD_ENDIAN</name>
              <description>
              apb_prdata Read from Rx FIFO Endian 
              0x0 = apb_prdata[31:0] = rxfifo_wdata[31:0] 
              0x1 = apb_prdata[31:0] = {rxfifo_wdata[15:0], rxfifo_wdata[31:16]} 
              0x2 = apb_prdata[31:0]= {rxfifo_wdata[7:0], rxfifo_wdata[15:8], rxfifo_wdata[23:16], rxfifo_wdata[31:24]} 
              0x3 = apb_prdata[31:0]= {rxfifo_wdata[23:16], rxfifo_wdata[31:24], rxfifo_wdata[7:0], rxfifo_wdata[15:8]}
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSRE</name>
              <description>
              Receive Service Request Enable 
              0: RxFIFO DMA service request is disabled 
              1: RxFIFO DMA service request is enabled
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TSRE</name>
              <description>
              Transmit Service Request Enable 
              0: TxFIFO DMA service request is disabled 
              1: TxFIFO DMA service request is enabled
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RFT</name>
              <description>
              RXFIFO Trigger Threshold This field sets the threshold level at which RXFIFO asserts interrupt. The level should be set to the preferred threshold value minus 1.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>TFT</name>
              <description>
              TXFIFO Trigger Threshold This field sets the threshold level at which TXFIFO asserts interrupt. The level should be set to the preferred threshold value minus 1. 
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>INTE</name>
          <displayName>INTE</displayName>
          <description>Interrupt Enable Register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>26</bitWidth>
            </field>
            <field>
              <name>TIM</name>
              <description>
              Transmit FIFO Underrun Interrupt Mask
              0 : TUR events generate an SPI interrupt 
              1 : TUR events do NOT generate an SPI interrupt 
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RIM</name>
              <description>
              Receive FIFO Overrun Interrupt Mask 
              0: ROR events generate an SPI interrupt 
              1: ROR events do NOT generate an SPI interrupt 
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TIE</name>
              <description>
              Transmit FIFO Interrupt Enable 
              0: TxFIFO threshold-level-reached interrupt is disabled 
              1: TxFIFO threshold-level-reached interrupt is enabled
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RIE</name>
              <description>
              Receive FIFO Interrupt Enable 
              0: RxFIFO threshold-level-reached interrupt is disabled 
              1: RxFIFO threshold-level-reached interrupt is enabled
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TINTE</name>
              <description>
              Receiver Time-out Interrupt Enable 
              0: Receiver time-out interrupt is disabled 
              1: Receiver time-out interrupt is enabled
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TO</name>
          <displayName>TO</displayName>
          <description>SPI Time Out Register</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>TIMEOUT</name>
              <description>
              Timeout Value TIMEOUT value is the value (0 to 2^24-1) that defines the time-out interval. The time-out interval is given by the equation shown in the TIMEOUT Interval Equation.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DATA</name>
          <displayName>DATA</displayName>
          <description>SPI DATA Register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              DATA This field is used for data to be written to the TXFIFO read from the RXFIFO.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS</name>
          <displayName>STATUS</displayName>
          <description>Status Register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>OSS</name>
              <description>
              Odd Sample Status 
              0: RxFIFO entry has two samples 
              1: RxFIFO entry has one sample  
              Note that this bit needs to be looked at only when FIFO Packing is enabled (FPCKE field in FIFO Control Register is set). Otherwise, this bit is zero. When SPI controller is in Packed mode and the CPU is used instead of DMA to read the RxFIFO, the CPU should make sure that [Receive FIFO Not Empty] = 1 AND this field = 0 before it attempts to read the RxFIFO.
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TX_OSS</name>
              <description>
              TX FIFO Odd Sample Status When SPI controller is in packed mode, 
              the number of samples in the TX FIFO is:  ([Transmit FIFO Level]*2 + this field), when [Transmit FIFO Not Full] = 1 32, when [Transmit FIFO Not Full] = 0.
              The TX FIFO cannot accept new data when [Transmit FIFO Not Full] = 1 and [Transmit FIFO Level] = 15 and this field = 1. (The TX FIFO has 31 samples).  
              0: TxFIFO entry has an even number of samples 
              1: TxFIFO entry has an odd number of samples Note that this bit needs to be read only when FIFO Packing is enabled ([FIFO Packing Enable] in the FIFO Control Register is set). Otherwise, this bit is zero.
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ROR</name>
              <description>
              Receive FIFO Overrun 
              0: RXFIFO has not experienced an overrun 
              1: Attempted data write to full RXFIFO, causes an interrupt request
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RFL</name>
              <description>
              Receive FIFO Level This field is the number of entries minus one in RXFIFO. When the value 0xF is read, the RXFIFO is either empty or full, and software should read the [Receive FIFO Not Empty] field.
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>RNE</name>
              <description>
              Receive FIFO Not Empty 
              0: RXFIFO is empty 
              1: RXFIFO is not empty
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RFS</name>
              <description>
              Receive FIFO Service Request 
              0: RXFIFO level is at or below RFT threshold (RFT) or SPI controller is disabled 
              1: RXFIFO level exceeds RFT threshold (RFT), causes an interrupt request
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TUR</name>
              <description>
              Transmit FIFO Underrun 
              0: The TXFIFO has not experienced an underrun 
              1: A read from the TXFIFO was attempted when the TXFIFO was empty, causes an interrupt if it is enabled ([Transmit FIFO Underrun Interrupt Mask] in the INT EN Register  is 0)
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TFL</name>
              <description>
              Transmit FIFO Level This field is the number of entries in TXFIFO.When the value 0x0 is read, the TXFIFO is either empty or full, and software should read the [Transmit FIFO Not Full] field.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>TNF</name>
              <description>
              Transmit FIFO Not Full 
              0: TXFIFO is full 
              1: TXFIFO is not full
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TFS</name>
              <description>
              Transmit FIFO Service Request 
              0: TX FIFO level exceeds the TFT threshold (TFT + 1) or SPI controller is disabled 
              1: TXFIFO level is at or below TFT threshold (TFT + 1), causes an interrupt request
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD5</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TINT</name>
              <description>
              Receiver Time-out Interrupt 
              0: No receiver time-out is pending 
              1: Receiver time-out pending, causes an interrupt request
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD6</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CSS</name>
              <description>
              Clock Synchronization Status 
              0: SPI controller is ready for slave clock operations 
              1: SPI controller is currently busy synchronizing slave mode signals
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BSY</name>
              <description>
              SPI controller Busy 
              0: SPI controller is idle or disabled 
              1: SPI controller is currently transmitting or receiving framed data
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD3</name>
          <displayName>RSVD3</displayName>
          <description></description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>RWOT_CTRL</name>
          <displayName>RWOT_CTRL</displayName>
          <description>RWOT Control Register</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>27</bitWidth>
            </field>
            <field>
              <name>MASK_RWOT_LAST_SAMPLE</name>
              <description>
              Mask last_sample_flag in RWOT Mode 
              1: Mask 
              0: Unmask
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CLR_RWOT_CYCLE</name>
              <description>
              Clear Internal rwot_counter This field clears the rwot_counter to 0. This field is self cleared after SSE = 1. 
              1: Clear rwot_counter
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SET_RWOT_CYCLE</name>
              <description>
              Set RWOT Cycle This field is used to set the value of the RWOT_CCM register to the internal rwot_counter. This field is self-cleared after SSE = 1. 
              1: Set rwot_counter
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CYCLE_RWOT_EN</name>
              <description>
              Enable RWOT Cycle Counter Mode 
              1: Enable
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RWOT</name>
              <description>
              Receive Without Transmit 
              0: Transmit/receive mode 
              1: Receive without transmit mode
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RWOT_CCM</name>
          <displayName>RWOT_CCM</displayName>
          <description>RWOT Counter Cycles Match Register</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RWOTCCM</name>
              <description>
              It's just total SPI_CLK Cycles. 
              The value of this register defines the total number of SPI_CLK cycles when SPI controller works in master and RWOT mode. 
              When the rwot_counter matches this value, SPI controller returns to IDLE state and does not output SPI_CLK anymore.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RWOT_CVWRN</name>
          <displayName>RWOT_CVWRN</displayName>
          <description>RWOT Counter Value Write for Red Request Register</description>
          <addressOffset>0x2c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RWOTCVWR</name>
              <description>
              RWOTCVWR This register prevents the risk of instability on rwot_counter value reading, it's only valid after SPI controller has been enabled Write 0 = No effect Write 1 = Capture value of rwot_counter Read: Returns the captured value of rwot_counter
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD2</name>
          <displayName>RSVD2</displayName>
          <description></description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>CLK_CTRL</name>
          <displayName>CLK_CTRL</displayName>
          <description>CLK  Control Register</description>
          <addressOffset>0x3c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>CLK_EN</name>
              <description>
              enable clk for internal logic
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CLK_SEL</name>
              <description>
              0: select clk_div as clk for SPI controller
              1: select clk_sys as clk for SPI controller
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CLK_DIV</name>
              <description>
              div ratio from clk_sys
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD1</name>
          <displayName>RSVD1</displayName>
          <description></description>
          <addressOffset>0x40</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>TRIWIRE_CTRL</name>
          <displayName>TRIWIRE_CTRL</displayName>
          <description>Three Wire Mode  Control Register</description>
          <addressOffset>0x54</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>29</bitWidth>
            </field>
            <field>
              <name>WORK_WIDTH_DYN_CHANGE</name>
              <description>
              WORK_WIDTH_DYN_CHNAGE 
              1: SW can dynamicly change TOP_CTRL[9:5] without disabling TOP_CTRL[0] and re-enabling TOP_CTRL[0]   
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TXD_OEN</name>
              <description>
              TXD_OEN control when TRI-WIRE mode
              1: SPI_DIO is input  
              0: SPI_DIO is output
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SPI_TRI_WIRE_EN</name>
              <description>
              SPI_THREE_WIRE_MODE_EN 
              0: normal mode
              1: enable TRI-WIRE mode
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>SPI2</name>
      <description></description>
      <groupName>SPI</groupName>
      <baseAddress>0x40016000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>TOP_CTRL</name>
          <displayName>TOP_CTRL</displayName>
          <description>Top Control Register</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>13</bitWidth>
            </field>
            <field>
              <name>TTELP</name>
              <description>
              SPI_DO Three-state Enable On Last Phase (can be set only when TI-SSP)
              0: SPI_DO is three-stated 1/2 clock cycle after the beginning of the LSB 
              1: SPI_DO output signal is three-stated on the clock edge that ends the LSB
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TTE</name>
              <description>
              SPI_DO Three-State Enable 
              0: SPI_DO output signal is not three-stated 
              1: SPI_DO is three-stated when not transmitting data
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IFS</name>
              <description>
              Invert Frame Signal 
              0: SPI_CS polarity is as defined in protocol
              1: SPI_CS will be inverted from normal-SPI_CS
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HOLD_FRAME_LOW</name>
              <description>
              Hold Frame Low Control 
              0:After this field is set to 1 and the SPI controller is operating in master mode,the output frame signal SPI_CS will be determined by control FSM.
              1:After this field is set to 1 and the SPI controller is operating in master mode, the output frame signal SPI_CS will hold low. 
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TRAIL</name>
              <description>
              Trailing Byte 
              0: Trailing bytes are handled by CPU 
              1: Trailing bytes are handled by DMA bursts
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              Reserved
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SPH</name>
              <description>
              Motorola SPI SPI_CLK phase setting 
              0: SPI_CLK is inactive until one cycle after the start of a frame and active until 1/2 cycle before the end of a frame 
              1: SPI_CLK is inactive until 1/2 cycle after the start of a frame and active until one cycle before the end of a frame
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SPO</name>
              <description>
              Motorola SPI SPI_CLK Polarity Setting 
              0: The inactive or idle state of SPI_CLK is low 
              1: The inactive or idle state of SPI_CLK is high
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DSS</name>
              <description>
              SPI controller Work data size,  register bits value 0~31 indicated data size 1~32 bits,  usually use data size 8bits, 16bits, 24bits, 32bits
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>SFRMDIR</name>
              <description>
              SPI_CS Direction 
              0: Master mode, SPI controller drives SPI_CS 
              1: Slave mode, SPI controller receives SPI_CS
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SCLKDIR</name>
              <description>
              SPI_CLK Direction 
              0: Master mode, SPI controller drives SPI_CLK 
              1: Slave mode, SPI controller receives SPI_CLK
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FRF</name>
              <description>
              Frame Format 
              0x0: Motorola* Serial Peripheral Interface (SPI)  
              0x1: Texas Instruments* Synchronous Serial Protocol (SSP) 
              0x2: National Semiconductor Microwire* 
              0x3: RSVD 
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>SSE</name>
              <description>
              SPI controller Enable 
              0: SPI controller is disabled  
              1: SPI controller is enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>FIFO_CTRL</name>
          <displayName>FIFO_CTRL</displayName>
          <description>FIFO Control Register</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>14</bitWidth>
            </field>
            <field>
              <name>RXFIFO_AUTO_FULL_CTRL</name>
              <description>
              Rx FIFO Auto Full Control: After this field is set to 1 and the SPI controller is operating in master mode, the controller FSM returns to IDLE state and stops the SPI_CLK. 
              When Rx FIFO is full, the controller FSM continues transferring data after the RxFIFO is not full. 
              This field is used to avoid an RxFIFO overrun issue. 
              1: Enable Rx FIFO auto full control
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FPCKE</name>
              <description>
              FIFO Packing Enable 
              0: FIFO packing mode disabled 
              1: FIFO packing mode enabled
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TXFIFO_WR_ENDIAN</name>
              <description>
              apb_pwdata Write to TxFIFO Endian 
              0x0: txfifo_wdata[31:0] = apb_pwdata[31:0] 
              0x1: fifo_wdata[31:0] = {apb_pwdata[15:0], apb_pwdata[31:16]} 
              0x2: txfifo_wdata[31:0] = {apb_pwdata[7:0], apb_pwdata[15:8], apb_pwdata[23:16], apb_pwdata[31:24]} 
              0x3: txfifo_wdata[31:0] = {apb_pwdata[23:16], apb_pwdata[31:24], apb_pwdata[7:0], apb_pwdata[15:8]}
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RXFIFO_RD_ENDIAN</name>
              <description>
              apb_prdata Read from Rx FIFO Endian 
              0x0 = apb_prdata[31:0] = rxfifo_wdata[31:0] 
              0x1 = apb_prdata[31:0] = {rxfifo_wdata[15:0], rxfifo_wdata[31:16]} 
              0x2 = apb_prdata[31:0]= {rxfifo_wdata[7:0], rxfifo_wdata[15:8], rxfifo_wdata[23:16], rxfifo_wdata[31:24]} 
              0x3 = apb_prdata[31:0]= {rxfifo_wdata[23:16], rxfifo_wdata[31:24], rxfifo_wdata[7:0], rxfifo_wdata[15:8]}
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSRE</name>
              <description>
              Receive Service Request Enable 
              0: RxFIFO DMA service request is disabled 
              1: RxFIFO DMA service request is enabled
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TSRE</name>
              <description>
              Transmit Service Request Enable 
              0: TxFIFO DMA service request is disabled 
              1: TxFIFO DMA service request is enabled
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RFT</name>
              <description>
              RXFIFO Trigger Threshold This field sets the threshold level at which RXFIFO asserts interrupt. The level should be set to the preferred threshold value minus 1.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>TFT</name>
              <description>
              TXFIFO Trigger Threshold This field sets the threshold level at which TXFIFO asserts interrupt. The level should be set to the preferred threshold value minus 1. 
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>INTE</name>
          <displayName>INTE</displayName>
          <description>Interrupt Enable Register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>26</bitWidth>
            </field>
            <field>
              <name>TIM</name>
              <description>
              Transmit FIFO Underrun Interrupt Mask
              0 : TUR events generate an SPI interrupt 
              1 : TUR events do NOT generate an SPI interrupt 
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RIM</name>
              <description>
              Receive FIFO Overrun Interrupt Mask 
              0: ROR events generate an SPI interrupt 
              1: ROR events do NOT generate an SPI interrupt 
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TIE</name>
              <description>
              Transmit FIFO Interrupt Enable 
              0: TxFIFO threshold-level-reached interrupt is disabled 
              1: TxFIFO threshold-level-reached interrupt is enabled
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RIE</name>
              <description>
              Receive FIFO Interrupt Enable 
              0: RxFIFO threshold-level-reached interrupt is disabled 
              1: RxFIFO threshold-level-reached interrupt is enabled
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TINTE</name>
              <description>
              Receiver Time-out Interrupt Enable 
              0: Receiver time-out interrupt is disabled 
              1: Receiver time-out interrupt is enabled
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TO</name>
          <displayName>TO</displayName>
          <description>SPI Time Out Register</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>TIMEOUT</name>
              <description>
              Timeout Value TIMEOUT value is the value (0 to 2^24-1) that defines the time-out interval. The time-out interval is given by the equation shown in the TIMEOUT Interval Equation.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DATA</name>
          <displayName>DATA</displayName>
          <description>SPI DATA Register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              DATA This field is used for data to be written to the TXFIFO read from the RXFIFO.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS</name>
          <displayName>STATUS</displayName>
          <description>Status Register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>OSS</name>
              <description>
              Odd Sample Status 
              0: RxFIFO entry has two samples 
              1: RxFIFO entry has one sample  
              Note that this bit needs to be looked at only when FIFO Packing is enabled (FPCKE field in FIFO Control Register is set). Otherwise, this bit is zero. When SPI controller is in Packed mode and the CPU is used instead of DMA to read the RxFIFO, the CPU should make sure that [Receive FIFO Not Empty] = 1 AND this field = 0 before it attempts to read the RxFIFO.
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TX_OSS</name>
              <description>
              TX FIFO Odd Sample Status When SPI controller is in packed mode, 
              the number of samples in the TX FIFO is:  ([Transmit FIFO Level]*2 + this field), when [Transmit FIFO Not Full] = 1 32, when [Transmit FIFO Not Full] = 0.
              The TX FIFO cannot accept new data when [Transmit FIFO Not Full] = 1 and [Transmit FIFO Level] = 15 and this field = 1. (The TX FIFO has 31 samples).  
              0: TxFIFO entry has an even number of samples 
              1: TxFIFO entry has an odd number of samples Note that this bit needs to be read only when FIFO Packing is enabled ([FIFO Packing Enable] in the FIFO Control Register is set). Otherwise, this bit is zero.
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ROR</name>
              <description>
              Receive FIFO Overrun 
              0: RXFIFO has not experienced an overrun 
              1: Attempted data write to full RXFIFO, causes an interrupt request
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RFL</name>
              <description>
              Receive FIFO Level This field is the number of entries minus one in RXFIFO. When the value 0xF is read, the RXFIFO is either empty or full, and software should read the [Receive FIFO Not Empty] field.
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>RNE</name>
              <description>
              Receive FIFO Not Empty 
              0: RXFIFO is empty 
              1: RXFIFO is not empty
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RFS</name>
              <description>
              Receive FIFO Service Request 
              0: RXFIFO level is at or below RFT threshold (RFT) or SPI controller is disabled 
              1: RXFIFO level exceeds RFT threshold (RFT), causes an interrupt request
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TUR</name>
              <description>
              Transmit FIFO Underrun 
              0: The TXFIFO has not experienced an underrun 
              1: A read from the TXFIFO was attempted when the TXFIFO was empty, causes an interrupt if it is enabled ([Transmit FIFO Underrun Interrupt Mask] in the INT EN Register  is 0)
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TFL</name>
              <description>
              Transmit FIFO Level This field is the number of entries in TXFIFO.When the value 0x0 is read, the TXFIFO is either empty or full, and software should read the [Transmit FIFO Not Full] field.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>TNF</name>
              <description>
              Transmit FIFO Not Full 
              0: TXFIFO is full 
              1: TXFIFO is not full
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TFS</name>
              <description>
              Transmit FIFO Service Request 
              0: TX FIFO level exceeds the TFT threshold (TFT + 1) or SPI controller is disabled 
              1: TXFIFO level is at or below TFT threshold (TFT + 1), causes an interrupt request
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD5</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TINT</name>
              <description>
              Receiver Time-out Interrupt 
              0: No receiver time-out is pending 
              1: Receiver time-out pending, causes an interrupt request
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD6</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CSS</name>
              <description>
              Clock Synchronization Status 
              0: SPI controller is ready for slave clock operations 
              1: SPI controller is currently busy synchronizing slave mode signals
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BSY</name>
              <description>
              SPI controller Busy 
              0: SPI controller is idle or disabled 
              1: SPI controller is currently transmitting or receiving framed data
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD3</name>
          <displayName>RSVD3</displayName>
          <description></description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>RWOT_CTRL</name>
          <displayName>RWOT_CTRL</displayName>
          <description>RWOT Control Register</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>27</bitWidth>
            </field>
            <field>
              <name>MASK_RWOT_LAST_SAMPLE</name>
              <description>
              Mask last_sample_flag in RWOT Mode 
              1: Mask 
              0: Unmask
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CLR_RWOT_CYCLE</name>
              <description>
              Clear Internal rwot_counter This field clears the rwot_counter to 0. This field is self cleared after SSE = 1. 
              1: Clear rwot_counter
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SET_RWOT_CYCLE</name>
              <description>
              Set RWOT Cycle This field is used to set the value of the RWOT_CCM register to the internal rwot_counter. This field is self-cleared after SSE = 1. 
              1: Set rwot_counter
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CYCLE_RWOT_EN</name>
              <description>
              Enable RWOT Cycle Counter Mode 
              1: Enable
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RWOT</name>
              <description>
              Receive Without Transmit 
              0: Transmit/receive mode 
              1: Receive without transmit mode
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RWOT_CCM</name>
          <displayName>RWOT_CCM</displayName>
          <description>RWOT Counter Cycles Match Register</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RWOTCCM</name>
              <description>
              It's just total SPI_CLK Cycles. 
              The value of this register defines the total number of SPI_CLK cycles when SPI controller works in master and RWOT mode. 
              When the rwot_counter matches this value, SPI controller returns to IDLE state and does not output SPI_CLK anymore.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RWOT_CVWRN</name>
          <displayName>RWOT_CVWRN</displayName>
          <description>RWOT Counter Value Write for Red Request Register</description>
          <addressOffset>0x2c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RWOTCVWR</name>
              <description>
              RWOTCVWR This register prevents the risk of instability on rwot_counter value reading, it's only valid after SPI controller has been enabled Write 0 = No effect Write 1 = Capture value of rwot_counter Read: Returns the captured value of rwot_counter
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD2</name>
          <displayName>RSVD2</displayName>
          <description></description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>CLK_CTRL</name>
          <displayName>CLK_CTRL</displayName>
          <description>CLK  Control Register</description>
          <addressOffset>0x3c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>CLK_EN</name>
              <description>
              enable clk for internal logic
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CLK_SEL</name>
              <description>
              0: select clk_div as clk for SPI controller
              1: select clk_sys as clk for SPI controller
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CLK_DIV</name>
              <description>
              div ratio from clk_sys
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD1</name>
          <displayName>RSVD1</displayName>
          <description></description>
          <addressOffset>0x40</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>TRIWIRE_CTRL</name>
          <displayName>TRIWIRE_CTRL</displayName>
          <description>Three Wire Mode  Control Register</description>
          <addressOffset>0x54</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>29</bitWidth>
            </field>
            <field>
              <name>WORK_WIDTH_DYN_CHANGE</name>
              <description>
              WORK_WIDTH_DYN_CHNAGE 
              1: SW can dynamicly change TOP_CTRL[9:5] without disabling TOP_CTRL[0] and re-enabling TOP_CTRL[0]   
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TXD_OEN</name>
              <description>
              TXD_OEN control when TRI-WIRE mode
              1: SPI_DIO is input  
              0: SPI_DIO is output
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SPI_TRI_WIRE_EN</name>
              <description>
              SPI_THREE_WIRE_MODE_EN 
              0: normal mode
              1: enable TRI-WIRE mode
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>EXTDMA</name>
      <description></description>
      <groupName>EXTDMA</groupName>
      <baseAddress>0x40017000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>ISR</name>
          <displayName>ISR</displayName>
          <description>interrupt status register </description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>27</bitWidth>
            </field>
            <field>
              <name>OFIF</name>
              <description>
              OFIF, overflow flag
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIF</name>
              <description>
              TEIF, transfer error flag
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HTIF</name>
              <description>
              HTIF, half transfer flag
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIF</name>
              <description>
              TCIF, transfer complete flag
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GIF</name>
              <description>
              GIF,  global interrupt flag
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IFCR</name>
          <displayName>IFCR</displayName>
          <description>interrupt clear register </description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>27</bitWidth>
            </field>
            <field>
              <name>COFIF</name>
              <description>
              COFIF, overflow flag clear
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTEIF</name>
              <description>
              CTEIF, transfer error flag clear
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CHTIF</name>
              <description>
              CHTIF, half transfer flag clear
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTCIF</name>
              <description>
              CTCIF, transfer complete flag clear
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CGIF</name>
              <description>
              CGIF,  global interrupt flag clear
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR</name>
          <displayName>CCR</displayName>
          <description>channel control register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x000F0AC0</resetValue>
          <fields>
            <field>
              <name>RESET</name>
              <description>
              Software reset, will clear extdma status. Active high. Will be cleared by HW automatically
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
            <field>
              <name>SRCBURST</name>
              <description>
              source burst transfer configuration
              00: single transfer
              01: INCR4 (incremental burst of 4 beats)
              10: INCR8 (incremental burst of 8 beats)
              11: INCR16 (incremental burst of 16 beats)
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>DSTBURST</name>
              <description>
              destination burst transfer configuration
              00: single transfer
              01: INCR4 (incremental burst of 4 beats)
              10: INCR8 (incremental burst of 8 beats)
              11: INCR16 (incremental burst of 16 beats)
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>SRCSIZE</name>
              <description>
              source size
              Defines the data size of each DMA transfer to the source memory.
              Should be fixed to 10 (32 bits), word access allowed only.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>DSTSIZE</name>
              <description>
              destination size
              Defines the data size of each DMA transfer to the destination memory.
              Should be fixed to 10 (32 bits), word access allowed only.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>SRCINC</name>
              <description>
              source increment mode
              Defines the increment mode for each DMA transfer to the source memory.
              0: disabled
              1: enabled
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DSTINC</name>
              <description>
              destination increment mode
              Defines the increment mode for each DMA transfer to the destination memory.
              0: disabled
              1: enabled
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OFIE</name>
              <description>
              overflow interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIE</name>
              <description>
              transfer error interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HTIE</name>
              <description>
              half transfer interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIE</name>
              <description>
              transfer complete interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EN</name>
              <description>
              extdma enable. Will be cleared if ccr_reset is written
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CNDTR</name>
          <displayName>CNDTR</displayName>
          <description>number of data register</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
            <field>
              <name>NDT</name>
              <description>
              number of data to transfer (0 to 2^20 - 1)
              This field is updated by hardware when the channel is enabled:
                 It is decremented after each transfer, indicating the remaining amount of data items to transfer.
                 It is kept at zero when the programmed amount of data to transfer is reached.
              If this field is zero, no transfer can be served whatever the channel enabled or not
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SRCAR</name>
          <displayName>SRCAR</displayName>
          <description>source address register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>SRCADDR</name>
              <description>
              source address
              It contains the base address of the source data to be read. Should be word aligned
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DSTAR</name>
          <displayName>DSTAR</displayName>
          <description>destination 0 address register </description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DSTADDR</name>
              <description>
              destination address
              It contains the base address of the destination data to be written. Should be word aligned
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD1</name>
          <displayName>RSVD1</displayName>
          <description></description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>CMPRCR</name>
          <displayName>CMPRCR</displayName>
          <description>Image Compression control register</description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>SRCPOS</name>
              <description>
              Starting byte position in the first word of the source frame
              Valid starting positon includes: 
              RGB565: 0x0,0x2
              RGB888: 0x0, 0x1, 0x2, 0x3
              ARGB8888: 0x0
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>SRCFMT</name>
              <description>
              Source frame format
              00: 16-bit RGB 5:6:5
              01: 24-bit RGB 8:8:8
              10: 32-bit ARGB 8:8:8:8
              11: Reserved
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>CMPREN</name>
              <description>
              Compression enable
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CMPRSR</name>
          <displayName>CMPRSR</displayName>
          <description>Compression size register</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>TGTSIZE</name>
              <description>
              output target size of each line after compression. output data size of each line is tgtsize*3*2 bytes
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>LINESIZE</name>
              <description>
              column number (pixel number) of each line. Input data size of each line is linesize*(size per pixel)
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CMPRNDTR</name>
          <displayName>CMPRNDTR</displayName>
          <description>number of compression output data register</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
            <field>
              <name>CMPRNDT</name>
              <description>
              If compression enabled, cmprndt is the number of data to transfer after compression (0 to 2^20 - 1) and have to be written by software before compression. The value should be TGTSIZE*6*line_number/4 in compression mode.
              If compression disabled, it reads the number of data that extdma has written into destination address. Software do not need to write this field.
              This field is updated by hardware when extdma enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CMPRCFG0</name>
          <displayName>CMPRCFG0</displayName>
          <description>Compression configuration 0</description>
          <addressOffset>0x2c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x80023307</resetValue>
          <fields>
            <field>
              <name>CFG</name>
              <description>
              Compression configuration
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CMPRCFG1</name>
          <displayName>CMPRCFG1</displayName>
          <description>Compression configuration 1</description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x01055982</resetValue>
          <fields>
            <field>
              <name>CFG</name>
              <description>
              Compression configuration
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CMPRQR</name>
          <displayName>CMPRQR</displayName>
          <description>Compression quality register</description>
          <addressOffset>0x34</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>DUMMY</name>
              <description>
              line least dummy word in one frame, update every frame.
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>13</bitWidth>
            </field>
            <field>
              <name>LQB</name>
              <description>
              low quality block number. the bigger of this number, the worse compressed image quality
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>LQR</name>
              <description>
              quality sum to low qulity block number ratio. the bigger of this number, the worse compressed image quality.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CMPRDR</name>
          <displayName>CMPRDR</displayName>
          <description>Compression debug register</description>
          <addressOffset>0x38</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>25</bitWidth>
            </field>
            <field>
              <name>MAXBUF</name>
              <description>
              record of max used buffer during compression output
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PDM1</name>
      <description></description>
      <groupName>PDM</groupName>
      <baseAddress>0x4001a000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CFG0</name>
          <displayName>CFG0</displayName>
          <description></description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>22</bitWidth>
            </field>
            <field>
              <name>SWAP_EN</name>
              <description>
              1: Swap right channel and left channel pdm data; 0: Not swap  right channel and left channel pdm data
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>STEREO_EN</name>
              <description>
              1:Enable double channels pdm data sampling; 0: Disable double channels pdm data sampling
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RIGHT_EN</name>
              <description>
              1: Enable right channel pdm data sampling; 0: Disable right channel pdm data sampling
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LEFT_EN</name>
              <description>
              1: Enable left channel  pdm data sampling; 0: Disable left channel  pdm data sampling
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CLK_DIV</name>
              <description>
              Clock frequency division ratio of 3.072MHz or 9.6MHz according to register clk_sel
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>CLK_SEL</name>
              <description>
              1:Clk select dll 3.072MHz; 0: Clk selct xtal 9.6MHz
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PDMCOREEN</name>
              <description>
              1:Enable pdm module; 0: Disable pdm module
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CFG1</name>
          <displayName>CFG1</displayName>
          <description></description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>21</bitWidth>
            </field>
            <field>
              <name>SAMPLE_DLY_R</name>
              <description>
              The number of delay dff before the right data stream in processing
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>SAMPLE_DLY_L</name>
              <description>
              The number of delay dff before the left data stream in processing
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SINC_CFG</name>
          <displayName>SINC_CFG</displayName>
          <description></description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>SINC_ORDER_SEL</name>
              <description>
              1:select four differentiators in sinc filter; 0:select three differentiators in sinc filter
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SINC_RATE</name>
              <description>
              dowmsampling rate of  sinc filter
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD3</name>
          <displayName>RSVD3</displayName>
          <description></description>
          <addressOffset>0xC</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>HPF_CFG</name>
          <displayName>HPF_CFG</displayName>
          <description></description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>26</bitWidth>
            </field>
            <field>
              <name>HPF_RST</name>
              <description>
              1:high-pass filter normal operation ; 0:reset high-pass filter 
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HPF_BYPASS</name>
              <description>
              1:bypass-high pass filter ; 0: enable high-pass filter
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HPF_COEFF</name>
              <description>
              coefficient of high-pass filter
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PGA_CFG</name>
          <displayName>PGA_CFG</displayName>
          <description></description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>18</bitWidth>
            </field>
            <field>
              <name>PGA_GAIN_R</name>
              <description>
              right channel gain control , the range is -15dB~45dB. Resolution is 0.5dB/LSB
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
            <field>
              <name>PGA_GAIN_L</name>
              <description>
              left channel gain control , the range is -15dB~45dB. Resolution is 0.5dB/LSB
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD2</name>
          <displayName>RSVD2</displayName>
          <description></description>
          <addressOffset>0x1C</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>LPF_CFG6</name>
          <displayName>LPF_CFG6</displayName>
          <description></description>
          <addressOffset>0x34</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>18</bitWidth>
            </field>
            <field>
              <name>LPF_BYPASS</name>
              <description>
              1:bypass low-pass filter ; 0: enable low-pass filter
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LPF_DS</name>
              <description>
              1:downsampling rate of low pass filter is two;0:No downsampling of low pass filter
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>FIFO_CFG</name>
          <displayName>FIFO_CFG</displayName>
          <description></description>
          <addressOffset>0x38</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>LR_CHG</name>
              <description>
              1:exchange storage location of left and right channel; 0: don't exchange storage location of left and right channel
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RX_DMA_MSK_L</name>
              <description>
              1:disable left channel dma request; 0: enable left channel dma request
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RX_DMA_MSK_R</name>
              <description>
              1:disable right channel dma request; 0: enable right channel dma request
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PDM_SHIFT</name>
              <description>
              the number of data left shift for higher data accuracy 
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>BYTE_TRUNC</name>
              <description>
              1: 16bits output ; 0: 24bits output ;2:  8bits output ; 3: 32bits output
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>BYTE_CON</name>
              <description>
              1: combine left channel and right channel; 0: not combine left channel and right channel
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD1</name>
          <displayName>RSVD1</displayName>
          <description></description>
          <addressOffset>0x3C</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>FIFO_ST</name>
          <displayName>FIFO_ST</displayName>
          <description></description>
          <addressOffset>0x44</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>FULL_L</name>
              <description>
              1 indicates left channel fifo is full
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EMPTY_L</name>
              <description>
              1 indicates left channel fifo is empty
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ALMOST_FULL_L</name>
              <description>
              1 indicates left channel fifo is less than two full
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ALMOST_EMPTY_L</name>
              <description>
              1 indicates left channel fifo is less than two datas left
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FULL_R</name>
              <description>
              1 indicates right channel fifo is full
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EMPTY_R</name>
              <description>
              1 indicates right channel fifo is empty
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ALMOST_FULL_R</name>
              <description>
              1 indicates right channel fifo is less than two full
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ALMOST_EMPTY_R</name>
              <description>
              1 indicates right channel fifo is less than two datas left
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>INT_ST</name>
          <displayName>INT_ST</displayName>
          <description></description>
          <addressOffset>0x48</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>30</bitWidth>
            </field>
            <field>
              <name>OVERFLOW_L</name>
              <description>
              1 indicates left channel fifo has already overflowed and as irq at same time 
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OVERFLOW_R</name>
              <description>
              1 indicates right channel fifo has already overflowed  and as irq at same time
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>INT_MSK</name>
          <displayName>INT_MSK</displayName>
          <description></description>
          <addressOffset>0x4c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>30</bitWidth>
            </field>
            <field>
              <name>INT_MASK_L</name>
              <description>
              1:disable left channel irq to system; 0: enable left channel irq to system
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>INT_MASK_R</name>
              <description>
              1:disable right channel irq to system; 0: enable right channel irq to system
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>INT_CLR</name>
          <displayName>INT_CLR</displayName>
          <description></description>
          <addressOffset>0x50</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>30</bitWidth>
            </field>
            <field>
              <name>INT_CLR_L</name>
              <description>
              clear left channel irq
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>INT_CLR_R</name>
              <description>
              clear right channel irq
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PDM2</name>
      <description></description>
      <groupName>PDM</groupName>
      <baseAddress>0x4001b000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CFG0</name>
          <displayName>CFG0</displayName>
          <description></description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>22</bitWidth>
            </field>
            <field>
              <name>SWAP_EN</name>
              <description>
              1: Swap right channel and left channel pdm data; 0: Not swap  right channel and left channel pdm data
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>STEREO_EN</name>
              <description>
              1:Enable double channels pdm data sampling; 0: Disable double channels pdm data sampling
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RIGHT_EN</name>
              <description>
              1: Enable right channel pdm data sampling; 0: Disable right channel pdm data sampling
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LEFT_EN</name>
              <description>
              1: Enable left channel  pdm data sampling; 0: Disable left channel  pdm data sampling
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CLK_DIV</name>
              <description>
              Clock frequency division ratio of 3.072MHz or 9.6MHz according to register clk_sel
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>CLK_SEL</name>
              <description>
              1:Clk select dll 3.072MHz; 0: Clk selct xtal 9.6MHz
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PDMCOREEN</name>
              <description>
              1:Enable pdm module; 0: Disable pdm module
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CFG1</name>
          <displayName>CFG1</displayName>
          <description></description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>21</bitWidth>
            </field>
            <field>
              <name>SAMPLE_DLY_R</name>
              <description>
              The number of delay dff before the right data stream in processing
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>SAMPLE_DLY_L</name>
              <description>
              The number of delay dff before the left data stream in processing
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SINC_CFG</name>
          <displayName>SINC_CFG</displayName>
          <description></description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>SINC_ORDER_SEL</name>
              <description>
              1:select four differentiators in sinc filter; 0:select three differentiators in sinc filter
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SINC_RATE</name>
              <description>
              dowmsampling rate of  sinc filter
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD3</name>
          <displayName>RSVD3</displayName>
          <description></description>
          <addressOffset>0xC</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>HPF_CFG</name>
          <displayName>HPF_CFG</displayName>
          <description></description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>26</bitWidth>
            </field>
            <field>
              <name>HPF_RST</name>
              <description>
              1:high-pass filter normal operation ; 0:reset high-pass filter 
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HPF_BYPASS</name>
              <description>
              1:bypass-high pass filter ; 0: enable high-pass filter
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HPF_COEFF</name>
              <description>
              coefficient of high-pass filter
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PGA_CFG</name>
          <displayName>PGA_CFG</displayName>
          <description></description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>18</bitWidth>
            </field>
            <field>
              <name>PGA_GAIN_R</name>
              <description>
              right channel gain control , the range is -15dB~45dB. Resolution is 0.5dB/LSB
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
            <field>
              <name>PGA_GAIN_L</name>
              <description>
              left channel gain control , the range is -15dB~45dB. Resolution is 0.5dB/LSB
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD2</name>
          <displayName>RSVD2</displayName>
          <description></description>
          <addressOffset>0x1C</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>LPF_CFG6</name>
          <displayName>LPF_CFG6</displayName>
          <description></description>
          <addressOffset>0x34</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>18</bitWidth>
            </field>
            <field>
              <name>LPF_BYPASS</name>
              <description>
              1:bypass low-pass filter ; 0: enable low-pass filter
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LPF_DS</name>
              <description>
              1:downsampling rate of low pass filter is two;0:No downsampling of low pass filter
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>FIFO_CFG</name>
          <displayName>FIFO_CFG</displayName>
          <description></description>
          <addressOffset>0x38</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>LR_CHG</name>
              <description>
              1:exchange storage location of left and right channel; 0: don't exchange storage location of left and right channel
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RX_DMA_MSK_L</name>
              <description>
              1:disable left channel dma request; 0: enable left channel dma request
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RX_DMA_MSK_R</name>
              <description>
              1:disable right channel dma request; 0: enable right channel dma request
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PDM_SHIFT</name>
              <description>
              the number of data left shift for higher data accuracy 
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>BYTE_TRUNC</name>
              <description>
              1: 16bits output ; 0: 24bits output ;2:  8bits output ; 3: 32bits output
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>BYTE_CON</name>
              <description>
              1: combine left channel and right channel; 0: not combine left channel and right channel
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD1</name>
          <displayName>RSVD1</displayName>
          <description></description>
          <addressOffset>0x3C</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>FIFO_ST</name>
          <displayName>FIFO_ST</displayName>
          <description></description>
          <addressOffset>0x44</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>FULL_L</name>
              <description>
              1 indicates left channel fifo is full
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EMPTY_L</name>
              <description>
              1 indicates left channel fifo is empty
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ALMOST_FULL_L</name>
              <description>
              1 indicates left channel fifo is less than two full
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ALMOST_EMPTY_L</name>
              <description>
              1 indicates left channel fifo is less than two datas left
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FULL_R</name>
              <description>
              1 indicates right channel fifo is full
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EMPTY_R</name>
              <description>
              1 indicates right channel fifo is empty
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ALMOST_FULL_R</name>
              <description>
              1 indicates right channel fifo is less than two full
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ALMOST_EMPTY_R</name>
              <description>
              1 indicates right channel fifo is less than two datas left
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>INT_ST</name>
          <displayName>INT_ST</displayName>
          <description></description>
          <addressOffset>0x48</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>30</bitWidth>
            </field>
            <field>
              <name>OVERFLOW_L</name>
              <description>
              1 indicates left channel fifo has already overflowed and as irq at same time 
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OVERFLOW_R</name>
              <description>
              1 indicates right channel fifo has already overflowed  and as irq at same time
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>INT_MSK</name>
          <displayName>INT_MSK</displayName>
          <description></description>
          <addressOffset>0x4c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>30</bitWidth>
            </field>
            <field>
              <name>INT_MASK_L</name>
              <description>
              1:disable left channel irq to system; 0: enable left channel irq to system
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>INT_MASK_R</name>
              <description>
              1:disable right channel irq to system; 0: enable right channel irq to system
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>INT_CLR</name>
          <displayName>INT_CLR</displayName>
          <description></description>
          <addressOffset>0x50</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>30</bitWidth>
            </field>
            <field>
              <name>INT_CLR_L</name>
              <description>
              clear left channel irq
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>INT_CLR_R</name>
              <description>
              clear right channel irq
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>I2C1</name>
      <description></description>
      <groupName>I2C</groupName>
      <baseAddress>0x4001c000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CR</name>
          <displayName>CR</displayName>
          <description>Control register</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>UR</name>
              <description>
              Unit Reset. Software need first assert to reset then deassert to release.
              0 = No reset.
              1 = Reset I2C module.
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSTREQ</name>
              <description>
              I2C will do bus reset upon this bit set. Will be cleared by HW automatically after RSTCYC cycles of SCL generated.
              1 = request for i2c bus reset
              0 = bus reset finished
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BRGRST</name>
              <description>
              Reset bus related state machine and signals. Will be cleared by HW automatically
              1 = request for reset
              0 = reset finished
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>14</bitWidth>
            </field>
            <field>
              <name>DNF</name>
              <description>
              Digital noise filter
              These bits are used to configure the digital noise filter on SDA and SCL input. The digital filter will filter spikes with a length of up to DNF*Tfclk.
              0: Digital filter disabled 
              1: Digital filter enabled and filtering capability up to 1 Tfclk
              ...
              7: digital filter enabled and filtering capability up to 7 Tfclk
              Digital filter is added to analog filter. Digital filter will introduce delay on SCL and SDA processing, which is essential in hs-mode. 
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>SLVEN</name>
              <description>
              Slave mode Enable for SCL.
              0 = Disable slave mode. Will not monitor slave address on I2C bus.
              1 = Enable slave mode. Will monitor slave address on I2C bus.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SCLPP</name>
              <description>
              Push-pull mode Enable for SCL.
              0 = open drain output for SCL.
              1 = Push-pull output for SCL
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MSDE</name>
              <description>
              Master Stop Detected Enable:
              0 = Master Stop Detect (MSD) status is not enabled.
              1 = Master Stop Detect (MSD) status is enabled.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LASTSTOP</name>
              <description>
              Generate STOP for last DMA transfer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LASTNACK</name>
              <description>
              Generate NACK for last DMA Read transfer
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMAEN</name>
              <description>
              DMA Enable for both TX and RX
              0 = DMA mode is NOT enabled
              1 = DMA mode enabled
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SCLE</name>
              <description>
              SCL Enable:
              0 = Disables the I2C from driving the SCL line.
              1 = Enables the I2C clock output for master-mode operation.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IUE</name>
              <description>
              I2C Unit Enable:
              0 = Disables the unit and does not master any transactions or respond to any slave transactions.
              1 = Enables the I2C (defaults to slave-receive mode).
              Software must guarantee the I2C bus is idle before setting this bit.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MODE</name>
              <description>
              Bus Mode (Master operation):
              2'b00: standard-mode
              2'b01: fast-mode and fast-mode plus
              2'b10: HS-mode (standard mode when not doing a high speed transfer)
              2'b11: HS-mode (fast mode when not doing a high speed transfer)
              Bus Mode (Slave operation):
              2'b0x: HS-mode is disabled. I2C unit uses Standard/Fast mode timing on the SDA pin.
              2'b1x: HS-mode is enabled. I2C unit uses HS-mode timing on the SDA pin when a master code is received.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TCR</name>
          <displayName>TCR</displayName>
          <description>Transfer Control register</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>ABORTDMA</name>
              <description>
              Abort DMA operation. Will be cleared by HW automatically
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RXREQ</name>
              <description>
              Request DMA RX. Will be cleared by HW automatically
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TXREQ</name>
              <description>
              Request DMA TX. Will be cleared by HW automatically
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MA</name>
              <description>
              Master Abort:
              Used by the I2C in master mode to generate a Stop without transmitting another data byte:
              0 = The I2C transmits Stop on if TCR[STOP] is set.
              1 = The I2C sends Stop without data transmission.
              When in master-transmit mode, after transmitting a data byte, the TCR[TB] bit is cleared. When no more data bytes need to be sent, setting master abort bit sends the Stop. The TCR[TB] bit must remain clear.
              In master-receive mode, when a NAK is sent without a Stop (TCR[STOP] bit was not set) and CPU does not send a repeated Start, setting this bit sends the Stop. Once again, the TCR[TB] bit must remain clear. Master Abort can be done immediately after the address phase (Master Transmit mode only).
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>NACK</name>
              <description>
              The positive/negative acknowledge control bit, defines the type of acknowledge pulse sent by the I2C when in master receive mode:
              0 = Send a positive acknowledge (ACK) pulse after receiving a data byte.
              1 = Send a negative acknowledge (NACK) pulse after receiving a data byte.
              The I2C automatically sends an ACK pulse when responding to its slave address or when responding in slave-receive mode, regardless of the NACK control-bit setting.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>STOP</name>
              <description>
              Stop:
              Used to initiate a Stop condition after transferring the next data byte on the I2C bus when in master mode. In master-receive mode, the NACK control bit must be set in conjunction with the STOP bit. 
              0 = Do not send a Stop.
              1 = Send a Stop.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>START</name>
              <description>
              Start:
              Used to initiate a Start condition to the I2C unit when in master mode. 
              0 = Do not send a Start pulse.
              1 = Send a Start pulse.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TB</name>
              <description>
              Transfer Byte:
              Used to send or receive a byte on the I2C bus:
              0 = Cleared by I2C when the byte is sent/received.
              1 = Send/receive a byte. 
              CPU can monitor this bit to determine when the byte transfer has completed. In master or slave mode, after each byte transfer including acknowledge pulse, the I2C holds the SCL line low (inserting wait states) until TB is set.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IER</name>
          <displayName>IER</displayName>
          <description>Interrupt Enable register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>UFIE</name>
              <description>
              FIFO Underflow Interrupt Enable
              0 = FIFO Underflow interrupt is not enabled
              1 = FIFO Underflow interrupt is enabled
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OFIE</name>
              <description>
              FIFO Overflow Interrupt Enable
              0 = FIFO Overflow interrupt is not enabled
              1 = FIFO Overflow interrupt is enabled
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMADONEIE</name>
              <description>
              DMA Transaction Done Interrupt Enable
              0 = DMA Transaction done interrupt is not enabled.
              1 = DMA Transaction done interrupt is enabled.
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MSDIE</name>
              <description>
              Master Stop Detected Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C unit to interrupt upon detecting a Master Stop sent by the I2C unit.
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BEDIE</name>
              <description>
              Bus Error Detected Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C to interrupt for the following I2C bus errors:
              As a master transmitter, no ACK was detected after a byte was sent.
              As a slave receiver, the I2C generated a NACK pulse.
              Software is responsible for guaranteeing that misplaced Start and Stop conditions do not occur.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SADIE</name>
              <description>
              Slave Address Detected Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C to interrupt upon detecting a slave address match or a general call address.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RFIE</name>
              <description>
              DBR Receive Full Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C to interrupt when the DBR has received a data byte from the I2C bus.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIE</name>
              <description>
              DBR Transmit Empty Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C to interrupt after transmitting a byte onto the I2C bus.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ALDIE</name>
              <description>
              Arbitration Loss Detected Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C to interrupt upon losing arbitration while in master mode.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SSDIE</name>
              <description>
              Slave Stop Detected Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C to interrupt when it detects a Stop condition while in slave mode.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SR</name>
          <displayName>SR</displayName>
          <description>Status register</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>UF</name>
              <description>
              FIFO Underflow Flag. Asserted when FIFO is empty and a POP request generated without a PUSH. Cleared if write 1
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OF</name>
              <description>
              FIFO Overflow Flag. Asserted when FIFO is full and a PUSH request generated without a POP. Cleared if write 1
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMADONE</name>
              <description>
              DMA Transaction Done. Asserted when both APB and I2C bus have finished transfer. Cleared if write 1
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MSD</name>
              <description>
              Master Stop Detected:
              0 = No Master Stop Detected.
              1 = This bit is set by the I2C unit when all of the following are true:
              This bit is enabled (CR[MSDE] = 1);
              I2C unit is configured as a master;
              I2C transmits a STOP signal
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EBB</name>
              <description>
              Early Bus Busy
              0 = I2C bus is idle or the I2C is using the bus (that is, unit busy).
              1 = Set when the unit detects that the SCL or SDA line is low without a START condition. Bit will remain set until the I2C unit detects the bus is idle by detecting a STOP condition. Bit will also be set whenever the IBB bit is set.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BED</name>
              <description>
              Bus Error Detected:
              0 = No error detected.
              1 = The I2C sets this bit when it detects one of the following error conditions:
              As a master transmitter, no ACK was detected on the interface after a byte was sent.
              As a slave receiver, the I2C generates a NACK pulse.
              When an error occurs, I2C bus transactions continue. Software must guarantee that misplaced Start and Stop conditions do not occur. 
              Cleared if write 1
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SAD</name>
              <description>
              Slave Address Detected:
              0 = No slave address was detected.
              1 = The I2C detected a seven-bit address that matches the general call address or SAR. An interrupt is signalled when enabled in the CR. 
              Cleared if write 1
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RF</name>
              <description>
              DBR Receive Full:
              0 = The DBR has not received a new data byte or the I2C is idle.
              1 = The DBR register received a new data byte from the I2C bus. An interrupt is signalled when enabled in the CR. 
              Cleared if write 1
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TE</name>
              <description>
              DBR Transmit Empty:
              0 = The data byte is still being transmitted.
              1 = The I2C has finished transmitting a data byte on the I2C bus. An interrupt is signalled when enabled in the CR.
              Cleared if write 1
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ALD</name>
              <description>
              Arbitration Loss Detected:
              Used during multi-master operation:
              0 = Cleared when arbitration is won or never took place.
              1 = Set when the I2C loses arbitration. 
              Cleared if write 1
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SSD</name>
              <description>
              Slave Stop Detected:
              0 = No Stop detected.
              1 = Set when the I2C detects a Stop while in slave-receive or slave-transmit mode. 
              Cleared if write 1
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IBB</name>
              <description>
              I2C Bus Busy:
              0 = I2C bus is idle or the I2C is using the bus (that is, unit busy).
              1 = Set when the I2C bus is busy but local I2C is not involved in the transaction.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UB</name>
              <description>
              Unit Busy:
              0 = I2C not busy.
              1 = Set when local I2C is busy. This is defined as the time between the first Start and Stop. 
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>NACK</name>
              <description>
              ACK/NACK Status:
              0 = The I2C received or sent an ACK on the bus. 
              1 = The I2C received or sent a NACK.on the bus.
              This bit is used in slave-transmit mode to determine when the byte transferred is the last one. This bit is updated after each byte and ACK/NACK information is received.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RWM</name>
              <description>
              Read/write Mode:
              0 = The I2C is in master-transmit or slave-receive mode. 
              1 = The I2C is in master-receive or slave-transmit mode. 
              This is the R/nW bit of the slave address. It is cleared automatically by hardware after a Stop state.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DBR</name>
          <displayName>DBR</displayName>
          <description>Data Buffer register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>DATA</name>
              <description>
              use the I2C Data Buffer register to transmit and receive data from the I2C bus. The DBR is accessed by software on one Side and by the I2C Shift register on the other. The DBR receives data coming into the I2C unit after a full byte is received and acknowledged. CPU writes data going out of the I2C to the DBR and sends it to the serial bus. 
              When the I2C is in transmit mode (master or slave), CPU writes data to the DBR over the internal bus. CPU write data to the DBR when a master transaction is initiated or when the DBR transmit-empty interrupt is signalled. Data moves from the DBR to the Shift register when the transfer byte bit is set. The DBR transmit-empty interrupt is signalled (if enabled) when a byte is transferred on the I2C bus and the acknowledge cycle is complete. If the DBR is not written, and a Stop condition is not in place before the I2C bus is ready to transfer the next byte packet, the I2C unit inserts wait states until CPU writes the DBR and sets the transfer byte bit.
              When the I2C is in receive mode (master or slave), CPU reads DBR data over the internal bus. CPU reads data from the DBR when the DBR receive-full interrupt is signalled. The data moves from the Shift register to the DBR when the acknowledge cycle is complete. The I2C inserts wait states until the DBR is read. After the software reads the DBR, CR[NACK] are written by the software, allowing the next byte transfer to proceed to the I2C bus.
              In DMA mode, DBR is automatically filled from FIFO in master transmit mode, or fetched and stored in FIFO in master receive mode until DMA done or aborted.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SAR</name>
          <displayName>SAR</displayName>
          <description>Slave Address Register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000047</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>25</bitWidth>
            </field>
            <field>
              <name>ADDR</name>
              <description>
              The seven-bit address to which the I2C responds when in slave-receive mode
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>LCR</name>
          <displayName>LCR</displayName>
          <description>Load Count Register</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x081C72ED</resetValue>
          <fields>
            <field>
              <name>HLVH</name>
              <description>
              Decrementer Load value for High Speed Mode SCL (master mode) for high phase. 
              Thigh=Tfclk*(HLVH+4+DNF)
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>HLVL</name>
              <description>
              Decrementer Load value for High Speed Mode SCL (master mode) for low phase. 
              Tlow=Tfclk*(HLVL+3+DNF). Data rate is generated as 1/(Thigh+Tlow), or Ffclk/(HLVH+HLVL+7+2*DNF). 
              3.2Mbps data rate is generated by default if fclk is 48MHz.
              HLVL also controls setup time and hold time for START and STOP condition in High Speed Mode(master mode). 
              Thdsta=Tsusta=Tsusto=Tfclk*(HLVL+1)
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
            <field>
              <name>FLV</name>
              <description>
              Decrementer Load value for Fast Mode (or Fast Mode Plus) SCL (master mode) for both high and low phase. 
              Data rate is generated as Ffclk/(FLV+max(FLV,CNT*2+6)+7+DNF) approximately. 
              400kbps data rate is generated by default if fclk is 48MHz.
              FLV also controls setup time and hold time for START and STOP condition in Fast Mode(master mode). 
              Thdsta=Tsusta=Tsusto=Tfclk*FLV
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
            <field>
              <name>SLV</name>
              <description>
              Decrementer Load value for Standard Mode SCL (master mode) for both high and low phase. 
              Data rate is generated as Ffclk/(SLV+max(SLV,CNT*2+6)+7+DNF) approximately. 
              100kbps data rate is generated by default if fclk is 48MHz.
              SLV also controls setup time and hold time for START and STOP condition in Standard Mode(master mode). 
              Thdsta=Tsusta=Tsusto=Tfclk*SLV
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>WCR</name>
          <displayName>WCR</displayName>
          <description>Wait Count Register</description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0000000A</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>CNT</name>
              <description>
              Controls the counter values defining the setup and hold times in standard and fast mode
              Tvddat=Thddat=Tfclk*(CNT+2)
              Tsudat=max(Tlow-Thddat,Thddat)
              Lower counter values may violate setup and hold times.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RCCR</name>
          <displayName>RCCR</displayName>
          <description>Bus Reset Cycle Counter Register</description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000009</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>28</bitWidth>
            </field>
            <field>
              <name>RSTCYC</name>
              <description>
              The cycles of SCL during bus reset
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BMR</name>
          <displayName>BMR</displayName>
          <description>Bus Monitor Register</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000003</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>30</bitWidth>
            </field>
            <field>
              <name>SCL</name>
              <description>
              value of the SCL pin. Software can check bus level when the I2C bus is hung and the I2C unit must be reset.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SDA</name>
              <description>
              value of the SDA pin.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DNR</name>
          <displayName>DNR</displayName>
          <description>DMA number register</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>NDT</name>
              <description>
              Write as number of data to transfer in byte. Read as left data number to transfer
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD1</name>
          <displayName>RSVD1</displayName>
          <description></description>
          <addressOffset>0x2C</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>FIFO</name>
          <displayName>FIFO</displayName>
          <description>FIFO Register</description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>DATA</name>
              <description>
              Write to push send data into FIFO. Read to pop received data from FIFO
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>I2C2</name>
      <description></description>
      <groupName>I2C</groupName>
      <baseAddress>0x4001d000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CR</name>
          <displayName>CR</displayName>
          <description>Control register</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>UR</name>
              <description>
              Unit Reset. Software need first assert to reset then deassert to release.
              0 = No reset.
              1 = Reset I2C module.
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSTREQ</name>
              <description>
              I2C will do bus reset upon this bit set. Will be cleared by HW automatically after RSTCYC cycles of SCL generated.
              1 = request for i2c bus reset
              0 = bus reset finished
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BRGRST</name>
              <description>
              Reset bus related state machine and signals. Will be cleared by HW automatically
              1 = request for reset
              0 = reset finished
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>14</bitWidth>
            </field>
            <field>
              <name>DNF</name>
              <description>
              Digital noise filter
              These bits are used to configure the digital noise filter on SDA and SCL input. The digital filter will filter spikes with a length of up to DNF*Tfclk.
              0: Digital filter disabled 
              1: Digital filter enabled and filtering capability up to 1 Tfclk
              ...
              7: digital filter enabled and filtering capability up to 7 Tfclk
              Digital filter is added to analog filter. Digital filter will introduce delay on SCL and SDA processing, which is essential in hs-mode. 
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>SLVEN</name>
              <description>
              Slave mode Enable for SCL.
              0 = Disable slave mode. Will not monitor slave address on I2C bus.
              1 = Enable slave mode. Will monitor slave address on I2C bus.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SCLPP</name>
              <description>
              Push-pull mode Enable for SCL.
              0 = open drain output for SCL.
              1 = Push-pull output for SCL
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MSDE</name>
              <description>
              Master Stop Detected Enable:
              0 = Master Stop Detect (MSD) status is not enabled.
              1 = Master Stop Detect (MSD) status is enabled.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LASTSTOP</name>
              <description>
              Generate STOP for last DMA transfer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LASTNACK</name>
              <description>
              Generate NACK for last DMA Read transfer
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMAEN</name>
              <description>
              DMA Enable for both TX and RX
              0 = DMA mode is NOT enabled
              1 = DMA mode enabled
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SCLE</name>
              <description>
              SCL Enable:
              0 = Disables the I2C from driving the SCL line.
              1 = Enables the I2C clock output for master-mode operation.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IUE</name>
              <description>
              I2C Unit Enable:
              0 = Disables the unit and does not master any transactions or respond to any slave transactions.
              1 = Enables the I2C (defaults to slave-receive mode).
              Software must guarantee the I2C bus is idle before setting this bit.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MODE</name>
              <description>
              Bus Mode (Master operation):
              2'b00: standard-mode
              2'b01: fast-mode and fast-mode plus
              2'b10: HS-mode (standard mode when not doing a high speed transfer)
              2'b11: HS-mode (fast mode when not doing a high speed transfer)
              Bus Mode (Slave operation):
              2'b0x: HS-mode is disabled. I2C unit uses Standard/Fast mode timing on the SDA pin.
              2'b1x: HS-mode is enabled. I2C unit uses HS-mode timing on the SDA pin when a master code is received.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TCR</name>
          <displayName>TCR</displayName>
          <description>Transfer Control register</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>ABORTDMA</name>
              <description>
              Abort DMA operation. Will be cleared by HW automatically
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RXREQ</name>
              <description>
              Request DMA RX. Will be cleared by HW automatically
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TXREQ</name>
              <description>
              Request DMA TX. Will be cleared by HW automatically
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MA</name>
              <description>
              Master Abort:
              Used by the I2C in master mode to generate a Stop without transmitting another data byte:
              0 = The I2C transmits Stop on if TCR[STOP] is set.
              1 = The I2C sends Stop without data transmission.
              When in master-transmit mode, after transmitting a data byte, the TCR[TB] bit is cleared. When no more data bytes need to be sent, setting master abort bit sends the Stop. The TCR[TB] bit must remain clear.
              In master-receive mode, when a NAK is sent without a Stop (TCR[STOP] bit was not set) and CPU does not send a repeated Start, setting this bit sends the Stop. Once again, the TCR[TB] bit must remain clear. Master Abort can be done immediately after the address phase (Master Transmit mode only).
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>NACK</name>
              <description>
              The positive/negative acknowledge control bit, defines the type of acknowledge pulse sent by the I2C when in master receive mode:
              0 = Send a positive acknowledge (ACK) pulse after receiving a data byte.
              1 = Send a negative acknowledge (NACK) pulse after receiving a data byte.
              The I2C automatically sends an ACK pulse when responding to its slave address or when responding in slave-receive mode, regardless of the NACK control-bit setting.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>STOP</name>
              <description>
              Stop:
              Used to initiate a Stop condition after transferring the next data byte on the I2C bus when in master mode. In master-receive mode, the NACK control bit must be set in conjunction with the STOP bit. 
              0 = Do not send a Stop.
              1 = Send a Stop.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>START</name>
              <description>
              Start:
              Used to initiate a Start condition to the I2C unit when in master mode. 
              0 = Do not send a Start pulse.
              1 = Send a Start pulse.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TB</name>
              <description>
              Transfer Byte:
              Used to send or receive a byte on the I2C bus:
              0 = Cleared by I2C when the byte is sent/received.
              1 = Send/receive a byte. 
              CPU can monitor this bit to determine when the byte transfer has completed. In master or slave mode, after each byte transfer including acknowledge pulse, the I2C holds the SCL line low (inserting wait states) until TB is set.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IER</name>
          <displayName>IER</displayName>
          <description>Interrupt Enable register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>UFIE</name>
              <description>
              FIFO Underflow Interrupt Enable
              0 = FIFO Underflow interrupt is not enabled
              1 = FIFO Underflow interrupt is enabled
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OFIE</name>
              <description>
              FIFO Overflow Interrupt Enable
              0 = FIFO Overflow interrupt is not enabled
              1 = FIFO Overflow interrupt is enabled
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMADONEIE</name>
              <description>
              DMA Transaction Done Interrupt Enable
              0 = DMA Transaction done interrupt is not enabled.
              1 = DMA Transaction done interrupt is enabled.
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MSDIE</name>
              <description>
              Master Stop Detected Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C unit to interrupt upon detecting a Master Stop sent by the I2C unit.
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BEDIE</name>
              <description>
              Bus Error Detected Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C to interrupt for the following I2C bus errors:
              As a master transmitter, no ACK was detected after a byte was sent.
              As a slave receiver, the I2C generated a NACK pulse.
              Software is responsible for guaranteeing that misplaced Start and Stop conditions do not occur.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SADIE</name>
              <description>
              Slave Address Detected Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C to interrupt upon detecting a slave address match or a general call address.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RFIE</name>
              <description>
              DBR Receive Full Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C to interrupt when the DBR has received a data byte from the I2C bus.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIE</name>
              <description>
              DBR Transmit Empty Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C to interrupt after transmitting a byte onto the I2C bus.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ALDIE</name>
              <description>
              Arbitration Loss Detected Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C to interrupt upon losing arbitration while in master mode.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SSDIE</name>
              <description>
              Slave Stop Detected Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C to interrupt when it detects a Stop condition while in slave mode.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SR</name>
          <displayName>SR</displayName>
          <description>Status register</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>UF</name>
              <description>
              FIFO Underflow Flag. Asserted when FIFO is empty and a POP request generated without a PUSH. Cleared if write 1
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OF</name>
              <description>
              FIFO Overflow Flag. Asserted when FIFO is full and a PUSH request generated without a POP. Cleared if write 1
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMADONE</name>
              <description>
              DMA Transaction Done. Asserted when both APB and I2C bus have finished transfer. Cleared if write 1
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MSD</name>
              <description>
              Master Stop Detected:
              0 = No Master Stop Detected.
              1 = This bit is set by the I2C unit when all of the following are true:
              This bit is enabled (CR[MSDE] = 1);
              I2C unit is configured as a master;
              I2C transmits a STOP signal
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EBB</name>
              <description>
              Early Bus Busy
              0 = I2C bus is idle or the I2C is using the bus (that is, unit busy).
              1 = Set when the unit detects that the SCL or SDA line is low without a START condition. Bit will remain set until the I2C unit detects the bus is idle by detecting a STOP condition. Bit will also be set whenever the IBB bit is set.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BED</name>
              <description>
              Bus Error Detected:
              0 = No error detected.
              1 = The I2C sets this bit when it detects one of the following error conditions:
              As a master transmitter, no ACK was detected on the interface after a byte was sent.
              As a slave receiver, the I2C generates a NACK pulse.
              When an error occurs, I2C bus transactions continue. Software must guarantee that misplaced Start and Stop conditions do not occur. 
              Cleared if write 1
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SAD</name>
              <description>
              Slave Address Detected:
              0 = No slave address was detected.
              1 = The I2C detected a seven-bit address that matches the general call address or SAR. An interrupt is signalled when enabled in the CR. 
              Cleared if write 1
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RF</name>
              <description>
              DBR Receive Full:
              0 = The DBR has not received a new data byte or the I2C is idle.
              1 = The DBR register received a new data byte from the I2C bus. An interrupt is signalled when enabled in the CR. 
              Cleared if write 1
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TE</name>
              <description>
              DBR Transmit Empty:
              0 = The data byte is still being transmitted.
              1 = The I2C has finished transmitting a data byte on the I2C bus. An interrupt is signalled when enabled in the CR.
              Cleared if write 1
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ALD</name>
              <description>
              Arbitration Loss Detected:
              Used during multi-master operation:
              0 = Cleared when arbitration is won or never took place.
              1 = Set when the I2C loses arbitration. 
              Cleared if write 1
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SSD</name>
              <description>
              Slave Stop Detected:
              0 = No Stop detected.
              1 = Set when the I2C detects a Stop while in slave-receive or slave-transmit mode. 
              Cleared if write 1
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IBB</name>
              <description>
              I2C Bus Busy:
              0 = I2C bus is idle or the I2C is using the bus (that is, unit busy).
              1 = Set when the I2C bus is busy but local I2C is not involved in the transaction.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UB</name>
              <description>
              Unit Busy:
              0 = I2C not busy.
              1 = Set when local I2C is busy. This is defined as the time between the first Start and Stop. 
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>NACK</name>
              <description>
              ACK/NACK Status:
              0 = The I2C received or sent an ACK on the bus. 
              1 = The I2C received or sent a NACK.on the bus.
              This bit is used in slave-transmit mode to determine when the byte transferred is the last one. This bit is updated after each byte and ACK/NACK information is received.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RWM</name>
              <description>
              Read/write Mode:
              0 = The I2C is in master-transmit or slave-receive mode. 
              1 = The I2C is in master-receive or slave-transmit mode. 
              This is the R/nW bit of the slave address. It is cleared automatically by hardware after a Stop state.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DBR</name>
          <displayName>DBR</displayName>
          <description>Data Buffer register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>DATA</name>
              <description>
              use the I2C Data Buffer register to transmit and receive data from the I2C bus. The DBR is accessed by software on one Side and by the I2C Shift register on the other. The DBR receives data coming into the I2C unit after a full byte is received and acknowledged. CPU writes data going out of the I2C to the DBR and sends it to the serial bus. 
              When the I2C is in transmit mode (master or slave), CPU writes data to the DBR over the internal bus. CPU write data to the DBR when a master transaction is initiated or when the DBR transmit-empty interrupt is signalled. Data moves from the DBR to the Shift register when the transfer byte bit is set. The DBR transmit-empty interrupt is signalled (if enabled) when a byte is transferred on the I2C bus and the acknowledge cycle is complete. If the DBR is not written, and a Stop condition is not in place before the I2C bus is ready to transfer the next byte packet, the I2C unit inserts wait states until CPU writes the DBR and sets the transfer byte bit.
              When the I2C is in receive mode (master or slave), CPU reads DBR data over the internal bus. CPU reads data from the DBR when the DBR receive-full interrupt is signalled. The data moves from the Shift register to the DBR when the acknowledge cycle is complete. The I2C inserts wait states until the DBR is read. After the software reads the DBR, CR[NACK] are written by the software, allowing the next byte transfer to proceed to the I2C bus.
              In DMA mode, DBR is automatically filled from FIFO in master transmit mode, or fetched and stored in FIFO in master receive mode until DMA done or aborted.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SAR</name>
          <displayName>SAR</displayName>
          <description>Slave Address Register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000047</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>25</bitWidth>
            </field>
            <field>
              <name>ADDR</name>
              <description>
              The seven-bit address to which the I2C responds when in slave-receive mode
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>LCR</name>
          <displayName>LCR</displayName>
          <description>Load Count Register</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x081C72ED</resetValue>
          <fields>
            <field>
              <name>HLVH</name>
              <description>
              Decrementer Load value for High Speed Mode SCL (master mode) for high phase. 
              Thigh=Tfclk*(HLVH+4+DNF)
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>HLVL</name>
              <description>
              Decrementer Load value for High Speed Mode SCL (master mode) for low phase. 
              Tlow=Tfclk*(HLVL+3+DNF). Data rate is generated as 1/(Thigh+Tlow), or Ffclk/(HLVH+HLVL+7+2*DNF). 
              3.2Mbps data rate is generated by default if fclk is 48MHz.
              HLVL also controls setup time and hold time for START and STOP condition in High Speed Mode(master mode). 
              Thdsta=Tsusta=Tsusto=Tfclk*(HLVL+1)
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
            <field>
              <name>FLV</name>
              <description>
              Decrementer Load value for Fast Mode (or Fast Mode Plus) SCL (master mode) for both high and low phase. 
              Data rate is generated as Ffclk/(FLV+max(FLV,CNT*2+6)+7+DNF) approximately. 
              400kbps data rate is generated by default if fclk is 48MHz.
              FLV also controls setup time and hold time for START and STOP condition in Fast Mode(master mode). 
              Thdsta=Tsusta=Tsusto=Tfclk*FLV
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
            <field>
              <name>SLV</name>
              <description>
              Decrementer Load value for Standard Mode SCL (master mode) for both high and low phase. 
              Data rate is generated as Ffclk/(SLV+max(SLV,CNT*2+6)+7+DNF) approximately. 
              100kbps data rate is generated by default if fclk is 48MHz.
              SLV also controls setup time and hold time for START and STOP condition in Standard Mode(master mode). 
              Thdsta=Tsusta=Tsusto=Tfclk*SLV
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>WCR</name>
          <displayName>WCR</displayName>
          <description>Wait Count Register</description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0000000A</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>CNT</name>
              <description>
              Controls the counter values defining the setup and hold times in standard and fast mode
              Tvddat=Thddat=Tfclk*(CNT+2)
              Tsudat=max(Tlow-Thddat,Thddat)
              Lower counter values may violate setup and hold times.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RCCR</name>
          <displayName>RCCR</displayName>
          <description>Bus Reset Cycle Counter Register</description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000009</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>28</bitWidth>
            </field>
            <field>
              <name>RSTCYC</name>
              <description>
              The cycles of SCL during bus reset
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BMR</name>
          <displayName>BMR</displayName>
          <description>Bus Monitor Register</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000003</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>30</bitWidth>
            </field>
            <field>
              <name>SCL</name>
              <description>
              value of the SCL pin. Software can check bus level when the I2C bus is hung and the I2C unit must be reset.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SDA</name>
              <description>
              value of the SDA pin.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DNR</name>
          <displayName>DNR</displayName>
          <description>DMA number register</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>NDT</name>
              <description>
              Write as number of data to transfer in byte. Read as left data number to transfer
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD1</name>
          <displayName>RSVD1</displayName>
          <description></description>
          <addressOffset>0x2C</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>FIFO</name>
          <displayName>FIFO</displayName>
          <description>FIFO Register</description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>DATA</name>
              <description>
              Write to push send data into FIFO. Read to pop received data from FIFO
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PTC1</name>
      <description></description>
      <groupName>PTC</groupName>
      <baseAddress>0x40020000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>ISR</name>
          <displayName>ISR</displayName>
          <description>interrupt status register</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>TEIF8</name>
              <description>
              transfer error flag for task 8
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIF7</name>
              <description>
              transfer error flag for task 7
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIF6</name>
              <description>
              transfer error flag for task 6
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIF5</name>
              <description>
              transfer error flag for task 5
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIF4</name>
              <description>
              transfer error flag for task 4
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIF3</name>
              <description>
              transfer error flag for task 3
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIF2</name>
              <description>
              transfer error flag for task 2
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIF1</name>
              <description>
              transfer error flag for task 1
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>TCIF8</name>
              <description>
              task complete interrupt flag for task 8
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIF7</name>
              <description>
              task complete interrupt flag for task 7
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIF6</name>
              <description>
              task complete interrupt flag for task 6
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIF5</name>
              <description>
              task complete interrupt flag for task 5
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIF4</name>
              <description>
              task complete interrupt flag for task 4
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIF3</name>
              <description>
              task complete interrupt flag for task 3
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIF2</name>
              <description>
              task complete interrupt flag for task 2
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIF1</name>
              <description>
              task complete interrupt flag for task 1
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ICR</name>
          <displayName>ICR</displayName>
          <description>interrupt clear register</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>15</bitWidth>
            </field>
            <field>
              <name>CTEIF</name>
              <description>
              clear transfer error flag
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>CTCIF8</name>
              <description>
              clear task complete interrupt flag for task 8
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTCIF7</name>
              <description>
              clear task complete interrupt flag for task 7
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTCIF6</name>
              <description>
              clear task complete interrupt flag for task 6
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTCIF5</name>
              <description>
              clear task complete interrupt flag for task 5
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTCIF4</name>
              <description>
              clear task complete interrupt flag for task 4
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTCIF3</name>
              <description>
              clear task complete interrupt flag for task 3
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTCIF2</name>
              <description>
              clear task complete interrupt flag for task 2
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTCIF1</name>
              <description>
              clear task complete interrupt flag for task 1
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IER</name>
          <displayName>IER</displayName>
          <description>interrupt enable register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>15</bitWidth>
            </field>
            <field>
              <name>TEIE</name>
              <description>
              enable transfer error flag
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>TCIE8</name>
              <description>
              enable task complete interrupt for task 8
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIE7</name>
              <description>
              enable task complete interrupt for task 7
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIE6</name>
              <description>
              enable task complete interrupt for task 6
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIE5</name>
              <description>
              enable task complete interrupt for task 5
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIE4</name>
              <description>
              enable task complete interrupt for task 4
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIE3</name>
              <description>
              enable task complete interrupt for task 3
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIE2</name>
              <description>
              enable task complete interrupt for task 2
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIE1</name>
              <description>
              enable task complete interrupt for task 1
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD2</name>
          <displayName>RSVD2</displayName>
          <description></description>
          <addressOffset>0xC</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>TCR1</name>
          <displayName>TCR1</displayName>
          <description>task 1 control register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>REPIRQ</name>
              <description>
              repetition interrupt
              0: interrupt will be generated after each operation
              1: interrupt will be generated after operation for REP times
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>REPTRIG</name>
              <description>
              repetition trigger
              0: ptc trigger will be generated after each operation
              1: ptc trigger will be generated after operation for REP times
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>REPEN</name>
              <description>
              repetition enable
              0: task will be triggerd no matter what value REP is
              1: task will only be triggerd when REP is not 0
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SWTRIG</name>
              <description>
              software trigger
              task will be triggerd at once after SWTRIG set. SWTRIG will be cleared automatically.
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TRIGPOL</name>
              <description>
              trigger polarity
              0: select positive edge of trigger
              1: select negative edge of trigger
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OP</name>
              <description>
              task operation
              3'b000: direct write data
              3'b100: read then XOR with data and write back
              3'b101: read then OR with data and write back
              3'b110: read then AND with data and write back
              3'b111: read then add with data and write back
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>TRIGSEL</name>
              <description>
              select trigger source
              0: task will only be triggered by SWTRIG
              others: task will be triggered by selected source or SWTRIG
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TAR1</name>
          <displayName>TAR1</displayName>
          <description>task 1 address register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ADDR</name>
              <description>
              peripheral address to access to
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TDR1</name>
          <displayName>TDR1</displayName>
          <description>task 1 data register</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              data value for task operation
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RCR1</name>
          <displayName>RCR1</displayName>
          <description>task 1 repetition and delay counter register</description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DLY</name>
              <description>
              Delay time before task operation after triggered
              0: no delay
              others: delay DLY HCLK cycles before task operation
              DLY is read as left delay time. DLY will be reloaded automatically after each operation.
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>REP</name>
              <description>
              Repetition counter value
              if REPEN is 1, task will only be triggerd when REP is not 0. 
              when REP is larger than 0, it will be decrease by 1 automatically each time task triggered.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TCR2</name>
          <displayName>TCR2</displayName>
          <description></description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>REPIRQ</name>
              <description>
              repetition interrupt
              0: interrupt will be generated after each operation
              1: interrupt will be generated after operation for REP times
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>REPTRIG</name>
              <description>
              repetition trigger
              0: ptc trigger will be generated after each operation
              1: ptc trigger will be generated after operation for REP times
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>REPEN</name>
              <description>
              repetition enable
              0: task will be triggerd no matter what value REP is
              1: task will only be triggerd when REP is not 0
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SWTRIG</name>
              <description>
              software trigger
              task will be triggerd at once after SWTRIG set. SWTRIG will be cleared automatically.
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TRIGPOL</name>
              <description>
              trigger polarity
              0: select positive edge of trigger
              1: select negative edge of trigger
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OP</name>
              <description>
              task operation
              3'b000: direct write data
              3'b100: read then XOR with data and write back
              3'b101: read then OR with data and write back
              3'b110: read then AND with data and write back
              3'b111: read then add with data and write back
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>TRIGSEL</name>
              <description>
              select trigger source
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TAR2</name>
          <displayName>TAR2</displayName>
          <description></description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ADDR</name>
              <description>
              peripheral address to access to
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TDR2</name>
          <displayName>TDR2</displayName>
          <description></description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              data value for task operation
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RCR2</name>
          <displayName>RCR2</displayName>
          <description>task 2 repetition and delay counter register</description>
          <addressOffset>0x2c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DLY</name>
              <description>
              Delay time before task operation after triggered
              0: no delay
              others: delay DLY HCLK cycles before task operation
              DLY is read as left delay time. DLY will be reloaded automatically after each operation.
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>REP</name>
              <description>
              Repetition counter value
              if REPEN is 1, task will only be triggerd when REP is not 0. 
              when REP is larger than 0, it will be decrease by 1 automatically each time task triggered.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TCR3</name>
          <displayName>TCR3</displayName>
          <description></description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>REPIRQ</name>
              <description>
              repetition interrupt
              0: interrupt will be generated after each operation
              1: interrupt will be generated after operation for REP times
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>REPTRIG</name>
              <description>
              repetition trigger
              0: ptc trigger will be generated after each operation
              1: ptc trigger will be generated after operation for REP times
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>REPEN</name>
              <description>
              repetition enable
              0: task will be triggerd no matter what value REP is
              1: task will only be triggerd when REP is not 0
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SWTRIG</name>
              <description>
              software trigger
              task will be triggerd at once after SWTRIG set. SWTRIG will be cleared automatically.
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TRIGPOL</name>
              <description>
              trigger polarity
              0: select positive edge of trigger
              1: select negative edge of trigger
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OP</name>
              <description>
              task operation
              3'b000: direct write data
              3'b100: read then XOR with data and write back
              3'b101: read then OR with data and write back
              3'b110: read then AND with data and write back
              3'b111: read then add with data and write back
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>TRIGSEL</name>
              <description>
              select trigger source
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TAR3</name>
          <displayName>TAR3</displayName>
          <description></description>
          <addressOffset>0x34</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ADDR</name>
              <description>
              peripheral address to access to
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TDR3</name>
          <displayName>TDR3</displayName>
          <description></description>
          <addressOffset>0x38</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              data value for task operation
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RCR3</name>
          <displayName>RCR3</displayName>
          <description>task 3 repetition and delay counter register</description>
          <addressOffset>0x3c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DLY</name>
              <description>
              Delay time before task operation after triggered
              0: no delay
              others: delay DLY HCLK cycles before task operation
              DLY is read as left delay time. DLY will be reloaded automatically after each operation.
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>REP</name>
              <description>
              Repetition counter value
              if REPEN is 1, task will only be triggerd when REP is not 0. 
              when REP is larger than 0, it will be decrease by 1 automatically each time task triggered.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TCR4</name>
          <displayName>TCR4</displayName>
          <description></description>
          <addressOffset>0x40</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>REPIRQ</name>
              <description>
              repetition interrupt
              0: interrupt will be generated after each operation
              1: interrupt will be generated after operation for REP times
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>REPTRIG</name>
              <description>
              repetition trigger
              0: ptc trigger will be generated after each operation
              1: ptc trigger will be generated after operation for REP times
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>REPEN</name>
              <description>
              repetition enable
              0: task will be triggerd no matter what value REP is
              1: task will only be triggerd when REP is not 0
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SWTRIG</name>
              <description>
              software trigger
              task will be triggerd at once after SWTRIG set. SWTRIG will be cleared automatically.
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TRIGPOL</name>
              <description>
              trigger polarity
              0: select positive edge of trigger
              1: select negative edge of trigger
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OP</name>
              <description>
              task operation
              3'b000: direct write data
              3'b100: read then XOR with data and write back
              3'b101: read then OR with data and write back
              3'b110: read then AND with data and write back
              3'b111: read then add with data and write back
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>TRIGSEL</name>
              <description>
              select trigger source
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TAR4</name>
          <displayName>TAR4</displayName>
          <description></description>
          <addressOffset>0x44</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ADDR</name>
              <description>
              peripheral address to access to
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TDR4</name>
          <displayName>TDR4</displayName>
          <description></description>
          <addressOffset>0x48</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              data value for task operation
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RCR4</name>
          <displayName>RCR4</displayName>
          <description>task 4 repetition and delay counter register</description>
          <addressOffset>0x4c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DLY</name>
              <description>
              Delay time before task operation after triggered
              0: no delay
              others: delay DLY HCLK cycles before task operation
              DLY is read as left delay time. DLY will be reloaded automatically after each operation.
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>REP</name>
              <description>
              Repetition counter value
              if REPEN is 1, task will only be triggerd when REP is not 0. 
              when REP is larger than 0, it will be decrease by 1 automatically each time task triggered.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TCR5</name>
          <displayName>TCR5</displayName>
          <description></description>
          <addressOffset>0x50</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>REPIRQ</name>
              <description>
              repetition interrupt
              0: interrupt will be generated after each operation
              1: interrupt will be generated after operation for REP times
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>REPTRIG</name>
              <description>
              repetition trigger
              0: ptc trigger will be generated after each operation
              1: ptc trigger will be generated after operation for REP times
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>REPEN</name>
              <description>
              repetition enable
              0: task will be triggerd no matter what value REP is
              1: task will only be triggerd when REP is not 0
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SWTRIG</name>
              <description>
              software trigger
              task will be triggerd at once after SWTRIG set. SWTRIG will be cleared automatically.
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TRIGPOL</name>
              <description>
              trigger polarity
              0: select positive edge of trigger
              1: select negative edge of trigger
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OP</name>
              <description>
              task operation
              3'b000: direct write data
              3'b100: read then XOR with data and write back
              3'b101: read then OR with data and write back
              3'b110: read then AND with data and write back
              3'b111: read then add with data and write back
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>TRIGSEL</name>
              <description>
              select trigger source
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TAR5</name>
          <displayName>TAR5</displayName>
          <description></description>
          <addressOffset>0x54</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ADDR</name>
              <description>
              peripheral address to access to
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TDR5</name>
          <displayName>TDR5</displayName>
          <description></description>
          <addressOffset>0x58</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              data value for task operation
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RCR5</name>
          <displayName>RCR5</displayName>
          <description>task 5 repetition counter register</description>
          <addressOffset>0x5c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>22</bitWidth>
            </field>
            <field>
              <name>REP</name>
              <description>
              Repetition counter value
              if REPEN is 1, task will only be triggerd when REP is not 0. 
              when REP is larger than 0, it will be decrease by 1 automatically each time task triggered.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TCR6</name>
          <displayName>TCR6</displayName>
          <description></description>
          <addressOffset>0x60</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>REPIRQ</name>
              <description>
              repetition interrupt
              0: interrupt will be generated after each operation
              1: interrupt will be generated after operation for REP times
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>REPTRIG</name>
              <description>
              repetition trigger
              0: ptc trigger will be generated after each operation
              1: ptc trigger will be generated after operation for REP times
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>REPEN</name>
              <description>
              repetition enable
              0: task will be triggerd no matter what value REP is
              1: task will only be triggerd when REP is not 0
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SWTRIG</name>
              <description>
              software trigger
              task will be triggerd at once after SWTRIG set. SWTRIG will be cleared automatically.
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TRIGPOL</name>
              <description>
              trigger polarity
              0: select positive edge of trigger
              1: select negative edge of trigger
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OP</name>
              <description>
              task operation
              3'b000: direct write data
              3'b100: read then XOR with data and write back
              3'b101: read then OR with data and write back
              3'b110: read then AND with data and write back
              3'b111: read then add with data and write back
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>TRIGSEL</name>
              <description>
              select trigger source
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TAR6</name>
          <displayName>TAR6</displayName>
          <description></description>
          <addressOffset>0x64</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ADDR</name>
              <description>
              peripheral address to access to
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TDR6</name>
          <displayName>TDR6</displayName>
          <description></description>
          <addressOffset>0x68</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              data value for task operation
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RCR6</name>
          <displayName>RCR6</displayName>
          <description>task 6 repetition counter register</description>
          <addressOffset>0x6c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>22</bitWidth>
            </field>
            <field>
              <name>REP</name>
              <description>
              Repetition counter value
              if REPEN is 1, task will only be triggerd when REP is not 0. 
              when REP is larger than 0, it will be decrease by 1 automatically each time task triggered.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TCR7</name>
          <displayName>TCR7</displayName>
          <description></description>
          <addressOffset>0x70</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>REPIRQ</name>
              <description>
              repetition interrupt
              0: interrupt will be generated after each operation
              1: interrupt will be generated after operation for REP times
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>REPTRIG</name>
              <description>
              repetition trigger
              0: ptc trigger will be generated after each operation
              1: ptc trigger will be generated after operation for REP times
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>REPEN</name>
              <description>
              repetition enable
              0: task will be triggerd no matter what value REP is
              1: task will only be triggerd when REP is not 0
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SWTRIG</name>
              <description>
              software trigger
              task will be triggerd at once after SWTRIG set. SWTRIG will be cleared automatically.
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TRIGPOL</name>
              <description>
              trigger polarity
              0: select positive edge of trigger
              1: select negative edge of trigger
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OP</name>
              <description>
              task operation
              3'b000: direct write data
              3'b100: read then XOR with data and write back
              3'b101: read then OR with data and write back
              3'b110: read then AND with data and write back
              3'b111: read then add with data and write back
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>TRIGSEL</name>
              <description>
              select trigger source
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TAR7</name>
          <displayName>TAR7</displayName>
          <description></description>
          <addressOffset>0x74</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ADDR</name>
              <description>
              peripheral address to access to
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TDR7</name>
          <displayName>TDR7</displayName>
          <description></description>
          <addressOffset>0x78</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              data value for task operation
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RCR7</name>
          <displayName>RCR7</displayName>
          <description>task 7 repetition counter register</description>
          <addressOffset>0x7c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>22</bitWidth>
            </field>
            <field>
              <name>REP</name>
              <description>
              Repetition counter value
              if REPEN is 1, task will only be triggerd when REP is not 0. 
              when REP is larger than 0, it will be decrease by 1 automatically each time task triggered.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TCR8</name>
          <displayName>TCR8</displayName>
          <description></description>
          <addressOffset>0x80</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>REPIRQ</name>
              <description>
              repetition interrupt
              0: interrupt will be generated after each operation
              1: interrupt will be generated after operation for REP times
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>REPTRIG</name>
              <description>
              repetition trigger
              0: ptc trigger will be generated after each operation
              1: ptc trigger will be generated after operation for REP times
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>REPEN</name>
              <description>
              repetition enable
              0: task will be triggerd no matter what value REP is
              1: task will only be triggerd when REP is not 0
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SWTRIG</name>
              <description>
              software trigger
              task will be triggerd at once after SWTRIG set. SWTRIG will be cleared automatically.
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TRIGPOL</name>
              <description>
              trigger polarity
              0: select positive edge of trigger
              1: select negative edge of trigger
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OP</name>
              <description>
              task operation
              3'b000: direct write data
              3'b100: read then XOR with data and write back
              3'b101: read then OR with data and write back
              3'b110: read then AND with data and write back
              3'b111: read then add with data and write back
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>TRIGSEL</name>
              <description>
              select trigger source
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TAR8</name>
          <displayName>TAR8</displayName>
          <description></description>
          <addressOffset>0x84</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ADDR</name>
              <description>
              peripheral address to access to
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TDR8</name>
          <displayName>TDR8</displayName>
          <description></description>
          <addressOffset>0x88</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              data value for task operation
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RCR8</name>
          <displayName>RCR8</displayName>
          <description>task 8 repetition counter register</description>
          <addressOffset>0x8c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>22</bitWidth>
            </field>
            <field>
              <name>REP</name>
              <description>
              Repetition counter value
              if REPEN is 1, task will only be triggerd when REP is not 0. 
              when REP is larger than 0, it will be decrease by 1 automatically each time task triggered.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD1</name>
          <displayName>RSVD1</displayName>
          <description></description>
          <addressOffset>0x90</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>MEM1</name>
          <displayName>MEM1</displayName>
          <description>temporary memory 1</description>
          <addressOffset>0xd0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              memory to store temporary variables
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>MEM2</name>
          <displayName>MEM2</displayName>
          <description>temporary memory 2</description>
          <addressOffset>0xd4</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              memory to store temporary variables
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>MEM3</name>
          <displayName>MEM3</displayName>
          <description>temporary memory 3</description>
          <addressOffset>0xd8</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              memory to store temporary variables
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>MEM4</name>
          <displayName>MEM4</displayName>
          <description>temporary memory 4</description>
          <addressOffset>0xdc</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              memory to store temporary variables
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>GPIO31_0</name>
          <displayName>GPIO31_0</displayName>
          <description></description>
          <addressOffset>0xe0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>SELD</name>
              <description>
              select trigger D of GPIO 31~0
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>SELC</name>
              <description>
              select trigger C of GPIO 31~0
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>SELB</name>
              <description>
              select trigger B of GPIO 31~0
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>SELA</name>
              <description>
              select trigger A of GPIO 31~0
              0: select GPIO 0
              1: select GPIO 1
              ......
              31: select GPIO 31
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>GPIO63_32</name>
          <displayName>GPIO63_32</displayName>
          <description></description>
          <addressOffset>0xe4</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>SELD</name>
              <description>
              select trigger D of GPIO 63~32
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>SELC</name>
              <description>
              select trigger C of GPIO 63~32
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>SELB</name>
              <description>
              select trigger B of GPIO 63~32
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>SELA</name>
              <description>
              select trigger A of GPIO 63~32
              0: select GPIO 32
              1: select GPIO 33
              ......
              31: select GPIO 63
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>GPIO95_64</name>
          <displayName>GPIO95_64</displayName>
          <description></description>
          <addressOffset>0xe8</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>SELD</name>
              <description>
              select trigger D of GPIO 95~64
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>SELC</name>
              <description>
              select trigger C of GPIO 95~64
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>SELB</name>
              <description>
              select trigger B of GPIO 95~64
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>SELA</name>
              <description>
              select trigger A of GPIO 95~64
              0: select GPIO 64
              1: select GPIO 65
              ......
              31: select GPIO 95
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>I2C3</name>
      <description></description>
      <groupName>I2C</groupName>
      <baseAddress>0x40022000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CR</name>
          <displayName>CR</displayName>
          <description>Control register</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>UR</name>
              <description>
              Unit Reset. Software need first assert to reset then deassert to release.
              0 = No reset.
              1 = Reset I2C module.
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSTREQ</name>
              <description>
              I2C will do bus reset upon this bit set. Will be cleared by HW automatically after RSTCYC cycles of SCL generated.
              1 = request for i2c bus reset
              0 = bus reset finished
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BRGRST</name>
              <description>
              Reset bus related state machine and signals. Will be cleared by HW automatically
              1 = request for reset
              0 = reset finished
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>14</bitWidth>
            </field>
            <field>
              <name>DNF</name>
              <description>
              Digital noise filter
              These bits are used to configure the digital noise filter on SDA and SCL input. The digital filter will filter spikes with a length of up to DNF*Tfclk.
              0: Digital filter disabled 
              1: Digital filter enabled and filtering capability up to 1 Tfclk
              ...
              7: digital filter enabled and filtering capability up to 7 Tfclk
              Digital filter is added to analog filter. Digital filter will introduce delay on SCL and SDA processing, which is essential in hs-mode. 
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>SLVEN</name>
              <description>
              Slave mode Enable for SCL.
              0 = Disable slave mode. Will not monitor slave address on I2C bus.
              1 = Enable slave mode. Will monitor slave address on I2C bus.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SCLPP</name>
              <description>
              Push-pull mode Enable for SCL.
              0 = open drain output for SCL.
              1 = Push-pull output for SCL
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MSDE</name>
              <description>
              Master Stop Detected Enable:
              0 = Master Stop Detect (MSD) status is not enabled.
              1 = Master Stop Detect (MSD) status is enabled.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LASTSTOP</name>
              <description>
              Generate STOP for last DMA transfer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LASTNACK</name>
              <description>
              Generate NACK for last DMA Read transfer
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMAEN</name>
              <description>
              DMA Enable for both TX and RX
              0 = DMA mode is NOT enabled
              1 = DMA mode enabled
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SCLE</name>
              <description>
              SCL Enable:
              0 = Disables the I2C from driving the SCL line.
              1 = Enables the I2C clock output for master-mode operation.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IUE</name>
              <description>
              I2C Unit Enable:
              0 = Disables the unit and does not master any transactions or respond to any slave transactions.
              1 = Enables the I2C (defaults to slave-receive mode).
              Software must guarantee the I2C bus is idle before setting this bit.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MODE</name>
              <description>
              Bus Mode (Master operation):
              2'b00: standard-mode
              2'b01: fast-mode and fast-mode plus
              2'b10: HS-mode (standard mode when not doing a high speed transfer)
              2'b11: HS-mode (fast mode when not doing a high speed transfer)
              Bus Mode (Slave operation):
              2'b0x: HS-mode is disabled. I2C unit uses Standard/Fast mode timing on the SDA pin.
              2'b1x: HS-mode is enabled. I2C unit uses HS-mode timing on the SDA pin when a master code is received.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TCR</name>
          <displayName>TCR</displayName>
          <description>Transfer Control register</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>ABORTDMA</name>
              <description>
              Abort DMA operation. Will be cleared by HW automatically
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RXREQ</name>
              <description>
              Request DMA RX. Will be cleared by HW automatically
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TXREQ</name>
              <description>
              Request DMA TX. Will be cleared by HW automatically
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MA</name>
              <description>
              Master Abort:
              Used by the I2C in master mode to generate a Stop without transmitting another data byte:
              0 = The I2C transmits Stop on if TCR[STOP] is set.
              1 = The I2C sends Stop without data transmission.
              When in master-transmit mode, after transmitting a data byte, the TCR[TB] bit is cleared. When no more data bytes need to be sent, setting master abort bit sends the Stop. The TCR[TB] bit must remain clear.
              In master-receive mode, when a NAK is sent without a Stop (TCR[STOP] bit was not set) and CPU does not send a repeated Start, setting this bit sends the Stop. Once again, the TCR[TB] bit must remain clear. Master Abort can be done immediately after the address phase (Master Transmit mode only).
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>NACK</name>
              <description>
              The positive/negative acknowledge control bit, defines the type of acknowledge pulse sent by the I2C when in master receive mode:
              0 = Send a positive acknowledge (ACK) pulse after receiving a data byte.
              1 = Send a negative acknowledge (NACK) pulse after receiving a data byte.
              The I2C automatically sends an ACK pulse when responding to its slave address or when responding in slave-receive mode, regardless of the NACK control-bit setting.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>STOP</name>
              <description>
              Stop:
              Used to initiate a Stop condition after transferring the next data byte on the I2C bus when in master mode. In master-receive mode, the NACK control bit must be set in conjunction with the STOP bit. 
              0 = Do not send a Stop.
              1 = Send a Stop.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>START</name>
              <description>
              Start:
              Used to initiate a Start condition to the I2C unit when in master mode. 
              0 = Do not send a Start pulse.
              1 = Send a Start pulse.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TB</name>
              <description>
              Transfer Byte:
              Used to send or receive a byte on the I2C bus:
              0 = Cleared by I2C when the byte is sent/received.
              1 = Send/receive a byte. 
              CPU can monitor this bit to determine when the byte transfer has completed. In master or slave mode, after each byte transfer including acknowledge pulse, the I2C holds the SCL line low (inserting wait states) until TB is set.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IER</name>
          <displayName>IER</displayName>
          <description>Interrupt Enable register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>UFIE</name>
              <description>
              FIFO Underflow Interrupt Enable
              0 = FIFO Underflow interrupt is not enabled
              1 = FIFO Underflow interrupt is enabled
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OFIE</name>
              <description>
              FIFO Overflow Interrupt Enable
              0 = FIFO Overflow interrupt is not enabled
              1 = FIFO Overflow interrupt is enabled
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMADONEIE</name>
              <description>
              DMA Transaction Done Interrupt Enable
              0 = DMA Transaction done interrupt is not enabled.
              1 = DMA Transaction done interrupt is enabled.
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MSDIE</name>
              <description>
              Master Stop Detected Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C unit to interrupt upon detecting a Master Stop sent by the I2C unit.
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BEDIE</name>
              <description>
              Bus Error Detected Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C to interrupt for the following I2C bus errors:
              As a master transmitter, no ACK was detected after a byte was sent.
              As a slave receiver, the I2C generated a NACK pulse.
              Software is responsible for guaranteeing that misplaced Start and Stop conditions do not occur.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SADIE</name>
              <description>
              Slave Address Detected Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C to interrupt upon detecting a slave address match or a general call address.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RFIE</name>
              <description>
              DBR Receive Full Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C to interrupt when the DBR has received a data byte from the I2C bus.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIE</name>
              <description>
              DBR Transmit Empty Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C to interrupt after transmitting a byte onto the I2C bus.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ALDIE</name>
              <description>
              Arbitration Loss Detected Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C to interrupt upon losing arbitration while in master mode.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SSDIE</name>
              <description>
              Slave Stop Detected Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C to interrupt when it detects a Stop condition while in slave mode.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SR</name>
          <displayName>SR</displayName>
          <description>Status register</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>UF</name>
              <description>
              FIFO Underflow Flag. Asserted when FIFO is empty and a POP request generated without a PUSH. Cleared if write 1
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OF</name>
              <description>
              FIFO Overflow Flag. Asserted when FIFO is full and a PUSH request generated without a POP. Cleared if write 1
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMADONE</name>
              <description>
              DMA Transaction Done. Asserted when both APB and I2C bus have finished transfer. Cleared if write 1
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MSD</name>
              <description>
              Master Stop Detected:
              0 = No Master Stop Detected.
              1 = This bit is set by the I2C unit when all of the following are true:
              This bit is enabled (CR[MSDE] = 1);
              I2C unit is configured as a master;
              I2C transmits a STOP signal
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EBB</name>
              <description>
              Early Bus Busy
              0 = I2C bus is idle or the I2C is using the bus (that is, unit busy).
              1 = Set when the unit detects that the SCL or SDA line is low without a START condition. Bit will remain set until the I2C unit detects the bus is idle by detecting a STOP condition. Bit will also be set whenever the IBB bit is set.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BED</name>
              <description>
              Bus Error Detected:
              0 = No error detected.
              1 = The I2C sets this bit when it detects one of the following error conditions:
              As a master transmitter, no ACK was detected on the interface after a byte was sent.
              As a slave receiver, the I2C generates a NACK pulse.
              When an error occurs, I2C bus transactions continue. Software must guarantee that misplaced Start and Stop conditions do not occur. 
              Cleared if write 1
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SAD</name>
              <description>
              Slave Address Detected:
              0 = No slave address was detected.
              1 = The I2C detected a seven-bit address that matches the general call address or SAR. An interrupt is signalled when enabled in the CR. 
              Cleared if write 1
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RF</name>
              <description>
              DBR Receive Full:
              0 = The DBR has not received a new data byte or the I2C is idle.
              1 = The DBR register received a new data byte from the I2C bus. An interrupt is signalled when enabled in the CR. 
              Cleared if write 1
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TE</name>
              <description>
              DBR Transmit Empty:
              0 = The data byte is still being transmitted.
              1 = The I2C has finished transmitting a data byte on the I2C bus. An interrupt is signalled when enabled in the CR.
              Cleared if write 1
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ALD</name>
              <description>
              Arbitration Loss Detected:
              Used during multi-master operation:
              0 = Cleared when arbitration is won or never took place.
              1 = Set when the I2C loses arbitration. 
              Cleared if write 1
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SSD</name>
              <description>
              Slave Stop Detected:
              0 = No Stop detected.
              1 = Set when the I2C detects a Stop while in slave-receive or slave-transmit mode. 
              Cleared if write 1
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IBB</name>
              <description>
              I2C Bus Busy:
              0 = I2C bus is idle or the I2C is using the bus (that is, unit busy).
              1 = Set when the I2C bus is busy but local I2C is not involved in the transaction.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UB</name>
              <description>
              Unit Busy:
              0 = I2C not busy.
              1 = Set when local I2C is busy. This is defined as the time between the first Start and Stop. 
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>NACK</name>
              <description>
              ACK/NACK Status:
              0 = The I2C received or sent an ACK on the bus. 
              1 = The I2C received or sent a NACK.on the bus.
              This bit is used in slave-transmit mode to determine when the byte transferred is the last one. This bit is updated after each byte and ACK/NACK information is received.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RWM</name>
              <description>
              Read/write Mode:
              0 = The I2C is in master-transmit or slave-receive mode. 
              1 = The I2C is in master-receive or slave-transmit mode. 
              This is the R/nW bit of the slave address. It is cleared automatically by hardware after a Stop state.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DBR</name>
          <displayName>DBR</displayName>
          <description>Data Buffer register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>DATA</name>
              <description>
              use the I2C Data Buffer register to transmit and receive data from the I2C bus. The DBR is accessed by software on one Side and by the I2C Shift register on the other. The DBR receives data coming into the I2C unit after a full byte is received and acknowledged. CPU writes data going out of the I2C to the DBR and sends it to the serial bus. 
              When the I2C is in transmit mode (master or slave), CPU writes data to the DBR over the internal bus. CPU write data to the DBR when a master transaction is initiated or when the DBR transmit-empty interrupt is signalled. Data moves from the DBR to the Shift register when the transfer byte bit is set. The DBR transmit-empty interrupt is signalled (if enabled) when a byte is transferred on the I2C bus and the acknowledge cycle is complete. If the DBR is not written, and a Stop condition is not in place before the I2C bus is ready to transfer the next byte packet, the I2C unit inserts wait states until CPU writes the DBR and sets the transfer byte bit.
              When the I2C is in receive mode (master or slave), CPU reads DBR data over the internal bus. CPU reads data from the DBR when the DBR receive-full interrupt is signalled. The data moves from the Shift register to the DBR when the acknowledge cycle is complete. The I2C inserts wait states until the DBR is read. After the software reads the DBR, CR[NACK] are written by the software, allowing the next byte transfer to proceed to the I2C bus.
              In DMA mode, DBR is automatically filled from FIFO in master transmit mode, or fetched and stored in FIFO in master receive mode until DMA done or aborted.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SAR</name>
          <displayName>SAR</displayName>
          <description>Slave Address Register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000047</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>25</bitWidth>
            </field>
            <field>
              <name>ADDR</name>
              <description>
              The seven-bit address to which the I2C responds when in slave-receive mode
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>LCR</name>
          <displayName>LCR</displayName>
          <description>Load Count Register</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x081C72ED</resetValue>
          <fields>
            <field>
              <name>HLVH</name>
              <description>
              Decrementer Load value for High Speed Mode SCL (master mode) for high phase. 
              Thigh=Tfclk*(HLVH+4+DNF)
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>HLVL</name>
              <description>
              Decrementer Load value for High Speed Mode SCL (master mode) for low phase. 
              Tlow=Tfclk*(HLVL+3+DNF). Data rate is generated as 1/(Thigh+Tlow), or Ffclk/(HLVH+HLVL+7+2*DNF). 
              3.2Mbps data rate is generated by default if fclk is 48MHz.
              HLVL also controls setup time and hold time for START and STOP condition in High Speed Mode(master mode). 
              Thdsta=Tsusta=Tsusto=Tfclk*(HLVL+1)
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
            <field>
              <name>FLV</name>
              <description>
              Decrementer Load value for Fast Mode (or Fast Mode Plus) SCL (master mode) for both high and low phase. 
              Data rate is generated as Ffclk/(FLV+max(FLV,CNT*2+6)+7+DNF) approximately. 
              400kbps data rate is generated by default if fclk is 48MHz.
              FLV also controls setup time and hold time for START and STOP condition in Fast Mode(master mode). 
              Thdsta=Tsusta=Tsusto=Tfclk*FLV
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
            <field>
              <name>SLV</name>
              <description>
              Decrementer Load value for Standard Mode SCL (master mode) for both high and low phase. 
              Data rate is generated as Ffclk/(SLV+max(SLV,CNT*2+6)+7+DNF) approximately. 
              100kbps data rate is generated by default if fclk is 48MHz.
              SLV also controls setup time and hold time for START and STOP condition in Standard Mode(master mode). 
              Thdsta=Tsusta=Tsusto=Tfclk*SLV
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>WCR</name>
          <displayName>WCR</displayName>
          <description>Wait Count Register</description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0000000A</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>CNT</name>
              <description>
              Controls the counter values defining the setup and hold times in standard and fast mode
              Tvddat=Thddat=Tfclk*(CNT+2)
              Tsudat=max(Tlow-Thddat,Thddat)
              Lower counter values may violate setup and hold times.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RCCR</name>
          <displayName>RCCR</displayName>
          <description>Bus Reset Cycle Counter Register</description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000009</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>28</bitWidth>
            </field>
            <field>
              <name>RSTCYC</name>
              <description>
              The cycles of SCL during bus reset
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BMR</name>
          <displayName>BMR</displayName>
          <description>Bus Monitor Register</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000003</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>30</bitWidth>
            </field>
            <field>
              <name>SCL</name>
              <description>
              value of the SCL pin. Software can check bus level when the I2C bus is hung and the I2C unit must be reset.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SDA</name>
              <description>
              value of the SDA pin.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DNR</name>
          <displayName>DNR</displayName>
          <description>DMA number register</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>NDT</name>
              <description>
              Write as number of data to transfer in byte. Read as left data number to transfer
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD1</name>
          <displayName>RSVD1</displayName>
          <description></description>
          <addressOffset>0x2C</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>FIFO</name>
          <displayName>FIFO</displayName>
          <description>FIFO Register</description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>DATA</name>
              <description>
              Write to push send data into FIFO. Read to pop received data from FIFO
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>ATIM1</name>
      <description></description>
      <groupName>ATIM</groupName>
      <baseAddress>0x40023000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CR1</name>
          <displayName>CR1</displayName>
          <description>TIM control register 1</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>UIFREMAP</name>
              <description>
              UIF status bit remapping
              0: No remapping. UIF status bit is not copied to CNT register bit 31
              1: Remapping enabled. UIF status bit is copied to CNT register bit 31.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>ARPE</name>
              <description>
              Auto-reload preload enable
              0: ARR register is not buffered
              1: ARR register is buffered
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CMS</name>
              <description>
              Center-aligned mode selection
              00: Edge-aligned mode. The counter counts up or down depending on the direction bit (DIR).
              01: Center-aligned mode 1. The counter counts up and down alternatively. Output compare interrupt flags of channels configured in output (CCxS=00 in CCMRx register) are set only when the counter is counting down.
              10: Center-aligned mode 2. The counter counts up and down alternatively. Output compare interrupt flags of channels configured in output (CCxS=00 in CCMRx register) are set only when the counter is counting up.
              11: Center-aligned mode 3. The counter counts up and down alternatively. Output compare interrupt flags of channels configured in output (CCxS=00 in CCMRx register) are set both when the counter is counting up or down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>DIR</name>
              <description>
              Direction
              0: Counter used as upcounter
              1: Counter used as downcounter
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OPM</name>
              <description>
              One-pulse mode
              0: Counter is not stopped at update event
              1: Counter stops counting at the next update event (clearing the bit CEN)
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>URS</name>
              <description>
              Update request source
              This bit is set and cleared by software to select the UEV event sources.
              0: Any of the following events generate an update interrupt or DMA request if enabled. 
              These events can be: 
                 Counter overflow/underflow
                 Setting the UG bit
                 Update generation through the slave mode controller
              1: Only counter overflow/underflow generates an update interrupt or DMA request if enabled.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UDIS</name>
              <description>
              Update disable
              This bit is set and cleared by software to enable/disable UEV event generation.
              0: UEV enabled. The Update (UEV) event is generated by one of the following events:
                 Counter overflow/underflow
                 Setting the UG bit
                 Update generation through the slave mode controller
              Buffered registers are then loaded with their preload values.
              1: UEV disabled. The Update event is not generated, shadow registers keep their value (ARR, PSC, CCRx). However the counter and the prescaler are reinitialized if the UG bit is set or if a hardware reset is received from the slave mode controller.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CEN</name>
              <description>
              Counter enable
              0: Counter disabled
              1: Counter enabled
              External clock, gated mode and encoder mode can work only if the CEN bit has been previously set by software. However trigger mode can set the CEN bit automatically by hardware. CEN is cleared automatically in one-pulse mode, when an update event occurs.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CR2</name>
          <displayName>CR2</displayName>
          <description>TIM control register 2</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>13</bitWidth>
            </field>
            <field>
              <name>OIS6</name>
              <description>
              Output Idle state 6 (OC6 output)
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OIS5</name>
              <description>
              Output Idle state 5 (OC5 output)
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OIS4</name>
              <description>
              Output Idle state 4 (OC4 output)
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OIS3N</name>
              <description>
              Output Idle state 3 (OC3N output)
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OIS3</name>
              <description>
              Output Idle state 3 (OC3 output)
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OIS2N</name>
              <description>
              Output Idle state 2 (OC2N output)
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OIS2</name>
              <description>
              Output Idle state 2 (OC2 output)
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OIS1N</name>
              <description>
              Output Idle state 1 (OC1N output)
              0: OC1N=0 after a dead-time when MOE=0
              1: OC1N=1 after a dead-time when MOE=0
              This bit, as well as other OISxN, can not be modified as long as LOCK level 1, 2 or 3 has been programmed
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OIS1</name>
              <description>
              Output Idle state 1 (OC1 output)
              0: OC1=0 (after a dead-time if OC1N is implemented) when MOE=0
              1: OC1=1 (after a dead-time if OC1N is implemented) when MOE=0
              This bit, as well as other OISx, can not be modified as long as LOCK level 1, 2 or 3 has been programmed
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TI1S</name>
              <description>
              TI1 selection
              0: The CH1 pin is connected to TI1 input
              1: The CH1, CH2 and CH3 pins are connected to the TI1 input (XOR combination) 
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MMS</name>
              <description>
              Master mode selection
              These bits allow to select the information to be sent in master mode to slave timers for synchronization (TRGO). The combination is as follows:
              000: Reset - the UG bit from the EGR register is used as trigger output (TRGO). If the reset is generated by the trigger input (slave mode controller configured in reset mode) then the signal on TRGO is delayed compared to the actual reset.
              001: Enable - the Counter enable signal, CNT_EN, is used as trigger output (TRGO). It is useful to start several timers at the same time or to control a window in which a slave timer is enabled. The Counter Enable signal is generated by a logic OR between CEN control bit and the trigger input when configured in gated mode. 
              When the Counter Enable signal is controlled by the trigger input, there is a delay on TRGO, except if the master/slave mode is selected.
              010: Update - The update event is selected as trigger output (TRGO). For instance a master timer can then be used as a prescaler for a slave timer.
              011: Compare Pulse - The trigger output send a positive pulse when the CC1IF flag is to be set (even if it was already high), as soon as a capture or a compare match occurred. (TRGO)
              100: Compare - OC1REFC signal is used as trigger output (TRGO)
              101: Compare - OC2REFC signal is used as trigger output (TRGO)
              110: Compare - OC3REFC signal is used as trigger output (TRGO)
              111: Compare - OC4REFC signal is used as trigger output (TRGO)
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>CCDS</name>
              <description>
              Capture/compare DMA selection
              0: CCx DMA request sent when CCx event occurs
              1: CCx DMA requests sent when update event occurs
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CCUS</name>
              <description>
              Capture/compare control update selection
              0: When capture/compare control bits are preloaded (CCPC=1), they are updated by setting the COMG bit only
              1: When capture/compare control bits are preloaded (CCPC=1), they are updated by setting the COMG bit or when an edge occurs on TRGI after Trigger selection
              This bit acts only on channels that have a complementary output.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CCPC</name>
              <description>
              Capture/compare preloaded control
              0: CCxE, CCxNE and OCxM bits are not preloaded
              1: CCxE, CCxNE and OCxM bits are preloaded, after having been written, they are updated only when a commutation event (COM) occurs (COMG bit set or edge detected on TRGI after Trigger selection, depending on the CCUS bit).
              This bit acts only on channels that have a complementary output.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SMCR</name>
          <displayName>SMCR</displayName>
          <description>TIM slave mode control register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
            <field>
              <name>SMS</name>
              <description>
              Slave mode selection
              When external signals are selected the active edge of the trigger signal (TRGI) is linked to the polarity selected on the external input.
              0000: Slave mode disabled.
              0001: Encoder mode 1 - Counter counts up/down on TI1FP1 edge depending on TI2FP2 level.
              0010: Encoder mode 2 - Counter counts up/down on TI2FP2 edge depending on TI1FP1 level.
              0011: Encoder mode 3 - Counter counts up/down on both TI1FP1 and TI2FP2 edges depending on the level of the other input.
              0100: Reset Mode - Rising edge of the selected trigger input (TRGI) reinitializes the counter and generates an update of the registers.
              0101: Gated Mode - The counter clock is enabled when the trigger input (TRGI) is high. The counter stops (but is not reset) as soon as the trigger becomes low. Both start and stop of the counter are controlled.
              0110: Trigger Mode - The counter starts at a rising edge of the trigger TRGI (but it is not reset). Only the start of the counter is controlled.
              0111: External Clock Mode 1 - Rising edges of the selected trigger (TRGI) clock the counter.
              1000: Combined reset + trigger mode - Rising edge of the selected trigger input (TRGI) reinitializes the counter, generates an update of the registers and starts the counter.
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>ETP</name>
              <description>
              External trigger polarity
              This bit selects whether ETR or ETR is used for trigger operations 
              0: ETR is non-inverted, active at high level or rising edge
              1: ETR is inverted, active at low level or falling edge
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ECE</name>
              <description>
              External clock enable
              This bit enables External clock mode 2.
              0: External clock mode 2 disabled
              1: External clock mode 2 enabled. The counter is clocked by any active edge on the ETRF signal.
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ETPS</name>
              <description>
              External trigger prescaler
              External trigger signal ETRP frequency must be at most 1/4 of CK_INT frequency. A prescaler can be enabled to reduce ETRP frequency. It is useful when inputting fast external clocks.
              00: Prescaler OFF
              01: ETRP frequency divided by 2
              10: ETRP frequency divided by 4
              11: ETRP frequency divided by 8
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>ETF</name>
              <description>
              External trigger filter
              This bit-field then defines the frequency used to sample ETRP signal and the length of the digital filter applied to ETRP. The digital filter is made of an event counter in which N 
              consecutive events are needed to validate a transition on the output:
              0000: No filter, sampling is done at fCLK
              0001:   fSAMPLING=fCLK, N=2
              0010:   fSAMPLING=fCLK, N=4
              0011:   fSAMPLING=fCLK, N=8
              0100:   fSAMPLING=fCLK/2, N=6
              0101:   fSAMPLING=fCLK/2, N=8
              0110:   fSAMPLING=fCLK/4, N=6
              0111:   fSAMPLING=fCLK/4, N=8
              1000:   fSAMPLING=fCLK/8, N=6
              1001:   fSAMPLING=fCLK/8, N=8
              1010:   fSAMPLING=fCLK/16, N=5
              1011:   fSAMPLING=fCLK/16, N=6
              1100:   fSAMPLING=fCLK/16, N=8
              1101:   fSAMPLING=fCLK/32, N=5
              1110:   fSAMPLING=fCLK/32, N=6
              1111:   fSAMPLING=fCLK/32, N=8
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>MSM</name>
              <description>
              Master/Slave mode
              0: No action
              1: The effect of an event on the trigger input (TRGI) is delayed to allow a perfect synchronization between the current timer and its slaves (through TRGO). It is useful if we want to synchronize several timers on a single external event.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TS</name>
              <description>
              Trigger selection
              This bit-field selects the trigger input to be used to synchronize the counter.
              000: Internal Trigger 0 (ITR0)
              001: Internal Trigger 1 (ITR1) 
              010: Internal Trigger 2 (ITR2)
              011: Internal Trigger 3 (ITR3)
              100: TI1 Edge Detector (TI1F_ED)
              101: Filtered Timer Input 1 (TI1FP1)
              110: Filtered Timer Input 2 (TI2FP2)
              111: External Trigger input (ETRF)
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DIER</name>
          <displayName>DIER</displayName>
          <description>TIM DMA/Interrupt enable register</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>14</bitWidth>
            </field>
            <field>
              <name>CC6IE</name>
              <description>
              Capture/Compare 6 interrupt enable
              0: CC6 interrupt disabled.
              1: CC6 interrupt enabled
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC5IE</name>
              <description>
              Capture/Compare 5 interrupt enable
              0: CC5 interrupt disabled.
              1: CC5 interrupt enabled
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TDE</name>
              <description>
              Trigger DMA request enable
              0: Trigger DMA request disabled.
              1: Trigger DMA request enabled.
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>COMDE</name>
              <description>
              COM DMA request enable
              0: COM DMA request disabled
              1: COM DMA request enabled
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC4DE</name>
              <description>
              Capture/Compare 4 DMA request enable
              0: CC4 DMA request disabled.
              1: CC4 DMA request enabled
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC3DE</name>
              <description>
              Capture/Compare 3 DMA request enable
              0: CC3 DMA request disabled.
              1: CC3 DMA request enabled.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC2DE</name>
              <description>
              Capture/Compare 2 DMA request enable
              0: CC2 DMA request disabled.
              1: CC2 DMA request enabled.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC1DE</name>
              <description>
              Capture/Compare 1 DMA request enable
              0: CC1 DMA request disabled.
              1: CC1 DMA request enabled.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UDE</name>
              <description>
              Update DMA request enable
              0: Update DMA request disabled.
              1: Update DMA request enabled
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BIE</name>
              <description>
              Break interrupt enable
              0: Break interrupt disabled
              1: Break interrupt enabled
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TIE</name>
              <description>
              Trigger interrupt enable
              0: Trigger interrupt disabled.
              1: Trigger interrupt enabled
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>COMIE</name>
              <description>
              COM interrupt enable
              0: COM interrupt disabled
              1: COM interrupt enabled
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC4IE</name>
              <description>
              Capture/Compare 4 interrupt enable
              0: CC4 interrupt disabled.
              1: CC4 interrupt enabled
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC3IE</name>
              <description>
              Capture/Compare 3 interrupt enable
              0: CC3 interrupt disabled.
              1: CC3 interrupt enabled
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC2IE</name>
              <description>
              Capture/Compare 2 interrupt enable
              0: CC2 interrupt disabled.
              1: CC2 interrupt enabled.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC1IE</name>
              <description>
              Capture/Compare 1 interrupt enable
              0: CC1 interrupt disabled.
              1: CC1 interrupt enabled
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UIE</name>
              <description>
              Update interrupt enable
              0: Update interrupt disabled.
              1: Update interrupt enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SR</name>
          <displayName>SR</displayName>
          <description>TIM status register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>14</bitWidth>
            </field>
            <field>
              <name>CC6IF</name>
              <description>
              Compare 6 interrupt flag
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC5IF</name>
              <description>
              Compare 5 interrupt flag
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SBIF</name>
              <description>
              System Break interrupt flag
              This flag is set by hardware as soon as the system break input goes active. It can be cleared by software if the system break input is not active.
              This flag must be reset to re-start PWM operation.
              0: No break event occurred.
              1: An active level has been detected on the system break input. An interrupt is generated if BIE=1 in the DIER register.
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC4OF</name>
              <description>
              Capture/Compare 4 overcapture flag
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC3OF</name>
              <description>
              Capture/Compare 3 overcapture flag
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC2OF</name>
              <description>
              Capture/Compare 2 overcapture flag
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC1OF</name>
              <description>
              Capture/Compare 1 overcapture flag
              This flag is set by hardware only when the corresponding channel is configured in input capture mode. It is cleared by software by writing it to '0'.
              0: No overcapture has been detected.
              1: The counter value has been captured in CCR1 register while CC1IF flag was already set
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>B2IF</name>
              <description>
              Break 2 interrupt flag
              This flag is set by hardware as soon as the break 2 input goes active. It can be cleared by software if the break 2 input is not active.
              0: No break event occurred.
              1: An active level has been detected on the break 2 input. An interrupt is generated if BIE=1 in the DIER register.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BIF</name>
              <description>
              Break interrupt flag
              This flag is set by hardware as soon as the break input goes active. It can be cleared by software if the break input is not active.
              0: No break event occurred.
              1: An active level has been detected on the break input. An interrupt is generated if BIE=1 in the DIER register.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TIF</name>
              <description>
              Trigger interrupt flag
              This flag is set by hardware on trigger event. It is set when the counter starts or stops when gated mode is selected. It is cleared by software.
              0: No trigger event occurred.
              1: Trigger interrupt pending.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>COMIF</name>
              <description>
              COM interrupt flag
              This flag is set by hardware on COM event (when Capture/compare Control bits - CCxE, CCxNE, OCxM - have been updated). It is cleared by software.
              0: No COM event occurred.
              1: COM interrupt pending.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC4IF</name>
              <description>
              Capture/Compare 4 interrupt flag
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC3IF</name>
              <description>
              Capture/Compare 3 interrupt flag
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC2IF</name>
              <description>
              Capture/Compare 2 interrupt flag
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC1IF</name>
              <description>
              Capture/Compare 1 interrupt flag
              If channel CC1 is configured as output: This flag is set by hardware when the counter matches the compare value and in retriggerable one pulse mode. It is cleared by software.
              0: No match.
              1: The content of the counter CNT has matched the content of the CCR1 register.
              If channel CC1 is configured as input: This bit is set by hardware on a capture. It is cleared by software or by reading the CCR1 register.
              0: No input capture occurred.
              1: The counter value has been captured in CCR1 register.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UIF</name>
              <description>
              Update interrupt flag
              This bit is set by hardware on an update event. It is cleared by software.
              0: No update occurred
              1: Update interrupt pending. This bit is set by hardware when the registers are updated:
              - At overflow or underflow regarding the repetition counter value (update if repetition counter = 0)  and if UDIS=0 in the CR1 register.
              - When CNT is reinitialized by software using the UG bit in EGR register, if URS=0 and UDIS=0 in the CR1 register.
              - When CNT is reinitialized by a trigger event, if URS=0 and UDIS=0 in the CR1 register.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>EGR</name>
          <displayName>EGR</displayName>
          <description>Event generation register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>B2G</name>
              <description>
              Break 2 generation
              This bit is set by software in order to generate an event, it is automatically cleared by hardware.
              0: No action
              1: A break 2 event is generated. MOE bit is cleared and B2IF flag is set. Related interrupt can occur if enabled.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BG</name>
              <description>
              Break generation
              This bit is set by software in order to generate an event, it is automatically cleared by hardware.
              0: No action
              1: A break event is generated. MOE bit is cleared and BIF flag is set. Related interrupt or DMA transfer can occur if enabled.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TG</name>
              <description>
              Trigger generation
              This bit is set by software in order to generate an event, it is automatically cleared by hardware.
              0: No action
              1: The TIF flag is set in SR register. Related interrupt or DMA transfer can occur if enabled.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>COMG</name>
              <description>
              Capture/Compare control update generation
              This bit can be set by software, it is automatically cleared by hardware
              0: No action
              1: When CCPC bit is set, it allows to update CCxE, CCxNE and OCxM bits
              This bit acts only on channels having a complementary output.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC4G</name>
              <description>
              Capture/compare 4 generation
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC3G</name>
              <description>
              Capture/compare 3 generation
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC2G</name>
              <description>
              Capture/compare 2 generation
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC1G</name>
              <description>
              Capture/compare 1 generation
              This bit is set by software in order to generate an event, it is automatically cleared by hardware.
              0: No action
              1: A capture/compare event is generated on channel 1:
              If channel CC1 is configured as output:
              CC1IF flag is set, Corresponding interrupt or DMA request is sent if enabled.
              If channel CC1 is configured as input:
              The current value of the counter is captured in CCR1 register. The CC1IF flag is set, the corresponding interrupt or DMA request is sent if enabled. The CC1OF flag is set if the CC1IF flag was already high.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UG</name>
              <description>
              Update generation
              This bit can be set by software, it is automatically cleared by hardware.
              0: No action
              1: Re-initialize the counter and generates an update of the registers. The prescaler counter is cleared too (anyway the prescaler ratio is not affected). The counter is cleared if the center-aligned mode is selected or if DIR=0 (upcounting), else it takes the auto-reload value (ARR) if DIR=1 (downcounting).
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCMR1</name>
          <displayName>CCMR1</displayName>
          <description>TIM capture/compare mode register 1</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>OC2M</name>
              <description>
              Output compare 2 mode
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>OC2PE</name>
              <description>
              Output compare 2 preload enable
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>OC2CE</name>
              <description>
              Output compare 2 clear enable
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OC1M</name>
              <description>
              Output compare 1 mode
              These bits define the behavior of the output reference signal OC1REF from which OC1 and OC1N are derived. OC1REF is active high whereas OC1 and OC1N active level depends on CC1P and CC1NP bits.
              0000: Frozen - The comparison between the output compare register CCR1 and the counter CNT has no effect on the outputs.
              0001: Set channel 1 to active level on match. OC1REF signal is forced high when the counter CNT matches the capture/compare register 1 (CCR1).
              0010: Set channel 1 to inactive level on match. OC1REF signal is forced low when the counter CNT matches the capture/compare register 1 (CCR1).
              0011: Toggle - OC1REF toggles when CNT=CCR1.
              0100: Force inactive level - OC1REF is forced low.
              0101: Force active level - OC1REF is forced high.
              0110: PWM mode 1 - In upcounting, channel 1 is active as long as CNTltCCR1 else inactive. In downcounting, channel 1 is inactive (OC1REF=0) as long as CNT>CCR1 else active (OC1REF=1).
              0111: PWM mode 2 - In upcounting, channel 1 is inactive as long as CNTltCCR1 else active. In downcounting, channel 1 is active as long as CNT>CCR1 else inactive.
              1000: Retriggerable OPM mode 1 - In up-counting mode, the channel is active until a trigger event is detected (on TRGI signal). Then, a comparison is performed as in PWM mode 1 and the channels becomes inactive again at the next update. In down-counting mode, the channel is inactive until a trigger event is detected (on TRGI signal). Then, a comparison is performed as in PWM mode 1 and the channels becomes inactive again at the next update.
              1001: Retriggerable OPM mode 2 - In up-counting mode, the channel is inactive until a trigger event is detected (on TRGI signal). Then, a comparison is performed as in PWM mode 2 and the channels becomes inactive again at the next update. In down-counting mode, the channel is active until a trigger event is detected (on TRGI signal). Then, a comparison is performed as in PWM mode 1 and the channels becomes active again at the next update.
              1010: Reserved,
              1011: Reserved,
              1100: Combined PWM mode 1 - OC1REF has the same behavior as in PWM mode 1. OC1REFC is the logical OR between OC1REF and OC2REF.
              1101: Combined PWM mode 2 - OC1REF has the same behavior as in PWM mode 2. OC1REFC is the logical AND between OC1REF and OC2REF.
              1110: Asymmetric PWM mode 1 - OC1REF has the same behavior as in PWM mode 1. OC1REFC outputs OC1REF when the counter is counting up, OC2REF when it is counting down.
              1111: Asymmetric PWM mode 2 - OC1REF has the same behavior as in PWM mode 2. OC1REFC outputs OC1REF when the counter is counting up, OC2REF when it is counting down.
              These bits can not be modified as long as LOCK level 3 has been programmed and CC1S=00 (the channel is configured in output).
              On channels having a complementary output, this bit field is preloaded. If the CCPC bit is set in the CR2 register then the OC1M active bits take the new value from the preloaded bits only when a COM event is generated.
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>OC1PE</name>
              <description>
              Output compare 1 preload enable
              0: Preload register on CCR1 disabled. CCR1 can be written at anytime, the new value is taken in account immediately.
              1: Preload register on CCR1 enabled. Read/Write operations access the preload register. CCR1 preload value is loaded in the active register at each update event.
              These bits can not be modified as long as LOCK level 3 has been programmed and CC1S='00' (the channel is configured in output).
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>OC1CE</name>
              <description>
              Output compare 1 clear enable
              0: OC1Ref is not affected by the ETRF input
              1: OC1Ref is cleared as soon as a High level is detected on ETRF input
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IC2F</name>
              <description>
              Input capture 2 filter
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>IC2PSC</name>
              <description>
              Input capture 2 prescaler
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>CC2S</name>
              <description>
              Capture/Compare 2 selection
              This bit-field defines the direction of the channel (input/output) as well as the used input. 
              00: CC2 channel is configured as output
              01: CC2 channel is configured as input, IC2 is mapped on TI2
              10: CC2 channel is configured as input, IC2 is mapped on TI1
              11: CC2 channel is configured as input, IC2 is mapped on TRC. This mode is working only if an internal trigger input is selected through the TS bit (SMCR register)
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>IC1F</name>
              <description>
              Input capture 1 filter
              This bit-field defines the frequency used to sample TI1 input and the length of the digital filter applied to TI1. The digital filter is made of an event counter in which N consecutive events are needed to validate a transition on the output:
              0000: No filter, sampling is done at fCLK
              0001: fSAMPLING=fCLK, N=2
              0010: fSAMPLING=fCLK, N=4
              0011: fSAMPLING=fCLK, N=8
              0100: fSAMPLING=fCLK/2, N=6
              0101: fSAMPLING=fCLK/2, N=8
              0110: fSAMPLING=fCLK/4, N=6
              0111: fSAMPLING=fCLK/4, N=8
              1000: fSAMPLING=fCLK/8, N=6
              1001: fSAMPLING=fCLK/8, N=8
              1010: fSAMPLING=fCLK/16, N=5
              1011: fSAMPLING=fCLK/16, N=6
              1100: fSAMPLING=fCLK/16, N=8
              1101: fSAMPLING=fCLK/32, N=5
              1110: fSAMPLING=fCLK/32, N=6
              1111: fSAMPLING=fCLK/32, N=8
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>IC1PSC</name>
              <description>
              Input capture 1 prescaler
              This bit-field defines the ratio of the prescaler acting on CC1 input (IC1). The prescaler is reset as soon as CC1E=0 (CCER register).
              00: no prescaler, capture is done each time an edge is detected on the capture input
              01: capture is done once every 2 events
              10: capture is done once every 4 events
              11: capture is done once every 8 events
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>CC1S</name>
              <description>
              Capture/Compare 1 selection
              This bit-field defines the direction of the channel (input/output) as well as the used input. 
              00: CC1 channel is configured as output
              01: CC1 channel is configured as input, IC1 is mapped on TI1
              10: CC1 channel is configured as input, IC1 is mapped on TI2
              11: CC1 channel is configured as input, IC1 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (SMCR register)
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCMR2</name>
          <displayName>CCMR2</displayName>
          <description>TIM capture/compare mode register 2</description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>OC4M</name>
              <description>
              Output compare 4 mode
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>OC4PE</name>
              <description>
              Output compare 4 preload enable
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>OC4CE</name>
              <description>
              Output compare 4 clear enable
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OC3M</name>
              <description>
              Output compare 3 mode
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>OC3PE</name>
              <description>
              Output compare 3 preload enable
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>OC3CE</name>
              <description>
              Output compare 3 clear enable
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IC4F</name>
              <description>
              Input capture 4 filter
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>IC4PSC</name>
              <description>
              Input capture 4 prescaler
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>CC4S</name>
              <description>
              Capture/Compare 4 selection
              This bit-field defines the direction of the channel (input/output) as well as the used input. 
              00: CC4 channel is configured as output
              01: CC4 channel is configured as input, IC4 is mapped on TI4
              10: CC4 channel is configured as input, IC4 is mapped on TI3
              11: CC4 channel is configured as input, IC4 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (SMCR register)
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>IC3F</name>
              <description>
              Input capture 3 filter
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>IC3PSC</name>
              <description>
              Input capture 3 prescaler
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>CC3S</name>
              <description>
              Capture/Compare 3 selection
              This bit-field defines the direction of the channel (input/output) as well as the used input. 
              00: CC3 channel is configured as output
              01: CC3 channel is configured as input, IC3 is mapped on TI3
              10: CC3 channel is configured as input, IC3 is mapped on TI4
              11: CC3 channel is configured as input, IC3 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (SMCR register)
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCER</name>
          <displayName>CCER</displayName>
          <description>Capture/Compare enable register</description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
            <field>
              <name>CC6P</name>
              <description>
              Capture/Compare 6 output Polarity.
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC6E</name>
              <description>
              Capture/Compare 6 output enable.
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC5P</name>
              <description>
              Capture/Compare 5 output Polarity.
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC5E</name>
              <description>
              Capture/Compare 5 output enable.
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC4NP</name>
              <description>
              Capture/Compare 4 complementary output polarity
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC4P</name>
              <description>
              Capture/Compare 4 output Polarity.
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC4E</name>
              <description>
              Capture/Compare 4 output enable.
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC3NP</name>
              <description>
              Capture/Compare 3 complementary output polarity
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC3NE</name>
              <description>
              Capture/Compare 3 complementary output enable
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC3P</name>
              <description>
              Capture/Compare 3 output Polarity.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC3E</name>
              <description>
              Capture/Compare 3 output enable.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC2NP</name>
              <description>
              Capture/Compare 2 complementary output polarity
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC2NE</name>
              <description>
              Capture/Compare 2 complementary output enable
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC2P</name>
              <description>
              Capture/Compare 2 output Polarity.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC2E</name>
              <description>
              Capture/Compare 2 output enable.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC1NP</name>
              <description>
              Capture/Compare 1 complementary output polarity
              CC1 channel configured as output:
              0: OC1N active high.
              1: OC1N active low.
              CC1 channel configured as input:
              This bit is used in conjunction with CC1P to define the polarity of TI1FP1 and TI2FP1. Refer to CC1P description.
              On channels having a complementary output, this bit is preloaded. If the CCPC bit is set in the CR2 register then the CC1NP active bit takes the new value from the preloaded bit only when a Commutation event is generated.
              This bit as well as other CCxNP is not writable as soon as LOCK level 2 or 3 has been programmed and CC1S=00 (channel configured as output).
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC1NE</name>
              <description>
              Capture/Compare 1 complementary output enable
              0: Off - OC1N is not active. OC1N level is then function of MOE, OSSI, OSSR, OIS1, OIS1N and CC1E bits.
              1: On - OC1N signal is output on the corresponding output pin depending on MOE, OSSI, OSSR, OIS1, OIS1N and CC1E bits.
              On channels having a complementary output, this bit is preloaded. If the CCPC bit is set in the CR2 register then the CC1NE active bit takes the new value from the preloaded bit only when a Commutation event is generated.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC1P</name>
              <description>
              Capture/Compare 1 output Polarity.
              CC1 channel configured as output:
              0: OC1 active high
              1: OC1 active low
              CC1 channel configured as input: CC1NP/CC1P bits select TI1FP1 and TI2FP1 polarity for trigger or capture operations.
              00: noninverted/rising edge. Circuit is sensitive to TIxFP1 rising edge (capture, trigger in reset, external clock or trigger mode), TIxFP1 is not inverted (trigger in gated mode, encoder mode).
              01: inverted/falling edge. Circuit is sensitive to TIxFP1 falling edge (capture, trigger in reset, external clock or trigger mode), TIxFP1 is inverted (trigger in gated mode, encoder mode).
              10: reserved, do not use this configuration.
              11: noninverted/both edges. Circuit is sensitive to both TIxFP1 rising and falling edges (capture, trigger in reset, external clock or trigger mode), TIxFP1 is not inverted (trigger in gated mode). This configuration must not be used for encoder mode.
              On channels having a complementary output, this bit is preloaded. If the CCPC bit is set in the CR2 register then the CC1P active bit takes the new value from the preloaded bit only when a Commutation event is generated.
              This bit as well as other CCxP is not writable as soon as LOCK level 2 or 3 has been programmed.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC1E</name>
              <description>
              Capture/Compare 1 output enable
              CC1 channel configured as output:
              0: Off - OC1 is not active. OC1 level is then function of MOE, OSSI, OSSR, OIS1, OIS1N and CC1NE bits.
              1: On - OC1 signal is output on the corresponding output pin depending on MOE, OSSI, OSSR, OIS1, OIS1N and CC1NE bits.
              CC1 channel configured as input: This bit determines if a capture of the counter value can actually be done into the input capture/compare register 1 (CCR1) or not.
              0: Capture disabled.
              1: Capture enabled.
              On channels having a complementary output, this bit is preloaded. If the CCPC bit is set in the CR2 register then the CC1E active bit takes the new value from the preloaded bit only when a Commutation event is generated.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CNT</name>
          <displayName>CNT</displayName>
          <description>Counter</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>CNT</name>
              <description>
              bit 30 to 0 is the lower bits of counter value
              bit 31 depends on IUFREMAP in CR1.
              If UIFREMAP = 1 this bit is a read-only copy of the UIF bit of the ISR register
              If UIFREMAP = 0 this bit is counter value bit 31
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PSC</name>
          <displayName>PSC</displayName>
          <description>Prescaler</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>PSC</name>
              <description>
              Prescaler value
              The counter clock frequency is fCLK/(PSC+1).
              PSC contains the value to be loaded in the active prescaler register at each update event (including when the counter is cleared through UG bit of EGR register or through trigger controller when configured in "reset mode").
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ARR</name>
          <displayName>ARR</displayName>
          <description>Auto-reload register</description>
          <addressOffset>0x2c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ARR</name>
              <description>
              Auto-reload value
              ARR is the value to be loaded in the actual auto-reload register.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RCR</name>
          <displayName>RCR</displayName>
          <description>Repetition counter register</description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>REP</name>
              <description>
              Repetition counter value
              These bits allow the user to set-up the update rate of the compare registers when preload registers are enable, as well as the update interrupt generation rate, if this interrupt is enable.
              Each time the REP_CNT related downcounter reaches zero, an update event is generated and it restarts counting from REP value. As REP_CNT is reloaded with REP value only at the repetition update event, any write to the RCR register is not taken in account until the next repetition update event.
              It means in PWM mode (REP+1) corresponds to the number of PWM periods in edge-aligned mode or the number of half PWM period in center-aligned mode..
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR1</name>
          <displayName>CCR1</displayName>
          <description>Capture/Compare register 1</description>
          <addressOffset>0x34</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>CCR1</name>
              <description>
              Capture/Compare 1 value
              If channel CC1 is configured as output:
              CCR1 is the value to be loaded in the actual capture/compare 1 register (preload value).It is loaded permanently if the preload feature is not selected in the CCMR1 register (bit OC1PE). Else the preload value is copied in the active capture/compare 1 register when an update event occurs.
              The active capture/compare register contains the value to be compared to the counter CNT and signaled on OC1 output.
              If channel CC1is configured as input:
              CCR1 is the counter value transferred by the last input capture 1 event (IC1).
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR2</name>
          <displayName>CCR2</displayName>
          <description>Capture/Compare register 2</description>
          <addressOffset>0x38</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>CCR2</name>
              <description>
              Capture/Compare 2 value
              If channel CC2 is configured as output:
              CCR2 is the value to be loaded in the actual capture/compare 2 register (preload value).It is loaded permanently if the preload feature is not selected in the CCMR1 register (bit OC2PE). Else the preload value is copied in the active capture/compare 2 register when an update event occurs.
              The active capture/compare register contains the value to be compared to the counter CNT and signalled on OC2 output.
              If channel CC2 is configured as input:
              CCR2 is the counter value transferred by the last input capture 2 event (IC2).
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR3</name>
          <displayName>CCR3</displayName>
          <description>Capture/Compare register 3</description>
          <addressOffset>0x3c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>CCR3</name>
              <description>
              Capture/Compare value
              If channel CC3 is configured as output:
              CCR3 is the value to be loaded in the actual capture/compare 3 register (preload value).It is loaded permanently if the preload feature is not selected in the CCMR2 register (bit OC3PE). Else the preload value is copied in the active capture/compare 3 register when an update event occurs.
              The active capture/compare register contains the value to be compared to the counter CNT and signalled on OC3 output.
              If channel CC3is configured as input:
              CCR3 is the counter value transferred by the last input capture 3 event (IC3).
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR4</name>
          <displayName>CCR4</displayName>
          <description>Capture/Compare register 4</description>
          <addressOffset>0x40</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>CCR4</name>
              <description>
              Capture/Compare value
              1. if CC4 channel is configured as output (CC4S bits):
              CCR4 is the value to be loaded in the actual capture/compare 4 register (preload value).It is loaded permanently if the preload feature is not selected in the CCMR2 register (bit OC4PE). Else the preload value is copied in the active capture/compare 4 register when an update event occurs.
              The active capture/compare register contains the value to be compared to the counter CNT and signalled on OC4 output.
              2.  if CC4 channel is configured as input (CC4S bits in CCMR4 register):
              CCR4 is the counter value transferred by the last input capture 4 event (IC4).
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BDTR</name>
          <displayName>BDTR</displayName>
          <description>TIM break and dead-time register</description>
          <addressOffset>0x44</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>OSSR</name>
              <description>
              Off-state selection for Run mode
              This bit is used when MOE=1 on channels having a complementary output which are configured as outputs. OSSR is not implemented if no complementary output is implemented in the timer.
              0: When inactive, OC/OCN outputs are disabled (the timer releases the output control, forces a Hi-Z state).
              1: When inactive, OC/OCN outputs are enabled with their inactive level as soon as CCxE=1 or CCxNE=1 (the output is still controlled by the timer).
              This bit can not be modified as soon as the LOCK level 2 has been programmed.
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OSSI</name>
              <description>
              Off-state selection for Idle mode
              This bit is used when MOE=0 due to a break event or by a software write, on channels configured as outputs.
              0: When inactive, OC/OCN outputs are disabled (the timer releases the output control, imposes a Hi-Z state). 
              1: When inactive, OC/OCN outputs are first forced with their inactive level then forced to their idle level after the deadtime. The timer maintains its control over the output.
              This bit can not be modified as soon as the LOCK level 2 has been programmed.
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BK2BID</name>
              <description>
              Break2 bidirectional
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BKBID</name>
              <description>
              Break Bidirectional
              0: Break input BRK in input mode
              1: Break input BRK in bidirectional mode
              In the bidirectional mode (BKBID bit set to 1), the break input is configured both in input mode and in open drain output mode. Any active break event asserts a low logic level on the Break input to indicate an internal break event to external devices.
              This bit cannot be modified as long as LOCK level 1 has been programmed (LOCK bits in BDTR register).
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BK2DSRM</name>
              <description>
              Break2 Disarm
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BKDSRM</name>
              <description>
              Break Disarm
              0: Break input BRK is armed
              1: Break input BRK is disarmed
              This bit is cleared by hardware when no break source is active.
              The BKDSRM bit must be set by software to release the bidirectional output control (open-drain output in Hi-Z state) and then be polled it until it is reset by hardware, indicating that the fault condition has disappeared.
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BK2P</name>
              <description>
              BK2P: Break 2 polarity
              0: Break input BRK2 is active low
              1: Break input BRK2 is active high
              This bit cannot be modified as long as LOCK level 1 has been programmed.
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BK2E</name>
              <description>
              Break 2 enable
              This bit enables the complete break 2 protection.
              0: Break2 function disabled
              1: Break2 function enabled
              This bit cannot be modified as long as LOCK level 1 has been programmed.
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BK2F</name>
              <description>
              Break 2 filter
              This bit-field defines the frequency used to sample BRK2 input and the length of the digital filter applied to BRK2. The digital filter is made of an event counter in which N consecutive events are needed to validate a transition on the output:
              0000: No filter, BRK2 acts asynchronously
              0001: fSAMPLING=fCLK, N=2
              0010: fSAMPLING=fCLK, N=4
              0011: fSAMPLING=fCLK, N=8
              0100: fSAMPLING=fCLK/2, N=6
              0101: fSAMPLING=fCLK/2, N=8
              0110: fSAMPLING=fCLK/4, N=6
              0111: fSAMPLING=fCLK/4, N=8
              1000: fSAMPLING=fCLK/8, N=6
              1001: fSAMPLING=fCLK/8, N=8
              1010: fSAMPLING=fCLK/16, N=5
              1011: fSAMPLING=fCLK/16, N=6
              1100: fSAMPLING=fCLK/16, N=8
              1101: fSAMPLING=fCLK/32, N=5
              1110: fSAMPLING=fCLK/32, N=6
              1111: fSAMPLING=fCLK/32, N=8
              This bit cannot be modified as long as LOCK level 1 has been programmed.
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>BKF</name>
              <description>
              Break filter
              This bit-field defines the frequency used to sample BRK input and the length of the digital filter applied to BRK. The digital filter is made of an event counter in which N consecutive events are needed to validate a transition on the output:
              0000: No filter, BRK acts asynchronously
              0001: fSAMPLING=fCLK, N=2
              0010: fSAMPLING=fCLK, N=4
              0011: fSAMPLING=fCLK, N=8
              0100: fSAMPLING=fCLK/2, N=6
              0101: fSAMPLING=fCLK/2, N=8
              0110: fSAMPLING=fCLK/4, N=6
              0111: fSAMPLING=fCLK/4, N=8
              1000: fSAMPLING=fCLK/8, N=6
              1001: fSAMPLING=fCLK/8, N=8
              1010: fSAMPLING=fCLK/16, N=5
              1011: fSAMPLING=fCLK/16, N=6
              1100: fSAMPLING=fCLK/16, N=8
              1101: fSAMPLING=fCLK/32, N=5
              1110: fSAMPLING=fCLK/32, N=6
              1111: fSAMPLING=fCLK/32, N=8
              This bit cannot be modified as long as LOCK level 1 has been programmed.
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>MOE</name>
              <description>
              Main output enable
              This bit is cleared asynchronously by hardware as soon as one of the break inputs is active (BRK or BRK2). It is set by software or automatically depending on the AOE bit. It is acting only on the channels which are configured in output. 
              0: In response to a break 2 event. OC and OCN outputs are disabled
              In response to a break event or if MOE is written to 0: OC and OCN outputs are disabled or forced to idle state depending on the OSSI bit.
              1: OC and OCN outputs are enabled if their respective enable bits are set (CCxE, CCxNE in CCER register).
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>AOE</name>
              <description>
              Automatic output enable
              0: MOE can be set only by software
              1: MOE can be set by software or automatically at the next update event (if none of the break inputs BRK and BRK2 is active)
              This bit cannot be modified as long as LOCK level 1 has been programmed.
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BKP</name>
              <description>
              Break polarity
              0: Break input BRK is active low
              1: Break input BRK is active high
              This bit cannot be modified as long as LOCK level 1 has been programmed.
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BKE</name>
              <description>
              Break enable
              This bit enables the complete break protection.
              0: Break function disabled
              1: Break function enabled
              This bit cannot be modified as long as LOCK level 1 has been programmed.
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DTPSC</name>
              <description>
              Dead-time prescaler
              This bit-field enables dead-time prescaler. 
              0: dead-time is tCLK*(DTG+1) if DTG is not zero
              1: dead-time is tCLK*(DTG+1)*16 if DTG is not zero
              This bit cannot be modified as long as LOCK level 1 has been programmed.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DTG</name>
              <description>
              Dead-time generator setup
              This bit-field, together with DTPSC, defines the duration of the dead-time inserted between the complementary outputs.
              If DTG=0, dead-time is disabled. 
              Example if tCLK=8.33ns (120MHz), dead-time possible values are:
              16.67ns to 8533.33 ns by 8.33 ns steps if DTPSC=0,
              266.67ns to 136.53 us by 133.33 ns steps if DTPSC=1
              This bit cannot be modified as long as LOCK level 1 has been programmed.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD1</name>
          <displayName>RSVD1</displayName>
          <description></description>
          <addressOffset>0x48</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>CCMR3</name>
          <displayName>CCMR3</displayName>
          <description>TIM capture/compare mode register 3</description>
          <addressOffset>0x54</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>OC6M</name>
              <description>
              Output compare 6 mode
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>OC6PE</name>
              <description>
              Output compare 6 preload enable
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>OC6CE</name>
              <description>
              Output compare 6 clear enable
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OC5M</name>
              <description>
              Output compare 5 mode
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>OC5PE</name>
              <description>
              Output compare 5 preload enable
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>OC5CE</name>
              <description>
              Output compare 5 clear enable
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GC5C3</name>
              <description>
              Group Channel 5 and Channel 3
              Distortion on Channel 3 output:
              0: No effect of OC5REF on OC3REFC
              1: OC3REFC is the logical AND of OC3REFC and OC5REF
              This bit can either have immediate effect or be preloaded and taken into account after an update event (if preload feature is selected in TIMxCCMR2).
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GC5C2</name>
              <description>
              Group Channel 5 and Channel 2
              Distortion on Channel 2 output:
              0: No effect of OC5REF on OC2REFC
              1: OC2REFC is the logical AND of OC2REFC and OC5REF
              This bit can either have immediate effect or be preloaded and taken into account after an update event (if preload feature is selected in TIMxCCMR1).
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GC5C1</name>
              <description>
              Group Channel 5 and Channel 1
              Distortion on Channel 1 output:
              0: No effect of OC5REF on OC1REFC5
              1: OC1REFC is the logical AND of OC1REFC and OC5REF
              This bit can either have immediate effect or be preloaded and taken into account after an update event (if preload feature is selected in TIMxCCMR1).
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>13</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR5</name>
          <displayName>CCR5</displayName>
          <description>Capture/Compare register 5</description>
          <addressOffset>0x58</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>CCR5</name>
              <description>
              Capture/Compare 5 value
              CCR5 is the value to be loaded in the actual capture/compare 5 register (preload value). It is loaded permanently if the preload feature is not selected in the CCMR3 register (bit OC5PE). Else the preload value is copied in the active capture/compare 5 register when an update event occurs.
              The active capture/compare register contains the value to be compared to the counter CNT and signaled on OC5 output.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR6</name>
          <displayName>CCR6</displayName>
          <description>Capture/Compare register 6</description>
          <addressOffset>0x5c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>CCR6</name>
              <description>
              Capture/Compare 6 value
              CCR6 is the value to be loaded in the actual capture/compare 6 register (preload value). It is loaded permanently if the preload feature is not selected in the CCMR3 register (bit OC6PE). Else the preload value is copied in the active capture/compare 6 register when an update event occurs.
              The active capture/compare register contains the value to be compared to the counter CNT and signaled on OC6 output.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>AF1</name>
          <displayName>AF1</displayName>
          <description>Alternate function option register</description>
          <addressOffset>0x60</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <fields>
            <field>
              <name>LOCK</name>
              <description>
              Lock configuration
              These bits offer a write protection against software errors.
              00: LOCK OFF - No bit is write protected.
              01: LOCK Level 1 = OISx and OISxN bits in CR2 register, BK2BID, BKBID, BK2DSRM, BKDSRM, BK2P, BK2E, BK2F[3:0], BKF[3:0], AOE, BKP, BKE, OSSI, OSSR, DTPSC and DTG bits in BDTR register, AF1 register and AF2 register can no longer be written.
              10: LOCK Level 2 = LOCK Level 1 + CC Polarity bits (CCxP/CCxNP bits in CCER register, as long as the related channel is configured in output through the CCxS bits) as well as OSSR and OSSI bits can no longer be written.
              11: LOCK Level 3 = LOCK Level 2 + CC Control bits (OCxM and OCxPE bits in CCMRx registers, as long as the related channel is configured in output through the CCxS bits) can no longer be written.
              The LOCK bits can be written to non-zero only once after reset. 
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>14</bitWidth>
            </field>
            <field>
              <name>ETRSEL</name>
              <description>
              ETR source selection
              00: ETR input is connected to I/O
              01: LPCOMP output1 (if LPCOMP integrated)
              10: LPCOMP output2 (if LPCOMP integrated)
              11: ETR input is connected to I/O
              This bit cannot be modified as long as LOCK level 1 has been programmed.
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>BKCMP2P</name>
              <description>
              BRK LPCOMP output2 polarity
              This bit selects the LPCOMP output2 sensitivity (if LPCOMP integrated). It must be programmed together with the BKP polarity bit.
              0: LPCOMP output2 is active high
              1: LPCOMP output2 is active low
              This bit cannot be modified as long as LOCK level 1 has been programmed.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BKCMP1P</name>
              <description>
              BRK LPCOMP output1 polarity
              This bit selects the LPCOMP output1 sensitivity (if LPCOMP integrated). It must be programmed together with the BKP polarity bit.
              0: LPCOMP output1 is active high
              1: LPCOMP output1 is active low
              This bit cannot be modified as long as LOCK level 1 has been programmed.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BKINP</name>
              <description>
              BRK BKIN input polarity
              This bit selects the BKIN input sensitivity. It must be programmed together with the BKP polarity bit.
              0: BKIN input is active high
              1: BKIN input is active low
              This bit cannot be modified as long as LOCK level 1 has been programmed.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>BKCMP2E</name>
              <description>
              BRK LPCOMP output2 enable
              This bit enables the LPCOMP output2 (if LPCOMP integrated) for the timer's BRK input. LPCOMP output2 is 'ORed' with the other BRK sources.
              0: LPCOMP output2 disabled
              1: LPCOMP output2 enabled
              This bit cannot be modified as long as LOCK level 1 has been programmed.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BKCMP1E</name>
              <description>
              BRK LPCOMP output1 enable
              This bit enables the LPCOMP output1 (if LPCOMP integrated) for the timer's BRK input. LPCOMP output1 is 'ORed' with the other BRK sources.
              0: LPCOMP output1 disabled
              1: LPCOMP output1 enabled
              This bit cannot be modified as long as LOCK level 1 has been programmed.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BKINE</name>
              <description>
              BRK BKIN input enable
              This bit enables the BKIN input. BKIN input is 'Ored' with the other BRK sources.
              0: BKIN input disabled
              1: BKIN input enabled
              This bit cannot be modified as long as LOCK level 1 has been programmed.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>AF2</name>
          <displayName>AF2</displayName>
          <description>Alternate function option register 2</description>
          <addressOffset>0x64</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>BK2CMP2P</name>
              <description>
              BRK2 LPCOMP output2 polarity
              This bit selects the LPCOMP output2 sensitivity (if LPCOMP integrated). It must be programmed together with the BK2P polarity bit.
              0: LPCOMP output2 is active high
              1: LPCOMP output2 is active low
              This bit cannot be modified as long as LOCK level 1 has been programmed.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BK2CMP1P</name>
              <description>
              BRK2 LPCOMP output1 polarity
              This bit selects the LPCOMP output1 sensitivity (if LPCOMP integrated). It must be programmed together with the BK2P polarity bit.
              0: LPCOMP output1 is active high
              1: LPCOMP output1 is active low
              This bit cannot be modified as long as LOCK level 1 has been programmed.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BK2INP</name>
              <description>
              BRK2 BKIN2 input polarity
              This bit selects the BKIN2 input sensitivity. It must be programmed together with the BK2P polarity bit.
              0: BKIN2 input is active low
              1: BKIN2 input is active high
              This bit cannot be modified as long as LOCK level 1 has been programmed.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>BK2CMP2E</name>
              <description>
              BRK2 LPCOMP output2 enable
              This bit enables the LPCOMP output2 (if LPCOMP integrated) for the timer's BRK2 input. LPCOMP output2 is 'ORed' with the other BRK2 sources.
              0: LPCOMP output2 disabled
              1: LPCOMP output2 enabled
              This bit cannot be modified as long as LOCK level 1 has been programmed.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BK2CMP1E</name>
              <description>
              BRK2 LPCOMP output1 enable
              This bit enables the LPCOMP output1 (if LPCOMP integrated) for the timer's BRK2 input. LPCOMP output1 is 'ORed' with the other BRK2 sources.
              0: LPCOMP output1 disabled
              1: LPCOMP output1 enabled
              This bit cannot be modified as long as LOCK level 1 has been programmed.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BK2INE</name>
              <description>
              BRK2 BKIN input enable
              This bit enables the BKIN2 input. BKIN2 input is 'Ored' with the other BRK2 sources.
              0: BKIN2 input disabled
              1: BKIN2 input enabled
              This bit cannot be modified as long as LOCK level 1 has been programmed.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>AUDPRC</name>
      <description></description>
      <groupName>AUDPRC</groupName>
      <baseAddress>0x40025000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>ID</name>
          <displayName>ID</displayName>
          <description></description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x000A0000</resetValue>
          <fields>
            <field>
              <name>REV</name>
              <description>
              revision id
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CFG</name>
          <displayName>CFG</displayName>
          <description></description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
            <field>
              <name>AUDCLK_DIV_UPDATE</name>
              <description>
              audprc clock divider update, write 1 to update
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>AUDCLK_DIV</name>
              <description>
              audprc clock divider, 0 and 1 means divide by 1
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>STB_CLK_SEL</name>
              <description>
              audio strobe clock select
              0: use xtal clock to generate strobe
              1: use pll clock to generate strobe
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>AUTO_GATE_EN</name>
              <description>
              auto clock gating enable, high active
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ADC_PATH_EN</name>
              <description>
              adc path enable
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DAC_PATH_EN</name>
              <description>
              dac path enable
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ADC_PATH_SRESET</name>
              <description>
              adc path software reset, high active
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DAC_PATH_SRESET</name>
              <description>
              dac path software reset, high active
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ADC_PATH_FLUSH</name>
              <description>
              adc path fifo flush, high active
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DAC_PATH_FLUSH</name>
              <description>
              dac path fifo flush, high active
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SRESET</name>
              <description>
              audprc software reset, high active
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ENABLE</name>
              <description>
              audprc enable
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>STB</name>
          <displayName>STB</displayName>
          <description></description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00010001</resetValue>
          <fields>
            <field>
              <name>ADC_DIV</name>
              <description>
              adc strobe divider
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>DAC_DIV</name>
              <description>
              dac strobe divider
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IRQ</name>
          <displayName>IRQ</displayName>
          <description></description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>TX_OUT1_FIFO_UF_MASK</name>
              <description>
              tx_out channel 1 fifo underflow mask, 0: mask the interrupt
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TX_OUT0_FIFO_UF_MASK</name>
              <description>
              tx_out channel 0 fifo underflow mask, 0: mask the interrupt
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RX_IN_FIFO_OF_MASK</name>
              <description>
              rx input fifo overflow mask, 0: mask the interrupt
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TX_OUT_FIFO_UF_MASK</name>
              <description>
              tx output fifo underflow mask, 0: mask the interrupt
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RX1_FIFO_UF_MASK</name>
              <description>
              rx channel 1 fifo underflow mask, 0: mask the interrupt
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RX0_FIFO_UF_MASK</name>
              <description>
              rx channel 0 fifo underflow mask, 0: mask the interrupt
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TX3_FIFO_OF_MASK</name>
              <description>
              tx channel 3 fifo overflow mask, 0: mask the interrupt
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TX2_FIFO_OF_MASK</name>
              <description>
              tx channel 2 fifo overflow mask, 0: mask the interrupt
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TX1_FIFO_OF_MASK</name>
              <description>
              tx channel 1 fifo overflow mask, 0: mask the interrupt
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TX0_FIFO_OF_MASK</name>
              <description>
              tx channel 0 fifo overflow mask, 0: mask the interrupt
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>TX_OUT1_FIFO_UF</name>
              <description>
              tx_out channel 1 fifo underflow, write 1 to clear
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TX_OUT0_FIFO_UF</name>
              <description>
              tx_out channel 0 fifo underflow, write 1 to clear
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RX_IN_FIFO_OF</name>
              <description>
              rx input fifo overflow, write 1 to clear
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TX_OUT_FIFO_UF</name>
              <description>
              tx output fifo underflow, write 1 to clear
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RX1_FIFO_UF</name>
              <description>
              rx channel 1 fifo underflow, write 1 to clear
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RX0_FIFO_UF</name>
              <description>
              rx channel 0 fifo underflow, write 1 to clear
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TX3_FIFO_OF</name>
              <description>
              tx channel 3 fifo overflow, write 1 to clear
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TX2_FIFO_OF</name>
              <description>
              tx channel 2 fifo overflow, write 1 to clear
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TX1_FIFO_OF</name>
              <description>
              tx channel 1 fifo overflow, write 1 to clear
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TX0_FIFO_OF</name>
              <description>
              tx channel 0 fifo overflow, write 1 to clear
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_CH0_CFG</name>
          <displayName>TX_CH0_CFG</displayName>
          <description></description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>FIFO_CNT</name>
              <description>
              tx fifo counter
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>DMA_MSK</name>
              <description>
              1: mask the dma request for tx ch0
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MODE</name>
              <description>
              tx mode
              1'h0: mono mode
              1'h1: stereo mode
              This bit is only used for 16-bit mode, in 24-bit mode, channel can only be set in mono mode.
              In 16-bit stereo mode, tx channel 1 is not working, both left and right audio data comes from channel 0.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FORMAT</name>
              <description>
              tx format
              0: 16-bit mode
              1: 24-bit mode
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ENABLE</name>
              <description>
              tx channel 0 enable
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_CH0_ENTRY</name>
          <displayName>TX_CH0_ENTRY</displayName>
          <description></description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              tx channel 0 data entry
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_CH1_CFG</name>
          <displayName>TX_CH1_CFG</displayName>
          <description></description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>FIFO_CNT</name>
              <description>
              tx fifo counter
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>DMA_MSK</name>
              <description>
              1: mask the dma request for tx ch1
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FORMAT</name>
              <description>
              tx format
              0: 16-bit mode
              1: 24-bit mode
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ENABLE</name>
              <description>
              tx channel 0 enable
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_CH1_ENTRY</name>
          <displayName>TX_CH1_ENTRY</displayName>
          <description></description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              tx channel 1 data entry
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_CH2_CFG</name>
          <displayName>TX_CH2_CFG</displayName>
          <description></description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>FIFO_CNT</name>
              <description>
              tx fifo counter
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>DMA_MSK</name>
              <description>
              1: mask the dma request for tx ch2
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MODE</name>
              <description>
              tx mode
              1'h0: mono mode
              1'h1: stereo mode
              This bit is only used for 16-bit mode, in 24-bit mode, channel can only be set in mono mode.
              In 16-bit stereo mode, tx channel 3 is not working, both left and right audio data comes from channel 2.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FORMAT</name>
              <description>
              tx format
              0: 16-bit mode
              1: 24-bit mode
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ENABLE</name>
              <description>
              tx channel 0 enable
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_CH2_ENTRY</name>
          <displayName>TX_CH2_ENTRY</displayName>
          <description></description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              tx channel 2 data entry
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_CH3_CFG</name>
          <displayName>TX_CH3_CFG</displayName>
          <description></description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>FIFO_CNT</name>
              <description>
              tx fifo counter
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>DMA_MSK</name>
              <description>
              1: mask the dma request for tx ch3
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FORMAT</name>
              <description>
              tx format
              0: 16-bit mode
              1: 24-bit mode
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ENABLE</name>
              <description>
              tx channel 0 enable
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_CH3_ENTRY</name>
          <displayName>TX_CH3_ENTRY</displayName>
          <description></description>
          <addressOffset>0x2c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              tx channel 3 data entry
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_CH0_CFG</name>
          <displayName>RX_CH0_CFG</displayName>
          <description></description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>FIFO_CNT</name>
              <description>
              rx fifo counter
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>DMA_MSK</name>
              <description>
              1: mask the dma request for rx ch0
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MODE</name>
              <description>
              rx mode
              1'h0: mono mode
              1'h1: stereo mode
              This bit is only used for 16-bit mode, in 24-bit mode, channel can only be set in mono mode.
              In 16-bit stereo mode, rx channel 1 is not working, both left and right audio data comes from channel 0.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FORMAT</name>
              <description>
              rx format
              0: 16-bit mode
              1: 24-bit mode
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ENABLE</name>
              <description>
              rx channel 0 enable
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_CH0_ENTRY</name>
          <displayName>RX_CH0_ENTRY</displayName>
          <description></description>
          <addressOffset>0x34</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              rx channel 0 data entry
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_CH1_CFG</name>
          <displayName>RX_CH1_CFG</displayName>
          <description></description>
          <addressOffset>0x38</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>FIFO_CNT</name>
              <description>
              rx fifo counter
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>DMA_MSK</name>
              <description>
              1: mask the dma request for rx ch1
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FORMAT</name>
              <description>
              rx format
              0: 16-bit mode
              1: 24-bit mode
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ENABLE</name>
              <description>
              rx channel 1 enable
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_CH1_ENTRY</name>
          <displayName>RX_CH1_ENTRY</displayName>
          <description></description>
          <addressOffset>0x3c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              rx channel 1 data entry
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_OUT_CH0_CFG</name>
          <displayName>TX_OUT_CH0_CFG</displayName>
          <description></description>
          <addressOffset>0x40</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>FIFO_CNT</name>
              <description>
              tx out fifo counter
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>DMA_MSK</name>
              <description>
              1: mask the dma request for tx out ch0
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MODE</name>
              <description>
              tx out mode
              1'h0: mono mode
              1'h1: stereo mode
              This bit is only used for 16-bit mode, in 24-bit mode, channel can only be set in mono mode.
              In 16-bit stereo mode, rx channel 1 is not working, both left and right audio data comes from channel 0.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FORMAT</name>
              <description>
              tx out format
              0: 16-bit mode
              1: 24-bit mode
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ENABLE</name>
              <description>
              tx out channel 0 enable
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_OUT_CH0_ENTRY</name>
          <displayName>TX_OUT_CH0_ENTRY</displayName>
          <description></description>
          <addressOffset>0x44</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              tx out channel 0 data entry
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_OUT_CH1_CFG</name>
          <displayName>TX_OUT_CH1_CFG</displayName>
          <description></description>
          <addressOffset>0x48</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>FIFO_CNT</name>
              <description>
              tx out fifo counter
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>DMA_MSK</name>
              <description>
              1: mask the dma request for tx out ch1
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FORMAT</name>
              <description>
              tx out format
              0: 16-bit mode
              1: 24-bit mode
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ENABLE</name>
              <description>
              tx out channel 1 enable
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_OUT_CH1_ENTRY</name>
          <displayName>TX_OUT_CH1_ENTRY</displayName>
          <description></description>
          <addressOffset>0x4c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              tx out channel 1 data entry
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DAC_PATH_CFG0</name>
          <displayName>DAC_PATH_CFG0</displayName>
          <description></description>
          <addressOffset>0x50</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>DST_SEL</name>
              <description>
              dac path destination select
              2'h0: select audio codec
              2'h1: select external interface
              2'h2: select apb interface
              2'h3: reserved
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>MIXRSRC1</name>
              <description>
              dac mixer right channel input source0 select
              3'h0:tx ch0
              3'h1:tx ch1
              3'h2:tx ch2
              3'h3:tx ch3
              3'h4:mute
              other: mute
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>MIXRSRC0</name>
              <description>
              dac mixer right channel input source0 select
              3'h0:tx ch0
              3'h1:tx ch1
              3'h2:tx ch2
              3'h3:tx ch3
              3'h4:mute
              other: mute
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>MIXLSRC1</name>
              <description>
              dac mixer left channel input source1 select
              3'h0:tx ch0
              3'h1:tx ch1
              3'h2:tx ch2
              3'h3:tx ch3
              3'h4:mute
              other: mute
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>MIXLSRC0</name>
              <description>
              dac mixer left channel input source0 select
              3'h0:tx ch0
              3'h1:tx ch1
              3'h2:tx ch2
              3'h3:tx ch3
              3'h4:mute
              other: mute
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>VOL_R</name>
              <description>
              volume control from -18~13dB, step is 0.5dB
              6'h0: -18dB
              6'h1: -17.5dB
              ......
              6'h3e: 13dB
              6'h3f: mute
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>VOL_L</name>
              <description>
              volume control from -18~13dB, step is 0.5dB
              6'h0: -18dB
              6'h1: -17.5dB
              ......
              6'h3e: 13dB
              6'h3f: mute
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DAC_PATH_CFG1</name>
          <displayName>DAC_PATH_CFG1</displayName>
          <description></description>
          <addressOffset>0x54</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>SRC_CH_CLR</name>
              <description>
              clear src channal internal data
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>SRC_CH_CLR_DONE</name>
              <description>
              src channel internal data clear done
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>SRC_HBF3_MODE</name>
              <description>
              3rd stage hbf mode:
              0: upsampling
              1: downsampling
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SRC_HBF3_EN</name>
              <description>
              3rd stage hbf enable
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SRC_HBF2_MODE</name>
              <description>
              2nd stage hbf mode:
              0: upsampling
              1: downsampling
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SRC_HBF2_EN</name>
              <description>
              2nd stage hbf enable
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SRC_HBF1_MODE</name>
              <description>
              1st stage hbf mode:
              0: upsampling
              1: downsampling
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SRC_HBF1_EN</name>
              <description>
              1st stage hbf enable
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SRC_CH_EN</name>
              <description>
              source rate converter channel enable
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>EQ_CLR</name>
              <description>
              equalizer clear request
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EQ_CLR_DONE</name>
              <description>
              equalizer clear done flag
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EQ_STAGE</name>
              <description>
              set equalizer stage, max is 10.
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>EQ_CH_EN</name>
              <description>
              equalizer channel enable
              2'b11: enable both channel
              2'b10: enable right chanel only
              2'b01: enable left channel only
              2'b00: bypass equalizer
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>MUXRSRC1</name>
              <description>
              dac mux right channel input source0 select
              3'h0:tx ch0
              3'h1:tx ch1
              3'h2:rx ch0
              3'h3:rx ch1
              3'h4:mute
              other: mute
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>MUXRSRC0</name>
              <description>
              dac mux right channel input source0 select
              3'h0:tx ch0
              3'h1:tx ch1
              3'h2:rx ch0
              3'h3:rx ch1
              3'h4:mute
              other: mute
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>MUXLSRC1</name>
              <description>
              dac mux left channel input source1 select
              3'h0:tx ch0
              3'h1:tx ch1
              3'h2:rx ch0
              3'h3:rx ch1
              3'h4:mute
              other: mute
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>MUXLSRC0</name>
              <description>
              dac mux left channel input source0 select
              3'h0:tx ch0
              3'h1:tx ch1
              3'h2:rx ch0
              3'h3:rx ch1
              3'h4:mute
              other: mute
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DAC_PATH_CFG2</name>
          <displayName>DAC_PATH_CFG2</displayName>
          <description></description>
          <addressOffset>0x58</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>SRC_SINC_EN</name>
              <description>
              sinc filter enable
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SINC_RATIO</name>
              <description>
              sinc filter ratio, s31.30 format. Range from 0~2
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>31</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ADC_PATH_CFG0</name>
          <displayName>ADC_PATH_CFG0</displayName>
          <description></description>
          <addressOffset>0x5c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
            <field>
              <name>RX2TX_LOOPBACK</name>
              <description>
              rx to tx loopback enable
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DATA_SWAP</name>
              <description>
              swap adc path left and right channel data
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SRC_SEL</name>
              <description>
              adc path source select
              1'h0: select audio codec
              1'h1: select external interface
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>VOL_R</name>
              <description>
              volume control from -18~13dB, step is 0.5dB
              6'h0: -18dB
              6'h1: -17.5dB
              ......
              6'h3e: 13dB
              6'h3f: mute
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>VOL_L</name>
              <description>
              volume control from -18~13dB, step is 0.5dB
              6'h0: -18dB
              6'h1: -17.5dB
              ......
              6'h3e: 13dB
              6'h3f: mute
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD1</name>
          <displayName>RSVD1</displayName>
          <description></description>
          <addressOffset>0x60</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>DAC_EQ_CFG0</name>
          <displayName>DAC_EQ_CFG0</displayName>
          <description></description>
          <addressOffset>0x70</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>COEF</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DAC_EQ_CFG1</name>
          <displayName>DAC_EQ_CFG1</displayName>
          <description></description>
          <addressOffset>0x74</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>COEF</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DAC_EQ_CFG2</name>
          <displayName>DAC_EQ_CFG2</displayName>
          <description></description>
          <addressOffset>0x78</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>COEF</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DAC_EQ_CFG3</name>
          <displayName>DAC_EQ_CFG3</displayName>
          <description></description>
          <addressOffset>0x7c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>COEF</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DAC_EQ_CFG4</name>
          <displayName>DAC_EQ_CFG4</displayName>
          <description></description>
          <addressOffset>0x80</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>COEF</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DAC_EQ_CFG5</name>
          <displayName>DAC_EQ_CFG5</displayName>
          <description></description>
          <addressOffset>0x84</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>COEF</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DAC_EQ_CFG6</name>
          <displayName>DAC_EQ_CFG6</displayName>
          <description></description>
          <addressOffset>0x88</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>COEF</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DAC_EQ_CFG7</name>
          <displayName>DAC_EQ_CFG7</displayName>
          <description></description>
          <addressOffset>0x8c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>COEF</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DAC_EQ_CFG8</name>
          <displayName>DAC_EQ_CFG8</displayName>
          <description></description>
          <addressOffset>0x90</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>COEF</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DAC_EQ_CFG9</name>
          <displayName>DAC_EQ_CFG9</displayName>
          <description></description>
          <addressOffset>0x94</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>COEF</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DAC_EQ_CFG10</name>
          <displayName>DAC_EQ_CFG10</displayName>
          <description></description>
          <addressOffset>0x98</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>COEF</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DAC_EQ_CFG11</name>
          <displayName>DAC_EQ_CFG11</displayName>
          <description></description>
          <addressOffset>0x9c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>COEF</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DAC_EQ_CFG12</name>
          <displayName>DAC_EQ_CFG12</displayName>
          <description></description>
          <addressOffset>0xa0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>COEF</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DAC_EQ_CFG13</name>
          <displayName>DAC_EQ_CFG13</displayName>
          <description></description>
          <addressOffset>0xa4</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>COEF</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DAC_EQ_CFG14</name>
          <displayName>DAC_EQ_CFG14</displayName>
          <description></description>
          <addressOffset>0xa8</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>COEF</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DAC_EQ_CFG15</name>
          <displayName>DAC_EQ_CFG15</displayName>
          <description></description>
          <addressOffset>0xac</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>COEF</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DAC_EQ_CFG16</name>
          <displayName>DAC_EQ_CFG16</displayName>
          <description></description>
          <addressOffset>0xb0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>COEF</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DAC_EQ_CFG17</name>
          <displayName>DAC_EQ_CFG17</displayName>
          <description></description>
          <addressOffset>0xb4</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>COEF</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DAC_EQ_CFG18</name>
          <displayName>DAC_EQ_CFG18</displayName>
          <description></description>
          <addressOffset>0xb8</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>COEF</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DAC_EQ_CFG19</name>
          <displayName>DAC_EQ_CFG19</displayName>
          <description></description>
          <addressOffset>0xbc</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>COEF</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DAC_EQ_CFG20</name>
          <displayName>DAC_EQ_CFG20</displayName>
          <description></description>
          <addressOffset>0xc0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>COEF</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DAC_EQ_CFG21</name>
          <displayName>DAC_EQ_CFG21</displayName>
          <description></description>
          <addressOffset>0xc4</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>COEF</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DAC_EQ_CFG22</name>
          <displayName>DAC_EQ_CFG22</displayName>
          <description></description>
          <addressOffset>0xc8</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>COEF</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DAC_EQ_CFG23</name>
          <displayName>DAC_EQ_CFG23</displayName>
          <description></description>
          <addressOffset>0xcc</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>COEF</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DAC_EQ_CFG24</name>
          <displayName>DAC_EQ_CFG24</displayName>
          <description></description>
          <addressOffset>0xd0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>COEF</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DAC_EQ_CFG25</name>
          <displayName>DAC_EQ_CFG25</displayName>
          <description></description>
          <addressOffset>0xd4</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>COEF</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DAC_EQ_CFG26</name>
          <displayName>DAC_EQ_CFG26</displayName>
          <description></description>
          <addressOffset>0xd8</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>COEF</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DAC_EQ_CFG27</name>
          <displayName>DAC_EQ_CFG27</displayName>
          <description></description>
          <addressOffset>0xdc</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>COEF</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DAC_EQ_CFG28</name>
          <displayName>DAC_EQ_CFG28</displayName>
          <description></description>
          <addressOffset>0xe0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>COEF</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DAC_EQ_CFG29</name>
          <displayName>DAC_EQ_CFG29</displayName>
          <description></description>
          <addressOffset>0xe4</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>COEF</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DAC_EQ_CFG30</name>
          <displayName>DAC_EQ_CFG30</displayName>
          <description></description>
          <addressOffset>0xe8</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>COEF</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DAC_EQ_CFG31</name>
          <displayName>DAC_EQ_CFG31</displayName>
          <description></description>
          <addressOffset>0xec</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>COEF</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DAC_EQ_CFG32</name>
          <displayName>DAC_EQ_CFG32</displayName>
          <description></description>
          <addressOffset>0xf0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>COEF</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DAC_EQ_CFG33</name>
          <displayName>DAC_EQ_CFG33</displayName>
          <description></description>
          <addressOffset>0xf4</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>COEF</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DAC_EQ_CFG34</name>
          <displayName>DAC_EQ_CFG34</displayName>
          <description></description>
          <addressOffset>0xf8</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>COEF</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DAC_EQ_CFG35</name>
          <displayName>DAC_EQ_CFG35</displayName>
          <description></description>
          <addressOffset>0xfc</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>COEF</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DAC_EQ_CFG36</name>
          <displayName>DAC_EQ_CFG36</displayName>
          <description></description>
          <addressOffset>0x100</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>COEF</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DAC_EQ_CFG37</name>
          <displayName>DAC_EQ_CFG37</displayName>
          <description></description>
          <addressOffset>0x104</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>COEF</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DAC_EQ_CFG38</name>
          <displayName>DAC_EQ_CFG38</displayName>
          <description></description>
          <addressOffset>0x108</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>COEF</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DAC_EQ_CFG39</name>
          <displayName>DAC_EQ_CFG39</displayName>
          <description></description>
          <addressOffset>0x10c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>COEF</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DAC_EQ_CFG40</name>
          <displayName>DAC_EQ_CFG40</displayName>
          <description></description>
          <addressOffset>0x110</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>COEF</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DAC_EQ_CFG41</name>
          <displayName>DAC_EQ_CFG41</displayName>
          <description></description>
          <addressOffset>0x114</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>COEF</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DAC_EQ_CFG42</name>
          <displayName>DAC_EQ_CFG42</displayName>
          <description></description>
          <addressOffset>0x118</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>COEF</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DAC_EQ_CFG43</name>
          <displayName>DAC_EQ_CFG43</displayName>
          <description></description>
          <addressOffset>0x11c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>COEF</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DAC_EQ_CFG44</name>
          <displayName>DAC_EQ_CFG44</displayName>
          <description></description>
          <addressOffset>0x120</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>COEF</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DAC_EQ_CFG45</name>
          <displayName>DAC_EQ_CFG45</displayName>
          <description></description>
          <addressOffset>0x124</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>COEF</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DAC_EQ_CFG46</name>
          <displayName>DAC_EQ_CFG46</displayName>
          <description></description>
          <addressOffset>0x128</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>COEF</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DAC_EQ_CFG47</name>
          <displayName>DAC_EQ_CFG47</displayName>
          <description></description>
          <addressOffset>0x12c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>COEF</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DAC_EQ_CFG48</name>
          <displayName>DAC_EQ_CFG48</displayName>
          <description></description>
          <addressOffset>0x130</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>COEF</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DAC_EQ_CFG49</name>
          <displayName>DAC_EQ_CFG49</displayName>
          <description></description>
          <addressOffset>0x134</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>COEF</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RESERVED_IN</name>
          <displayName>RESERVED_IN</displayName>
          <description></description>
          <addressOffset>0x138</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>CTRL_2</name>
              <description>
              reserved control 2
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>CTRL_1</name>
              <description>
              reserved control 1
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>CTRL_0</name>
              <description>
              reserved control 0
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RESERVED_OUT</name>
          <displayName>RESERVED_OUT</displayName>
          <description></description>
          <addressOffset>0x13c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>STAT</name>
              <description>
              reserved status
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>AUDCODEC_HP</name>
      <description></description>
      <groupName>AUDCODEC_HP</groupName>
      <baseAddress>0x40026000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>ID</name>
          <displayName>ID</displayName>
          <description></description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0xC0DEC000</resetValue>
          <fields>
            <field>
              <name>FUNC</name>
              <description>
              function id
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CFG</name>
          <displayName>CFG</displayName>
          <description></description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>28</bitWidth>
            </field>
            <field>
              <name>EN_DLY_SEL</name>
              <description>
              codec enable delay count
              0: no delay
              1: 32 pclk
              2: 64 pclk
              3: 128 pclk
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>DAC_1K_MODE</name>
              <description>
              codec dac sine 1k mode
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ENABLE</name>
              <description>
              codec enable
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IRQ</name>
          <displayName>IRQ</displayName>
          <description></description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>DAC_CH1_STB_UF_MSK</name>
              <description>
              interrupt mask. 0: mask the interrupt.
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DAC_CH1_STB_OF_MSK</name>
              <description>
              interrupt mask. 0: mask the interrupt.
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DAC_CH1_OUT_UF_MSK</name>
              <description>
              interrupt mask. 0: mask the interrupt.
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DAC_CH1_OUT_OF_MSK</name>
              <description>
              interrupt mask. 0: mask the interrupt.
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DAC_CH1_APB_UF_MSK</name>
              <description>
              interrupt mask. 0: mask the interrupt.
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DAC_CH1_APB_OF_MSK</name>
              <description>
              interrupt mask. 0: mask the interrupt.
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DAC_CH0_STB_UF_MSK</name>
              <description>
              interrupt mask. 0: mask the interrupt.
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DAC_CH0_STB_OF_MSK</name>
              <description>
              interrupt mask. 0: mask the interrupt.
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DAC_CH0_OUT_UF_MSK</name>
              <description>
              interrupt mask. 0: mask the interrupt.
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DAC_CH0_OUT_OF_MSK</name>
              <description>
              interrupt mask. 0: mask the interrupt.
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DAC_CH0_APB_UF_MSK</name>
              <description>
              interrupt mask. 0: mask the interrupt.
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DAC_CH0_APB_OF_MSK</name>
              <description>
              interrupt mask. 0: mask the interrupt.
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>DAC_CH1_STB_UF</name>
              <description>
              dac ch1 input stb fifo overflow interrupt status. Write 1 to clear.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DAC_CH1_STB_OF</name>
              <description>
              dac ch1 input stb fifo overflow interrupt status. Write 1 to clear.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DAC_CH1_OUT_UF</name>
              <description>
              dac ch1 output fifo underflow interrupt status. Write 1 to clear.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DAC_CH1_OUT_OF</name>
              <description>
              dac ch1 output fifo overflow interrupt status. Write 1 to clear.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DAC_CH1_APB_UF</name>
              <description>
              dac ch1 apb fifo underflow interrupt status. Write 1 to clear.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DAC_CH1_APB_OF</name>
              <description>
              dac ch1 apb fifo overflow interrupt status. Write 1 to clear.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DAC_CH0_STB_UF</name>
              <description>
              dac ch0 input stb fifo overflow interrupt status. Write 1 to clear.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DAC_CH0_STB_OF</name>
              <description>
              dac ch0 input stb fifo overflow interrupt status. Write 1 to clear.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DAC_CH0_OUT_UF</name>
              <description>
              dac ch0 output fifo underflow interrupt status. Write 1 to clear.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DAC_CH0_OUT_OF</name>
              <description>
              dac ch0 output fifo overflow interrupt status. Write 1 to clear.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DAC_CH0_APB_UF</name>
              <description>
              dac ch0 apb fifo underflow interrupt status. Write 1 to clear.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DAC_CH0_APB_OF</name>
              <description>
              dac ch0 apb fifo overflow interrupt status. Write 1 to clear.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD3</name>
          <displayName>RSVD3</displayName>
          <description></description>
          <addressOffset>0xC</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>DAC_CFG</name>
          <displayName>DAC_CFG</displayName>
          <description></description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>CLK_DIV</name>
              <description>
              dac clock divider
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CLK_SRC_SEL</name>
              <description>
              dac clock source select
              1: pll
              0: xtal
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PATH_RESET</name>
              <description>
              dac path reset, set 1 to reset dac path
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OP_MODE</name>
              <description>
              dac operation mode
              2'h0: normal mode: send dac data through tx interface
              2'h1: apb mode: send dac data out through apb interface
              2'h2, 2'h3: reserved
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>OSR_SEL</name>
              <description>
              DAC oversample rate
              3'b000: 100
              3'b001: 150
              3'b010: 300
              3'b100: 64
              3'b101: 128
              3'b110: 256
              other: reserved
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>APB_STAT</name>
          <displayName>APB_STAT</displayName>
          <description></description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>DAC_CH1_FIFO_CNT</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>DAC_CH0_FIFO_CNT</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD2</name>
          <displayName>RSVD2</displayName>
          <description></description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>DAC_CH0_CFG</name>
          <displayName>DAC_CH0_CFG</displayName>
          <description></description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CLK_ANA_POL</name>
              <description>
              analog dac clock polarity
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DITHER_EN</name>
              <description>
              sdm dither enable
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DITHER_GAIN</name>
              <description>
              sdm dither gain
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>SINC_GAIN</name>
              <description>
              dac sinc filter gain
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
            <field>
              <name>DATA_FORMAT</name>
              <description>
              dac data format
              1: 16-bit
              0: 24-bit
              this bit only affect the data format accessed by apb interface. For 24-bit, every 24-bit data occupied 32-bit word. Bit[31:24] are zeros. For 16-bit mode, every 32-bit word contains two 16-bit audio data{D1, D0}
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FINE_VOL</name>
              <description>
              dac fine volume control
              range from 0dB to 6dB
              step is 0.5dB
              4'h0: 0dB
              4'h1: 0.5dB
              ......
              4'hb: 5.5dB
              4'hc, 4'hd, 4'he, 4'hf: mute
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>ROUGH_VOL</name>
              <description>
              dac rough volume control
              range from -36dB to 54dB
              step is 6dB
              4'h0: -36dB
              4'h1: -30dB
              ......
              4'h6: 0dB
              ......
              4'he: 48dB
              4'hf: 54dB
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>DMA_EN</name>
              <description>
              dma interface enable in apb mode
              1: enable dac ch0 dma request interface
              0: disable dac ch0 dma request interface
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>STB_FIFO_CNT</name>
              <description>
              dac input stb fifo cnt
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>DEM_MODE</name>
              <description>
              dem output mode
              2'h0: no shift for dem output
              2'h1: shift dem output incrementally
              2'h2: shift dem output according to input
              2'h3: reserved
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>DOUT_MUTE</name>
              <description>
              dac output mute, set 1 to mute the output
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ENABLE</name>
              <description>
              dac channel enable
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DAC_CH0_CFG_EXT</name>
          <displayName>DAC_CH0_CFG_EXT</displayName>
          <description></description>
          <addressOffset>0x34</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>RAMP_STAT</name>
              <description>
              ramp module status
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RAMP_INTERVAL</name>
              <description>
              volume ramp interval.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>ZERO_ADJUST_EN</name>
              <description>
              enable volume adjustment during 0 volume cross.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RAMP_MODE</name>
              <description>
              volume ramp mode:
              1: slowly ramp to target volume. Step is 0.5db
              0: directly ramp to target volume. 
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RAMP_EN</name>
              <description>
              volume ramp enable
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DAC_CH1_CFG</name>
          <displayName>DAC_CH1_CFG</displayName>
          <description></description>
          <addressOffset>0x38</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CLK_ANA_POL</name>
              <description>
              analog dac clock polarity
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DITHER_EN</name>
              <description>
              sdm dither enable
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DITHER_GAIN</name>
              <description>
              sdm dither gain
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>SINC_GAIN</name>
              <description>
              dac sinc filter gain
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
            <field>
              <name>DATA_FORMAT</name>
              <description>
              dac data format
              1: 16-bit
              0: 24-bit
              this bit only affect the data format accessed by apb interface. For 24-bit, every 24-bit data occupied 32-bit word. Bit[31:24] are zeros. For 16-bit mode, every 32-bit word contains two 16-bit audio data{D1, D0}
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FINE_VOL</name>
              <description>
              dac fine volume control
              range from 0dB to 6dB
              step is 0.5dB
              4'h0: 0dB
              4'h1: 0.5dB
              ......
              4'hb: 5.5dB
              4'hc, 4'hd, 4'he, 4'hf: mute
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>ROUGH_VOL</name>
              <description>
              dac rough volume control
              range from -36dB to 54dB
              step is 6dB
              4'h0: -36dB
              4'h1: -30dB
              ......
              4'h6: 0dB
              ......
              4'he: 48dB
              4'hf: 54dB
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>DMA_EN</name>
              <description>
              dma interface enable in apb mode
              1: enable dac ch0 dma request interface
              0: disable dac ch0 dma request interface
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>STB_FIFO_CNT</name>
              <description>
              dac input stb fifo cnt
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>DEM_MODE</name>
              <description>
              dem output mode
              2'h0: no shift for dem output
              2'h1: shift dem output incrementally
              2'h2: shift dem output according to input
              2'h3: reserved
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>DOUT_MUTE</name>
              <description>
              dac output mute, set 1 to mute the output
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ENABLE</name>
              <description>
              dac channel enable
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DAC_CH1_CFG_EXT</name>
          <displayName>DAC_CH1_CFG_EXT</displayName>
          <description></description>
          <addressOffset>0x3c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>RAMP_STAT</name>
              <description>
              ramp module status
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RAMP_INTERVAL</name>
              <description>
              volume ramp interval.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>ZERO_ADJUST_EN</name>
              <description>
              enable volume adjustment during 0 volume cross.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RAMP_MODE</name>
              <description>
              volume ramp mode:
              1: slowly ramp to target volume. Step is 0.5db
              0: directly ramp to target volume. 
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RAMP_EN</name>
              <description>
              volume ramp enable
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD1</name>
          <displayName>RSVD1</displayName>
          <description></description>
          <addressOffset>0x40</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>DAC_CH0_ENTRY</name>
          <displayName>DAC_CH0_ENTRY</displayName>
          <description></description>
          <addressOffset>0x50</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              dac channel0 data input
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DAC_CH1_ENTRY</name>
          <displayName>DAC_CH1_ENTRY</displayName>
          <description></description>
          <addressOffset>0x54</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              dac channel0 data input
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DAC_CH0_DEBUG</name>
          <displayName>DAC_CH0_DEBUG</displayName>
          <description></description>
          <addressOffset>0x58</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>15</bitWidth>
            </field>
            <field>
              <name>BYPASS</name>
              <description>
              debug bypass mode
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DATA_OUT</name>
              <description>
              debug dac output
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DAC_CH1_DEBUG</name>
          <displayName>DAC_CH1_DEBUG</displayName>
          <description></description>
          <addressOffset>0x5c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>15</bitWidth>
            </field>
            <field>
              <name>BYPASS</name>
              <description>
              debug bypass mode
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DATA_OUT</name>
              <description>
              debug dac output
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DAC_CH0_DC</name>
          <displayName>DAC_CH0_DC</displayName>
          <description></description>
          <addressOffset>0x60</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>OFFSET</name>
              <description>
              dac ch0 dc offset
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DAC_CH1_DC</name>
          <displayName>DAC_CH1_DC</displayName>
          <description></description>
          <addressOffset>0x64</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>OFFSET</name>
              <description>
              dac ch1 dc offset
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RESERVED_IN</name>
          <displayName>RESERVED_IN</displayName>
          <description></description>
          <addressOffset>0x68</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>CTRL_2</name>
              <description>
              reserved control 2
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>CTRL_1</name>
              <description>
              reserved control 1
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>CTRL_0</name>
              <description>
              reserved control 0
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RESERVED_OUT</name>
          <displayName>RESERVED_OUT</displayName>
          <description></description>
          <addressOffset>0x6c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>STAT</name>
              <description>
              reserved status
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>FACC1</name>
      <description></description>
      <groupName>FACC</groupName>
      <baseAddress>0x40028000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>FACC_EN</name>
          <displayName>FACC_EN</displayName>
          <description>facc enable ctrl</description>
          <addressOffset>0x000</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>31</bitWidth>
            </field>
            <field>
              <name>FACC_EN</name>
              <description>
              1:enable
              0:stop
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>FACC_PARA</name>
          <displayName>FACC_PARA</displayName>
          <description>FACC parameter</description>
          <addressOffset>0x004</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>BUF_SEL</name>
              <description>
              0:only support one group  data
              1:store intermediate data to external buffer,support cross processing  of multiple groups  data 
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EVEN_SEL</name>
              <description>
              when sym_sel=1, this bit is effective
              0: odd
              1: even
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CONV_SEL</name>
              <description>
              0: filter
              1: convolution(only support fir mod)
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FP_SEL</name>
              <description>
              0: 16bit
              1: 8bit
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SYM_SEL</name>
              <description>
              0:normal
              1:symmetric(only support fir mod)
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MOD_SEL</name>
              <description>
              0: fir
              1: iir
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FIRST_SEL</name>
              <description>
              unused
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LAST_SEL</name>
              <description>
              when conv_sel=1 ,it is necrssary 
              0:other data block
              1:last data block 
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GAIN</name>
              <description>
              facc gain
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SRC_ADDR</name>
          <displayName>SRC_ADDR</displayName>
          <description>source address</description>
          <addressOffset>0x008</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>SRC_ADDR</name>
              <description>
              source address
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DST_ADDR</name>
          <displayName>DST_ADDR</displayName>
          <description>destination address</description>
          <addressOffset>0x00c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DST_ADDR</name>
              <description>
              destination address
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BLK_LEN</name>
          <displayName>BLK_LEN</displayName>
          <description>source block length</description>
          <addressOffset>0x010</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>BLK_LEN</name>
              <description>
              block data byte(8bit) or word(16bit) number,count from 1
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BUF_ADDR</name>
          <displayName>BUF_ADDR</displayName>
          <description>buffer address</description>
          <addressOffset>0x014</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>BUF_ADDR</name>
              <description>
              intermediate data buffer address
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DATA_SEQ</name>
          <displayName>DATA_SEQ</displayName>
          <description>the sequence of the  first data</description>
          <addressOffset>0x018</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA_SEQ</name>
              <description>
              unused
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>VECT_PARA</name>
          <displayName>VECT_PARA</displayName>
          <description>vector number</description>
          <addressOffset>0x01c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>M</name>
              <description>
              IIR vector a step , count from 0
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>P</name>
              <description>
              FIR/IIR vector  b step , count from 0
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>VECT_B</name>
          <displayName>VECT_B</displayName>
          <description>vector b fifo</description>
          <addressOffset>0x020</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>VECT_B</name>
              <description>
              vector b
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>VECT_A</name>
          <displayName>VECT_A</displayName>
          <description>vector a fifo</description>
          <addressOffset>0x024</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>VECT_A</name>
              <description>
              vector a
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>VECT_CLR</name>
          <displayName>VECT_CLR</displayName>
          <description>vector fifo clr</description>
          <addressOffset>0x028</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>31</bitWidth>
            </field>
            <field>
              <name>VECT_CLR</name>
              <description>
              vector fifo clr
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>INT_EN</name>
          <displayName>INT_EN</displayName>
          <description>interrupt enable</description>
          <addressOffset>0x02c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>31</bitWidth>
            </field>
            <field>
              <name>INT_EN</name>
              <description>
              interrupt enable
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>INT_STA</name>
          <displayName>INT_STA</displayName>
          <description>interrupt state</description>
          <addressOffset>0x030</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>31</bitWidth>
            </field>
            <field>
              <name>INT_STA</name>
              <description>
              interrupt state
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DBG_DATA</name>
          <displayName>DBG_DATA</displayName>
          <description>debug data</description>
          <addressOffset>0x034</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DEBUG_DATA</name>
              <description>
              13:inbuf_empty
              12:inmem_full
              11:inmem_empty
              10:iir_en
              9:iir_on
              8:iir_ok
              7:fir_end
              6:conv_act
              5:fir_on
              4:blk_on
              3~0 :ahb_state
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>USART3</name>
      <description></description>
      <groupName>USART</groupName>
      <baseAddress>0x40029000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CR1</name>
          <displayName>CR1</displayName>
          <description>Control Register 1</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>M</name>
              <description>
              Mode bit indicates the length of the packet, including data bits and parity. Stop bits not included.
              0: 6 bits (e.g. 6 data bits + no parity bit)
              1: 7 bits (e.g. 6 data bits + 1 parity bit)
              2: 8 bits (e.g. 7 data bits + 1 parity bit, or 6 data bits + 2 parity bits)
              3: 9 bits (e.g. 8 data bits + 1 parity bit, or 7 data bits + 2 parity bits)
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>RSVD5</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>OVER8</name>
              <description>
              Oversampling mode
              0: Oversampling by 16
              1: Oversampling by 8
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD6</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD7</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD8</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PCE</name>
              <description>
              Parity check enable. If enabled, parity bit is inserted at the MSB position 
              0: parity check disabled
              1: parity check enabled
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Parity select
              0: even parity
              1: odd parity
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PEIE</name>
              <description>
              Parity error interrupt enable
              0: interrupt disabled
              1: interrupt is generated whenever PE=1 in the ISR register
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TXEIE</name>
              <description>
              Tx empty interrupt enable
              0: interrupt disabled
              1: interrupt is generated whenver TXE=1 in the ISR register
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIE</name>
              <description>
              Transfer compelete interrupt enable
              0: interrupt disabled
              1: interrupt is generated whenever TC=1 in the ISR register
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RXNEIE</name>
              <description>
              Rx not empty interrupt enable
              0: interrupt disabled
              1: interrupt is generated whenever RXNE=1 in the ISR register
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IDLEIE</name>
              <description>
              Idle line interrupt enable
              0: interrupt disabled
              1: interrupt is generated whenever IDLE=1 in the ISR  register
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TE</name>
              <description>
              Transmitter enable
              0: transmitter is disabled
              1: transmitter is enabled
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RE</name>
              <description>
              Receiver enable
              0: receiver is disabled
              1: receiver is enabled
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD9</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UE</name>
              <description>
              USART enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CR2</name>
          <displayName>CR2</displayName>
          <description>Control Register 2</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD5</name>
              <description>
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD6</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD7</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD8</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD9</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD10</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>STOP</name>
              <description>
              Stop bits
              0/1: 1 stop bit
              2/3: 2 stop bits
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD11</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD12</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD13</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD14</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD15</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD16</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD17</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD18</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD19</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CR3</name>
          <displayName>CR3</displayName>
          <description>Control Register 3</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD5</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD6</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD7</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD8</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD9</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD10</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OVRDIS</name>
              <description>
              Overrun disable
              0: overrun error flag (ORE) will be set if new data received but previous data not read. New data will not overwrite the content in RDR register.
              1: overrun disabled. If new data is received before previous data is read, the new data will overwrite the content in RDR register and ORE flag remains unset.
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ONEBIT</name>
              <description>
              One bit sampling mode
              0: 3-bit sampling mode, the sampling value is determined by the voted result out of 3 bits
              1: 1-bit sampling mode
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTSIE</name>
              <description>
              CTS interrupt enable
              0: interrupt disabled
              1: interrupt is generated whenever CTSIF=1 in the ISR register
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTSE</name>
              <description>
              CTS enable
              0: CTS hardware flow control disabled
              1: CTS hardware flow control enabled, data is transmitted only when CTS input is asserted low
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RTSE</name>
              <description>
              RTS enable
              0: RTS hardware flow control disabled
              1: RTS hardware flow control enabled, RTS output is asserted low when new data can be received
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMAT</name>
              <description>
              Transmitter DMA enable
              0: DMA mode disabled for transmission
              1: DMA mode enabled for transmission
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMAR</name>
              <description>
              Receiver DMA enable
              0: DMA mode disabled for reception
              1: DMA mode enabled for reception
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD11</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD12</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD13</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD14</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD15</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EIE</name>
              <description>
              Error interrupt enable
              0: interrupt disabled
              1: interrupt is generated whenever FE=1 or ORE=1 or NF=1 in the ISR register
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BRR</name>
          <displayName>BRR</displayName>
          <description>Baud Rate Register</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>INT</name>
              <description>
              Integer part of baud rate prescaler
              If OVER8 = 0, Baud Rate = 48000000 / (INT + FRAC/16) / 16
              If OVER8 = 1, Baud Rate = 48000000 / (INT + FRAC/16) / 8
              For example:
              OVER=0, INT=3, FRAC=0, Baud Rate = 48000000/(3+0)/16 = 1Mbps
              OVER=0, INT=3, FRAC=4, Baud Rate = 48000000/(3+4/16)/16 = 923077 = 921600 + 1.6
              OVER=1, INT=52, FRAC=1, Baud Rate = 48000000/(52+1/16)/8 = 115246 = 115200 + 0.4
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
            <field>
              <name>FRAC</name>
              <description>
              Fractional part of baud rate prescaler
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD1</name>
          <displayName>RSVD1</displayName>
          <description></description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>RQR</name>
          <displayName>RQR</displayName>
          <description>Request Register</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>27</bitWidth>
            </field>
            <field>
              <name>TXFRQ</name>
              <description>
              Tx data flush requestReserved-Do not modify
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RXFRQ</name>
              <description>
              Rx data flush request. Write 1 to clear the RXNE flag and discard the current data in RDR
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ISR</name>
          <displayName>ISR</displayName>
          <description>Interrupt and Status Register</description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x020000C0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD5</name>
              <description>
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD6</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD7</name>
              <description>
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD8</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD9</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD10</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD11</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD12</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD13</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD14</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD15</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTS</name>
              <description>
              CTS input. Read this bit to get the raw status of the CTS line.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTSIF</name>
              <description>
              CTS interrupt flag. This bit is set by hardware whenever CTS input toggles.
              0: no change on the CTS line
              1: there is a change on the CTS line
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD16</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TXE</name>
              <description>
              Tx data empty
              0: data is ready in TDR
              1: data is already transferred to shift register, i.e. transmission is in progress or complete
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TC</name>
              <description>
              transmission complete. This bit is set by hardware if the transmission is complete
              0: transmission is not complete
              1: transmission is complete
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RXNE</name>
              <description>
              Rx data not empty. This bit is set by hardware when the received data is transferred into RDR register.
              0: data is not received
              1: data is ready in RDR to be read
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IDLE</name>
              <description>
              Idle line detected
              0: no idle line is detected
              1: idle line is detected
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ORE</name>
              <description>
              Overrun error. When new data is received but Rx buffer is not empty (i.e. previous data is not read yet), ORE is asserted and current RDR content is not lost. This feature can be disabled by set CR3_OVRDIS to 1.
              0: no overrun error
              1: overrun error is detected
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>NF</name>
              <description>
              Noise flag. Noise means the samping values in the 3-bit sampling mode are not the same.
              0: no noise is detected
              1: noise is detected
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FE</name>
              <description>
              Framing error. This bit is set by hardware when stop bit is not correctly received
              0: no framing error is detected
              1: framing error is detected
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Parity error. This bit is set when a parity error is detected in the received packet.
              0: no parity error
              1: parity error detected
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ICR</name>
          <displayName>ICR</displayName>
          <description>Interrupt flag Clear Register</description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD5</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>RSVD6</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD7</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD8</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTSCF</name>
              <description>
              CTS clear flag. Writing 1 to this bit clears the CTSIF flag in the ISR register.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD9</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD10</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCCF</name>
              <description>
              Transmission complete clear flag. Writing 1 to this bit clears the TC flag in the ISR register.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD11</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IDLECF</name>
              <description>
              Idle line detected clear flag. Writing 1 to this bit clears the IDLECF flag in the ISR register.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ORECF</name>
              <description>
              Overrun error clear flag. Writing 1 to this bit clears the ORE flag in the ISR register.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>NCF</name>
              <description>
              Noise detected clear flag. Writing 1 to this bit clears the NF flag in the ISR register.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FECF</name>
              <description>
              Framing error clear flag. Writing 1 to this bit clears the FE flag in the ISR register.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PECF</name>
              <description>
              Parity error clear flag. Wriring 1 to this bit clears the PE flag in the ISR register.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RDR</name>
          <displayName>RDR</displayName>
          <description>Receive Data Register</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>RDR</name>
              <description>
              Received data
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TDR</name>
          <displayName>TDR</displayName>
          <description>Transmit Data Register</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>TDR</name>
              <description>
              Transmit data
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>MISCR</name>
          <displayName>MISCR</displayName>
          <description>Miscellaneous Register</description>
          <addressOffset>0x2c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>AUTOCAL</name>
              <description>
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>RTSBIT</name>
              <description>
              assert RTS ahead of the frame completion (in number of bits)Reserved-Do not modify
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>SMPLINI</name>
              <description>
              initial sample count, count down from this value to zero to reach the middle of the start bit in RxReserved-Do not modify
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DRDR</name>
          <displayName>DRDR</displayName>
          <description>Debug Receive Data Register</description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              DbgUART is still a preliminary version in this project. 
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DTDR</name>
          <displayName>DTDR</displayName>
          <description>Debug Receive Data Register</description>
          <addressOffset>0x34</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>EXR</name>
          <displayName>EXR</displayName>
          <description>Mutual Exclusive Register</description>
          <addressOffset>0x38</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>27</bitWidth>
            </field>
            <field>
              <name>ID</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>BUSY</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>SCI</name>
      <description></description>
      <groupName>SCI</groupName>
      <baseAddress>0x4002d000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CONFIG</name>
          <displayName>CONFIG</displayName>
          <description></description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>SCI_MODE</name>
              <description>
              These bits are reserved and must be written as '00' for the SCI module to work properly: 
              2'b11: Ser In lt- Ser Out loopback 
              2'b10: Ser In lt- Ser In (unmasked) 
              others = Ser In lt- Ser In masked with Txing_H (normal mode) 
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>PAR_CHK_OFFSET</name>
              <description>
              Allows fine control of the parity check position during the parity error time period
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IN_AVG_EN</name>
              <description>
              Input data average enable. 
              0: Disable 
              1: Enable 
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DLY_SEL</name>
              <description>
              This selects between two delay times for the automatic clock stop startup and shutdown: 
              0: short delay 
              Startup/Shutdown : 744 SCI clocks / 1860 SCI clocks 
              1: long delay 
              Startup/Shutdown : (2 x 744) SCI clocks / (2 x 1860) SCI clocks 
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RESET</name>
              <description>
              Direct connection to the SIM card reset pin. This is overridden when ARG_H is enabled 
              0: SCI_Reset low voltage 
              1: SCI Reset high voltage
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TX_RESEND_EN_H</name>
              <description>
              1: Enable automatic resend of characters when Tx parity error is detected 
              0: Disable automatic resend 
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>AFD_EN_H</name>
              <description>
              Automatic format detection. 
              This bit is generally set in conjunction with the ARG_H bit to enable automatic detection of the data convention. 
              1: Enable TS detection and automatic convention settings programming 
              0: disable automatic settings and use the register bits (MSBH_LSBL and LLI) to control the convention 
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ARG_H</name>
              <description>
              Automatic Reset Generator. 
              Write a '1' to this bit to initiate an automatic reset procedure on the SIM. 
              Write '0' to switch back to SCI_Reset control (bit 20). 
              An ARG interrupt will be generated if the ARG process succeeded or failed. 
              The ARG status bit (ARG_Det) must be read to determine if a reset response from the card was detected. 
              This bit needs to be cleared between ARG attempts
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RX_CLK_CNT_SAMPLE</name>
              <description>
              tunning the sample local
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>STOP_LEVEL</name>
              <description>
              Logical value of the clock signal when SCI clock is stopped (either due to automatic shutdown or manual shutdown) 
              0: Stop clock at low level 
              1: Stop clock at high level 
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PARITY_EN</name>
              <description>
              Enable or disable parity error checking on the receive data 
              0: Disable parity error checking 
              1: Enable parity error checking 
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PEGEN_LEN</name>
              <description>
              Parity Error signal length. This configuration bit can be used to extend the duration of the parity error signal generation from 1 ETU to 1.5 ETU 
              0: Parity Error signal duration is 1 ETU starting at 10.5 ETU 
              1: Parity Error signal duration is 1.5 ETU starting at 10.5 ETU
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LLI</name>
              <description>
              Logic Level Invert
              0: Logic level 0 data is sent/received as '0' or 'A' which is the same as the start bit. (direct convention)
              1: logic level 0 data is sent/received as '1' or 'Z' which is the opposite of the start bit. (Inverse convention)
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MSBH_LSBL</name>
              <description>
              Sets the transmission and reception bit order: 
              0: LSB is sent/recieved first (Direct convention) 
              1: MSB is sent/received first (Inverse convention) 
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>AUTOSTOP_EN_H</name>
              <description>
              Enables automatic clock shutdown when command is complete. Enabling this will generate the necessary startup and shutdown delays required by the SIM protocol
              0: Auto clock control not enabled. SCI clock controlled by SCI_Clockstop bit
              1:Auto clock control enabled
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CLOCKSTOP</name>
              <description>
              Manual SCI Clock Stop control. Manually starts and stops the SCI clock. This bit must be set to '1' when Autostop mode is enabled
              0: Enable the SCI clock
              1: Disable SCI clock
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FILTER_DISABLE</name>
              <description>
              Enable or disable NULL(0x60) character filter when SIM card sends NULL to reset WWT timer
              0: Enable NULL character filtering, nULL characters are not reported if not data
              1: Disable NULL character filtering. NULL characters(0x60) are transferred to the SCIdata buffer
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PERF</name>
              <description>
              parity error receive feed-through
              0: don't store bytes with detected parity errors
              1: feed-through bytes with detected parity errors
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PARITY</name>
              <description>
              select the parity generation/detection
              1: even parity
              0: odd parity
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ENABLE</name>
              <description>
              enable the SIM Card IF module
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS</name>
          <displayName>STATUS</displayName>
          <description></description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>AUTOSTOP_STATE</name>
              <description>
              Returns the state of the clock management state machine when AutoStop mode is enabled. 
              This value is '00' when manual mode is selected
              2'h0: Startup_phase - Clock is on, but not ready to be used
              2'h1: Auto_on - Clock is on and ready to be used
              2'h2: Shutdown_phase - Clock is still on, but should not be used
              2'h3: Clock_off - Clock is off
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>18</bitWidth>
            </field>
            <field>
              <name>TXOVERFLOW</name>
              <description>
              The internal transmit FIFO has reached an overflow condition. Reading this register clears the bit
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RXOVERFLOW</name>
              <description>
              The internal receive FIFO has reached an overflow condition. Reading this register clears the bit
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TX_ERR</name>
              <description>
              A transmit parity error was detected. Reading this register clears the bit
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RX_ERR</name>
              <description>
              A receive parity error was detected. Reading this register clears the bit
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CLK_OFF</name>
              <description>
              Status bit of the Sci clock. 
              0: Sci clock is ON 
              1: Sci clock is OFF 
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CLK_RDY_H</name>
              <description>
              Status of the control signal to the clock control module. This bit respects the startup and shutdown phases, so during these times, the clock may actually be on, but it is not considered to be 'ready' 
              0: SCI clock may be on or off but is not ready for use 
              1: SCI clock is on and ready for use 
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RESET_DET</name>
              <description>
              This is the status of the Reset pin when automatic reset generation is enabled.
              This bit can be used to discover whether the SIM card that has successfully responded to an ARG procedure has an active high or active low reset. (Det means 'Detection')
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ARG_DET</name>
              <description>
              Returns the status of the automatic reset procedure: 
              0 = ARG detection has failed 
              1 = ARG detection has detected that the SIM has responded to the reset 
              This bit is used in conjunction with the ARG interrupt. 
              The ARG interrupt will be generated at the successful or unsuccessful termination of the ARG process. 
              This bit can be used to determine the success or failure. 
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FORMAT_DET</name>
              <description>
              Returns the status of the automatic format detection after reset: 
              0: TS character has not been detected in the ATR 
              1: TS character has been detected and SCI module is using the automatic convention settings 
              This bit is cleared when the AFD_En bit is cleared 
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TX_FIFO_RDY</name>
              <description>
              Returns the status of the Tx FIFO: 
              0: Tx FIFO is full 
              1: There is at least 1 free spot in the Tx FIFO 
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RXDATA_RDY</name>
              <description>
              Returns the status of the Rx FIFO: 
              0: Rx FIFO empty 
              1: There is at least 1 character in the Rx FIFO 
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DATA</name>
          <displayName>DATA</displayName>
          <description></description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>DATA_IO</name>
              <description>
              Writing to this register will send the data to the SIM card. If automatic clock shutdown is enabled, the appropriate delay will be applied before the data is actually sent
              Reading this register will read from the receive data FIFO
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CLKDIV</name>
          <displayName>CLKDIV</displayName>
          <description></description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>CLK_INV</name>
              <description>
              Inverts SCI clock to the SIM card . 
              0: No inversion 
              1: Invert external SCI clock 
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CLK_OUT_INV</name>
              <description>
              Inverts the polarity of the SCI clock to the SIM card only. 
              0: No inversion 
              1: Invert external SCI clock 
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MAINDIV</name>
              <description>
              Main clock divider to generate the SCI clock. This value should be calculated as follows: 
              MainDiv = Clk_Sys/(2xSCI_Clk) - 1 
              where SCI_Clk is in the range of 3-5 MHz as specified in the SIM specification. 
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>VAL_16</name>
              <description>
              Secondary clock divider for generating 16x baud clock
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>CLK_TST</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RX_CLK_CNT_LIMIT</name>
              <description>
              Rx_clk_cnt wrap value
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>BAUD_X8_EN</name>
              <description>
              Speed mode enable. 
              0: Low speed mode 
              1: High speed mode(372/32, 372/64, 512/64) 
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>VAL</name>
              <description>
              Clock divider for generating the baud clock from the SCI clock. This value must match the value used by the SIM card whose default value is 0x174
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RXCNT</name>
          <displayName>RXCNT</displayName>
          <description></description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>CLK_PERSIST</name>
              <description>
              When in automatic clock shutdown mode, this bit can prevent the clock from entering shutdown mode when the transfer is complete. This should be used for multi-transfer commands where the clock must not be shut down until the command is complete. This bit must be programmed for each transfer. 
              1: Keep clock on 
              0: Allow clock shutdown when transfer is complete 
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>21</bitWidth>
            </field>
            <field>
              <name>VAL</name>
              <description>
              This value should be programmed with the number of expected characters to receive. It will be decremented each time a character is actually received and should be 0 when the transfer is complete. If a character is sent after the RxCnt reaches zero, the extra character flag will be set but this value will stay at zero. 
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TIMES</name>
          <displayName>TIMES</displayName>
          <description></description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>TX_PERT</name>
              <description>
              Number of times to try resending character when the SIM indicates a parity error
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>WI</name>
              <description>
              Work Waiting Time factor. A timeout will be generated when the WWT is exceeded. The WWT is calculated by:
              WWT = 960 x WI x (F/Fi) 
              where Fi is the main SCI clock frequency (3-5 MHz) and F is 372 before an enhanced PPS and 512 after an enhanced PPS.
              The SCI_WI value must be calculated as follows:
              SCI_WI = WI * D
              Thus, by default (WI = 10) this value needs to be set to 10 before an EPPS, but needs to be scaled to WI*D=80 after the EPPS procedure. The WWT is disabled when the number of expected characters has been received. Extra characters will not cause a WWT interrupt.
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>TURNAROUNDGUARD</name>
              <description>
              Turnaround guard time configuration. This value can be used to adjust the delay between the leading edge of a received character and the leading edge of the next transmitted character. The minimum time specified in the SIM recommendation is 16 ETU. The number of ETUs can be calculated using the following formula: 
              Total Turnaround Time (in ETUs) = 11 + TurnaroundGuard 
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>CHGUARD</name>
              <description>
              This is the extra guard time that can be added to the 2 ETU minimum (and default) guard time between successive transmitted characters. This should be programmed depending on the SIM's ATR. 
              The total ETU guard time will be ChGuard + 1.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CH_FILT</name>
          <displayName>CH_FILT</displayName>
          <description></description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>VAL</name>
              <description>
              Value of the character to be filtered. 0x60 is the NULL character in the SIM protocol. If character filtering is enabled, the 
              first 0x60 character that is received by the SIM during a transfer will not be recorded. The purpose of this character is to enable the SIM to reset the WWT counter when the SIM is not ready to send the data. This filter has no effect on characters within the datastream.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DBG</name>
          <displayName>DBG</displayName>
          <description></description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>30</bitWidth>
            </field>
            <field>
              <name>FIFO_TX_CLR</name>
              <description>
              Clear TX FIFO
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FIFO_RX_CLR</name>
              <description>
              Clear RX FIFO
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>INT_CAUSE</name>
          <displayName>INT_CAUSE</displayName>
          <description></description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>SCI_DMA_RX_DONE_R</name>
              <description>
              Not used
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SCI_DMA_TX_DONE_R</name>
              <description>
              Not used
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ARG_END_R</name>
              <description>
              Raw End of the ARG sequence. The status register must be read to determine whether the ARG sequence was successful or not
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RESEND_OVFL_R</name>
              <description>
              Raw The automatic re-transmit of parity error characters has exceeded the threshold specified in the Tx_PERT field
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EXTRA_RX_R</name>
              <description>
              Raw An extra character has been received after the number of characters in RxCnt has been received
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>WWT_TIMEOUT_R</name>
              <description>
              Raw No Tx character has been sent NOR any Rx character detected within the WWT timeout
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RX_HALF_R</name>
              <description>
              Raw Receiver FIFO is half full
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RX_DONE_R</name>
              <description>
              Raw Number of expected Rx characters, as programmed in the RxCnt register, has been received.
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>SCI_DMA_RX_DONE</name>
              <description>
              Not used
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SCI_DMA_TX_DONE</name>
              <description>
              Not used
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ARG_END</name>
              <description>
              End of the ARG sequence. The status register must be read to determine whether the ARG sequence was successful or not
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RESEND_OVFL</name>
              <description>
              The automatic re-transmit of parity error characters has exceeded the threshold specified in the Tx_PERT field
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EXTRA_RX</name>
              <description>
              An extra character has been received after the number of characters in RxCnt has been received
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>WWT_TIMEOUT</name>
              <description>
              No Tx character has been sent NOR any Rx character detected within the WWT timeout
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RX_HALF</name>
              <description>
              Receiver FIFO is half full
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RX_DONE</name>
              <description>
              Number of expected Rx characters, as programmed in the RxCnt register, has been received.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>INT_CLR</name>
          <displayName>INT_CLR</displayName>
          <description></description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>SCI_DMA_RX_DONE</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SCI_DMA_TX_DONE</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ARG_END</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RESEND_OVFL</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EXTRA_RX</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>WWT_TIMEOUT</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RX_HALF</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RX_DONE</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>INT_MASK</name>
          <displayName>INT_MASK</displayName>
          <description></description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>SCI_DMA_RX_DONE</name>
              <description>
              0: mask the interrupt
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SCI_DMA_TX_DONE</name>
              <description>
              0: mask the interrupt
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ARG_END</name>
              <description>
              0: mask the interrupt
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RESEND_OVFL</name>
              <description>
              0: mask the interrupt
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EXTRA_RX</name>
              <description>
              0: mask the interrupt
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>WWT_TIMEOUT</name>
              <description>
              0: mask the interrupt
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RX_HALF</name>
              <description>
              0: mask the interrupt
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RX_DONE</name>
              <description>
              0: mask the interrupt
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>MISC_CTRL</name>
          <displayName>MISC_CTRL</displayName>
          <description></description>
          <addressOffset>0x2c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>29</bitWidth>
            </field>
            <field>
              <name>RX_DMA_EN</name>
              <description>
              rx dma enable
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TX_DMA_EN</name>
              <description>
              tx dma enable
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PA_CLK_EN</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PA_STATUS</name>
          <displayName>PA_STATUS</displayName>
          <description></description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>31</bitWidth>
            </field>
            <field>
              <name>ENABLE</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>I2C4</name>
      <description></description>
      <groupName>I2C</groupName>
      <baseAddress>0x4002f000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CR</name>
          <displayName>CR</displayName>
          <description>Control register</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>UR</name>
              <description>
              Unit Reset. Software need first assert to reset then deassert to release.
              0 = No reset.
              1 = Reset I2C module.
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSTREQ</name>
              <description>
              I2C will do bus reset upon this bit set. Will be cleared by HW automatically after RSTCYC cycles of SCL generated.
              1 = request for i2c bus reset
              0 = bus reset finished
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BRGRST</name>
              <description>
              Reset bus related state machine and signals. Will be cleared by HW automatically
              1 = request for reset
              0 = reset finished
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>14</bitWidth>
            </field>
            <field>
              <name>DNF</name>
              <description>
              Digital noise filter
              These bits are used to configure the digital noise filter on SDA and SCL input. The digital filter will filter spikes with a length of up to DNF*Tfclk.
              0: Digital filter disabled 
              1: Digital filter enabled and filtering capability up to 1 Tfclk
              ...
              7: digital filter enabled and filtering capability up to 7 Tfclk
              Digital filter is added to analog filter. Digital filter will introduce delay on SCL and SDA processing, which is essential in hs-mode. 
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>SLVEN</name>
              <description>
              Slave mode Enable for SCL.
              0 = Disable slave mode. Will not monitor slave address on I2C bus.
              1 = Enable slave mode. Will monitor slave address on I2C bus.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SCLPP</name>
              <description>
              Push-pull mode Enable for SCL.
              0 = open drain output for SCL.
              1 = Push-pull output for SCL
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MSDE</name>
              <description>
              Master Stop Detected Enable:
              0 = Master Stop Detect (MSD) status is not enabled.
              1 = Master Stop Detect (MSD) status is enabled.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LASTSTOP</name>
              <description>
              Generate STOP for last DMA transfer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LASTNACK</name>
              <description>
              Generate NACK for last DMA Read transfer
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMAEN</name>
              <description>
              DMA Enable for both TX and RX
              0 = DMA mode is NOT enabled
              1 = DMA mode enabled
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SCLE</name>
              <description>
              SCL Enable:
              0 = Disables the I2C from driving the SCL line.
              1 = Enables the I2C clock output for master-mode operation.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IUE</name>
              <description>
              I2C Unit Enable:
              0 = Disables the unit and does not master any transactions or respond to any slave transactions.
              1 = Enables the I2C (defaults to slave-receive mode).
              Software must guarantee the I2C bus is idle before setting this bit.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MODE</name>
              <description>
              Bus Mode (Master operation):
              2'b00: standard-mode
              2'b01: fast-mode and fast-mode plus
              2'b10: HS-mode (standard mode when not doing a high speed transfer)
              2'b11: HS-mode (fast mode when not doing a high speed transfer)
              Bus Mode (Slave operation):
              2'b0x: HS-mode is disabled. I2C unit uses Standard/Fast mode timing on the SDA pin.
              2'b1x: HS-mode is enabled. I2C unit uses HS-mode timing on the SDA pin when a master code is received.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TCR</name>
          <displayName>TCR</displayName>
          <description>Transfer Control register</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>ABORTDMA</name>
              <description>
              Abort DMA operation. Will be cleared by HW automatically
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RXREQ</name>
              <description>
              Request DMA RX. Will be cleared by HW automatically
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TXREQ</name>
              <description>
              Request DMA TX. Will be cleared by HW automatically
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MA</name>
              <description>
              Master Abort:
              Used by the I2C in master mode to generate a Stop without transmitting another data byte:
              0 = The I2C transmits Stop on if TCR[STOP] is set.
              1 = The I2C sends Stop without data transmission.
              When in master-transmit mode, after transmitting a data byte, the TCR[TB] bit is cleared. When no more data bytes need to be sent, setting master abort bit sends the Stop. The TCR[TB] bit must remain clear.
              In master-receive mode, when a NAK is sent without a Stop (TCR[STOP] bit was not set) and CPU does not send a repeated Start, setting this bit sends the Stop. Once again, the TCR[TB] bit must remain clear. Master Abort can be done immediately after the address phase (Master Transmit mode only).
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>NACK</name>
              <description>
              The positive/negative acknowledge control bit, defines the type of acknowledge pulse sent by the I2C when in master receive mode:
              0 = Send a positive acknowledge (ACK) pulse after receiving a data byte.
              1 = Send a negative acknowledge (NACK) pulse after receiving a data byte.
              The I2C automatically sends an ACK pulse when responding to its slave address or when responding in slave-receive mode, regardless of the NACK control-bit setting.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>STOP</name>
              <description>
              Stop:
              Used to initiate a Stop condition after transferring the next data byte on the I2C bus when in master mode. In master-receive mode, the NACK control bit must be set in conjunction with the STOP bit. 
              0 = Do not send a Stop.
              1 = Send a Stop.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>START</name>
              <description>
              Start:
              Used to initiate a Start condition to the I2C unit when in master mode. 
              0 = Do not send a Start pulse.
              1 = Send a Start pulse.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TB</name>
              <description>
              Transfer Byte:
              Used to send or receive a byte on the I2C bus:
              0 = Cleared by I2C when the byte is sent/received.
              1 = Send/receive a byte. 
              CPU can monitor this bit to determine when the byte transfer has completed. In master or slave mode, after each byte transfer including acknowledge pulse, the I2C holds the SCL line low (inserting wait states) until TB is set.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IER</name>
          <displayName>IER</displayName>
          <description>Interrupt Enable register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>UFIE</name>
              <description>
              FIFO Underflow Interrupt Enable
              0 = FIFO Underflow interrupt is not enabled
              1 = FIFO Underflow interrupt is enabled
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OFIE</name>
              <description>
              FIFO Overflow Interrupt Enable
              0 = FIFO Overflow interrupt is not enabled
              1 = FIFO Overflow interrupt is enabled
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMADONEIE</name>
              <description>
              DMA Transaction Done Interrupt Enable
              0 = DMA Transaction done interrupt is not enabled.
              1 = DMA Transaction done interrupt is enabled.
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MSDIE</name>
              <description>
              Master Stop Detected Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C unit to interrupt upon detecting a Master Stop sent by the I2C unit.
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BEDIE</name>
              <description>
              Bus Error Detected Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C to interrupt for the following I2C bus errors:
              As a master transmitter, no ACK was detected after a byte was sent.
              As a slave receiver, the I2C generated a NACK pulse.
              Software is responsible for guaranteeing that misplaced Start and Stop conditions do not occur.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SADIE</name>
              <description>
              Slave Address Detected Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C to interrupt upon detecting a slave address match or a general call address.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RFIE</name>
              <description>
              DBR Receive Full Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C to interrupt when the DBR has received a data byte from the I2C bus.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIE</name>
              <description>
              DBR Transmit Empty Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C to interrupt after transmitting a byte onto the I2C bus.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ALDIE</name>
              <description>
              Arbitration Loss Detected Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C to interrupt upon losing arbitration while in master mode.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SSDIE</name>
              <description>
              Slave Stop Detected Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C to interrupt when it detects a Stop condition while in slave mode.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SR</name>
          <displayName>SR</displayName>
          <description>Status register</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>UF</name>
              <description>
              FIFO Underflow Flag. Asserted when FIFO is empty and a POP request generated without a PUSH. Cleared if write 1
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OF</name>
              <description>
              FIFO Overflow Flag. Asserted when FIFO is full and a PUSH request generated without a POP. Cleared if write 1
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMADONE</name>
              <description>
              DMA Transaction Done. Asserted when both APB and I2C bus have finished transfer. Cleared if write 1
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MSD</name>
              <description>
              Master Stop Detected:
              0 = No Master Stop Detected.
              1 = This bit is set by the I2C unit when all of the following are true:
              This bit is enabled (CR[MSDE] = 1);
              I2C unit is configured as a master;
              I2C transmits a STOP signal
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EBB</name>
              <description>
              Early Bus Busy
              0 = I2C bus is idle or the I2C is using the bus (that is, unit busy).
              1 = Set when the unit detects that the SCL or SDA line is low without a START condition. Bit will remain set until the I2C unit detects the bus is idle by detecting a STOP condition. Bit will also be set whenever the IBB bit is set.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BED</name>
              <description>
              Bus Error Detected:
              0 = No error detected.
              1 = The I2C sets this bit when it detects one of the following error conditions:
              As a master transmitter, no ACK was detected on the interface after a byte was sent.
              As a slave receiver, the I2C generates a NACK pulse.
              When an error occurs, I2C bus transactions continue. Software must guarantee that misplaced Start and Stop conditions do not occur. 
              Cleared if write 1
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SAD</name>
              <description>
              Slave Address Detected:
              0 = No slave address was detected.
              1 = The I2C detected a seven-bit address that matches the general call address or SAR. An interrupt is signalled when enabled in the CR. 
              Cleared if write 1
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RF</name>
              <description>
              DBR Receive Full:
              0 = The DBR has not received a new data byte or the I2C is idle.
              1 = The DBR register received a new data byte from the I2C bus. An interrupt is signalled when enabled in the CR. 
              Cleared if write 1
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TE</name>
              <description>
              DBR Transmit Empty:
              0 = The data byte is still being transmitted.
              1 = The I2C has finished transmitting a data byte on the I2C bus. An interrupt is signalled when enabled in the CR.
              Cleared if write 1
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ALD</name>
              <description>
              Arbitration Loss Detected:
              Used during multi-master operation:
              0 = Cleared when arbitration is won or never took place.
              1 = Set when the I2C loses arbitration. 
              Cleared if write 1
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SSD</name>
              <description>
              Slave Stop Detected:
              0 = No Stop detected.
              1 = Set when the I2C detects a Stop while in slave-receive or slave-transmit mode. 
              Cleared if write 1
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IBB</name>
              <description>
              I2C Bus Busy:
              0 = I2C bus is idle or the I2C is using the bus (that is, unit busy).
              1 = Set when the I2C bus is busy but local I2C is not involved in the transaction.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UB</name>
              <description>
              Unit Busy:
              0 = I2C not busy.
              1 = Set when local I2C is busy. This is defined as the time between the first Start and Stop. 
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>NACK</name>
              <description>
              ACK/NACK Status:
              0 = The I2C received or sent an ACK on the bus. 
              1 = The I2C received or sent a NACK.on the bus.
              This bit is used in slave-transmit mode to determine when the byte transferred is the last one. This bit is updated after each byte and ACK/NACK information is received.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RWM</name>
              <description>
              Read/write Mode:
              0 = The I2C is in master-transmit or slave-receive mode. 
              1 = The I2C is in master-receive or slave-transmit mode. 
              This is the R/nW bit of the slave address. It is cleared automatically by hardware after a Stop state.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DBR</name>
          <displayName>DBR</displayName>
          <description>Data Buffer register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>DATA</name>
              <description>
              use the I2C Data Buffer register to transmit and receive data from the I2C bus. The DBR is accessed by software on one Side and by the I2C Shift register on the other. The DBR receives data coming into the I2C unit after a full byte is received and acknowledged. CPU writes data going out of the I2C to the DBR and sends it to the serial bus. 
              When the I2C is in transmit mode (master or slave), CPU writes data to the DBR over the internal bus. CPU write data to the DBR when a master transaction is initiated or when the DBR transmit-empty interrupt is signalled. Data moves from the DBR to the Shift register when the transfer byte bit is set. The DBR transmit-empty interrupt is signalled (if enabled) when a byte is transferred on the I2C bus and the acknowledge cycle is complete. If the DBR is not written, and a Stop condition is not in place before the I2C bus is ready to transfer the next byte packet, the I2C unit inserts wait states until CPU writes the DBR and sets the transfer byte bit.
              When the I2C is in receive mode (master or slave), CPU reads DBR data over the internal bus. CPU reads data from the DBR when the DBR receive-full interrupt is signalled. The data moves from the Shift register to the DBR when the acknowledge cycle is complete. The I2C inserts wait states until the DBR is read. After the software reads the DBR, CR[NACK] are written by the software, allowing the next byte transfer to proceed to the I2C bus.
              In DMA mode, DBR is automatically filled from FIFO in master transmit mode, or fetched and stored in FIFO in master receive mode until DMA done or aborted.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SAR</name>
          <displayName>SAR</displayName>
          <description>Slave Address Register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000047</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>25</bitWidth>
            </field>
            <field>
              <name>ADDR</name>
              <description>
              The seven-bit address to which the I2C responds when in slave-receive mode
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>LCR</name>
          <displayName>LCR</displayName>
          <description>Load Count Register</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x081C72ED</resetValue>
          <fields>
            <field>
              <name>HLVH</name>
              <description>
              Decrementer Load value for High Speed Mode SCL (master mode) for high phase. 
              Thigh=Tfclk*(HLVH+4+DNF)
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>HLVL</name>
              <description>
              Decrementer Load value for High Speed Mode SCL (master mode) for low phase. 
              Tlow=Tfclk*(HLVL+3+DNF). Data rate is generated as 1/(Thigh+Tlow), or Ffclk/(HLVH+HLVL+7+2*DNF). 
              3.2Mbps data rate is generated by default if fclk is 48MHz.
              HLVL also controls setup time and hold time for START and STOP condition in High Speed Mode(master mode). 
              Thdsta=Tsusta=Tsusto=Tfclk*(HLVL+1)
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
            <field>
              <name>FLV</name>
              <description>
              Decrementer Load value for Fast Mode (or Fast Mode Plus) SCL (master mode) for both high and low phase. 
              Data rate is generated as Ffclk/(FLV+max(FLV,CNT*2+6)+7+DNF) approximately. 
              400kbps data rate is generated by default if fclk is 48MHz.
              FLV also controls setup time and hold time for START and STOP condition in Fast Mode(master mode). 
              Thdsta=Tsusta=Tsusto=Tfclk*FLV
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
            <field>
              <name>SLV</name>
              <description>
              Decrementer Load value for Standard Mode SCL (master mode) for both high and low phase. 
              Data rate is generated as Ffclk/(SLV+max(SLV,CNT*2+6)+7+DNF) approximately. 
              100kbps data rate is generated by default if fclk is 48MHz.
              SLV also controls setup time and hold time for START and STOP condition in Standard Mode(master mode). 
              Thdsta=Tsusta=Tsusto=Tfclk*SLV
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>WCR</name>
          <displayName>WCR</displayName>
          <description>Wait Count Register</description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0000000A</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>CNT</name>
              <description>
              Controls the counter values defining the setup and hold times in standard and fast mode
              Tvddat=Thddat=Tfclk*(CNT+2)
              Tsudat=max(Tlow-Thddat,Thddat)
              Lower counter values may violate setup and hold times.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RCCR</name>
          <displayName>RCCR</displayName>
          <description>Bus Reset Cycle Counter Register</description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000009</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>28</bitWidth>
            </field>
            <field>
              <name>RSTCYC</name>
              <description>
              The cycles of SCL during bus reset
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BMR</name>
          <displayName>BMR</displayName>
          <description>Bus Monitor Register</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000003</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>30</bitWidth>
            </field>
            <field>
              <name>SCL</name>
              <description>
              value of the SCL pin. Software can check bus level when the I2C bus is hung and the I2C unit must be reset.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SDA</name>
              <description>
              value of the SDA pin.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DNR</name>
          <displayName>DNR</displayName>
          <description>DMA number register</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>NDT</name>
              <description>
              Write as number of data to transfer in byte. Read as left data number to transfer
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD1</name>
          <displayName>RSVD1</displayName>
          <description></description>
          <addressOffset>0x2C</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>FIFO</name>
          <displayName>FIFO</displayName>
          <description>FIFO Register</description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>DATA</name>
              <description>
              Write to push send data into FIFO. Read to pop received data from FIFO
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>HPSYS_AON</name>
      <description></description>
      <groupName>HPSYS_AON</groupName>
      <baseAddress>0x40040000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>PMR</name>
          <displayName>PMR</displayName>
          <description>Power Mode Register</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>FORCE_SLEEP</name>
              <description>
              Set 1 to force enter low power mode. Will be cleared automatically
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FORCE_HCPU</name>
              <description>
              for debug only
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>28</bitWidth>
            </field>
            <field>
              <name>MODE</name>
              <description>
              Power Mode: 2'h0 - active; 2'h1 - light sleep; 2'h2 - deep sleep; 2'h3 - standby
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CR1</name>
          <displayName>CR1</displayName>
          <description>Control Register 1</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>GTIM_EN</name>
              <description>
              Enable global timer
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
            <field>
              <name>PIN7_MODE</name>
              <description>
              mode for wakeup PIN7 (PA52)
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>PIN6_MODE</name>
              <description>
              mode for wakeup PIN6 (PA51)
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>PIN5_MODE</name>
              <description>
              mode for wakeup PIN5 (PA50)
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>PIN4_MODE</name>
              <description>
              mode for wakeup PIN4 (PB36)
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>PIN3_MODE</name>
              <description>
              mode for wakeup PIN3 (PB35)
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>PIN2_MODE</name>
              <description>
              mode for wakeup PIN2 (PB34)
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>PIN1_MODE</name>
              <description>
              mode for wakeup PIN1 (PB33)
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>PIN0_MODE</name>
              <description>
              mode for wakeup PIN0 (PB32)
              0 - high level, 1 - low level, 2 - pos edge, 3 - neg edge, 4/5/6/7: pos or neg edge
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CR2</name>
          <displayName>CR2</displayName>
          <description>Control Register 2</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>14</bitWidth>
            </field>
            <field>
              <name>PIN13_MODE</name>
              <description>
              mode for wakeup PIN13 (PBR3)
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>PIN12_MODE</name>
              <description>
              mode for wakeup PIN12 (PBR2)
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>PIN11_MODE</name>
              <description>
              mode for wakeup PIN11 (PBR1)
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>PIN10_MODE</name>
              <description>
              mode for wakeup PIN10 (PBR0)
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>PIN9_MODE</name>
              <description>
              mode for wakeup PIN9 (PA54)
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>PIN8_MODE</name>
              <description>
              mode for wakeup PIN8 (PA53)
              0 - high level, 1 - low level, 2 - pos edge, 3 - neg edge, 4/5/6/7: pos or neg edge
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ACR</name>
          <displayName>ACR</displayName>
          <description>Active Mode Control register</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>HXT48_RDY</name>
              <description>
              Indicate hxt48 is ready
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HRC48_RDY</name>
              <description>
              Indicate hrc48 is ready
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>DS_ULPMEM</name>
              <description>
              for debug only
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PD_LPMEM</name>
              <description>
              for debug only
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EXTPWR_REQ</name>
              <description>
              Request power for LPSYS during Active mode
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PWR_REQ</name>
              <description>
              Request power for HPSYS during Active mode
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HXT48_REQ</name>
              <description>
              Request hxt48 in active mode
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HRC48_REQ</name>
              <description>
              Request hrc48 in active mode
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>LSCR</name>
          <displayName>LSCR</displayName>
          <description>Light Sleep Ctrl Register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>28</bitWidth>
            </field>
            <field>
              <name>EXTPWR_REQ</name>
              <description>
              Request power for LPSYS during Light Sleep mode
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PWR_REQ</name>
              <description>
              Request power for HPSYS during Light Sleep mode
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HXT48_REQ</name>
              <description>
              Request hxt48 in Light Sleep mode
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HRC48_REQ</name>
              <description>
              Request hrc48 in Light Sleep mode
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DSCR</name>
          <displayName>DSCR</displayName>
          <description>Deep Sleep Ctrl Register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>28</bitWidth>
            </field>
            <field>
              <name>EXTPWR_REQ</name>
              <description>
              Request power for LPSYS during Deep Sleep mode
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PWR_REQ</name>
              <description>
              Request power for HPSYS during Deep Sleep mode
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HXT48_REQ</name>
              <description>
              Request hxt48 in Deep Sleep mode
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HRC48_REQ</name>
              <description>
              Request hrc48 in Deep Sleep mode
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SBCR</name>
          <displayName>SBCR</displayName>
          <description>Standby Mode Ctrl Register</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>28</bitWidth>
            </field>
            <field>
              <name>EXTPWR_REQ</name>
              <description>
              Request power for LPSYS during Standby mode
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PWR_REQ</name>
              <description>
              Request power for HPSYS during Standby mode
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HXT48_REQ</name>
              <description>
              Request hxt48 in Standby mode
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HRC48_REQ</name>
              <description>
              Request hrc48 in Standby mode
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>WER</name>
          <displayName>WER</displayName>
          <description>Wakeup Enable register</description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
            <field>
              <name>PIN13</name>
              <description>
              Set 1 to enable PBR3 as wakeup source
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN12</name>
              <description>
              Set 1 to enable PBR2 as wakeup source
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN11</name>
              <description>
              Set 1 to enable PBR1 as wakeup source
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN10</name>
              <description>
              Set 1 to enable PBR0 as wakeup source
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN9</name>
              <description>
              Set 1 to enable PA54 as wakeup source
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN8</name>
              <description>
              Set 1 to enable PA53 as wakeup source
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN7</name>
              <description>
              Set 1 to enable PA52 as wakeup source
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN6</name>
              <description>
              Set 1 to enable PA51 as wakeup source
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN5</name>
              <description>
              Set 1 to enable PA50 as wakeup source
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN4</name>
              <description>
              Set 1 to enable PB36 as wakeup source
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN3</name>
              <description>
              Set 1 to enable PB35 as wakeup source
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN2</name>
              <description>
              Set 1 to enable PB34 as wakeup source
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN1</name>
              <description>
              Set 1 to enable PB33 as wakeup source
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN0</name>
              <description>
              Set 1 to enable PB32 as wakeup source
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LP2HP_IRQ</name>
              <description>
              Set 1 to enable MAILBOX2 as wakeup source
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LP2HP_REQ</name>
              <description>
              Set 1 to enable LPSYS request as wakeup source
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>LPTIM1</name>
              <description>
              Set 1 to enable LPTIM1 as wakeup source
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GPIO1</name>
              <description>
              Set 1 to enable IO(PA) as wakeup source
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RTC</name>
              <description>
              Set 1 to enable RTC as wakeup source
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>WSR</name>
          <displayName>WSR</displayName>
          <description>Wakeup Status register</description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
            <field>
              <name>PIN13</name>
              <description>
              Indicates the wakeup status from PBR3 request. Note: the status is masked by WER
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN12</name>
              <description>
              Indicates the wakeup status from PBR2 request. Note: the status is masked by WER
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN11</name>
              <description>
              Indicates the wakeup status from PBR1 request. Note: the status is masked by WER
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN10</name>
              <description>
              Indicates the wakeup status from PBR0 request. Note: the status is masked by WER
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN9</name>
              <description>
              Indicates the wakeup status from PA54 request. Note: the status is masked by WER
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN8</name>
              <description>
              Indicates the wakeup status from PA53 request. Note: the status is masked by WER
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN7</name>
              <description>
              Indicates the wakeup status from PA52 request. Note: the status is masked by WER
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN6</name>
              <description>
              Indicates the wakeup status from PA51 request. Note: the status is masked by WER
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN5</name>
              <description>
              Indicates the wakeup status from PA50 request. Note: the status is masked by WER
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN4</name>
              <description>
              Indicates the wakeup status from PB36 request. Note: the status is masked by WER
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN3</name>
              <description>
              Indicates the wakeup status from PB35 request. Note: the status is masked by WER
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN2</name>
              <description>
              Indicates the wakeup status from PB34 request. Note: the status is masked by WER
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN1</name>
              <description>
              Indicates the wakeup status from PB33 request. Note: the status is masked by WER
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN0</name>
              <description>
              Indicates the wakeup status from PB32 request. Note: the status is masked by WER
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LP2HP_IRQ</name>
              <description>
              Indicates the wakeup status from MAILBOX2. Note: the status is masked by WER
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LP2HP_REQ</name>
              <description>
              Indicates the wakeup status from LPSYS request. Note: the status is masked by WER
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>LPTIM1</name>
              <description>
              Indicates the wakeup status from LPTIM1. Note: the status is masked by WER
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GPIO1</name>
              <description>
              Indicates the wakeup status from IO(PA). Note: the status is masked by WER
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RTC</name>
              <description>
              Indicates the wakeup status from RTC. Note: the status is masked by WER
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>WCR</name>
          <displayName>WCR</displayName>
          <description>Wakeup Clear register</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>AON</name>
              <description>
              Write 1 to clear the AON wakeup IRQ status
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
            <field>
              <name>PIN13</name>
              <description>
              Write 1 to clear PBR3 wakeup source. Only valid if PIN wakeup is configured as edge trigger
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN12</name>
              <description>
              Write 1 to clear PBR2 wakeup source. Only valid if PIN wakeup is configured as edge trigger
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN11</name>
              <description>
              Write 1 to clear PBR1 wakeup source. Only valid if PIN wakeup is configured as edge trigger
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN10</name>
              <description>
              Write 1 to clear PBR0 wakeup source. Only valid if PIN wakeup is configured as edge trigger
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN9</name>
              <description>
              Write 1 to clear PA54 wakeup source. Only valid if PIN wakeup is configured as edge trigger
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN8</name>
              <description>
              Write 1 to clear PA53 wakeup source. Only valid if PIN wakeup is configured as edge trigger
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN7</name>
              <description>
              Write 1 to clear PA52 wakeup source. Only valid if PIN wakeup is configured as edge trigger
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN6</name>
              <description>
              Write 1 to clear PA51 wakeup source. Only valid if PIN wakeup is configured as edge trigger
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN5</name>
              <description>
              Write 1 to clear PA50 wakeup source. Only valid if PIN wakeup is configured as edge trigger
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN4</name>
              <description>
              Write 1 to clear PB36 wakeup source. Only valid if PIN wakeup is configured as edge trigger
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN3</name>
              <description>
              Write 1 to clear PB35 wakeup source. Only valid if PIN wakeup is configured as edge trigger
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN2</name>
              <description>
              Write 1 to clear PB34 wakeup source. Only valid if PIN wakeup is configured as edge trigger
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN1</name>
              <description>
              Write 1 to clear PB33 wakeup source. Only valid if PIN wakeup is configured as edge trigger
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN0</name>
              <description>
              Write 1 to clear PB32 wakeup source. Only valid if PIN wakeup is configured as edge trigger
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              Note: for LPTIM and RTC, clear the wakeup status directly in the orignal module
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ISSR</name>
          <displayName>ISSR</displayName>
          <description>Inter System Wakeup Register</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>26</bitWidth>
            </field>
            <field>
              <name>LP_ACTIVE</name>
              <description>
              read 1 indicates LPSYS is active
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HP_ACTIVE</name>
              <description>
              write 1 to indicates HPSYS is active
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>LP2HP_REQ</name>
              <description>
              indicate LPSYS request exists
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HP2LP_REQ</name>
              <description>
              write 1 to request LPSYS to stay in active mode
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ANACR</name>
          <displayName>ANACR</displayName>
          <description>Analog Control Register</description>
          <addressOffset>0x2c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>30</bitWidth>
            </field>
            <field>
              <name>VHP_ISO</name>
              <description>
              Set 1 to force off all HPSYS related analog modules
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PA_ISO</name>
              <description>
              Set 1 to force IO(PA) into retention mode
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>GTIMR</name>
          <displayName>GTIMR</displayName>
          <description>Global Timer Register</description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>CNT</name>
              <description>
              Global timer value
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RESERVE0</name>
          <displayName>RESERVE0</displayName>
          <description>Reserved Register 0</description>
          <addressOffset>0x34</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              for debug only
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RESERVE1</name>
          <displayName>RESERVE1</displayName>
          <description>Reserved Register 1</description>
          <addressOffset>0x38</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              for debug only
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>LPTIM1</name>
      <description></description>
      <groupName>LPTIM</groupName>
      <baseAddress>0x40041000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>ISR</name>
          <displayName>ISR</displayName>
          <description>LPTIM interrupt and status register</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>21</bitWidth>
            </field>
            <field>
              <name>OCWKUP</name>
              <description>
              Indicates output compare wakeup occurred
              The OCWKUP bit is set by hardware when LPTIM_CNT register value reached the LPTIM_CMP register's value. To clear OCWKUP, first  write 0 to the OCWE bit in the LPTIM_IER register to disable, then write 1 to the WKUPCLR bit in the LPTIM_ICR register. 
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OFWKUP</name>
              <description>
              Indicates overflow wakeup occurred
              OFWKUP is set by hardware when LPTIM_CNT register's value reached the LPTIM_ARR register's value and count from zero again. To clear OFWKUP, first  write 0 to the OFWE bit in the LPTIM_IER register to disable, then write 1 to the WKUPCLR bit in the LPTIM_ICR register. 
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UEWKUP</name>
              <description>
              Indicates update event wakeup occurred
              UEWKUP is set by hardware when an update event was generated (overflow occurred while repetition counter reached zero). To clear UEWKUP, first  write 0 to the UEWE bit in the LPTIM_IER register to disable, then write 1 to the WKUPCLR bit in the LPTIM_ICR register. 
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>ET</name>
              <description>
              External trigger edge event
              ET is set by hardware to inform application that a valid edge on the selected external trigger input has occurred. If the trigger is ignored because the timer has already started, then this flag is not set. ET flag can be cleared by writing 1 to the ETCLR bit in the LPTIM_ICR register.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OC</name>
              <description>
              Output compare match
              The OC bit is set by hardware to inform application that LPTIM_CNT register value reached the LPTIM_CMP register's value. OC flag can be cleared by writing 1 to the OCCLR bit in the LPTIM_ICR register.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OF</name>
              <description>
              Overflow occurred
              OF is set by hardware to inform application that LPTIM_CNT register's value reached the LPTIM_ARR register's value and count from zero again. OF flag can be cleared by writing 1 to the OFCLR bit in the LPTIM_ICR register.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UE</name>
              <description>
              LPTIM update event occurred
              UE is set by hardware to inform application that an update event was generated when overflow occurred while repetition counter reached zero. UE flag can be cleared by writing 1 to the UECLR bit in the LPTIM_ICR register. 
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ICR</name>
          <displayName>ICR</displayName>
          <description>LPTIM interrupt and status clear register</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>WKUPCLR</name>
              <description>
              wakeup status clear flag
              Writing 1 to this bit clears all wakeup status flags in the LPTIM_ISR register.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>ETCLR</name>
              <description>
              External trigger valid edge clear flag
              Writing 1 to this bit clears the ET flag in the LPTIM_ISR register
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OCCLR</name>
              <description>
              Output compare clear flag
              Writing 1 to this bit clears the OC flag in the LPTIM_ISR register
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OFCLR</name>
              <description>
              Overflow clear flag
              Writing 1 to this bit clears the OF flag in the LPTIM_ISR register
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UECLR</name>
              <description>
              Update event clear flag
              Writing 1 to this bit clear the UE flag in the LPTIM_ISR register.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IER</name>
          <displayName>IER</displayName>
          <description>LPTIM interrupt and wakeup enable register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>21</bitWidth>
            </field>
            <field>
              <name>OCWE</name>
              <description>
              Output compare Wakeup Enable
              0: Output compare wakeup disabled
              1: Output compare wakeup enabled
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OFWE</name>
              <description>
              Overflow Wakeup Enable
              0: Overflow Wakeup disabled
              1: Overflow Wakeup enabled
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UEWE</name>
              <description>
              Update event Wakeup enable
              0: Update event Wakeup disabled
              1: Update event Wakeup enabled
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>ETIE</name>
              <description>
              External trigger valid edge Interrupt Enable
              0: External trigger interrupt disabled
              1: External trigger interrupt enabled
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OCIE</name>
              <description>
              Output compare Interrupt Enable
              0: Output compare interrupt disabled
              1: Output compare interrupt enabled
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OFIE</name>
              <description>
              Overflow Interrupt Enable
              0: Overflow interrupt disabled
              1: Overflow interrupt enabled
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UEIE</name>
              <description>
              Update event interrupt enable
              0: Update event interrupt disabled
              1: Update event interrupt enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CFGR</name>
          <displayName>CFGR</displayName>
          <description>LPTIM configuration register</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>COUNTMODE</name>
              <description>
              counter mode in internal clock source mode (CKSEL=0). If CKSEL=1, this bit has no effect.
              0: the counter is incremented following each internal clock pulse
              1: the counter is incremented following each valid pulse on the external clock
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>WAVPOL</name>
              <description>
              Waveform shape polarity
              The WAVEPOL bit controls the output polarity
              0: The LPTIM output reflects the compare results between LPTIM_ARR and LPTIM_CMP registers
              1: The LPTIM output reflects the inverse of the compare results between LPTIM_ARR and LPTIM_CMP registers
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>WAVE</name>
              <description>
              Waveform shape
              The WAVE bit controls the output shape
              0: Deactivate Set-once mode
              1: Activate the Set-once mode
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TIMOUT</name>
              <description>
              Timeout enable
              The TIMOUT bit controls the Timeout feature
              0: A trigger event arriving when the timer is already started will be ignored
              1: A trigger event arriving when the timer is already started will reset and restart the LPTIM counter and the repetition counter
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TRIGEN</name>
              <description>
              Trigger enable and polarity
              The TRIGEN bits controls whether the LPTIM counter is started by an external trigger or not. If the external trigger option is selected, three configurations are possible for the trigger active edge:
              00: software trigger (counting start is initiated by software)
              01: rising edge is the active edge
              10: falling edge is the active edge
              11: both edges are active edges
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TRIGSEL</name>
              <description>
              Trigger selector
              The TRIGSEL bits select the trigger source that will serve as a trigger event for the LPTIM among the below 8 available sources:
              000: lptim_ext0
              001: lptim_ext1
              010: lptim_ext2
              011: lptim_ext3
              100: lptim_ext4
              101: lptim_ext5
              110: lptim_ext6
              111: lptim_ext7
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PRESC</name>
              <description>
              Clock prescaler
              The PRESC bits configure the prescaler division factor. It can be one among the following division factors:
              000: /1
              001: /2
              010: /4
              011: /8
              100: /16
              101: /32
              110: /64
              111: /128
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>EXTCKSEL</name>
              <description>
              External clock source selector
              0: external clock source is from lptim_in
              1: external clock source is from LPCOMP (if LPCOMP integrated)
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TRGFLT</name>
              <description>
              Configurable digital filter for trigger
              The TRGFLT value sets the number of consecutive equal samples that should be detected when a level change occurs on an internal trigger before it is considered as a valid level transition. An internal clock source must be present to use this feature
              00: any trigger active level change is considered as a valid trigger
              01: trigger active level change must be stable for at least 2 clock periods before it is considered as valid trigger.
              10: trigger active level change must be stable for at least 4 clock periods before it is considered as valid trigger.
              11: trigger active level change must be stable for at least 8 clock periods before it is considered as valid trigger.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>INTCKSEL</name>
              <description>
              Internal clock source selector
              0: internal clock source is clk_lp
              1: internal clock source is pclk2
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CKFLT</name>
              <description>
              Configurable digital filter for external clock
              The CKFLT value sets the number of consecutive equal samples that should be detected when a level change occurs on an external clock signal before it is considered as a valid level transition. An internal clock source must be present to use this feature
              00: any external clock signal level change is considered as a valid transition
              01: external clock signal level change must be stable for at least 2 clock periods before it is considered as valid transition.
              10: external clock signal level change must be stable for at least 4 clock periods before it is considered as valid transition.
              11: external clock signal level change must be stable for at least 8 clock periods before it is considered as valid transition.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>CKPOL</name>
              <description>
              Clock Polarity
              If LPTIM is clocked by an external clock source, CKPOL bits is used to configure the active edge or edges used by the counter:
              00: the rising edge is the active edge used for counting
              01: the falling edge is the active edge used for counting
              10: both edges are active edges. When both external clock signal edges are considered active ones, the LPTIM must also be clocked by an internal clock source with a frequency equal to at least four time the external clock frequency.
              11: not allowed
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>CKSEL</name>
              <description>
              Clock selector
              The CKSEL bit selects which clock source the LPTIM will use:
              0: LPTIM is clocked by internal clock source, according to INTCKSEL
              1: LPTIM is clocked by external clock source, according to EXTCKSEL
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CR</name>
          <displayName>CR</displayName>
          <description>LPTIM control register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>28</bitWidth>
            </field>
            <field>
              <name>COUNTRST</name>
              <description>
              Counter reset
              This bit is set by software and cleared by hardware. When set to 1 this bit will trigger a synchronous reset of the CNT register. Due to the synchronous nature of this reset, it only takes place after a synchronization delay.
              COUNTRST must never be set to 1 by software before it is already cleared to 0 by hardware. Software should consequently check that COUNTRST bit is already cleared to 0 before attempting to set it to 1.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CNTSTRT</name>
              <description>
              Timer start in Continuous mode
              This bit is set by software and cleared by hardware.
              In case of software start (TRIGEN[1:0] = 00), setting this bit starts the LPTIM in Continuous mode.
              If the software start is disabled (TRIGEN[1:0] different than 00), setting this bit starts the timer in Continuous mode as soon as an external trigger is detected.
              If this bit is set when a single pulse mode counting is ongoing, then the timer will not stop at the next match between ARR and CNT registers and the LPTIM counter keeps counting in Continuous mode.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SNGSTRT</name>
              <description>
              LPTIM start in Single mode
              This bit is set by software and cleared by hardware.
              In case of software start (TRIGEN[1:0] = 00), setting this bit starts the LPTIM in single pulse mode.
              If the software start is disabled (TRIGEN[1:0] different than 00), setting this bit starts the LPTIM in single pulse mode as soon as an external trigger is detected.
              If this bit is set when the LPTIM is in continuous counting mode, then the LPTIM will stop at the following match between ARR and CNT registers.
              If this bit is set simultaneously with CNTSTRT, then LPTIM will be in continuous counting mode.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ENABLE</name>
              <description>
              LPTIM enable
              The ENABLE bit is set and cleared by software. 
              0:LPTIM is disabled
              1:LPTIM is enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CMP</name>
          <displayName>CMP</displayName>
          <description>LPTIM compare register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>CMP</name>
              <description>
              Compare value
              CMP is the compare value used by the LPTIM.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ARR</name>
          <displayName>ARR</displayName>
          <description>LPTIM autoreload register</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>ARR</name>
              <description>
              Auto reload value
              ARR is the autoreload value for the LPTIM. This value must be strictly greater than the CMP[15:0] value.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CNT</name>
          <displayName>CNT</displayName>
          <description>LPTIM counter register</description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>CNT</name>
              <description>
              Counter value
              When the LPTIM is running with an asynchronous clock, reading the CNT register may return unreliable values. So in this case it is necessary to perform two consecutive read accesses and verify that the two returned values are identical.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RCR</name>
          <displayName>RCR</displayName>
          <description>LPTIM repetition register</description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>REP</name>
              <description>
              Repetition register value
              REP is the repetition value for the LPTIM.
              Read REP will return left repetition times. It should be noted that for a reliable REP register read access, two consecutive read accesses must be performed and compared. A read access can be considered reliable when the values of the two consecutive read accesses are equal.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>HPSYS_GPIO</name>
      <description></description>
      <groupName>HPSYS_GPIO</groupName>
      <baseAddress>0x40080000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>DIR0</name>
          <displayName>DIR0</displayName>
          <description>Data Input Register</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>IN</name>
              <description>
              GPIO[31:0] input value
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DOR0</name>
          <displayName>DOR0</displayName>
          <description>Data Output Register</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>OUT</name>
              <description>
              GPIO[31:0] output value if output enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DOSR0</name>
          <displayName>DOSR0</displayName>
          <description>Data Output  Set Register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>DOS</name>
              <description>
              set 1 to pull up output of corresponding GPIO[31:0]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DOCR0</name>
          <displayName>DOCR0</displayName>
          <description>Data Output  Clear Register</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>DOC</name>
              <description>
              set 1 to  pull down output of corresponding GPIO[31:0]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DOER0</name>
          <displayName>DOER0</displayName>
          <description>Data Output Enable Register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>DOE</name>
              <description>
              GPIO[31:0] output enable
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DOESR0</name>
          <displayName>DOESR0</displayName>
          <description>Data Output Enable Set Register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>DOES</name>
              <description>
              set 1 to enable output of corresponding GPIO[31:0]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DOECR0</name>
          <displayName>DOECR0</displayName>
          <description>Data Output Enable Clear Register</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>DOEC</name>
              <description>
              set 1 to disable output of corresponding GPIO[31:0]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IER0</name>
          <displayName>IER0</displayName>
          <description>Interrupt Enable Register</description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>IER</name>
              <description>
              GPIO[31:0]  interrupt  enable
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IESR0</name>
          <displayName>IESR0</displayName>
          <description>Interrupt Enable Set Register</description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>IES</name>
              <description>
              set 1 to enable interrupt of corresponding GPIO[31:0]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IECR0</name>
          <displayName>IECR0</displayName>
          <description>Interrupt Enable Clear Register</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>IEC</name>
              <description>
              set 1 to disable interrupt of corresponding GPIO[31:0]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ITR0</name>
          <displayName>ITR0</displayName>
          <description>Interrupt Type Register</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>ITR</name>
              <description>
              GPIO[31:0]  interrupt  type
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ITSR0</name>
          <displayName>ITSR0</displayName>
          <description>Interrupt Type Set Register</description>
          <addressOffset>0x2c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>ITS</name>
              <description>
              set 1 for edge-sensitive interrupt mode of corresponding GPIO[31:0]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ITCR0</name>
          <displayName>ITCR0</displayName>
          <description>Interrupt Type Clear Register</description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>ITC</name>
              <description>
              set 1 for level-sensitive interrupt mode of corresponding GPIO[31:0]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IPHR0</name>
          <displayName>IPHR0</displayName>
          <description>Interrupt Polarity High Register</description>
          <addressOffset>0x34</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>IPH</name>
              <description>
              rising edge in edge mode, or high level in level mode of corresponding GPIO[31:0]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IPHSR0</name>
          <displayName>IPHSR0</displayName>
          <description>Interrupt Polarity  High Set Register</description>
          <addressOffset>0x38</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>IPHS</name>
              <description>
              set 1 for rising edge in edge mode, or high level in level mode of corresponding GPIO[31:0]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IPHCR0</name>
          <displayName>IPHCR0</displayName>
          <description>Interrupt Polarity  High Clear  Register</description>
          <addressOffset>0x3c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>IPHC</name>
              <description>
              set 1 for disable rising edge in edge mode, or high level in level mode of corresponding GPIO[31:0]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IPLR0</name>
          <displayName>IPLR0</displayName>
          <description>Interrupt Polarity Low Register</description>
          <addressOffset>0x40</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>IPL</name>
              <description>
              falling edge in edge mode, or low level in level mode of corresponding GPIO[31:0]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IPLSR0</name>
          <displayName>IPLSR0</displayName>
          <description>Interrupt Polarity Low Set Register</description>
          <addressOffset>0x44</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>IPLS</name>
              <description>
              set 1 for falling edge in edge mode, or low level in level mode of corresponding GPIO[31:0]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IPLCR0</name>
          <displayName>IPLCR0</displayName>
          <description>Interrupt Polarity Low Clear Register</description>
          <addressOffset>0x48</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>IPLC</name>
              <description>
              set 1 for disable falling edge in edge mode, or low level in level mode of corresponding GPIO[31:0]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ISR0</name>
          <displayName>ISR0</displayName>
          <description>Interrupt Status Register</description>
          <addressOffset>0x4c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>IS</name>
              <description>
              Interrupt status. Write 1 will clear interrupt status of corresponding GPIO[31:0]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD5</name>
          <displayName>RSVD5</displayName>
          <description></description>
          <addressOffset>0x50</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>OEMR0</name>
          <displayName>OEMR0</displayName>
          <description>output mode Register</description>
          <addressOffset>0x60</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>OEM</name>
              <description>
              output mode of corresponding GPIO[31:0]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>OEMSR0</name>
          <displayName>OEMSR0</displayName>
          <description>output mode Set Register</description>
          <addressOffset>0x64</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>OEMS</name>
              <description>
              output mode Set of corresponding GPIO[31:0]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>OEMCR0</name>
          <displayName>OEMCR0</displayName>
          <description>output mode Clear Register</description>
          <addressOffset>0x68</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>OEMC</name>
              <description>
              output mode Clear of corresponding GPIO[31:0]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD4</name>
          <displayName>RSVD4</displayName>
          <description></description>
          <addressOffset>0x6C</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>DIR1</name>
          <displayName>DIR1</displayName>
          <description>Data Input Register</description>
          <addressOffset>0x80</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>IN</name>
              <description>
              GPIO[63:32] input value
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DOR1</name>
          <displayName>DOR1</displayName>
          <description>Data Output Register</description>
          <addressOffset>0x84</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>OUT</name>
              <description>
              GPIO[63:32] output value if output enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DOSR1</name>
          <displayName>DOSR1</displayName>
          <description>Data Output  Set Register</description>
          <addressOffset>0x88</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>DOS</name>
              <description>
              set 1 to pull up output of corresponding GPIO[63:32]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DOCR1</name>
          <displayName>DOCR1</displayName>
          <description>Data Output  Clear Register</description>
          <addressOffset>0x8c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>DOC</name>
              <description>
              set 1 to  pull down output of corresponding GPIO[63:32]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DOER1</name>
          <displayName>DOER1</displayName>
          <description>Data Output Enable Register</description>
          <addressOffset>0x90</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>DOE</name>
              <description>
              GPIO[63:32] output enable
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DOESR1</name>
          <displayName>DOESR1</displayName>
          <description>Data Output Enable Set Register</description>
          <addressOffset>0x94</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>DOES</name>
              <description>
              set 1 to enable output of corresponding GPIO[63:32]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DOECR1</name>
          <displayName>DOECR1</displayName>
          <description>Data Output Enable Clear Register</description>
          <addressOffset>0x98</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>DOEC</name>
              <description>
              set 1 to disable output of corresponding GPIO[63:32]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IER1</name>
          <displayName>IER1</displayName>
          <description>Interrupt Enable Register</description>
          <addressOffset>0x9c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>IER</name>
              <description>
              GPIO[63:32]  interrupt  enable
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IESR1</name>
          <displayName>IESR1</displayName>
          <description>Interrupt Enable Set Register</description>
          <addressOffset>0xa0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>IES</name>
              <description>
              set 1 to enable interrupt of corresponding GPIO[63:32]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IECR1</name>
          <displayName>IECR1</displayName>
          <description>Interrupt Enable Clear Register</description>
          <addressOffset>0xa4</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>IEC</name>
              <description>
              set 1 to disable interrupt of corresponding GPIO[63:32]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ITR1</name>
          <displayName>ITR1</displayName>
          <description>Interrupt Type Register</description>
          <addressOffset>0xa8</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>ITR</name>
              <description>
              GPIO[63:32]  interrupt  type
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ITSR1</name>
          <displayName>ITSR1</displayName>
          <description>Interrupt Type Set Register</description>
          <addressOffset>0xac</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>ITS</name>
              <description>
              set 1 for edge-sensitive interrupt mode of corresponding GPIO[63:32]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ITCR1</name>
          <displayName>ITCR1</displayName>
          <description>Interrupt Type Clear Register</description>
          <addressOffset>0xb0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>ITC</name>
              <description>
              set 1 for level-sensitive interrupt mode of corresponding GPIO[63:32]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IPHR1</name>
          <displayName>IPHR1</displayName>
          <description>Interrupt Polarity High Register</description>
          <addressOffset>0xb4</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>IPH</name>
              <description>
              rising edge in edge mode, or high level in level mode of corresponding GPIO[63:32]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IPHSR1</name>
          <displayName>IPHSR1</displayName>
          <description>Interrupt Polarity  High Set Register</description>
          <addressOffset>0xb8</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>IPHS</name>
              <description>
              set 1 for rising edge in edge mode, or high level in level mode of corresponding GPIO[63:32]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IPHCR1</name>
          <displayName>IPHCR1</displayName>
          <description>Interrupt Polarity  High Clear  Register</description>
          <addressOffset>0xbc</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>IPHC</name>
              <description>
              set 1 for disable rising edge in edge mode, or high level in level mode of corresponding GPIO[63:32]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IPLR1</name>
          <displayName>IPLR1</displayName>
          <description>Interrupt Polarity Low Register</description>
          <addressOffset>0xc0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>IPL</name>
              <description>
              falling edge in edge mode, or low level in level mode of corresponding GPIO[63:32]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IPLSR1</name>
          <displayName>IPLSR1</displayName>
          <description>Interrupt Polarity Low Set Register</description>
          <addressOffset>0xc4</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>IPLS</name>
              <description>
              set 1 for falling edge in edge mode, or low level in level mode of corresponding GPIO[63:32]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IPLCR1</name>
          <displayName>IPLCR1</displayName>
          <description>Interrupt Polarity Low Clear Register</description>
          <addressOffset>0xc8</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>IPLC</name>
              <description>
              set 1 for disable falling edge in edge mode, or low level in level mode of corresponding GPIO[63:32]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ISR1</name>
          <displayName>ISR1</displayName>
          <description>Interrupt Status Register</description>
          <addressOffset>0xcc</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>IS</name>
              <description>
              Interrupt status. Write 1 will clear interrupt status of corresponding GPIO[63:32] 
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD3</name>
          <displayName>RSVD3</displayName>
          <description></description>
          <addressOffset>0xD0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>OEMR1</name>
          <displayName>OEMR1</displayName>
          <description>output mode Register</description>
          <addressOffset>0xe0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>OEM</name>
              <description>
              output mode of corresponding GPIO[63:32]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>OEMSR1</name>
          <displayName>OEMSR1</displayName>
          <description>output mode Set Register</description>
          <addressOffset>0xe4</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>OEMS</name>
              <description>
              output mode Set of corresponding GPIO[63:32]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>OEMCR1</name>
          <displayName>OEMCR1</displayName>
          <description>output mode Clear Register</description>
          <addressOffset>0xe8</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>OEMC</name>
              <description>
              output mode Clear of corresponding GPIO[63:32]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD2</name>
          <displayName>RSVD2</displayName>
          <description></description>
          <addressOffset>0xEC</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>DIR2</name>
          <displayName>DIR2</displayName>
          <description>Data Input Register</description>
          <addressOffset>0x100</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
            <field>
              <name>IN</name>
              <description>
              GPIO[78:64] input value
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>15</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DOR2</name>
          <displayName>DOR2</displayName>
          <description>Data Output Register</description>
          <addressOffset>0x104</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
            <field>
              <name>OUT</name>
              <description>
              GPIO[78:64] output value if output enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>15</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DOSR2</name>
          <displayName>DOSR2</displayName>
          <description>Data Output  Set Register</description>
          <addressOffset>0x108</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
            <field>
              <name>DOS</name>
              <description>
              set 1 to pull up output of corresponding GPIO[78:64]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>15</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DOCR2</name>
          <displayName>DOCR2</displayName>
          <description>Data Output  Clear Register</description>
          <addressOffset>0x10c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
            <field>
              <name>DOC</name>
              <description>
              set 1 to  pull down output of corresponding GPIO[78:64]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>15</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DOER2</name>
          <displayName>DOER2</displayName>
          <description>Data Output Enable Register</description>
          <addressOffset>0x110</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
            <field>
              <name>DOE</name>
              <description>
              GPIO[78:64] output enable
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>15</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DOESR2</name>
          <displayName>DOESR2</displayName>
          <description>Data Output Enable Set Register</description>
          <addressOffset>0x114</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
            <field>
              <name>DOES</name>
              <description>
              set 1 to enable output of corresponding GPIO[78:64]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>15</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DOECR2</name>
          <displayName>DOECR2</displayName>
          <description>Data Output Enable Clear Register</description>
          <addressOffset>0x118</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
            <field>
              <name>DOEC</name>
              <description>
              set 1 to disable output of corresponding GPIO[78:64]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>15</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IER2</name>
          <displayName>IER2</displayName>
          <description>Interrupt Enable Register</description>
          <addressOffset>0x11c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
            <field>
              <name>IER</name>
              <description>
              GPIO[78:64]  interrupt  enable
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>15</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IESR2</name>
          <displayName>IESR2</displayName>
          <description>Interrupt Enable Set Register</description>
          <addressOffset>0x120</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
            <field>
              <name>IES</name>
              <description>
              set 1 to enable interrupt of corresponding GPIO[78:64]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>15</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IECR2</name>
          <displayName>IECR2</displayName>
          <description>Interrupt Enable Clear Register</description>
          <addressOffset>0x124</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
            <field>
              <name>IEC</name>
              <description>
              set 1 to disable interrupt of corresponding GPIO[78:64]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>15</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ITR2</name>
          <displayName>ITR2</displayName>
          <description>Interrupt Type Register</description>
          <addressOffset>0x128</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
            <field>
              <name>ITR</name>
              <description>
              GPIO[78:64]  interrupt  type
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>15</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ITSR2</name>
          <displayName>ITSR2</displayName>
          <description>Interrupt Type Set Register</description>
          <addressOffset>0x12c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
            <field>
              <name>ITS</name>
              <description>
              set 1 for edge-sensitive interrupt mode of corresponding GPIO[78:64]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>15</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ITCR2</name>
          <displayName>ITCR2</displayName>
          <description>Interrupt Type Clear Register</description>
          <addressOffset>0x130</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
            <field>
              <name>ITC</name>
              <description>
              set 1 for level-sensitive interrupt mode of corresponding GPIO[78:64]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>15</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IPHR2</name>
          <displayName>IPHR2</displayName>
          <description>Interrupt Polarity High Register</description>
          <addressOffset>0x134</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
            <field>
              <name>IPH</name>
              <description>
              rising edge in edge mode, or high level in level mode of corresponding GPIO[78:64]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>15</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IPHSR2</name>
          <displayName>IPHSR2</displayName>
          <description>Interrupt Polarity  High Set Register</description>
          <addressOffset>0x138</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
            <field>
              <name>IPHS</name>
              <description>
              set 1 for rising edge in edge mode, or high level in level mode of corresponding GPIO[78:64]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>15</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IPHCR2</name>
          <displayName>IPHCR2</displayName>
          <description>Interrupt Polarity  High Clear  Register</description>
          <addressOffset>0x13c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
            <field>
              <name>IPHC</name>
              <description>
              set 1 for disable rising edge in edge mode, or high level in level mode of corresponding GPIO[78:64]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>15</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IPLR2</name>
          <displayName>IPLR2</displayName>
          <description>Interrupt Polarity Low Register</description>
          <addressOffset>0x140</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
            <field>
              <name>IPL</name>
              <description>
              falling edge in edge mode, or low level in level mode of corresponding GPIO[78:64]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>15</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IPLSR2</name>
          <displayName>IPLSR2</displayName>
          <description>Interrupt Polarity Low Set Register</description>
          <addressOffset>0x144</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
            <field>
              <name>IPLS</name>
              <description>
              set 1 for falling edge in edge mode, or low level in level mode of corresponding GPIO[78:64]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>15</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IPLCR2</name>
          <displayName>IPLCR2</displayName>
          <description>Interrupt Polarity Low Clear Register</description>
          <addressOffset>0x148</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
            <field>
              <name>IPLC</name>
              <description>
              set 1 for disable falling edge in edge mode, or low level in level mode of corresponding GPIO[78:64]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>15</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ISR2</name>
          <displayName>ISR2</displayName>
          <description>Interrupt Status Register</description>
          <addressOffset>0x14c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Interrupt status. Write 1 will clear interrupt status of corresponding GPIO[78:64]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>15</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD1</name>
          <displayName>RSVD1</displayName>
          <description></description>
          <addressOffset>0x150</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>OEMR2</name>
          <displayName>OEMR2</displayName>
          <description>output mode Register</description>
          <addressOffset>0x160</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
            <field>
              <name>OEM</name>
              <description>
              output mode of corresponding GPIO[78:64]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>15</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>OEMSR2</name>
          <displayName>OEMSR2</displayName>
          <description>output mode Set Register</description>
          <addressOffset>0x164</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
            <field>
              <name>OEMS</name>
              <description>
              output mode Set of corresponding GPIO[78:64]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>15</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>OEMCR2</name>
          <displayName>OEMCR2</displayName>
          <description>output mode Clear Register</description>
          <addressOffset>0x168</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
            <field>
              <name>OEMC</name>
              <description>
              output mode Clear of corresponding GPIO[78:64]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>15</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>MPI1</name>
      <description></description>
      <groupName>MPI</groupName>
      <baseAddress>0x40081000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CR</name>
          <displayName>CR</displayName>
          <description>Control Register</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ABORT</name>
              <description>
              Write 1 to abort internal state machine. For debug purpose only
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>AHBDIS</name>
              <description>
              Hold hreadyout low if AHB access
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DFM</name>
              <description>
              Dual Flash ModeReserved-Do not modify
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MX16</name>
              <description>
              Mode X16Reserved-Do not modify
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PREFE</name>
              <description>
              Prefetch enable. If enabled, MPI will prefetch at consequtive address following a read transaction. 
              Recommend to use when reading large data in a burst manner.
              0: prefetch disabled
              1: prefetch enabled
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OPIE</name>
              <description>
              OPI interface enable
              0: x8 mode disabled
              1: x8 mode enabled
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HWIFE</name>
              <description>
              Hardware interface enableReserved-Do not modify
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SMM</name>
              <description>
              Status match mode
              0: AND mode
              1: OR mode
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SME2</name>
              <description>
              Status match enable. If enabled, CMD2 will be issued repeatedly until the data match the value in SMR and SMKR
              0: disabled
              1: enabled
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SME1</name>
              <description>
              Status match enable. If enabled, CMD1 will be issued repeatedly until the data match the value in SMR and SMKR
              0: disabled
              1: enabled (either SME1 or SME2 can be enabled, and SME1 has high priority)
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CMD2E</name>
              <description>
              Enable CMD2
              0: disabled
              1: CMD2 is enabled and will be issued after CMD1 with an interval of TI2
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RBXIE</name>
              <description>
              Row boundary crossing interrupt enable
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CSVIE</name>
              <description>
              CS max violation interrupt enable
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SMIE</name>
              <description>
              Status match interrupt enable
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIE</name>
              <description>
              Transfer complete interrupt enable
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTRM</name>
              <description>
              AES-CTR mode
              0: AES-128
              1: AES-256
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTRE</name>
              <description>
              AES-CTR on-the-fly decryption enable
              0: disabled
              1: enabled, data read from memory will be decrypted on the fly by MPI controller
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMAE</name>
              <description>
              DMA enable
              0: disabled
              1: enable DMA to read or write DR register
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HOLD</name>
              <description>
              The value of HOLD when HOLDE is set
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HOLDE</name>
              <description>
              Enable HOLD function on IO3. Use this only in SPI or Dual SPI mode
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>WP</name>
              <description>
              The value of WP when WPE is set
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>WPE</name>
              <description>
              Enable WP function on IO2. Use this only in SPI or Dual SPI mode
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EN</name>
              <description>
              Enable MPI
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DR</name>
          <displayName>DR</displayName>
          <description>Data Register</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              The entry of internal data FIFO
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DCR</name>
          <displayName>DCR</displayName>
          <description>Device Control Register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>FIXLAT</name>
              <description>
              Indicate PSRAM is fixed latency or variable latency. It must be compatible to the configuration in PSRAM registers.
              Recommend always set to 1.
              0: variable latency
              1: fixed latency
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TRCMIN</name>
              <description>
              Write/Read cycle minimum time in internal MCLK cycles. Please see MCLK frequency in PSCLR description.
              For example, if PSRAM clock is 120MHz (i.e. internal MCLK is 240MHz) and TRCMIN = n, then
              tRC time = (n+1) * 1000/240 ns which must meet minimum tRC requirement for PSRAM
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>CSHMIN</name>
              <description>
              Minimum CS high deselect time in MCLK cycles.
              For example, if PSRAM clock is 120MHz (i.e. internal MCLK is 240MHz) and CSHMIN = n, then
              CS High time = (n+1) * 1000/240 ns which must meet minimum tCPH requirement for PSRAM
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>CSLMIN</name>
              <description>
              Minimum CS low active time in MCLK cycles.
              For example, if PSRAM clock is 120MHz (i.e. internal MCLK is 240MHz) and CSLMIN = n, then
              CS Low time = (n+1) * 1000/240 ns which must meet the minimum tCEM requirement for PSRAM
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>CSLMAX</name>
              <description>
              Maximum CS low active time in MCLK cycles
              For example, if PSRAM clock is 120MHz (i.e. internal MCLK is 240MHz) and CSLMAX = n, then
              CS Low time = (n+1) * 1000/240 ns which must meet the maximum tCEM requirement for PSRAM
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
            <field>
              <name>XLEGACY</name>
              <description>
              Xccela legacy protocol. Set to 1 for AP 32Mb PSRAM only, othersize always set to 0.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HYPER</name>
              <description>
              HyperBus protocol. Set to 1 for HyperRAM.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DQSE</name>
              <description>
              DQS enable. Setting to 1 indicates device provides DQS signal for Rx data latching
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RBSIZE</name>
              <description>
              Row boundary size.
              0: no row boundary
              1: 2^(1+3) = 16 bytes
              2: 2^(2+3) = 32 bytes
              
              n: 2^(n+3) bytes
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PSCLR</name>
          <displayName>PSCLR</displayName>
          <description>Prescaler Register</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>DIV</name>
              <description>
              Prescaler divider.
              0: MCLK = FCLK/1
              1: MCLK = FCLK/1
              2: MCLK = FCLK/2
              n: MCLK = FCLK/n
              Note: FLASH clock = MCLK. E.g. FCLK=192M and DIV=2, then FLASH clock = MCLK = 192/2 = 96MHz
              PSRAM clock = MCLK/2. E.g. FCLK=240M and DIV=1, then PSRAM clock = MCLK/2 = 240/2 = 120MHz
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SR</name>
          <displayName>SR</displayName>
          <description>Status Register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000006</resetValue>
          <fields>
            <field>
              <name>BUSY</name>
              <description>
              For debug purpose only
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>25</bitWidth>
            </field>
            <field>
              <name>RBXF</name>
              <description>
              Row boundary crossing flag
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CSVF</name>
              <description>
              CS max violation flag
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SMF</name>
              <description>
              Status match flag in Polling Mode
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCF</name>
              <description>
              Transfer complete flag
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SCR</name>
          <displayName>SCR</displayName>
          <description>Status Clear Register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>26</bitWidth>
            </field>
            <field>
              <name>RBXFC</name>
              <description>
              Write 1 to clear RBXF
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CSVFC</name>
              <description>
              Write 1 to clear CSVF
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SMFC</name>
              <description>
              Write 1 to clear SMF
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCFC</name>
              <description>
              Write 1 to clear TCF
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CMDR1</name>
          <displayName>CMDR1</displayName>
          <description>Command Register</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>CMD</name>
              <description>
              Command. Write to this register will trigger the sequence specified in CCR1
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>AR1</name>
          <displayName>AR1</displayName>
          <description>Address Register</description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ADDR</name>
              <description>
              Address
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ABR1</name>
          <displayName>ABR1</displayName>
          <description>Alternate Byte Register</description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ABYTE</name>
              <description>
              Alternate byte
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DLR1</name>
          <displayName>DLR1</displayName>
          <description>Data Length Register</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
            <field>
              <name>DLEN</name>
              <description>
              Data length
              0: one byte
              1: two bytes
              
              n: (n+1) bytes
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR1</name>
          <displayName>CCR1</displayName>
          <description>Communication Configuration Register</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
            <field>
              <name>FMODE</name>
              <description>
              Function Mode
              0: read mode
              1: write mode
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMODE</name>
              <description>
              Data Mode
              0: no data phase
              1: single line
              2: dual lines
              3: quad lines
              4/5/6: reserved
              7: quad lines DDR
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>DCYC</name>
              <description>
              Number of dummy cycles
              0: no dummy cycle
              1: one dummy cycle
              2: two dummy cycles
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>ABSIZE</name>
              <description>
              Alternate byte size
              0: one byte
              1: two bytes
              2: three bytes
              3: four bytes
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>ABMODE</name>
              <description>
              Alternate byte mode
              0: no alternate byte
              1: single line
              2: dual lines
              3: quad lines
              4/5/6: reserved
              7: quad lines DDR
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>ADSIZE</name>
              <description>
              Address size
              0: one byte
              1: two bytes
              2: three bytes
              3: four bytes
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>ADMODE</name>
              <description>
              Address mode
              0: no address phase
              1: single line
              2: dual line
              3: quad line
              4/5/6: reserved
              7: quad line DDR
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>IMODE</name>
              <description>
              Instruction mode
              0: no instruction phase
              1: single line
              2: dual lines
              3: quad lines
              4/5/6 - reserved
              7 - quad lines DDR
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CMDR2</name>
          <displayName>CMDR2</displayName>
          <description>Command Register</description>
          <addressOffset>0x2c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>CMD</name>
              <description>
              Command 2. If CMD2E is enabled, the CMD2 sequence will be issued after CMD1 as specified in CCR2
              Note: CMD2 sequence cannot be issue individually
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>AR2</name>
          <displayName>AR2</displayName>
          <description>Address Register</description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ADDR</name>
              <description>
              Address byte in CMD2 sequence
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ABR2</name>
          <displayName>ABR2</displayName>
          <description>Alternate Byte Register</description>
          <addressOffset>0x34</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ABYTE</name>
              <description>
              Alternate byte in CMD2 sequence
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DLR2</name>
          <displayName>DLR2</displayName>
          <description>Data Length Register</description>
          <addressOffset>0x38</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
            <field>
              <name>DLEN</name>
              <description>
              Data length in CMD2 sequence
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR2</name>
          <displayName>CCR2</displayName>
          <description>Communication Configuration Register</description>
          <addressOffset>0x3c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
            <field>
              <name>FMODE</name>
              <description>
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMODE</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>DCYC</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>ABSIZE</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>ABMODE</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>ADSIZE</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>ADMODE</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>IMODE</name>
              <description>
              This register specifies the format of CMD2 sequence. Refer to CCR1 description
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>HCMDR</name>
          <displayName>HCMDR</displayName>
          <description>AHB Command Register</description>
          <addressOffset>0x40</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>WCMD</name>
              <description>
              AHB write command. During XIP, the AHB write transaction will be translated into this Write Command on memory interface
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>RCMD</name>
              <description>
              AHB read command. During XIP, the AHB read transaction will be translated into this Read Command on memory interface
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>HRABR</name>
          <displayName>HRABR</displayName>
          <description>AHB Read Alternate Byte Register</description>
          <addressOffset>0x44</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ABYTE</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>HRCCR</name>
          <displayName>HRCCR</displayName>
          <description>AHB Read Communication Configuration Register</description>
          <addressOffset>0x48</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
            <field>
              <name>DMODE</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>DCYC</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>ABSIZE</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>ABMODE</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>ADSIZE</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>ADMODE</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>IMODE</name>
              <description>
              This register specifies the format of AHB read command sequence. Refer to CCR1 description
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>HWABR</name>
          <displayName>HWABR</displayName>
          <description>AHB Write Alternate Byte Register</description>
          <addressOffset>0x4c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ABYTE</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>HWCCR</name>
          <displayName>HWCCR</displayName>
          <description>AHB Write Communication Configuration Register</description>
          <addressOffset>0x50</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
            <field>
              <name>DMODE</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>DCYC</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>ABSIZE</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>ABMODE</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>ADSIZE</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>ADMODE</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>IMODE</name>
              <description>
              This register specifies the format of AHB write command sequence. Refer to CCR1 description
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>FIFOCR</name>
          <displayName>FIFOCR</displayName>
          <description>FIFO Control Register</description>
          <addressOffset>0x54</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
            <field>
              <name>TXSLOTS</name>
              <description>
              When DMA enabled, asserts DMA reqeust if TXFIFO vacant slots is greater than or equal to TXSLOTS.
              Note: this field should be set in accordance to the burst length in DMA. For example, if DMA employs BURST8 transction, then this filed is set to 8
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>TXF</name>
              <description>
              Tx FIFO full flag
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TXCLR</name>
              <description>
              write 1 to clear Tx FIFO
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>RXE</name>
              <description>
              Rx FIFO empty
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RXCLR</name>
              <description>
              write 1 to clear Rx FIFO
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>MISCR</name>
          <displayName>MISCR</displayName>
          <description>Miscelaneous Register</description>
          <addressOffset>0x58</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DBGSEL</name>
              <description>
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DTRPRE</name>
              <description>
              Enable pre-sampling for DTRReserved-Do not modify
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SCKINV</name>
              <description>
              Invert output clock. This bit is used to align (coarse tune) the output clock to the center of output data.
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RXCLKINV</name>
              <description>
              Invert internal Rx clock to add half-cycle delay (coarse tune) when sampling data. It is usually used for FLASH device w/ higher frequency.
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DQSDLY</name>
              <description>
              Delay the input DQS signal to the appropriate sampling position.  For device w/ DQS signal only. Note: effective 7-bit
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>SCKDLY</name>
              <description>
              Add delay on output clock to fine tune the clock position. Note: effective 7-bit
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>RXCLKDLY</name>
              <description>
              Add delay on internal Rx clock  to fine tune the sampling position. Note: effective 5-bit
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CTRSAR</name>
          <displayName>CTRSAR</displayName>
          <description>CTR Starting Address Register</description>
          <addressOffset>0x5c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>SA</name>
              <description>
              Starting address of the AES decryption area. Since the lowest 10 bits are zero, the address is always 1KB aligned.
              Together with CTREAR, the total area is [CTRSAR, CTREAR)
              For example, CTRSAR = 32'h0, CTREAR = 32'h200000, then the on-the-fly decryption area is 0x0 - 0x1FFFFF
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>22</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CTREAR</name>
          <displayName>CTREAR</displayName>
          <description>CTR Ending Address Register</description>
          <addressOffset>0x60</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>EA</name>
              <description>
              Ending address of the AES decryption area
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>22</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>NONCEA</name>
          <displayName>NONCEA</displayName>
          <description>Nonce A Register</description>
          <addressOffset>0x64</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>NONCEA</name>
              <description>
              Used for on-the-fly decryption
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>NONCEB</name>
          <displayName>NONCEB</displayName>
          <description>Nonce B Register</description>
          <addressOffset>0x68</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>NONCEB</name>
              <description>
              Used for on-the-fly decryption
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>AASAR</name>
          <displayName>AASAR</displayName>
          <description>Address Aliasing Start Address Register</description>
          <addressOffset>0x6c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>SA</name>
              <description>
              Starting address of the address aliasing area. Always 1KB aligned.Together with AAEAR, the aliasing area is [AASAR, AAEAR). 
              If the address falls into this area, an offset AAOAR is added and the aliased address will be used to access external memory
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>22</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>AAEAR</name>
          <displayName>AAEAR</displayName>
          <description>Address Aliasing Ending Address Register</description>
          <addressOffset>0x70</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>EA</name>
              <description>
              Ending address of the address aliasing area
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>22</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>AAOAR</name>
          <displayName>AAOAR</displayName>
          <description>Address Aliasing Offset Address Register</description>
          <addressOffset>0x74</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>OA</name>
              <description>
              The offset to be added to the original address
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>22</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CIR</name>
          <displayName>CIR</displayName>
          <description>Command Interval Register</description>
          <addressOffset>0x78</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>INTERVAL2</name>
              <description>
              The interval between CMD1 and CMD2 (or between CMD2 itself) if CMD2E is enabled. The unit is in MCLK cycles
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>INTERVAL1</name>
              <description>
              The interval between CMD1 itself. The unit is in MCLK cycles
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SMR</name>
          <displayName>SMR</displayName>
          <description>Status Match Register</description>
          <addressOffset>0x7c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>STATUS</name>
              <description>
              If status match is enabled, this register is compared with the data read from external memory.
              Together with SMKR, only the bits with mask=1 will be considered to compare in AND or OR mode as configured in SMM field.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SMKR</name>
          <displayName>SMKR</displayName>
          <description>Status Mask Register</description>
          <addressOffset>0x80</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>MASK</name>
              <description>
              Status mask
              0: the corresponding bit is not considered to compare
              1: the corresponding bit is considered to compare
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TIMR</name>
          <displayName>TIMR</displayName>
          <description>Timer Register</description>
          <addressOffset>0x84</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>TIMEOUT</name>
              <description>
              After the transaction is complete, CS remains low for multiple cycles of MCLK as specified by this register.
              For example if TIMEOUT=n, CS remains active for n cycles, during which if a new transaction occurs and the address is consecutive, the memory access can be resumed w/o sending the command and address again.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>WDTR</name>
          <displayName>WDTR</displayName>
          <description>WDT Register</description>
          <addressOffset>0x88</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>TOF</name>
              <description>
              Timeout flag. Self cleared when HREADYOUT becomes ready
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>14</bitWidth>
            </field>
            <field>
              <name>EN</name>
              <description>
              WDT enable. This watchdog is on AHB side such that bus access will not hang in exceptional cases
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TIMEOUT</name>
              <description>
              Set timeout value in number of clk_wdt cycles
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PRSAR</name>
          <displayName>PRSAR</displayName>
          <description>Prefetch Starting Address Register</description>
          <addressOffset>0x8c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>SA</name>
              <description>
              Starting address of the prefetch area
              If prefetch is enabled and the read address falls into [PRSAR, PREAR), controller will prefetch the following data
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>22</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PREAR</name>
          <displayName>PREAR</displayName>
          <description>Prefetch Ending Address Register</description>
          <addressOffset>0x90</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>EA</name>
              <description>
              Ending address of the prefetch area
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>22</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CALCR</name>
          <displayName>CALCR</displayName>
          <description>Calibration Clock Register</description>
          <addressOffset>0x94</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>EN</name>
              <description>
              calibration enable
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>22</bitWidth>
            </field>
            <field>
              <name>DONE</name>
              <description>
              calibration done flag
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DELAY</name>
              <description>
              calibration delay result
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>APM32CR</name>
          <displayName>APM32CR</displayName>
          <description>APM32 Control Register</description>
          <addressOffset>0x98</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>TCPHW</name>
              <description>
              For special use by AP 32Mb PSRAM.Reserved-Do not modify
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>TCPHR</name>
              <description>
              For special use by AP 32Mb PSRAM.Reserved-Do not modify
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CR2</name>
          <displayName>CR2</displayName>
          <description>Control Register 2</description>
          <addressOffset>0x9c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>LOOP</name>
              <description>
              Repeat CMD1->CMD2 sequence for n times. This filed is only valid when CMD2E=1 and SME2=0.
              For example if LOOP=0, then the sequence is CMD1 -> CMD2.
              If LOOP=2, then the sequence is (CMD1->CMD2) -> (CMD1->CMD2) -> (CMD1->CMD2)
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>MPI2</name>
      <description></description>
      <groupName>MPI</groupName>
      <baseAddress>0x40082000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CR</name>
          <displayName>CR</displayName>
          <description>Control Register</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ABORT</name>
              <description>
              Write 1 to abort internal state machine. For debug purpose only
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>AHBDIS</name>
              <description>
              Hold hreadyout low if AHB access
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DFM</name>
              <description>
              Dual Flash ModeReserved-Do not modify
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MX16</name>
              <description>
              Mode X16Reserved-Do not modify
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PREFE</name>
              <description>
              Prefetch enable. If enabled, MPI will prefetch at consequtive address following a read transaction. 
              Recommend to use when reading large data in a burst manner.
              0: prefetch disabled
              1: prefetch enabled
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OPIE</name>
              <description>
              OPI interface enable
              0: x8 mode disabled
              1: x8 mode enabled
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HWIFE</name>
              <description>
              Hardware interface enableReserved-Do not modify
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SMM</name>
              <description>
              Status match mode
              0: AND mode
              1: OR mode
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SME2</name>
              <description>
              Status match enable. If enabled, CMD2 will be issued repeatedly until the data match the value in SMR and SMKR
              0: disabled
              1: enabled
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SME1</name>
              <description>
              Status match enable. If enabled, CMD1 will be issued repeatedly until the data match the value in SMR and SMKR
              0: disabled
              1: enabled (either SME1 or SME2 can be enabled, and SME1 has high priority)
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CMD2E</name>
              <description>
              Enable CMD2
              0: disabled
              1: CMD2 is enabled and will be issued after CMD1 with an interval of TI2
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RBXIE</name>
              <description>
              Row boundary crossing interrupt enable
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CSVIE</name>
              <description>
              CS max violation interrupt enable
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SMIE</name>
              <description>
              Status match interrupt enable
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIE</name>
              <description>
              Transfer complete interrupt enable
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTRM</name>
              <description>
              AES-CTR mode
              0: AES-128
              1: AES-256
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTRE</name>
              <description>
              AES-CTR on-the-fly decryption enable
              0: disabled
              1: enabled, data read from memory will be decrypted on the fly by MPI controller
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMAE</name>
              <description>
              DMA enable
              0: disabled
              1: enable DMA to read or write DR register
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HOLD</name>
              <description>
              The value of HOLD when HOLDE is set
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HOLDE</name>
              <description>
              Enable HOLD function on IO3. Use this only in SPI or Dual SPI mode
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>WP</name>
              <description>
              The value of WP when WPE is set
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>WPE</name>
              <description>
              Enable WP function on IO2. Use this only in SPI or Dual SPI mode
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EN</name>
              <description>
              Enable MPI
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DR</name>
          <displayName>DR</displayName>
          <description>Data Register</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              The entry of internal data FIFO
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DCR</name>
          <displayName>DCR</displayName>
          <description>Device Control Register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>FIXLAT</name>
              <description>
              Indicate PSRAM is fixed latency or variable latency. It must be compatible to the configuration in PSRAM registers.
              Recommend always set to 1.
              0: variable latency
              1: fixed latency
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TRCMIN</name>
              <description>
              Write/Read cycle minimum time in internal MCLK cycles. Please see MCLK frequency in PSCLR description.
              For example, if PSRAM clock is 120MHz (i.e. internal MCLK is 240MHz) and TRCMIN = n, then
              tRC time = (n+1) * 1000/240 ns which must meet minimum tRC requirement for PSRAM
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>CSHMIN</name>
              <description>
              Minimum CS high deselect time in MCLK cycles.
              For example, if PSRAM clock is 120MHz (i.e. internal MCLK is 240MHz) and CSHMIN = n, then
              CS High time = (n+1) * 1000/240 ns which must meet minimum tCPH requirement for PSRAM
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>CSLMIN</name>
              <description>
              Minimum CS low active time in MCLK cycles.
              For example, if PSRAM clock is 120MHz (i.e. internal MCLK is 240MHz) and CSLMIN = n, then
              CS Low time = (n+1) * 1000/240 ns which must meet the minimum tCEM requirement for PSRAM
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>CSLMAX</name>
              <description>
              Maximum CS low active time in MCLK cycles
              For example, if PSRAM clock is 120MHz (i.e. internal MCLK is 240MHz) and CSLMAX = n, then
              CS Low time = (n+1) * 1000/240 ns which must meet the maximum tCEM requirement for PSRAM
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
            <field>
              <name>XLEGACY</name>
              <description>
              Xccela legacy protocol. Set to 1 for AP 32Mb PSRAM only, othersize always set to 0.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HYPER</name>
              <description>
              HyperBus protocol. Set to 1 for HyperRAM.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DQSE</name>
              <description>
              DQS enable. Setting to 1 indicates device provides DQS signal for Rx data latching
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RBSIZE</name>
              <description>
              Row boundary size.
              0: no row boundary
              1: 2^(1+3) = 16 bytes
              2: 2^(2+3) = 32 bytes
              
              n: 2^(n+3) bytes
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PSCLR</name>
          <displayName>PSCLR</displayName>
          <description>Prescaler Register</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>DIV</name>
              <description>
              Prescaler divider.
              0: MCLK = FCLK/1
              1: MCLK = FCLK/1
              2: MCLK = FCLK/2
              n: MCLK = FCLK/n
              Note: FLASH clock = MCLK. E.g. FCLK=192M and DIV=2, then FLASH clock = MCLK = 192/2 = 96MHz
              PSRAM clock = MCLK/2. E.g. FCLK=240M and DIV=1, then PSRAM clock = MCLK/2 = 240/2 = 120MHz
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SR</name>
          <displayName>SR</displayName>
          <description>Status Register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000006</resetValue>
          <fields>
            <field>
              <name>BUSY</name>
              <description>
              For debug purpose only
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>25</bitWidth>
            </field>
            <field>
              <name>RBXF</name>
              <description>
              Row boundary crossing flag
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CSVF</name>
              <description>
              CS max violation flag
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SMF</name>
              <description>
              Status match flag in Polling Mode
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCF</name>
              <description>
              Transfer complete flag
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SCR</name>
          <displayName>SCR</displayName>
          <description>Status Clear Register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>26</bitWidth>
            </field>
            <field>
              <name>RBXFC</name>
              <description>
              Write 1 to clear RBXF
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CSVFC</name>
              <description>
              Write 1 to clear CSVF
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SMFC</name>
              <description>
              Write 1 to clear SMF
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCFC</name>
              <description>
              Write 1 to clear TCF
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CMDR1</name>
          <displayName>CMDR1</displayName>
          <description>Command Register</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>CMD</name>
              <description>
              Command. Write to this register will trigger the sequence specified in CCR1
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>AR1</name>
          <displayName>AR1</displayName>
          <description>Address Register</description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ADDR</name>
              <description>
              Address
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ABR1</name>
          <displayName>ABR1</displayName>
          <description>Alternate Byte Register</description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ABYTE</name>
              <description>
              Alternate byte
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DLR1</name>
          <displayName>DLR1</displayName>
          <description>Data Length Register</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
            <field>
              <name>DLEN</name>
              <description>
              Data length
              0: one byte
              1: two bytes
              
              n: (n+1) bytes
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR1</name>
          <displayName>CCR1</displayName>
          <description>Communication Configuration Register</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
            <field>
              <name>FMODE</name>
              <description>
              Function Mode
              0: read mode
              1: write mode
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMODE</name>
              <description>
              Data Mode
              0: no data phase
              1: single line
              2: dual lines
              3: quad lines
              4/5/6: reserved
              7: quad lines DDR
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>DCYC</name>
              <description>
              Number of dummy cycles
              0: no dummy cycle
              1: one dummy cycle
              2: two dummy cycles
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>ABSIZE</name>
              <description>
              Alternate byte size
              0: one byte
              1: two bytes
              2: three bytes
              3: four bytes
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>ABMODE</name>
              <description>
              Alternate byte mode
              0: no alternate byte
              1: single line
              2: dual lines
              3: quad lines
              4/5/6: reserved
              7: quad lines DDR
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>ADSIZE</name>
              <description>
              Address size
              0: one byte
              1: two bytes
              2: three bytes
              3: four bytes
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>ADMODE</name>
              <description>
              Address mode
              0: no address phase
              1: single line
              2: dual line
              3: quad line
              4/5/6: reserved
              7: quad line DDR
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>IMODE</name>
              <description>
              Instruction mode
              0: no instruction phase
              1: single line
              2: dual lines
              3: quad lines
              4/5/6 - reserved
              7 - quad lines DDR
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CMDR2</name>
          <displayName>CMDR2</displayName>
          <description>Command Register</description>
          <addressOffset>0x2c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>CMD</name>
              <description>
              Command 2. If CMD2E is enabled, the CMD2 sequence will be issued after CMD1 as specified in CCR2
              Note: CMD2 sequence cannot be issue individually
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>AR2</name>
          <displayName>AR2</displayName>
          <description>Address Register</description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ADDR</name>
              <description>
              Address byte in CMD2 sequence
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ABR2</name>
          <displayName>ABR2</displayName>
          <description>Alternate Byte Register</description>
          <addressOffset>0x34</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ABYTE</name>
              <description>
              Alternate byte in CMD2 sequence
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DLR2</name>
          <displayName>DLR2</displayName>
          <description>Data Length Register</description>
          <addressOffset>0x38</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
            <field>
              <name>DLEN</name>
              <description>
              Data length in CMD2 sequence
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR2</name>
          <displayName>CCR2</displayName>
          <description>Communication Configuration Register</description>
          <addressOffset>0x3c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
            <field>
              <name>FMODE</name>
              <description>
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMODE</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>DCYC</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>ABSIZE</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>ABMODE</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>ADSIZE</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>ADMODE</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>IMODE</name>
              <description>
              This register specifies the format of CMD2 sequence. Refer to CCR1 description
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>HCMDR</name>
          <displayName>HCMDR</displayName>
          <description>AHB Command Register</description>
          <addressOffset>0x40</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>WCMD</name>
              <description>
              AHB write command. During XIP, the AHB write transaction will be translated into this Write Command on memory interface
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>RCMD</name>
              <description>
              AHB read command. During XIP, the AHB read transaction will be translated into this Read Command on memory interface
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>HRABR</name>
          <displayName>HRABR</displayName>
          <description>AHB Read Alternate Byte Register</description>
          <addressOffset>0x44</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ABYTE</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>HRCCR</name>
          <displayName>HRCCR</displayName>
          <description>AHB Read Communication Configuration Register</description>
          <addressOffset>0x48</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
            <field>
              <name>DMODE</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>DCYC</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>ABSIZE</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>ABMODE</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>ADSIZE</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>ADMODE</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>IMODE</name>
              <description>
              This register specifies the format of AHB read command sequence. Refer to CCR1 description
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>HWABR</name>
          <displayName>HWABR</displayName>
          <description>AHB Write Alternate Byte Register</description>
          <addressOffset>0x4c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ABYTE</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>HWCCR</name>
          <displayName>HWCCR</displayName>
          <description>AHB Write Communication Configuration Register</description>
          <addressOffset>0x50</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
            <field>
              <name>DMODE</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>DCYC</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>ABSIZE</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>ABMODE</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>ADSIZE</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>ADMODE</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>IMODE</name>
              <description>
              This register specifies the format of AHB write command sequence. Refer to CCR1 description
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>FIFOCR</name>
          <displayName>FIFOCR</displayName>
          <description>FIFO Control Register</description>
          <addressOffset>0x54</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
            <field>
              <name>TXSLOTS</name>
              <description>
              When DMA enabled, asserts DMA reqeust if TXFIFO vacant slots is greater than or equal to TXSLOTS.
              Note: this field should be set in accordance to the burst length in DMA. For example, if DMA employs BURST8 transction, then this filed is set to 8
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>TXF</name>
              <description>
              Tx FIFO full flag
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TXCLR</name>
              <description>
              write 1 to clear Tx FIFO
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>RXE</name>
              <description>
              Rx FIFO empty
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RXCLR</name>
              <description>
              write 1 to clear Rx FIFO
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>MISCR</name>
          <displayName>MISCR</displayName>
          <description>Miscelaneous Register</description>
          <addressOffset>0x58</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DBGSEL</name>
              <description>
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DTRPRE</name>
              <description>
              Enable pre-sampling for DTRReserved-Do not modify
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SCKINV</name>
              <description>
              Invert output clock. This bit is used to align (coarse tune) the output clock to the center of output data.
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RXCLKINV</name>
              <description>
              Invert internal Rx clock to add half-cycle delay (coarse tune) when sampling data. It is usually used for FLASH device w/ higher frequency.
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DQSDLY</name>
              <description>
              Delay the input DQS signal to the appropriate sampling position.  For device w/ DQS signal only. Note: effective 7-bit
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>SCKDLY</name>
              <description>
              Add delay on output clock to fine tune the clock position. Note: effective 7-bit
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>RXCLKDLY</name>
              <description>
              Add delay on internal Rx clock  to fine tune the sampling position. Note: effective 5-bit
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CTRSAR</name>
          <displayName>CTRSAR</displayName>
          <description>CTR Starting Address Register</description>
          <addressOffset>0x5c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>SA</name>
              <description>
              Starting address of the AES decryption area. Since the lowest 10 bits are zero, the address is always 1KB aligned.
              Together with CTREAR, the total area is [CTRSAR, CTREAR)
              For example, CTRSAR = 32'h0, CTREAR = 32'h200000, then the on-the-fly decryption area is 0x0 - 0x1FFFFF
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>22</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CTREAR</name>
          <displayName>CTREAR</displayName>
          <description>CTR Ending Address Register</description>
          <addressOffset>0x60</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>EA</name>
              <description>
              Ending address of the AES decryption area
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>22</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>NONCEA</name>
          <displayName>NONCEA</displayName>
          <description>Nonce A Register</description>
          <addressOffset>0x64</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>NONCEA</name>
              <description>
              Used for on-the-fly decryption
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>NONCEB</name>
          <displayName>NONCEB</displayName>
          <description>Nonce B Register</description>
          <addressOffset>0x68</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>NONCEB</name>
              <description>
              Used for on-the-fly decryption
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>AASAR</name>
          <displayName>AASAR</displayName>
          <description>Address Aliasing Start Address Register</description>
          <addressOffset>0x6c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>SA</name>
              <description>
              Starting address of the address aliasing area. Always 1KB aligned.Together with AAEAR, the aliasing area is [AASAR, AAEAR). 
              If the address falls into this area, an offset AAOAR is added and the aliased address will be used to access external memory
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>22</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>AAEAR</name>
          <displayName>AAEAR</displayName>
          <description>Address Aliasing Ending Address Register</description>
          <addressOffset>0x70</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>EA</name>
              <description>
              Ending address of the address aliasing area
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>22</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>AAOAR</name>
          <displayName>AAOAR</displayName>
          <description>Address Aliasing Offset Address Register</description>
          <addressOffset>0x74</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>OA</name>
              <description>
              The offset to be added to the original address
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>22</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CIR</name>
          <displayName>CIR</displayName>
          <description>Command Interval Register</description>
          <addressOffset>0x78</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>INTERVAL2</name>
              <description>
              The interval between CMD1 and CMD2 (or between CMD2 itself) if CMD2E is enabled. The unit is in MCLK cycles
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>INTERVAL1</name>
              <description>
              The interval between CMD1 itself. The unit is in MCLK cycles
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SMR</name>
          <displayName>SMR</displayName>
          <description>Status Match Register</description>
          <addressOffset>0x7c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>STATUS</name>
              <description>
              If status match is enabled, this register is compared with the data read from external memory.
              Together with SMKR, only the bits with mask=1 will be considered to compare in AND or OR mode as configured in SMM field.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SMKR</name>
          <displayName>SMKR</displayName>
          <description>Status Mask Register</description>
          <addressOffset>0x80</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>MASK</name>
              <description>
              Status mask
              0: the corresponding bit is not considered to compare
              1: the corresponding bit is considered to compare
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TIMR</name>
          <displayName>TIMR</displayName>
          <description>Timer Register</description>
          <addressOffset>0x84</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>TIMEOUT</name>
              <description>
              After the transaction is complete, CS remains low for multiple cycles of MCLK as specified by this register.
              For example if TIMEOUT=n, CS remains active for n cycles, during which if a new transaction occurs and the address is consecutive, the memory access can be resumed w/o sending the command and address again.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>WDTR</name>
          <displayName>WDTR</displayName>
          <description>WDT Register</description>
          <addressOffset>0x88</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>TOF</name>
              <description>
              Timeout flag. Self cleared when HREADYOUT becomes ready
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>14</bitWidth>
            </field>
            <field>
              <name>EN</name>
              <description>
              WDT enable. This watchdog is on AHB side such that bus access will not hang in exceptional cases
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TIMEOUT</name>
              <description>
              Set timeout value in number of clk_wdt cycles
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PRSAR</name>
          <displayName>PRSAR</displayName>
          <description>Prefetch Starting Address Register</description>
          <addressOffset>0x8c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>SA</name>
              <description>
              Starting address of the prefetch area
              If prefetch is enabled and the read address falls into [PRSAR, PREAR), controller will prefetch the following data
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>22</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PREAR</name>
          <displayName>PREAR</displayName>
          <description>Prefetch Ending Address Register</description>
          <addressOffset>0x90</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>EA</name>
              <description>
              Ending address of the prefetch area
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>22</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CALCR</name>
          <displayName>CALCR</displayName>
          <description>Calibration Clock Register</description>
          <addressOffset>0x94</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>EN</name>
              <description>
              calibration enable
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>22</bitWidth>
            </field>
            <field>
              <name>DONE</name>
              <description>
              calibration done flag
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DELAY</name>
              <description>
              calibration delay result
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>APM32CR</name>
          <displayName>APM32CR</displayName>
          <description>APM32 Control Register</description>
          <addressOffset>0x98</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>TCPHW</name>
              <description>
              For special use by AP 32Mb PSRAM.Reserved-Do not modify
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>TCPHR</name>
              <description>
              For special use by AP 32Mb PSRAM.Reserved-Do not modify
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CR2</name>
          <displayName>CR2</displayName>
          <description>Control Register 2</description>
          <addressOffset>0x9c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>LOOP</name>
              <description>
              Repeat CMD1->CMD2 sequence for n times. This filed is only valid when CMD2E=1 and SME2=0.
              For example if LOOP=0, then the sequence is CMD1 -> CMD2.
              If LOOP=2, then the sequence is (CMD1->CMD2) -> (CMD1->CMD2) -> (CMD1->CMD2)
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>MPI3</name>
      <description></description>
      <groupName>MPI</groupName>
      <baseAddress>0x40083000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CR</name>
          <displayName>CR</displayName>
          <description>Control Register</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ABORT</name>
              <description>
              Write 1 to abort internal state machine. For debug purpose only
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>AHBDIS</name>
              <description>
              Hold hreadyout low if AHB access
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DFM</name>
              <description>
              Dual Flash ModeReserved-Do not modify
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MX16</name>
              <description>
              Mode X16Reserved-Do not modify
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PREFE</name>
              <description>
              Prefetch enable. If enabled, MPI will prefetch at consequtive address following a read transaction. 
              Recommend to use when reading large data in a burst manner.
              0: prefetch disabled
              1: prefetch enabled
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OPIE</name>
              <description>
              OPI interface enable
              0: x8 mode disabled
              1: x8 mode enabled
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HWIFE</name>
              <description>
              Hardware interface enableReserved-Do not modify
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SMM</name>
              <description>
              Status match mode
              0: AND mode
              1: OR mode
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SME2</name>
              <description>
              Status match enable. If enabled, CMD2 will be issued repeatedly until the data match the value in SMR and SMKR
              0: disabled
              1: enabled
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SME1</name>
              <description>
              Status match enable. If enabled, CMD1 will be issued repeatedly until the data match the value in SMR and SMKR
              0: disabled
              1: enabled (either SME1 or SME2 can be enabled, and SME1 has high priority)
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CMD2E</name>
              <description>
              Enable CMD2
              0: disabled
              1: CMD2 is enabled and will be issued after CMD1 with an interval of TI2
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RBXIE</name>
              <description>
              Row boundary crossing interrupt enable
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CSVIE</name>
              <description>
              CS max violation interrupt enable
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SMIE</name>
              <description>
              Status match interrupt enable
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIE</name>
              <description>
              Transfer complete interrupt enable
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTRM</name>
              <description>
              AES-CTR mode
              0: AES-128
              1: AES-256
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTRE</name>
              <description>
              AES-CTR on-the-fly decryption enable
              0: disabled
              1: enabled, data read from memory will be decrypted on the fly by MPI controller
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMAE</name>
              <description>
              DMA enable
              0: disabled
              1: enable DMA to read or write DR register
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HOLD</name>
              <description>
              The value of HOLD when HOLDE is set
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HOLDE</name>
              <description>
              Enable HOLD function on IO3. Use this only in SPI or Dual SPI mode
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>WP</name>
              <description>
              The value of WP when WPE is set
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>WPE</name>
              <description>
              Enable WP function on IO2. Use this only in SPI or Dual SPI mode
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EN</name>
              <description>
              Enable MPI
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DR</name>
          <displayName>DR</displayName>
          <description>Data Register</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              The entry of internal data FIFO
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DCR</name>
          <displayName>DCR</displayName>
          <description>Device Control Register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>FIXLAT</name>
              <description>
              Indicate PSRAM is fixed latency or variable latency. It must be compatible to the configuration in PSRAM registers.
              Recommend always set to 1.
              0: variable latency
              1: fixed latency
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TRCMIN</name>
              <description>
              Write/Read cycle minimum time in internal MCLK cycles. Please see MCLK frequency in PSCLR description.
              For example, if PSRAM clock is 120MHz (i.e. internal MCLK is 240MHz) and TRCMIN = n, then
              tRC time = (n+1) * 1000/240 ns which must meet minimum tRC requirement for PSRAM
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>CSHMIN</name>
              <description>
              Minimum CS high deselect time in MCLK cycles.
              For example, if PSRAM clock is 120MHz (i.e. internal MCLK is 240MHz) and CSHMIN = n, then
              CS High time = (n+1) * 1000/240 ns which must meet minimum tCPH requirement for PSRAM
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>CSLMIN</name>
              <description>
              Minimum CS low active time in MCLK cycles.
              For example, if PSRAM clock is 120MHz (i.e. internal MCLK is 240MHz) and CSLMIN = n, then
              CS Low time = (n+1) * 1000/240 ns which must meet the minimum tCEM requirement for PSRAM
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>CSLMAX</name>
              <description>
              Maximum CS low active time in MCLK cycles
              For example, if PSRAM clock is 120MHz (i.e. internal MCLK is 240MHz) and CSLMAX = n, then
              CS Low time = (n+1) * 1000/240 ns which must meet the maximum tCEM requirement for PSRAM
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
            <field>
              <name>XLEGACY</name>
              <description>
              Xccela legacy protocol. Set to 1 for AP 32Mb PSRAM only, othersize always set to 0.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HYPER</name>
              <description>
              HyperBus protocol. Set to 1 for HyperRAM.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DQSE</name>
              <description>
              DQS enable. Setting to 1 indicates device provides DQS signal for Rx data latching
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RBSIZE</name>
              <description>
              Row boundary size.
              0: no row boundary
              1: 2^(1+3) = 16 bytes
              2: 2^(2+3) = 32 bytes
              
              n: 2^(n+3) bytes
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PSCLR</name>
          <displayName>PSCLR</displayName>
          <description>Prescaler Register</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>DIV</name>
              <description>
              Prescaler divider.
              0: MCLK = FCLK/1
              1: MCLK = FCLK/1
              2: MCLK = FCLK/2
              n: MCLK = FCLK/n
              Note: FLASH clock = MCLK. E.g. FCLK=192M and DIV=2, then FLASH clock = MCLK = 192/2 = 96MHz
              PSRAM clock = MCLK/2. E.g. FCLK=240M and DIV=1, then PSRAM clock = MCLK/2 = 240/2 = 120MHz
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SR</name>
          <displayName>SR</displayName>
          <description>Status Register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000006</resetValue>
          <fields>
            <field>
              <name>BUSY</name>
              <description>
              For debug purpose only
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>25</bitWidth>
            </field>
            <field>
              <name>RBXF</name>
              <description>
              Row boundary crossing flag
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CSVF</name>
              <description>
              CS max violation flag
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SMF</name>
              <description>
              Status match flag in Polling Mode
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCF</name>
              <description>
              Transfer complete flag
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SCR</name>
          <displayName>SCR</displayName>
          <description>Status Clear Register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>26</bitWidth>
            </field>
            <field>
              <name>RBXFC</name>
              <description>
              Write 1 to clear RBXF
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CSVFC</name>
              <description>
              Write 1 to clear CSVF
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SMFC</name>
              <description>
              Write 1 to clear SMF
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCFC</name>
              <description>
              Write 1 to clear TCF
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CMDR1</name>
          <displayName>CMDR1</displayName>
          <description>Command Register</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>CMD</name>
              <description>
              Command. Write to this register will trigger the sequence specified in CCR1
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>AR1</name>
          <displayName>AR1</displayName>
          <description>Address Register</description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ADDR</name>
              <description>
              Address
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ABR1</name>
          <displayName>ABR1</displayName>
          <description>Alternate Byte Register</description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ABYTE</name>
              <description>
              Alternate byte
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DLR1</name>
          <displayName>DLR1</displayName>
          <description>Data Length Register</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
            <field>
              <name>DLEN</name>
              <description>
              Data length
              0: one byte
              1: two bytes
              
              n: (n+1) bytes
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR1</name>
          <displayName>CCR1</displayName>
          <description>Communication Configuration Register</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
            <field>
              <name>FMODE</name>
              <description>
              Function Mode
              0: read mode
              1: write mode
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMODE</name>
              <description>
              Data Mode
              0: no data phase
              1: single line
              2: dual lines
              3: quad lines
              4/5/6: reserved
              7: quad lines DDR
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>DCYC</name>
              <description>
              Number of dummy cycles
              0: no dummy cycle
              1: one dummy cycle
              2: two dummy cycles
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>ABSIZE</name>
              <description>
              Alternate byte size
              0: one byte
              1: two bytes
              2: three bytes
              3: four bytes
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>ABMODE</name>
              <description>
              Alternate byte mode
              0: no alternate byte
              1: single line
              2: dual lines
              3: quad lines
              4/5/6: reserved
              7: quad lines DDR
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>ADSIZE</name>
              <description>
              Address size
              0: one byte
              1: two bytes
              2: three bytes
              3: four bytes
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>ADMODE</name>
              <description>
              Address mode
              0: no address phase
              1: single line
              2: dual line
              3: quad line
              4/5/6: reserved
              7: quad line DDR
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>IMODE</name>
              <description>
              Instruction mode
              0: no instruction phase
              1: single line
              2: dual lines
              3: quad lines
              4/5/6 - reserved
              7 - quad lines DDR
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CMDR2</name>
          <displayName>CMDR2</displayName>
          <description>Command Register</description>
          <addressOffset>0x2c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>CMD</name>
              <description>
              Command 2. If CMD2E is enabled, the CMD2 sequence will be issued after CMD1 as specified in CCR2
              Note: CMD2 sequence cannot be issue individually
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>AR2</name>
          <displayName>AR2</displayName>
          <description>Address Register</description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ADDR</name>
              <description>
              Address byte in CMD2 sequence
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ABR2</name>
          <displayName>ABR2</displayName>
          <description>Alternate Byte Register</description>
          <addressOffset>0x34</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ABYTE</name>
              <description>
              Alternate byte in CMD2 sequence
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DLR2</name>
          <displayName>DLR2</displayName>
          <description>Data Length Register</description>
          <addressOffset>0x38</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
            <field>
              <name>DLEN</name>
              <description>
              Data length in CMD2 sequence
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR2</name>
          <displayName>CCR2</displayName>
          <description>Communication Configuration Register</description>
          <addressOffset>0x3c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
            <field>
              <name>FMODE</name>
              <description>
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMODE</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>DCYC</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>ABSIZE</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>ABMODE</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>ADSIZE</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>ADMODE</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>IMODE</name>
              <description>
              This register specifies the format of CMD2 sequence. Refer to CCR1 description
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>HCMDR</name>
          <displayName>HCMDR</displayName>
          <description>AHB Command Register</description>
          <addressOffset>0x40</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>WCMD</name>
              <description>
              AHB write command. During XIP, the AHB write transaction will be translated into this Write Command on memory interface
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>RCMD</name>
              <description>
              AHB read command. During XIP, the AHB read transaction will be translated into this Read Command on memory interface
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>HRABR</name>
          <displayName>HRABR</displayName>
          <description>AHB Read Alternate Byte Register</description>
          <addressOffset>0x44</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ABYTE</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>HRCCR</name>
          <displayName>HRCCR</displayName>
          <description>AHB Read Communication Configuration Register</description>
          <addressOffset>0x48</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
            <field>
              <name>DMODE</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>DCYC</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>ABSIZE</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>ABMODE</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>ADSIZE</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>ADMODE</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>IMODE</name>
              <description>
              This register specifies the format of AHB read command sequence. Refer to CCR1 description
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>HWABR</name>
          <displayName>HWABR</displayName>
          <description>AHB Write Alternate Byte Register</description>
          <addressOffset>0x4c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ABYTE</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>HWCCR</name>
          <displayName>HWCCR</displayName>
          <description>AHB Write Communication Configuration Register</description>
          <addressOffset>0x50</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
            <field>
              <name>DMODE</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>DCYC</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>ABSIZE</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>ABMODE</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>ADSIZE</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>ADMODE</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>IMODE</name>
              <description>
              This register specifies the format of AHB write command sequence. Refer to CCR1 description
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>FIFOCR</name>
          <displayName>FIFOCR</displayName>
          <description>FIFO Control Register</description>
          <addressOffset>0x54</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
            <field>
              <name>TXSLOTS</name>
              <description>
              When DMA enabled, asserts DMA reqeust if TXFIFO vacant slots is greater than or equal to TXSLOTS.
              Note: this field should be set in accordance to the burst length in DMA. For example, if DMA employs BURST8 transction, then this filed is set to 8
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>TXF</name>
              <description>
              Tx FIFO full flag
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TXCLR</name>
              <description>
              write 1 to clear Tx FIFO
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>RXE</name>
              <description>
              Rx FIFO empty
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RXCLR</name>
              <description>
              write 1 to clear Rx FIFO
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>MISCR</name>
          <displayName>MISCR</displayName>
          <description>Miscelaneous Register</description>
          <addressOffset>0x58</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DBGSEL</name>
              <description>
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DTRPRE</name>
              <description>
              Enable pre-sampling for DTRReserved-Do not modify
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SCKINV</name>
              <description>
              Invert output clock. This bit is used to align (coarse tune) the output clock to the center of output data.
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RXCLKINV</name>
              <description>
              Invert internal Rx clock to add half-cycle delay (coarse tune) when sampling data. It is usually used for FLASH device w/ higher frequency.
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DQSDLY</name>
              <description>
              Delay the input DQS signal to the appropriate sampling position.  For device w/ DQS signal only. Note: effective 7-bit
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>SCKDLY</name>
              <description>
              Add delay on output clock to fine tune the clock position. Note: effective 7-bit
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>RXCLKDLY</name>
              <description>
              Add delay on internal Rx clock  to fine tune the sampling position. Note: effective 5-bit
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CTRSAR</name>
          <displayName>CTRSAR</displayName>
          <description>CTR Starting Address Register</description>
          <addressOffset>0x5c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>SA</name>
              <description>
              Starting address of the AES decryption area. Since the lowest 10 bits are zero, the address is always 1KB aligned.
              Together with CTREAR, the total area is [CTRSAR, CTREAR)
              For example, CTRSAR = 32'h0, CTREAR = 32'h200000, then the on-the-fly decryption area is 0x0 - 0x1FFFFF
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>22</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CTREAR</name>
          <displayName>CTREAR</displayName>
          <description>CTR Ending Address Register</description>
          <addressOffset>0x60</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>EA</name>
              <description>
              Ending address of the AES decryption area
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>22</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>NONCEA</name>
          <displayName>NONCEA</displayName>
          <description>Nonce A Register</description>
          <addressOffset>0x64</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>NONCEA</name>
              <description>
              Used for on-the-fly decryption
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>NONCEB</name>
          <displayName>NONCEB</displayName>
          <description>Nonce B Register</description>
          <addressOffset>0x68</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>NONCEB</name>
              <description>
              Used for on-the-fly decryption
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>AASAR</name>
          <displayName>AASAR</displayName>
          <description>Address Aliasing Start Address Register</description>
          <addressOffset>0x6c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>SA</name>
              <description>
              Starting address of the address aliasing area. Always 1KB aligned.Together with AAEAR, the aliasing area is [AASAR, AAEAR). 
              If the address falls into this area, an offset AAOAR is added and the aliased address will be used to access external memory
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>22</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>AAEAR</name>
          <displayName>AAEAR</displayName>
          <description>Address Aliasing Ending Address Register</description>
          <addressOffset>0x70</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>EA</name>
              <description>
              Ending address of the address aliasing area
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>22</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>AAOAR</name>
          <displayName>AAOAR</displayName>
          <description>Address Aliasing Offset Address Register</description>
          <addressOffset>0x74</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>OA</name>
              <description>
              The offset to be added to the original address
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>22</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CIR</name>
          <displayName>CIR</displayName>
          <description>Command Interval Register</description>
          <addressOffset>0x78</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>INTERVAL2</name>
              <description>
              The interval between CMD1 and CMD2 (or between CMD2 itself) if CMD2E is enabled. The unit is in MCLK cycles
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>INTERVAL1</name>
              <description>
              The interval between CMD1 itself. The unit is in MCLK cycles
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SMR</name>
          <displayName>SMR</displayName>
          <description>Status Match Register</description>
          <addressOffset>0x7c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>STATUS</name>
              <description>
              If status match is enabled, this register is compared with the data read from external memory.
              Together with SMKR, only the bits with mask=1 will be considered to compare in AND or OR mode as configured in SMM field.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SMKR</name>
          <displayName>SMKR</displayName>
          <description>Status Mask Register</description>
          <addressOffset>0x80</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>MASK</name>
              <description>
              Status mask
              0: the corresponding bit is not considered to compare
              1: the corresponding bit is considered to compare
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TIMR</name>
          <displayName>TIMR</displayName>
          <description>Timer Register</description>
          <addressOffset>0x84</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>TIMEOUT</name>
              <description>
              After the transaction is complete, CS remains low for multiple cycles of MCLK as specified by this register.
              For example if TIMEOUT=n, CS remains active for n cycles, during which if a new transaction occurs and the address is consecutive, the memory access can be resumed w/o sending the command and address again.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>WDTR</name>
          <displayName>WDTR</displayName>
          <description>WDT Register</description>
          <addressOffset>0x88</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>TOF</name>
              <description>
              Timeout flag. Self cleared when HREADYOUT becomes ready
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>14</bitWidth>
            </field>
            <field>
              <name>EN</name>
              <description>
              WDT enable. This watchdog is on AHB side such that bus access will not hang in exceptional cases
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TIMEOUT</name>
              <description>
              Set timeout value in number of clk_wdt cycles
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PRSAR</name>
          <displayName>PRSAR</displayName>
          <description>Prefetch Starting Address Register</description>
          <addressOffset>0x8c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>SA</name>
              <description>
              Starting address of the prefetch area
              If prefetch is enabled and the read address falls into [PRSAR, PREAR), controller will prefetch the following data
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>22</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PREAR</name>
          <displayName>PREAR</displayName>
          <description>Prefetch Ending Address Register</description>
          <addressOffset>0x90</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>EA</name>
              <description>
              Ending address of the prefetch area
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>22</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CALCR</name>
          <displayName>CALCR</displayName>
          <description>Calibration Clock Register</description>
          <addressOffset>0x94</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>EN</name>
              <description>
              calibration enable
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>22</bitWidth>
            </field>
            <field>
              <name>DONE</name>
              <description>
              calibration done flag
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DELAY</name>
              <description>
              calibration delay result
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>APM32CR</name>
          <displayName>APM32CR</displayName>
          <description>APM32 Control Register</description>
          <addressOffset>0x98</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>TCPHW</name>
              <description>
              For special use by AP 32Mb PSRAM.Reserved-Do not modify
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>TCPHR</name>
              <description>
              For special use by AP 32Mb PSRAM.Reserved-Do not modify
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CR2</name>
          <displayName>CR2</displayName>
          <description>Control Register 2</description>
          <addressOffset>0x9c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>LOOP</name>
              <description>
              Repeat CMD1->CMD2 sequence for n times. This filed is only valid when CMD2E=1 and SME2=0.
              For example if LOOP=0, then the sequence is CMD1 -> CMD2.
              If LOOP=2, then the sequence is (CMD1->CMD2) -> (CMD1->CMD2) -> (CMD1->CMD2)
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>MPI4</name>
      <description></description>
      <groupName>MPI</groupName>
      <baseAddress>0x40084000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CR</name>
          <displayName>CR</displayName>
          <description>Control Register</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ABORT</name>
              <description>
              Write 1 to abort internal state machine. For debug purpose only
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>AHBDIS</name>
              <description>
              Hold hreadyout low if AHB access
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DFM</name>
              <description>
              Dual Flash ModeReserved-Do not modify
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MX16</name>
              <description>
              Mode X16Reserved-Do not modify
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PREFE</name>
              <description>
              Prefetch enable. If enabled, MPI will prefetch at consequtive address following a read transaction. 
              Recommend to use when reading large data in a burst manner.
              0: prefetch disabled
              1: prefetch enabled
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OPIE</name>
              <description>
              OPI interface enable
              0: x8 mode disabled
              1: x8 mode enabled
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HWIFE</name>
              <description>
              Hardware interface enableReserved-Do not modify
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SMM</name>
              <description>
              Status match mode
              0: AND mode
              1: OR mode
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SME2</name>
              <description>
              Status match enable. If enabled, CMD2 will be issued repeatedly until the data match the value in SMR and SMKR
              0: disabled
              1: enabled
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SME1</name>
              <description>
              Status match enable. If enabled, CMD1 will be issued repeatedly until the data match the value in SMR and SMKR
              0: disabled
              1: enabled (either SME1 or SME2 can be enabled, and SME1 has high priority)
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CMD2E</name>
              <description>
              Enable CMD2
              0: disabled
              1: CMD2 is enabled and will be issued after CMD1 with an interval of TI2
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RBXIE</name>
              <description>
              Row boundary crossing interrupt enable
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CSVIE</name>
              <description>
              CS max violation interrupt enable
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SMIE</name>
              <description>
              Status match interrupt enable
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIE</name>
              <description>
              Transfer complete interrupt enable
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTRM</name>
              <description>
              AES-CTR mode
              0: AES-128
              1: AES-256
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTRE</name>
              <description>
              AES-CTR on-the-fly decryption enable
              0: disabled
              1: enabled, data read from memory will be decrypted on the fly by MPI controller
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMAE</name>
              <description>
              DMA enable
              0: disabled
              1: enable DMA to read or write DR register
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HOLD</name>
              <description>
              The value of HOLD when HOLDE is set
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HOLDE</name>
              <description>
              Enable HOLD function on IO3. Use this only in SPI or Dual SPI mode
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>WP</name>
              <description>
              The value of WP when WPE is set
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>WPE</name>
              <description>
              Enable WP function on IO2. Use this only in SPI or Dual SPI mode
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EN</name>
              <description>
              Enable MPI
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DR</name>
          <displayName>DR</displayName>
          <description>Data Register</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              The entry of internal data FIFO
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DCR</name>
          <displayName>DCR</displayName>
          <description>Device Control Register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>FIXLAT</name>
              <description>
              Indicate PSRAM is fixed latency or variable latency. It must be compatible to the configuration in PSRAM registers.
              Recommend always set to 1.
              0: variable latency
              1: fixed latency
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TRCMIN</name>
              <description>
              Write/Read cycle minimum time in internal MCLK cycles. Please see MCLK frequency in PSCLR description.
              For example, if PSRAM clock is 120MHz (i.e. internal MCLK is 240MHz) and TRCMIN = n, then
              tRC time = (n+1) * 1000/240 ns which must meet minimum tRC requirement for PSRAM
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>CSHMIN</name>
              <description>
              Minimum CS high deselect time in MCLK cycles.
              For example, if PSRAM clock is 120MHz (i.e. internal MCLK is 240MHz) and CSHMIN = n, then
              CS High time = (n+1) * 1000/240 ns which must meet minimum tCPH requirement for PSRAM
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>CSLMIN</name>
              <description>
              Minimum CS low active time in MCLK cycles.
              For example, if PSRAM clock is 120MHz (i.e. internal MCLK is 240MHz) and CSLMIN = n, then
              CS Low time = (n+1) * 1000/240 ns which must meet the minimum tCEM requirement for PSRAM
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>CSLMAX</name>
              <description>
              Maximum CS low active time in MCLK cycles
              For example, if PSRAM clock is 120MHz (i.e. internal MCLK is 240MHz) and CSLMAX = n, then
              CS Low time = (n+1) * 1000/240 ns which must meet the maximum tCEM requirement for PSRAM
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
            <field>
              <name>XLEGACY</name>
              <description>
              Xccela legacy protocol. Set to 1 for AP 32Mb PSRAM only, othersize always set to 0.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HYPER</name>
              <description>
              HyperBus protocol. Set to 1 for HyperRAM.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DQSE</name>
              <description>
              DQS enable. Setting to 1 indicates device provides DQS signal for Rx data latching
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RBSIZE</name>
              <description>
              Row boundary size.
              0: no row boundary
              1: 2^(1+3) = 16 bytes
              2: 2^(2+3) = 32 bytes
              
              n: 2^(n+3) bytes
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PSCLR</name>
          <displayName>PSCLR</displayName>
          <description>Prescaler Register</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>DIV</name>
              <description>
              Prescaler divider.
              0: MCLK = FCLK/1
              1: MCLK = FCLK/1
              2: MCLK = FCLK/2
              n: MCLK = FCLK/n
              Note: FLASH clock = MCLK. E.g. FCLK=192M and DIV=2, then FLASH clock = MCLK = 192/2 = 96MHz
              PSRAM clock = MCLK/2. E.g. FCLK=240M and DIV=1, then PSRAM clock = MCLK/2 = 240/2 = 120MHz
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SR</name>
          <displayName>SR</displayName>
          <description>Status Register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000006</resetValue>
          <fields>
            <field>
              <name>BUSY</name>
              <description>
              For debug purpose only
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>25</bitWidth>
            </field>
            <field>
              <name>RBXF</name>
              <description>
              Row boundary crossing flag
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CSVF</name>
              <description>
              CS max violation flag
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SMF</name>
              <description>
              Status match flag in Polling Mode
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCF</name>
              <description>
              Transfer complete flag
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SCR</name>
          <displayName>SCR</displayName>
          <description>Status Clear Register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>26</bitWidth>
            </field>
            <field>
              <name>RBXFC</name>
              <description>
              Write 1 to clear RBXF
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CSVFC</name>
              <description>
              Write 1 to clear CSVF
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SMFC</name>
              <description>
              Write 1 to clear SMF
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCFC</name>
              <description>
              Write 1 to clear TCF
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CMDR1</name>
          <displayName>CMDR1</displayName>
          <description>Command Register</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>CMD</name>
              <description>
              Command. Write to this register will trigger the sequence specified in CCR1
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>AR1</name>
          <displayName>AR1</displayName>
          <description>Address Register</description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ADDR</name>
              <description>
              Address
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ABR1</name>
          <displayName>ABR1</displayName>
          <description>Alternate Byte Register</description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ABYTE</name>
              <description>
              Alternate byte
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DLR1</name>
          <displayName>DLR1</displayName>
          <description>Data Length Register</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
            <field>
              <name>DLEN</name>
              <description>
              Data length
              0: one byte
              1: two bytes
              
              n: (n+1) bytes
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR1</name>
          <displayName>CCR1</displayName>
          <description>Communication Configuration Register</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
            <field>
              <name>FMODE</name>
              <description>
              Function Mode
              0: read mode
              1: write mode
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMODE</name>
              <description>
              Data Mode
              0: no data phase
              1: single line
              2: dual lines
              3: quad lines
              4/5/6: reserved
              7: quad lines DDR
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>DCYC</name>
              <description>
              Number of dummy cycles
              0: no dummy cycle
              1: one dummy cycle
              2: two dummy cycles
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>ABSIZE</name>
              <description>
              Alternate byte size
              0: one byte
              1: two bytes
              2: three bytes
              3: four bytes
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>ABMODE</name>
              <description>
              Alternate byte mode
              0: no alternate byte
              1: single line
              2: dual lines
              3: quad lines
              4/5/6: reserved
              7: quad lines DDR
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>ADSIZE</name>
              <description>
              Address size
              0: one byte
              1: two bytes
              2: three bytes
              3: four bytes
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>ADMODE</name>
              <description>
              Address mode
              0: no address phase
              1: single line
              2: dual line
              3: quad line
              4/5/6: reserved
              7: quad line DDR
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>IMODE</name>
              <description>
              Instruction mode
              0: no instruction phase
              1: single line
              2: dual lines
              3: quad lines
              4/5/6 - reserved
              7 - quad lines DDR
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CMDR2</name>
          <displayName>CMDR2</displayName>
          <description>Command Register</description>
          <addressOffset>0x2c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>CMD</name>
              <description>
              Command 2. If CMD2E is enabled, the CMD2 sequence will be issued after CMD1 as specified in CCR2
              Note: CMD2 sequence cannot be issue individually
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>AR2</name>
          <displayName>AR2</displayName>
          <description>Address Register</description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ADDR</name>
              <description>
              Address byte in CMD2 sequence
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ABR2</name>
          <displayName>ABR2</displayName>
          <description>Alternate Byte Register</description>
          <addressOffset>0x34</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ABYTE</name>
              <description>
              Alternate byte in CMD2 sequence
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DLR2</name>
          <displayName>DLR2</displayName>
          <description>Data Length Register</description>
          <addressOffset>0x38</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
            <field>
              <name>DLEN</name>
              <description>
              Data length in CMD2 sequence
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR2</name>
          <displayName>CCR2</displayName>
          <description>Communication Configuration Register</description>
          <addressOffset>0x3c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
            <field>
              <name>FMODE</name>
              <description>
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMODE</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>DCYC</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>ABSIZE</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>ABMODE</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>ADSIZE</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>ADMODE</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>IMODE</name>
              <description>
              This register specifies the format of CMD2 sequence. Refer to CCR1 description
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>HCMDR</name>
          <displayName>HCMDR</displayName>
          <description>AHB Command Register</description>
          <addressOffset>0x40</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>WCMD</name>
              <description>
              AHB write command. During XIP, the AHB write transaction will be translated into this Write Command on memory interface
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>RCMD</name>
              <description>
              AHB read command. During XIP, the AHB read transaction will be translated into this Read Command on memory interface
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>HRABR</name>
          <displayName>HRABR</displayName>
          <description>AHB Read Alternate Byte Register</description>
          <addressOffset>0x44</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ABYTE</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>HRCCR</name>
          <displayName>HRCCR</displayName>
          <description>AHB Read Communication Configuration Register</description>
          <addressOffset>0x48</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
            <field>
              <name>DMODE</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>DCYC</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>ABSIZE</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>ABMODE</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>ADSIZE</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>ADMODE</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>IMODE</name>
              <description>
              This register specifies the format of AHB read command sequence. Refer to CCR1 description
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>HWABR</name>
          <displayName>HWABR</displayName>
          <description>AHB Write Alternate Byte Register</description>
          <addressOffset>0x4c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ABYTE</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>HWCCR</name>
          <displayName>HWCCR</displayName>
          <description>AHB Write Communication Configuration Register</description>
          <addressOffset>0x50</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
            <field>
              <name>DMODE</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>DCYC</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>ABSIZE</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>ABMODE</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>ADSIZE</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>ADMODE</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>IMODE</name>
              <description>
              This register specifies the format of AHB write command sequence. Refer to CCR1 description
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>FIFOCR</name>
          <displayName>FIFOCR</displayName>
          <description>FIFO Control Register</description>
          <addressOffset>0x54</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
            <field>
              <name>TXSLOTS</name>
              <description>
              When DMA enabled, asserts DMA reqeust if TXFIFO vacant slots is greater than or equal to TXSLOTS.
              Note: this field should be set in accordance to the burst length in DMA. For example, if DMA employs BURST8 transction, then this filed is set to 8
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>TXF</name>
              <description>
              Tx FIFO full flag
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TXCLR</name>
              <description>
              write 1 to clear Tx FIFO
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>RXE</name>
              <description>
              Rx FIFO empty
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RXCLR</name>
              <description>
              write 1 to clear Rx FIFO
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>MISCR</name>
          <displayName>MISCR</displayName>
          <description>Miscelaneous Register</description>
          <addressOffset>0x58</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DBGSEL</name>
              <description>
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DTRPRE</name>
              <description>
              Enable pre-sampling for DTRReserved-Do not modify
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SCKINV</name>
              <description>
              Invert output clock. This bit is used to align (coarse tune) the output clock to the center of output data.
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RXCLKINV</name>
              <description>
              Invert internal Rx clock to add half-cycle delay (coarse tune) when sampling data. It is usually used for FLASH device w/ higher frequency.
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DQSDLY</name>
              <description>
              Delay the input DQS signal to the appropriate sampling position.  For device w/ DQS signal only. Note: effective 7-bit
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>SCKDLY</name>
              <description>
              Add delay on output clock to fine tune the clock position. Note: effective 7-bit
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>RXCLKDLY</name>
              <description>
              Add delay on internal Rx clock  to fine tune the sampling position. Note: effective 5-bit
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CTRSAR</name>
          <displayName>CTRSAR</displayName>
          <description>CTR Starting Address Register</description>
          <addressOffset>0x5c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>SA</name>
              <description>
              Starting address of the AES decryption area. Since the lowest 10 bits are zero, the address is always 1KB aligned.
              Together with CTREAR, the total area is [CTRSAR, CTREAR)
              For example, CTRSAR = 32'h0, CTREAR = 32'h200000, then the on-the-fly decryption area is 0x0 - 0x1FFFFF
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>22</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CTREAR</name>
          <displayName>CTREAR</displayName>
          <description>CTR Ending Address Register</description>
          <addressOffset>0x60</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>EA</name>
              <description>
              Ending address of the AES decryption area
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>22</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>NONCEA</name>
          <displayName>NONCEA</displayName>
          <description>Nonce A Register</description>
          <addressOffset>0x64</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>NONCEA</name>
              <description>
              Used for on-the-fly decryption
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>NONCEB</name>
          <displayName>NONCEB</displayName>
          <description>Nonce B Register</description>
          <addressOffset>0x68</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>NONCEB</name>
              <description>
              Used for on-the-fly decryption
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>AASAR</name>
          <displayName>AASAR</displayName>
          <description>Address Aliasing Start Address Register</description>
          <addressOffset>0x6c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>SA</name>
              <description>
              Starting address of the address aliasing area. Always 1KB aligned.Together with AAEAR, the aliasing area is [AASAR, AAEAR). 
              If the address falls into this area, an offset AAOAR is added and the aliased address will be used to access external memory
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>22</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>AAEAR</name>
          <displayName>AAEAR</displayName>
          <description>Address Aliasing Ending Address Register</description>
          <addressOffset>0x70</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>EA</name>
              <description>
              Ending address of the address aliasing area
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>22</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>AAOAR</name>
          <displayName>AAOAR</displayName>
          <description>Address Aliasing Offset Address Register</description>
          <addressOffset>0x74</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>OA</name>
              <description>
              The offset to be added to the original address
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>22</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CIR</name>
          <displayName>CIR</displayName>
          <description>Command Interval Register</description>
          <addressOffset>0x78</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>INTERVAL2</name>
              <description>
              The interval between CMD1 and CMD2 (or between CMD2 itself) if CMD2E is enabled. The unit is in MCLK cycles
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>INTERVAL1</name>
              <description>
              The interval between CMD1 itself. The unit is in MCLK cycles
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SMR</name>
          <displayName>SMR</displayName>
          <description>Status Match Register</description>
          <addressOffset>0x7c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>STATUS</name>
              <description>
              If status match is enabled, this register is compared with the data read from external memory.
              Together with SMKR, only the bits with mask=1 will be considered to compare in AND or OR mode as configured in SMM field.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SMKR</name>
          <displayName>SMKR</displayName>
          <description>Status Mask Register</description>
          <addressOffset>0x80</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>MASK</name>
              <description>
              Status mask
              0: the corresponding bit is not considered to compare
              1: the corresponding bit is considered to compare
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TIMR</name>
          <displayName>TIMR</displayName>
          <description>Timer Register</description>
          <addressOffset>0x84</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>TIMEOUT</name>
              <description>
              After the transaction is complete, CS remains low for multiple cycles of MCLK as specified by this register.
              For example if TIMEOUT=n, CS remains active for n cycles, during which if a new transaction occurs and the address is consecutive, the memory access can be resumed w/o sending the command and address again.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>WDTR</name>
          <displayName>WDTR</displayName>
          <description>WDT Register</description>
          <addressOffset>0x88</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>TOF</name>
              <description>
              Timeout flag. Self cleared when HREADYOUT becomes ready
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>14</bitWidth>
            </field>
            <field>
              <name>EN</name>
              <description>
              WDT enable. This watchdog is on AHB side such that bus access will not hang in exceptional cases
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TIMEOUT</name>
              <description>
              Set timeout value in number of clk_wdt cycles
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PRSAR</name>
          <displayName>PRSAR</displayName>
          <description>Prefetch Starting Address Register</description>
          <addressOffset>0x8c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>SA</name>
              <description>
              Starting address of the prefetch area
              If prefetch is enabled and the read address falls into [PRSAR, PREAR), controller will prefetch the following data
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>22</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PREAR</name>
          <displayName>PREAR</displayName>
          <description>Prefetch Ending Address Register</description>
          <addressOffset>0x90</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>EA</name>
              <description>
              Ending address of the prefetch area
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>22</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CALCR</name>
          <displayName>CALCR</displayName>
          <description>Calibration Clock Register</description>
          <addressOffset>0x94</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>EN</name>
              <description>
              calibration enable
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>22</bitWidth>
            </field>
            <field>
              <name>DONE</name>
              <description>
              calibration done flag
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DELAY</name>
              <description>
              calibration delay result
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>APM32CR</name>
          <displayName>APM32CR</displayName>
          <description>APM32 Control Register</description>
          <addressOffset>0x98</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>TCPHW</name>
              <description>
              For special use by AP 32Mb PSRAM.Reserved-Do not modify
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>TCPHR</name>
              <description>
              For special use by AP 32Mb PSRAM.Reserved-Do not modify
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CR2</name>
          <displayName>CR2</displayName>
          <description>Control Register 2</description>
          <addressOffset>0x9c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>LOOP</name>
              <description>
              Repeat CMD1->CMD2 sequence for n times. This filed is only valid when CMD2E=1 and SME2=0.
              For example if LOOP=0, then the sequence is CMD1 -> CMD2.
              If LOOP=2, then the sequence is (CMD1->CMD2) -> (CMD1->CMD2) -> (CMD1->CMD2)
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>SDMMC</name>
      <description></description>
      <groupName>SDMMC</groupName>
      <baseAddress>0x40085000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>SAR</name>
          <displayName>SAR</displayName>
          <description>System Address/Argument2 Register</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>ADDR</name>
              <description>
              This register contains the physical system memory address used for DMA transfers or the second argument for the Auto CMD23. 
              (1) SDMA System Address 
              This register contains the system memory address for a SDMA transfer. 
              The SDMA transfer waits at the every boundary specified by BSR_SDMABDY. After SDMA has stopped, the next system address of the next contiguous data position cannot be read from this register but from NSAR. The Host Controller generates ISR_DMA Interrupt to request the Host Driver to update this register. The Host Driver sets the next system address of the next data position to this register. When the most upper byte of this register is written, the Host Controller restarts the SDMA transfer. 
              (2) Argument 2 
              This register is used with the Auto CMD23 to set a 32-bit block count value to the argument of the CMD23 while executing Auto CMD23. If Auto CMD23 is used with ADMA, the full 32-bit block count value can be used. If Auto CMD23 is used without AMDA, the available block count value is limited by BSR_BCNT. 65535 blocks is the maximum value in this case. 
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BSR</name>
          <displayName>BSR</displayName>
          <description>Block Size Register</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>BCNT</name>
              <description>
              Blocks Count For Current Transfer.
              This register is enabled when MULTIBLK is set to 1 and is valid only for multiple block transfers. Controller decrements the block count after each block transfer. Setting the block count to 0 results in no data blocks is transferred. 
              This register should be accessed only when no transaction is executing (i.e., after transactions are stopped). During data transfer, read operations on this register may return an invalid value and write operations are ignored. 
              When a suspend command is completed, the number of blocks yet to be transferred can be determined by reading this register. Before issuing a resume command, the Host Driver shall restore the previously saved block count. 
              FFFFh 65535 blocks 
              ... ... 
              0002h 2 blocks 
              0001h 1 block 
              0000h Stop Count
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SDMABDY</name>
              <description>
              Host SDMA Buffer Boundary.
              The large contiguous memory space may not be available in the virtual memory system. To perform long SDMA transfer, SDMA System Address register shall be updated at every system memory boundary during SDMA transfer. 
              These bits specify the size of contiguous buffer in the system memory. The SDMA transfer shall wait at the every boundary specified by these fields and the Controller generates the ISR_DMA Interrupt to request the Host Driver to update the SDMA System Address register. At the end of transfer, the Controller may issue or may not issue ISR_DMA Interrupt. In particular, ISR_DMA Interrupt shall not be issued after ISR_TC Interrupt is issued. 
              In case of this register is set to 0 (buffer size = 4K bytes), lower 12-bit of byte address points data in the contiguous buffer and the upper 20-bit points the location of the buffer in the system memory. The SDMA transfer stops when the Controller detects carry out of the address from bit 11 to 12. 
              ADMA does not use this register. 
              000b 4K bytes (Detects A11 carry out) 
              001b 8K bytes (Detects A12 carry out) 
              010b 16K Bytes (Detects A13 carry out) 
              011b 32K Bytes (Detects A14 carry out) 
              100b 64K bytes (Detects A15 carry out) 
              101b 128K Bytes (Detects A16 carry out) 
              110b 256K Bytes (Detects A17 carry out) 
              111b 512K Bytes (Detects A18 carry out) 
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>BSIZE</name>
              <description>
              Transfer Block Size
              This register specifies the block size of data transfers such as CMD17, CMD18, CMD24, CMD25, and CMD53. Usually set to 512 for SD and eMMC access.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ARG1</name>
          <displayName>ARG1</displayName>
          <description>Argument 1</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>ARG</name>
              <description>
              Command Argument 1 
              The SD command argument is specified as bit39-8 of Command-Format in the Physical Layer Specification. 
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CR1</name>
          <displayName>CR1</displayName>
          <description>Control and Command Register 1</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>CMDIDX</name>
              <description>
              Command Index 
              These bits shall be set to the command number (CMD0-63, ACMD0-63) that is specified in bits 45-40 of the Command-Format in the Physical Layer Specification and SDIO Card Specification. 
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>CMDTYPE</name>
              <description>
              Command Type
              There are three types of special commands: Suspend, Resume and Abort. These bits shall be set to 00b for all other commands. 
              (1) Suspend Command 
              If the Suspend command succeeds, the Controller shall assume the SD Bus has been released and that it is possible to issue the next command, which uses the DAT line. The Controller shall de-assert Read Wait for read transactions and stop checking busy for write transactions. The interrupt cycle shall start, in 4-bit mode. If the Suspend command fails, the Controller shall maintain its current state, and the Host Driver shall restart the transfer by setting CR2_CONTREQ. 
              (2) Resume Command 
              The Host Driver re-starts the data transfer. The Controller shall check for busy before starting write transfers. 
              (3) Abort Command 
              If this command is set when executing a read transfer, the Controller shall stop reads to the buffer. If this command is set when executing a write transfer, the Controller shall stop driving the DAT line. After issuing the Abort command, the Host Driver should issue a software reset. 
              11b Abort CMD12, CMD52 for writing "I/O Abort" in CCCR 
              10b Resume CMD52 for writing "Function Select" in CCCR 
              01b Suspend CMD52 for writing "Bus Suspend" in CCCR 
              00b Normal Other commands
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>DATAPRESENT</name>
              <description>
              Data Present Select 
              This bit is set to 1 to indicate that data is present and shall be transferred using the DAT line. It is set to 0 for the following: 
              (1) Commands using only CMD line (ex. CMD52). 
              (2) Commands with no data transfer but using busy signal on DAT[0] line (R1b or R5b ex. CMD38) 
              (3) Resume command 
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CHECKIDX</name>
              <description>
              Command Index Check Enable 
              If this bit is set to 1, the Controller shall check the Index field in the response to see if it has the same value as the command index. If it is not, it is reported as a Command Index Error. If this bit is set to 0, the Index field is not checked. 
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CHECKCRC</name>
              <description>
              Command CRC Check Enable 
              If this bit is set to 1, the Controller shall check the CRC field in the response. If an error is detected, it is reported as a Command CRC Error. If this bit is set to 0, the CRC field is not checked. The position of CRC field is determined according to the length of the response. 
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSPTYPE</name>
              <description>
              Response Type Select 
              00 No Response 
              01 Response Length 136 
              10 Response Length 48 
              11 Response Length 48 check Busy after
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>STREAMMODE</name>
              <description>
              Stream Mode Enable 
              The Host driver has to set this bit for MMC CMD11 / CMD20 Stream Read/Write Operations. 
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>MULTIBLK</name>
              <description>
              Multi / Single Block Select 
              This bit is set when issuing multiple-block transfer commands using DAT line. For any other commands, this bit shall be set to 0. If this bit is 0, it is not necessary to set BSR_BCNT
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DIR</name>
              <description>
              Data Transfer Direction Select 
              This bit defines the direction of DAT line data transfers. The bit is set to 1 to read data from the SD card to the Controller and it is set to 0 for all other commands. 
              1 Read (Card to Host) 
              0 Write (Host to Card) 
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>AUTOCMD</name>
              <description>
              Auto CMD Enable 
              This field determines use of auto command functions. 
              00b Auto Command Disabled 
              01b Auto CMD12 Enabled 
              10b Auto CMD23 Enabled 
              11b Reserved 
              There are two methods to stop Multiple-block read and write operation. 
              (1) Auto CMD12 Enable 
              When this field is set to 01b, the Controller issues CMD12 automatically when last block transfer is completed. Auto CMD12 error is indicated to CR4. 
              The Host Driver shall not set this bit if the command does not require CMD12. 
              (2) Auto CMD23 Enable 
              When this bit field is set to 10b, the Controller issues a CMD23 automatically before issuing a command specified. The following conditions are required to use the Auto CMD23. 
               A memory card that supports CMD23 (SCR[33]=1) 
               If DMA is used, it shall be ADMA. 
               Only when CMD18 or CMD25 is issued (Note, the Controller does not check command index.) 
              Auto CMD23 can be used with or without ADMA. The Controller issues a CMD23 first and then issues a command specified by CR1. If response errors of CMD23 are detected, the second command is not issued. A CMD23 error is indicated in CR4. 
              32-bit block count value for CMD23 is set to SAR. 
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>BCNTEN</name>
              <description>
              Block Count Enable 
              This bit is used to enable the Block Count register, which is only relevant for multiple block transfers. When this bit is 0, the Block Count register is disabled, which is useful in executing an infinite transfer. 
              If ADMA data transfer is more than 65535 blocks, this bit shall be set to 0. In this case, data transfer length is designated by Descriptor Table. 
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMAEN</name>
              <description>
              DMA Enable
              This bit enables DMA functionality. SDMA or ADMA mode can be selected by CR2_DMAMODE.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSP1</name>
          <displayName>RSP1</displayName>
          <description>Command Response 31~0</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSP</name>
              <description>
              Command Response [31:0]
              The Response Field indicates bit positions of "Responses" defined in the Physical Layer Spec. Most responses with a length of 48 (R[47:0]) have 32 bits of the response data (R[39:8]) stored in RSP1. Responses of type R1b (Auto CMD12 responses) and R1 (Auto CMD23 response) have response data bits R[39:8] stored in RSP4. Responses with length 136 (R[135:0]) have 120 bits of the response data (R[127:8]) stored in RSP1~RSP4. 
              To be able to read the response status efficiently, the Controller only stores part of the response data. This enables the Host Driver to read 32 bits of response data efficiently in one read cycle on a 32-bit bus system. Parts of the response, the Index field and the CRC, are checked by the Controller (as specified by CR1_CHECKIDX and the CR1_CHECKCRC) and generate an error interrupt if an error is detected. The bit range for the CRC check depends on the response length. If the response length is 48, the Controller shall check R[47:1], and if the response length is 136 the Controller shall check R[119:1]. 
              Since the Controller may have a multiple block data DAT line transfer executing concurrently with a CMD_wo_DAT command, the Controller stores the Auto CMD12 response in RSP4. The CMD_wo_DAT response is stored in RSP1. This allows the Controller to avoid overwriting the Auto CMD12 response with the CMD_wo_DAT and vice versa. 
              While executing Auto CMD23, the response of CMD23 is saved to RSP4 and the response of multiple-block read and write command is save to RSP1. The response error of CMD23 is indicated in CR4. 
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSP2</name>
          <displayName>RSP2</displayName>
          <description>Command Response 63~32</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSP</name>
              <description>
              Command Response [63:32]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSP3</name>
          <displayName>RSP3</displayName>
          <description>Command Response 95~64</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSP</name>
              <description>
              Command Response [95:64]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSP4</name>
          <displayName>RSP4</displayName>
          <description>Command Response 127~96</description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSP</name>
              <description>
              Command Response [127:96]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BUF</name>
          <displayName>BUF</displayName>
          <description>Buffer Data Port Register</description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              Buffer Data 
              The Controller buffer can be accessed through this 32-bit Data Port register. 
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SR</name>
          <displayName>SR</displayName>
          <description>Present State Register</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
            <field>
              <name>CMDLVL</name>
              <description>
              CMD Line Signal Level 
              This status is used to check the CMD line level to recover from errors, and for debugging.
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DATLVL</name>
              <description>
              DAT-DAT3 Line Signal Level 
              This status is used to check the DAT line level to recover from errors, and for debugging. This is especially useful in detecting the busy signal level from DAT [0].
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>BUFREN</name>
              <description>
              Buffer Read Enable 
              This status is used for non-DMA read transfers. 
              The Controller may implement multiple buffers to transfer data efficiently. This read only flag indicates that valid data exists in the host side buffer. If this bit is 1, readable data exists in the buffer. A change of this bit from 1 to 0 occurs when all the block data is read from the buffer. A change of this bit from 0 to 1 occurs when block data is ready in the buffer and generates ISR_BUFRRDY. 
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BUFWEN</name>
              <description>
              Buffer Write Enable
              This status is used for non-DMA write transfers.
              The Controller can implement multiple buffers to transfer data efficiently. This read only flag indicates if space is available for write data. If this bit is 1, data can be written to the buffer. A change of this bit from 1 to 0 occurs when all the block data is written to the buffer. A change of this bit from 0 to 1 occurs when top of block data can be written to the buffer and generates ISR_BUFWRDY. The Controller should neither set Buffer Write Enable nor generate ISR_BUFWRDY after the last block data is written to the Buffer Data Port Register.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RACTIVE</name>
              <description>
              Read Transfer Active 
              This status is used for detecting completion of a read transfer. 
              This bit is set to 1 for either of the following conditions: 
              (1) After the end bit of the readcommand. 
              (2) When read operation is restarted by writing 1 to CR2_CONTREQ. 
              This bit is cleared to 0 for either of the following conditions:
              (1) When the last data block as specified by block length is transferred to the System. 
              (2) In case of ADMA, end of read operation is designated by Descriptor Table. 
              (3) When all valid data blocks in the Controller have been transferred to the System and no current block transfers are being sent as a result of CR2_BLKGAPSTOP being set to 1. 
              A Transfer Complete interrupt is generated when this bit changes to 0.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>WACTIVE</name>
              <description>
              Write Transfer Active 
              This status indicates a write transfer is active. If this bit is 0, it means no valid write data exists in the Controller. 
              This bit is set in either of the following cases: 
                     After the end bit of the write command. 
                     When write operation is restarted by writing 1 to CR2_CONTREQ. 
              This bit is cleared in either of the following cases: 
                     After getting the CRC status of the last data block as specified by the transfer count (Single and Multiple) In case of ADMA, transfer count is designated by Descriptor Table. 
                     After getting the CRC status of any block where data transmission is about to be stopped by CR2_BLKGAPSTOP. 
              During a write transaction, ISR_BLKGAP is generated when this bit is changed to 0, as the result of CR2_BLKGAPSTOP begin set. This status is useful for the Host Driver in determining non DAT line commands can be issued during write busy. 
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>DATACTIVE</name>
              <description>
              DAT Line Active 
              This bit indicates whether one of the DAT line on SD Bus is in use. 
              (a) In the case of read transactions 
              This status indicates whether a read transfer is executing on the SD Bus. Changing this value from 1 to 0 generates ISR_BLKGAP, as the result of CR2_BLKGAPSTOP being set. 
              This bit shall be set in either of the following cases: 
              (1) After the end bit of the read command. 
              (2) When writing 1 to CR2_CONTREQ to restart a read transfer. 
              This bit shall be cleared in either of the following cases 
              (1) When the end bit of the last data block is sent from the SD Bus to the Controller. In case of ADMA, the last block is designated by the last transfer of Descriptor Table. 
              (2) When a read transfer is stopped at the block gap initiated by CR2_BLKGAPSTOP. 
              The Controller shall stop read operation at the start of the interrupt cycle of the next block gap by driving Read Wait or stopping SD clock. If the Read Wait signal is already driven (due to data buffer cannot receive data), the Controller can continue to stop read operation by driving the Read Wait signal. It is necessary to support Read Wait in order to use suspend / resume function. 
              (b) In the case of write transactions 
              This status indicates that a write transfer is executing on the SD Bus. Changing this value from 1 to 0 generate ISR_TC.
              This bit shall be set in either of the following cases: 
              (1) After the end bit of the write command. 
              (2) When writing 1 to CR2_CONTREQ to continue a write transfer. 
              This bit shall be cleared in either of the following cases: 
              (1) When the SD card releases write busy of the last data block. If SD card does not drive busy signal for 8 SD Clocks, the Controller shall consider the card drive "Not Busy". In case of ADMA, the last block is designated by the last transfer of Descriptor Table. 
              (2) When the SD card releases write busy prior to waiting for write transfer as a result of CR2_BLKGAPSTOP. 
              (c) Command with busy
              This status indicates whether a command indicates busy (ex. erase command for memory) is executing on the SD Bus. This bit is set after the end bit of the command with busy and cleared when busy is de-asserted. Changing this bit from 1 to 0 generate ISR_TC. 
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DATBUSY</name>
              <description>
              Command Inhibit (DAT) 
              This status bit is generated if either the DAT Line Active or the Read Transfer Active is set to 1. If this bit is 0, it indicates the Controller can issue the next SD Command. Commands with busy signal belong to Command Inhibit (DAT) (ex. R1b, R5b type). 
              Changing from 1 to 0 generates ISR_TC interrupt. 
              1 Cannot issue command which uses the DAT line 
              0 Can issue command which uses the DAT line
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CMDBUSY</name>
              <description>
              Command Inhibit (CMD) 
              If this bit is 0, it indicates the CMD line is not in use and the Controller can issue a SD Command using the CMD line. 
              This bit is set immediately after CR1 is written. This bit is cleared when the command response is received. Auto CMD12 and Auto CMD23 consist of two responses. In this case, this bit is not cleared by the response of CMD12 or CMD23 but cleared by the response of a read/write command. Status issuing Auto CMD12 is not read from this bit. So if a command is issued during Auto CMD12 operation, Controller shall manage to issue two commands: CMD12 and a command set by CR1. 
              Even if the DATBUSY is set to 1, commands using only the CMD line can be issued if this bit is 0. Changing from 1 to 0 generates ISR_CC Interrupt. 
              If the Controller cannot issue the command because of a command conflict error or because of Command Not Issued By Auto CMD12 Error, this bit shall remain 1 and the Command Complete is not set. 
              1 Cannot issue command 
              0 Can issue command using only CMD line
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CR2</name>
          <displayName>CR2</displayName>
          <description>Control Register 2</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
            <field>
              <name>BLKGAPIE</name>
              <description>
              Interrupt At Block Gap 
              This bit is valid only in 4-bit mode of the SDIO card and selects a sample point in the interrupt cycle. Setting to 1 enables interrupt detection at the block gap for a multiple block transfer. Setting to 0 disables interrupt detection during a multiple block transfer. If the SD card cannot signal an interrupt during a multiple block transfer, this bit should be set to 0. The Host Driver shall set this bit according to the CCCR of the SDIO card. 
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RWAITEN</name>
              <description>
              Read Wait Control 
              The read wait function is optional for SDIO cards. If the card supports read wait, set this bit to enable use of the read wait protocol to stop read data using the DAT2 line. Otherwise, the Controller has to stop the SD Clock to hold read data, which restricts commands generation. The Host Driver shall set this bit according to the CCCR of the SDIO card. 
              If the card does not support read wait, this bit shall never be set to 1 otherwise DAT line conflict may occur. If this bit is set to 0, Suspend/Resume cannot be supported.
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CONTREQ</name>
              <description>
              Continue Request
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BLKGAPSTOP</name>
              <description>
              Stop At Block Gap request
              This bit is used to stop executing read and write transaction at the next block gap for non-DMA, SDMA and ADMA transfers. The Host Driver shall leave this bit set to 1 until the Transfer Complete is set to 1. Clearing both Stop At Block Gap Request and Continue Request shall not cause the transaction to restart. The Controller shall stop read transfer by using Read Wait or stopping SD clock. In case of write transfers in which the Host Driver writes data to the Buffer Data Port register, the Host Driver shall set this bit after all block data is written. If this bit is set to 1, the Host Driver shall not write data to BUF. 
              1 Stop 
              0 Transfer
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>PPMODE</name>
              <description>
              CMD line output mode. Open drain mode should only be used when accessing eMMC device.
              1 Push Pull Mode 
              0 Open Drain Mode 
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>EXTWIDTH</name>
              <description>
              Extended Data Transfer Width 
              1 8-bit Bus Width 
              0 Bus Width is Selected by DATAWIDTH
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMAMODE</name>
              <description>
              DMA Select 
              One of supported DMA modes can be selected. DMA mode is enabled by CR1_DMAEN. 
              00b SDMA
              01b Reserved
              10b ADMA
              11b Reserved 
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>HSMODE</name>
              <description>
              Reserved for debug. Adjust output timing of CMD line and DAT lines. 
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DATWIDTH</name>
              <description>
              Data Transfer Width 
              This bit selects the data width of the Controller when EXTWIDTH is 0. The Host Driver shall set it to match the data width of the SD card. 
              1 4-bit mode 
              0 1-bit mode 
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CR3</name>
          <displayName>CR3</displayName>
          <description>Control Register 3</description>
          <addressOffset>0x2c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>RSTDAT</name>
              <description>
              Software Reset For DAT Line 
              Only part of data circuit is reset. DMA circuit is also reset. Will be cleared automatically. Because it takes some time to complete software reset, the SD Host Driver shall confirm that these bits are 0.
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSTCMD</name>
              <description>
              Software Reset For CMD Line 
              Only part of command circuit is reset. Will be cleared automatically. Because it takes some time to complete software reset, the SD Host Driver shall confirm that these bits are 0.
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RST</name>
              <description>
              This reset affects the entire Controller except for the card detection circuit. Register bits (except read-only bits) are cleared to 0. During its initialization, the Host Driver shall set this bit to 1 to reset the Controller. If this bit is set to 1, the host driver should issue reset command and reinitialize the SD card. Will be cleared automatically. Because it takes some time to complete software reset, the SD Host Driver shall confirm that these bits are 0.
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>DTOCNT</name>
              <description>
              Data Timeout Counter Value 
              This value determines the interval by which DAT line timeouts are detected. 
              Timeout period is defined as:
              1111b Reserved 
              1110b 4096*2^14 FCLK periods
              ............ ............ 
              0001b 4096*2^1 FCLK periods
              0000b 4096*2 FCLK periods
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>CLKDIVL</name>
              <description>
              CLK divider lower 8 bits
              10-bit CLKDIV is {CLKDIVU,CLKDIVL}. 
              If CLKDIV=0, CLK = FCLK. 
              If CLKDIV!=0,  CLK = FCLK/(2*CLKDIV).
              e.g. FCLK=192MHz, CLKDIV=240, then CLK frequency is 400KHz.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>CLKDIVU</name>
              <description>
              CLK divider upper 2 bits
              These bits expand clk divider to 10-bit. 
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>CLKEN</name>
              <description>
              SD Clock Enable
              0: SD clock disabled
              1: SD clock enabled
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>INTCLKEN</name>
              <description>
              Internal Clock Enable
              0: Internal clock disabled
              1: Internal clock enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ISR</name>
          <displayName>ISR</displayName>
          <description>Interrupt State Register</description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>ADMAERR</name>
              <description>
              ADMA Error 
              This bit is set when the Controller detects errors during ADMA based data transfer. The state of the ADMA at an error occurrence is saved in the AESR, In addition, the Controller generates this Interrupt when it detects invalid descriptor data (Valid=0). ADMA Error State in the ADMA Error Status indicates that an error occurs. The Host Driver may find that Valid bit is not set at the error descriptor. 
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ACERR</name>
              <description>
              Auto CMD Error 
              Auto CMD12 and Auto CMD23 use this error status. In case of Auto CMD12, this bit is set to 1, not only when the errors in Auto CMD12 occur but also when Auto CMD12 is not executed due to the previous command error. 
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DEBERR</name>
              <description>
              Data End Bit Error 
              Occurs either when detecting 0 at the end bit position of read data which uses the DAT line or at the end bit position of the CRC Status. 
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DCRCERR</name>
              <description>
              Data CRC Error 
              Occurs when detecting CRC error when transferring read data which uses the DAT line or when detecting the Write CRC status having a value of other than "010". 
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DTOERR</name>
              <description>
              Data Timeout Error 
              This bit is set when detecting one of following timeout conditions. 
                   Busy timeout for R1b,R5b type 
                   Busy timeout after Write CRC status 
                   Write CRC Status timeout 
                   Read Data timeout.
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IDXERR</name>
              <description>
              Command Index Error
              This bit is set if a Command Index error occurs in the command response.
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CEBERR</name>
              <description>
              Command End Bit Error 
              This bit is set when detecting that the end bit of a command response is 0.
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CCRCERR</name>
              <description>
              Command CRC Error 
              Command CRC Error is generated in two cases. 
              If a response is returned and the Command Timeout Error is set to 0 (indicating no timeout), this bit is set to 1 when detecting a CRC error in the command response. 
              The Controller detects a CMD line conflict by monitoring the CMD line when a command is issued. If the Controller drives the CMD line to 1 level, but detects 0 level on the CMD line at the next SD clock edge, then the Controller shall abort the command (Stop driving CMD line) and set this bit to 1. The Command Timeout Error shall also be set to 1 to distinguish CMD line conflict 
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTOERR</name>
              <description>
              Command Timeout Error
              This bit is set only if no response is returned within 64 SD clock cycles from the end bit of the command. If the Controller detects a CMD line conflict, in which case Command CRC Error shall also be set, this bit shall be set without waiting for 64 SD clock cycles because the command will be aborted by the Controller.
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ERR</name>
              <description>
              Error Interrupt 
              If any error bit (bit16~bit31) of ISR are set, then this bit is set. Therefore the Host Driver can efficiently test for an error by checking this bit first. This bit is read only.
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>CARD</name>
              <description>
              Card Interrupt 
              Writing this bit to 1 does not clear this bit. It is cleared by resetting the SD card interrupt factor.
              In 4-bit mode, the card interrupt signal is sampled during the interrupt cycle, so there are some sample delays between the interrupt signal from the SD card and the interrupt to the Host System. 
              When this status has been set and the Host Driver needs to start this interrupt service, ISER_CARDEN may be set to 0 in order to clear the card interrupt statuses latched in the Controller and to stop driving the interrupt signal to the Host System. After completion of the card interrupt service (It should reset interrupt factors in the SD card and the interrupt signal may not be asserted), set ISER_CARDEN to 1 and start sampling the interrupt signal again. 
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>BUFRRDY</name>
              <description>
              Buffer Read Ready 
              This status is set if the Buffer Read Enable changes from 0 to 1. Refer to SR_BUFREN register. 
              1 Ready to read buffer 
              0 Not ready to read buffer 
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BUFWRDY</name>
              <description>
              Buffer Write Ready
              This status is set if the Buffer Write Enable changes from 0 to 1. Refer to SR_BUFWEN register. 
              1 Ready to write buffer 
              0 Not ready to write buffer
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMA</name>
              <description>
              DMA Interrupt 
              This status is set if the Controller detects the Host SDMA Buffer boundary during transfer. Refer to BSR_SDMABDY. 
              In case of ADMA, by setting INT field in the descriptor table, Controller generates this interrupt. This interrupt shall not be generated after the Transfer Complete.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BLKGAP</name>
              <description>
              Block Gap Event 
              If CR2_BLKGAPSTOP is set, this bit is set when both a read / write transaction is stopped at a block gap. If CR2_BLKGAPSTOP is not set to 1, this bit is not set to 1. 
              (1) In the case of a Read Transaction 
              This bit is set at the falling edge of the DAT Line Active Status (When the transaction is stopped at SD Bus timing. The Read Wait shall be supported in order to use this function. 
              (2) Case of Write Transaction 
              This bit is set at the falling edge of Write Transfer Active Status (After getting CRC status at SD Bus timing). 
              1 Transaction stopped at block
              0 No Block Gap Event 
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TC</name>
              <description>
              Transfer Complete 
              This bit is set when a read / write transfer and a command with busy is completed. 
              (1) In the case of a Read Transaction
              This bit is set at the falling edge of Read Transfer Active Status. This interrupt is generated in two cases. The first is when a data transfer is completed as specified by data length (After the last data has been read to the Host System). The second is when data has stopped at the block gap and completed the data transfer by setting CR2_BLKGAPSTOP (After valid data has been read to the Host System). 
              (2) In the case of a Write Transaction
              This bit is set at the falling edge of the DAT Line Active Status. This interrupt is generated in two cases. The first is when the last data is written to the SD card as specified by data length and the busy signal released. The second is when data transfers are stopped at the block gap by setting CR2_BLKGAPSTOP and data transfers completed. (After valid data is written to the SD card and the busy signal released). 
              (3) In the case of a command with busy
              This bit is set when busy is de-asserted. Refer to SR_DATACTIVE and SR_CMDBUSY.
              Transfer Complete has higher priority than Data Timeout Error. If both bits are set to 1, execution of a command can be considered to be completed.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC</name>
              <description>
              Command Complete 
              This bit is set when get the end bit of the command response. Auto CMD12 and Auto CMD23 consist of two responses. Command Complete is not generated by the response of CMD12 or CMD23 but generated by the response of a read/write command. 
              Command Timeout Error has higher priority than Command Complete. If both bits are set to 1, it can be considered that the response was not received correctly.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ISER</name>
          <displayName>ISER</displayName>
          <description>Interrupt Status Enable Register</description>
          <addressOffset>0x34</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>ADMAERREN</name>
              <description>
              ADMA Error Status Enable 
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ACERREN</name>
              <description>
              Auto CMD Error Status Enable 
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DEBERREN</name>
              <description>
              Data End Bit Error Status Enable 
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DCRCERREN</name>
              <description>
              Data CRC Error Status Enable 
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DTOERREN</name>
              <description>
              Data Timeout Error Status Enable 
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IDXERREN</name>
              <description>
              Command Index Error Status Enable
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CEBERREN</name>
              <description>
              Command End Bit Error Status Enable 
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CCRCERREN</name>
              <description>
              Command CRC Error Status Enable 
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTOERREN</name>
              <description>
              Command Timeout Error Status Enable 
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
            <field>
              <name>CARDEN</name>
              <description>
              Card Interrupt Status Enable 
              If this bit is set to 0, the Controller shall clear interrupt request to the System. The Card Interrupt detection is stopped when this bit is cleared and restarted when this bit is set to 1. The Host Driver may clear the Card Interrupt Status Enable before servicing the Card Interrupt and may set this bit again after all interrupt requests from the card are cleared to prevent inadvertent interrupts.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>BUFRRDYEN</name>
              <description>
              Buffer Read Ready Status Enable 
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BUFWRDYEN</name>
              <description>
              Buffer Write Ready Status Enable 
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMAEN</name>
              <description>
              DMA Interrupt Status Enable 
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BLKGAPEN</name>
              <description>
              Block Gap Event Status Enable 
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCEN</name>
              <description>
              Transfer Complete Status Enable 
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CCEN</name>
              <description>
              Command Complete Status Enable 
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IER</name>
          <displayName>IER</displayName>
          <description>Interrupt Enable Register</description>
          <addressOffset>0x38</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>ADMAERRIE</name>
              <description>
              ADMA Error Interrupt Enable 
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ACERRIE</name>
              <description>
              Auto CMD Error Interrupt Enable 
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DEBERRIE</name>
              <description>
              Data End Bit Error Interrupt Enable 
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DCRCERRIE</name>
              <description>
              Data CRC Error Interrupt Enable 
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DTOERRIE</name>
              <description>
              Data Timeout Error Interrupt Enable 
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IDXERRIE</name>
              <description>
              Command Index Error Interrupt Enable
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CEBERRIE</name>
              <description>
              Command End Bit Error Interrupt Enable 
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CCRCERRIE</name>
              <description>
              Command CRC Error Interrupt Enable 
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTOERRIE</name>
              <description>
              Command Timeout Error Interrupt Enable 
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
            <field>
              <name>CARDIE</name>
              <description>
              Card Interrupt Interrupt Enable 
              If this bit is set to 0, the Controller shall clear interrupt request to the System. The Card Interrupt detection is stopped when this bit is cleared and restarted when this bit is set to 1. The Host Driver may clear the Card Interrupt Status Enable before servicing the Card Interrupt and may set this bit again after all interrupt requests from the card are cleared to prevent inadvertent interrupts.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>BUFRRDYIE</name>
              <description>
              Buffer Read Ready Interrupt Enable 
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BUFWRDYIE</name>
              <description>
              Buffer Write Ready Interrupt Enable 
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMAIE</name>
              <description>
              DMA Interrupt Interrupt Enable 
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BLKGAPIE</name>
              <description>
              Block Gap Event Interrupt Enable 
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIE</name>
              <description>
              Transfer Complete Interrupt Enable 
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CCIE</name>
              <description>
              Command Complete Interrupt Enable 
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CR4</name>
          <displayName>CR4</displayName>
          <description>Control Register 4</description>
          <addressOffset>0x3c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>13</bitWidth>
            </field>
            <field>
              <name>UHSMODE</name>
              <description>
              UHS Mode Select 
              100b DDR
              others SDR
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>CNIERR</name>
              <description>
              Command Not Issued By Auto CMD12 Error 
              Setting this bit to 1 means CMD_wo_DAT is not executed due to an Auto CMD12 Error in this register. 
              This bit is set to 0 when Auto CMD Error is generated by Auto CMD23. 
              1 Not Issued 
              0 No Error 
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>ACIDXERR</name>
              <description>
              Auto CMD Index Error 
              This bit is set if the Command Index error occurs in response to a command
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ACEBERR</name>
              <description>
              Auto CMD End Bit Error 
              This bit is set when detecting that the end bit of command response is 0.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ACCRCERR</name>
              <description>
              Auto CMD CRC Error 
              This bit is set when detecting a CRC error in the command response. 
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ACTOERR</name>
              <description>
              Auto CMD Timeout Error 
              This bit is set if no response is returned within 64 SDCLK cycles from the end bit of command. If this bit is set to1, the other error status bits are meaningless. 
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ACNE</name>
              <description>
              Auto CMD12 Not Executed 
              If memory multiple block data transfer is not started due to command error, this bit is not set because it is not necessary to issue Auto CMD12. Setting this bit to 1 means the Controller cannot issue Auto CMD12 to stop memory multiple block data transfer due to some error. If this bit is set to 1, other error status bits are meaningless. 
              This bit is set to 0 when Auto CMD Error is generated by Auto CMD23. 
              1 Not Executed 
              0 Executed
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD3</name>
          <displayName>RSVD3</displayName>
          <description></description>
          <addressOffset>0x40</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>AESR</name>
          <displayName>AESR</displayName>
          <description>ADMA Error Status Register</description>
          <addressOffset>0x54</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>29</bitWidth>
            </field>
            <field>
              <name>LENERR</name>
              <description>
              ADMA Length Mismatch Error 
              This error occurs in the following 2 cases. 
              (1) While CR1_BCNTEN being set, the total data length specified by the Descriptor table is different from that specified by the Block Count and Block Length. 
              (2) Total data length cannot be divided by the block length. 
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ERRSTATE</name>
              <description>
              ADMA Error State 
              This field indicates the state of ADMA when error is occurred during ADMA data transfer. This field never indicates "10" because ADMA never stops in this state. 
              00 ST_STOP (Stop DMA) Points next of the error descriptor 
              01 ST_FDS (Fetch Descriptor) Points the error descriptor 
              10 Never set this state (Not used) 
              11 ST_TFR (Transfer Data) Points the next of the error descriptor 
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ASAR</name>
          <displayName>ASAR</displayName>
          <description>ADMA System Address Register</description>
          <addressOffset>0x58</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>ADDR</name>
              <description>
              ADMA System Address
              This register holds byte address of executing command of the Descriptor table.
              At the start of ADMA, the Host Driver shall set start address of the Descriptor table. The ADMA increments this register address, which points to next line, when every fetching a Descriptor line. When the ADMA Error Interrupt is generated, this register shall hold valid Descriptor address depending on the ADMA state. The Host Driver shall program Descriptor Table on 32-bit boundary and set 32-bit boundary address to this register. Lower 2-bit of this register is ignored and assumes it to be 00b. 
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>NSAR</name>
          <displayName>NSAR</displayName>
          <description>Next System Address Register</description>
          <addressOffset>0x5c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>ADDR</name>
              <description>
              This register contains next physical system memory address used for SDMA transfer.
              When the Host Controller stops a SDMA transfer, this register shall point to the system address of the next contiguous data position. It can be accessed only if no transaction is executing (i.e., after a transaction has stopped). Read operations during transfers may return an invalid value. After SDMA has stopped, the next system address of the next contiguous data position can be read from this register. 
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD2</name>
          <displayName>RSVD2</displayName>
          <description></description>
          <addressOffset>0x60</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>ABSR</name>
          <displayName>ABSR</displayName>
          <description> AHB Burst Size Register</description>
          <addressOffset>0xec</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>25</bitWidth>
            </field>
            <field>
              <name>BSIZE</name>
              <description>
              AHB Master Burst Size Register 
              AHB Master performs Burst operations as per this register. 
              0:Disabled 
              1:Enabled
              Bit 00 INCR4 
              Bit 01 INCR8 
              Bit 02 INCR16 
              Bit 03 INCR 
              Bit 04 WRAP4 
              Bit 05 WRAP8 
              Bit 06 WRAP16
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD1</name>
          <displayName>RSVD1</displayName>
          <description></description>
          <addressOffset>0xF0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>SCR</name>
          <displayName>SCR</displayName>
          <description>Sampling Clock Register</description>
          <addressOffset>0xf4</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>SEL</name>
              <description>
              select sampling clock source (delay line input)
              0: use internal clock
              1: use loopback clock
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DLY</name>
              <description>
              Stages of delay line for sampling clock
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>SD</name>
      <description></description>
      <groupName>SD</groupName>
      <baseAddress>0x40086000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>SR</name>
          <displayName>SR</displayName>
          <description>command and data status register </description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>14</bitWidth>
            </field>
            <field>
              <name>CACHE_ERR</name>
              <description>
              Detect cache error
              Read 1: cache error occur
              Read 0: no cache error
              Write 1: clear the bit
              Write 0: no any influence to the bit
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SDIO</name>
              <description>
              Detect SDIO Card Interrupt
              Read 1: detect sdio card generating interrupt
              Read 0: no interrupt
              Write 1: clear the bit
              Write 0: no any influence to the bit
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CARD_EXIST</name>
              <description>
              Card exist status
              Read 1: card exist
              Read 0: no card exist
              This bit will be valid after enable detect card.
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CARD_REMOVE</name>
              <description>
              Detect card removed
              Read 1: detect card removed. When detect card inserted bit is set, the bit will also be back to 0
              Read 0:  no meaning
              Write 1: clear the bit
              Write 0: no any influence to the bit
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CARD_INSERT</name>
              <description>
              Detect card inserted 
              Read 1: detect card inserted. When detect card removed bit is set, the bit will also be back to 0
              Read 0:  no meaning
              Write 1: clear the bit
              Write 0: no any influence to the bit
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CMD_SENT</name>
              <description>
              Command sent (perhaps no response back yet) 
              Read 1: command sent. When command start bit is set, the bit will also be back to 0
              Read 0: command transferring or others
              Write 1: clear the bit
              Write 0: no any influence to the bit
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FIFO_OVERRUN</name>
              <description>
              FIFO overrun 
              Read 1: FIFO overrun error
              Read 0: no FIFO overrun error
              Write 1: clear the bit
              Write 0: no any influence to the bit
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FIFO_UNDERRUN</name>
              <description>
              FIFO underrun 
              Read 1: FIFO underrun error
              Read 0: no FIFO underrun error
              Write 1: clear the bit
              Write 0: no any influence to the bit
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>STARTBIT_ERROR</name>
              <description>
              Wide bus start bits error 
              Didn't detect all start bits in data bus
              Read 1: start bits error
              Read 0: no start bits error
              Write 1: clear the bit
              Write 0: no any influence to the bit
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DATA_TIMEOUT</name>
              <description>
              Data timeout 
              Read 1: timeout
              Read 0: no timeout
              Write 1: clear the bit
              Write 0: no any influence to the bit
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DATA_CRC</name>
              <description>
              Data CRC error 
              Read 1: data CRC error
              Read 0: data CRC right
              Write 1: clear the bit
              Write 0: no any influence to the bit
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DATA_DONE</name>
              <description>
              Data transfer done 
              Read 1: transfer data done, and start a new transfer will take the bit into 0
              Read 0: data transferring or idle
              Write 1: clear the bit 
              Write 0: no any influence to the bit
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DATA_BUSY</name>
              <description>
              Transfer Data busy 
              1: busy, and when busy, start transfer data bit is no usage and you should not modify the relative register. If want to do this, first disable transfer data enable bit, then the busy bit will be back to 0, and this transfer will also be cancelled.
              0: data idle
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CMD_TIMEOUT</name>
              <description>
              Command timeout (response timeout) 
              Read 1: timeout
              Read 0: no timeout
              Write 1: clear the bit
              Write 0: no any influence to the bit
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CMD_RSP_CRC</name>
              <description>
              Command response CRC error status 
              Read 1: response CRC error
              Read 0: response CRC right
              Write 1: clear the bit
              Write 0: no any influence to the bit
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CMD_DONE</name>
              <description>
              Command done 
              Read 1: transfer command done, and start a new transfer will take the bit into 0
              Read 0: command transferring or idle
              Write 1: clear the bit 
              Write 0: no any influence to the bit
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CMD_BUSY</name>
              <description>
              Command busy
              1: busy, and when busy, start TX command bit is no usage and should not modify the relative register
              0: command idle
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR</name>
          <displayName>CCR</displayName>
          <description>command control register</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>CMD_INDEX</name>
              <description>
              Command index
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>CMD_LONG_RSP</name>
              <description>
              1: Response will be 136-bit, long response
              0: Response will be 48-bit, normal response
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CMD_HAS_RSP</name>
              <description>
              1: Response expected after command
              0: No response expected after command
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>CMD_PEND</name>
              <description>
              Command pending enable
              When prepare to send stop command, this bit should be set. Controller will calculate a proper time point to send out the command to guarantee all the data have been transferred. And this is mainly used in stream mode.
              Recommend using set_block_count (SD/MMC basis command) to control transferring data for block mode.
              If send stop command for canceling this transfer (such as CRC error in multi-block), no need to set the bit. 
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CMD_TX_EN</name>
              <description>
              TX command enable
              1: enable TX command
              0: disable TX command
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
            <field>
              <name>CMD_START</name>
              <description>
              Command start
              write 1 to start command TX, and when begin to TX command, the bit will return into 0.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CAR</name>
          <displayName>CAR</displayName>
          <description>command argument register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>CMD_ARG</name>
              <description>
              Command argument
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RIR</name>
          <displayName>RIR</displayName>
          <description>response command index register</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>26</bitWidth>
            </field>
            <field>
              <name>RSP_INDEX</name>
              <description>
              Response command index
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RAR1</name>
          <displayName>RAR1</displayName>
          <description>response command argument1 register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSP_ARG1</name>
              <description>
              Response command content
              If long response, it is rsp_arg[39:8]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RAR2</name>
          <displayName>RAR2</displayName>
          <description>response command argument2 register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSP_ARG2</name>
              <description>
              Long response, it is rsp_arg[71:40]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RAR3</name>
          <displayName>RAR3</displayName>
          <description>response command argument3 register</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSP_ARG3</name>
              <description>
              Long response, it is rsp_arg[103:72]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RAR4</name>
          <displayName>RAR4</displayName>
          <description>response command argument4 register</description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>RSP_ARG4</name>
              <description>
              Long response, it is rsp_arg[127:104]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TOR</name>
          <displayName>TOR</displayName>
          <description>timeout count register</description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>TIMEOUT_CNT</name>
              <description>
              Used to determine how much time waiting response or data bus busy is timeout, and decreased under card clock.
              Set to 400000 for 1s timeout if interface clock is 400KHz.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DCR</name>
          <displayName>DCR</displayName>
          <description>data control register</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>BLOCK_SIZE</name>
              <description>
              Data block size is block_size+1 (max 2048 bytes)
              0: 1 byte
              0x1ff: 512 bytes
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>WIRE_MODE</name>
              <description>
              Wide data bus mode
              00: 1 wire bus
              01: 4 wires wide bus
              1X: reserved
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>STREAM_MODE</name>
              <description>
              Data transfer mode
              0: block
              1: stream
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>R_WN</name>
              <description>
              Write or read
              0: write data into card
              1: read data from card
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TRAN_DATA_EN</name>
              <description>
              Transfer data enable
              0: disable transfer data. After disable data transfer, stop command should be sent to card
              1: enable data transfer
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
            <field>
              <name>DATA_START</name>
              <description>
              Start transfer data
              set 1 to let the controller begin to transfer data (in fact, go into wait write or wait read state). After begin to transfer, this bit will be back to 0.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DLR</name>
          <displayName>DLR</displayName>
          <description>data length register</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>BLOCK_TRAN_NUM</name>
              <description>
              The number of blocks which have been transferred successfully
              1 = 1 block transferred
              It is cleared when start transfer data bit is set.
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>DATA_LEN</name>
              <description>
              Data length value. The number of data bytes is data_len+1.
              The number of data bytes should be a multiple of data block size.
              0 is 1 byte. 0x1ff is 512 bytes. Max is 63.5KB.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IER</name>
          <displayName>IER</displayName>
          <description>command and data interrupt mask register</description>
          <addressOffset>0x2c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>14</bitWidth>
            </field>
            <field>
              <name>CACHE_ERR_MASK</name>
              <description>
              cache error mask for interrupt
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SDIO_MASK</name>
              <description>
              Detect SDIO interrupt(data[1]) mask for interrupt
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CARD_REMOVE_MASK</name>
              <description>
              Detect card remove mask for interrupt
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CARD_INSERT_MASK</name>
              <description>
              Detect card insert mask for interrupt
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CMD_SENT_MASK</name>
              <description>
              Command sent mask for interrupt
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FIFO_OVERRUN_MASK</name>
              <description>
              FIFO overrun bit mask for interrupt
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FIFO_UNDERRUN_MASK</name>
              <description>
              FIFO underrun bit mask for interrupt
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>STARTBIT_ERROR_MASK</name>
              <description>
              Wide bus start bits error bit mask for interrupt
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DATA_TIMEOUT_MASK</name>
              <description>
              Data timeout bit mask for interrupt
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DATA_CRC_MASK</name>
              <description>
              Data CRC error bit mask for interrupt
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DATA_DONE_MASK</name>
              <description>
              Data transfer done bit mask for interrupt
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CMD_TIMEOUT_MASK</name>
              <description>
              Command timeout bit mask for interrupt
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CMD_RSP_CRC_MASK</name>
              <description>
              Command CRC error bit mask for interrupt
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CMD_DONE_MASK</name>
              <description>
              Command done bit mask for interrupt
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD5</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CLKCR</name>
          <displayName>CLKCR</displayName>
          <description>clock control register</description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
            <field>
              <name>DIV</name>
              <description>
              Divide card clock counter. 
              0 is illegal.
              sd_clock = hclk/(div + 1)
              If hclk is 240M and div is 599, 400KHz SD clock will be generated.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>13</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>CLK_TUNE_SEL</name>
              <description>
              select clock delay for rx sample 
              0: no delay
              1: delay level 1 (~1.5ns typical)
              2: delay level 2 (~3ns typical)
              3: delay level 3 (~5ns typical)
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>VOID_FIFO_ERROR</name>
              <description>
              Void FIFO error
              0: close the function
              1: open the function
              If open it, when FIFO will be overrun or underrun soon, the SD_CLK and the clock enable of this module will be closed, and wait to host to read or write FIFO.
              Note: this function needs to be supported by card.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>STOP_CLK</name>
              <description>
              Disable SD card clock
              1: stop SD card clock
              0: SD card clock generated
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD3</name>
          <displayName>RSVD3</displayName>
          <description></description>
          <addressOffset>0x34</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>CDR</name>
          <displayName>CDR</displayName>
          <description>card interface control and card detect register</description>
          <addressOffset>0x3c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>OTIMING</name>
              <description>
              define output timing
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>13</bitWidth>
            </field>
            <field>
              <name>ITIMING</name>
              <description>
              define input timing
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>13</bitWidth>
            </field>
            <field>
              <name>CMD_OD</name>
              <description>
              Open Drain mode for cmd line (for eMMC identification mode)
              0: cmd line is push-pull
              1: cmd line is open-drain
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CD_HVALID</name>
              <description>
              Card detect high level valid
              0: detect low level means card exist
              1: detect high level means card exist (default)
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EN_CD</name>
              <description>
              Enable card detect 
              Only when the bit is valid, controller does card detect.
              If use sd_data[3] to do card detect, the bit should be cleared when transfer valid data.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OTIMING_SEL</name>
              <description>
              select output timing (according to otiming config)
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ITIMING_SEL</name>
              <description>
              select input sample timing (according to itiming config)
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SD_DATA3_CD</name>
              <description>
              Use sd_data[3] to do card detect 
              0: use special pin to do card detect / write protect. (Currently not supported)
              1: use sd_data[3] to do card detect (default)
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DBGR1</name>
          <displayName>DBGR1</displayName>
          <description>card debug port1 register</description>
          <addressOffset>0x40</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DATA_ST</name>
              <description>
              data state for debug only
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>15</bitWidth>
            </field>
            <field>
              <name>CMD_ST</name>
              <description>
              command state for debug only
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DBGR2</name>
          <displayName>DBGR2</displayName>
          <description>card debug port2 register</description>
          <addressOffset>0x44</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>DBG_SEL</name>
              <description>
              for debug only
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>VALID_DATA_COU</name>
              <description>
              for debug only
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>HOST_WORD_COUNTER</name>
              <description>
              for debug only
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>14</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CEATA</name>
          <displayName>CEATA</displayName>
          <description>CE-ATA/SDIO mode register</description>
          <addressOffset>0x48</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>28</bitWidth>
            </field>
            <field>
              <name>SDIO_4WIRES_MULTI_IRQ</name>
              <description>
              Select the sdio host 4 wires interrupt on multi-block support
              0: host not support 4 wires interrupt on multi-block data transfers
              1: host support 4 wires interrupt on multi-block data transfers
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SDIO_4WIRES_IRQ</name>
              <description>
              Select the sdio host 4 wires interrupt support
              0: host not support 4 wires interrupt on single-block data transfers
              1: host support 4 wires interrupt on single-block data transfers
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ENABLE_SDIO_IRQ</name>
              <description>
              Select the sdio card mode, default is sd card
              0: sd card mode , no sdio card interrupt 
              1: sdio card mode , enable sdio card interrupt
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ATA_MODE</name>
              <description>
              Select the card type, default is sd card
              0: sd card mode
              1: CE-ATA device mode
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD2</name>
          <displayName>RSVD2</displayName>
          <description></description>
          <addressOffset>0x4C</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>DSR</name>
          <displayName>DSR</displayName>
          <description>data status register</description>
          <addressOffset>0x54</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>SD_DATA_I_LL</name>
              <description>
              The status of each sd data pad status
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CDCR</name>
          <displayName>CDCR</displayName>
          <description>clock duty cycle register</description>
          <addressOffset>0x58</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>31</bitWidth>
            </field>
            <field>
              <name>CLK_CONFIG</name>
              <description>
              1: the sd clock is 50% duty cycle
              0: the high level of the sd clock is 1 hclk cycle
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CASR</name>
          <displayName>CASR</displayName>
          <description>cache status register</description>
          <addressOffset>0x5c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>28</bitWidth>
            </field>
            <field>
              <name>CACHE_FLUSH</name>
              <description>
              Set 1 to flush cache. Should set when cache not busy.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CACHE_BUSY</name>
              <description>
              Indicates cache is working
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SD_BUSY</name>
              <description>
              Read 1 indicates sd is ready for normal access. Ahb access will be hold during sd_busy asserted.
              After sd normal access done, write 1 to clear, and ahb access will continue
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SD_REQ</name>
              <description>
              Set 1 to request sd normal access. sd_req will be cleared automatically after sd_busy asserted
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CACR</name>
          <displayName>CACR</displayName>
          <description>cache control register</description>
          <addressOffset>0x60</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0xd0844c52</resetValue>
          <fields>
            <field>
              <name>CACHE_EN</name>
              <description>
              enable cache
              1: ahb read will return cached data
              0: ahb read always return dummy data with no error response
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CACHE_TO_EN</name>
              <description>
              enable ahb read timeout recover
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CACHE_FORCE_READ</name>
              <description>
              force cache read done
              1: start new fetch for miss access only after cache read done
              0: start new fetch for miss access even when cache is still filling (read will be breaked by cmd12)
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CACHE_SDSC</name>
              <description>
              select card version
              1: card size  lte 2GB, address of cmd18 is in byte
              0: card size >2GB, address of cmd18 is in block
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CACHE_NOCRC</name>
              <description>
              1: return ahb data without crc check
              0: return ahb data after block crc pass
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CACHE_HRESP</name>
              <description>
              1: generate ahb error response when error occur
              0: no ahb error response generated. Could check cache_err interrupt
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>CACHE_PREF_BLOCK</name>
              <description>
              cache prefetch depth is cache_pref_block blocks. Should be no less than cache_block
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CACHE_BLOCK</name>
              <description>
              cache depth is cache_block blocks
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>STOP_LONG_RSP</name>
              <description>
              Stop response is 136-bit, long response
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>STOP_HAS_RSP</name>
              <description>
              Stop command have a response
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>STOP_INDEX</name>
              <description>
              Command index for stop. CMD12 by default
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>READ_LONG_RSP</name>
              <description>
              Read response is 136-bit, long response
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>READ_HAS_RSP</name>
              <description>
              Read command have a response
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>READ_INDEX</name>
              <description>
              Command index for cache read. CMD18 by default
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CACNT</name>
          <displayName>CACNT</displayName>
          <description>cache counter register</description>
          <addressOffset>0x64</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0xffff0020</resetValue>
          <fields>
            <field>
              <name>CACHE_TOR</name>
              <description>
              timeout count register for ahb read
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>CACHE_NDC</name>
              <description>
              data-cmd interval counter in hclk cycles
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>CACHE_NCC</name>
              <description>
              cmd-cmd interval counter in hclk cycles
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CAOFF</name>
          <displayName>CAOFF</displayName>
          <description>cache offset register</description>
          <addressOffset>0x68</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>CACHE_OFFSET</name>
              <description>
              offset to map ahb address to sd address for ahb access
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD1</name>
          <displayName>RSVD1</displayName>
          <description></description>
          <addressOffset>0x6C</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>FIFO</name>
          <displayName>FIFO</displayName>
          <description>FIFO entry</description>
          <addressOffset>0x200</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              Entry to access internal FIFO. Access should be word-aligned, ranging from 0x200 to 0x3fc. Inside the range, write to any address will push the data into the FIFO, and read any address will pop a word from the FIFO.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>CRC1</name>
      <description></description>
      <groupName>CRC</groupName>
      <baseAddress>0x40088000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>DR</name>
          <displayName>DR</displayName>
          <description>Data register</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>DR</name>
              <description>
              Data register bits.
              This register is used to write new data to the CRC calculator.
              It holds the previous CRC calculation result when it is read.
              If the data size is less than 32 bits, the least significant bits are used to write/read the correct value.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SR</name>
          <displayName>SR</displayName>
          <description>Status register</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>30</bitWidth>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>
              Overflow when new data arrive while last calculation not done yet
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DONE</name>
              <description>
              Done flag. When DR written, done flag will be cleared automatically. The flag will assert after CRC operation of current DR finished.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CR</name>
          <displayName>CR</displayName>
          <description>Control register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>REV_OUT</name>
              <description>
              Reverse output data
              This bit controls the reversal of the bit order of the output data.
              0: Bit order not affected
              1: Bit-reversed output format
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>REV_IN</name>
              <description>
              Reverse input data
              These bits control the reversal of the bit order of the input data
              00: Bit order not affected
              01: Bit reversal done by byte
              10: Bit reversal done by half-word
              11: Bit reversal done by word
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>POLYSIZE</name>
              <description>
              Polynomial size
              These bits control the size of the polynomial.
              00: 32 bit polynomial
              01: 16 bit polynomial
              10: 8 bit polynomial
              11: 7 bit polynomial
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>DATASIZE</name>
              <description>
              Valid input data size
              These bits control the valid size of the input data.
              00: lower 8-bit
              01: lower 16-bit
              10: lower 24-bit
              11: all 32-bit
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RESET</name>
              <description>
              This bit is set by software to reset the CRC calculation unit and set the data register to the value stored in the CRC_INIT register. This bit can only be set, it is automatically cleared by hardware
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD1</name>
          <displayName>RSVD1</displayName>
          <description></description>
          <addressOffset>0xC</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>INIT</name>
          <displayName>INIT</displayName>
          <description>Initial CRC value</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>INIT</name>
              <description>
              Programmable initial CRC value
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>POL</name>
          <displayName>POL</displayName>
          <description>CRC polynomial</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>POL</name>
              <description>
              Programmable polynomial 
              This register is used to write the coefficients of the polynomial to be used for CRC calculation.
              If the polynomial size is less than 32 bits, the least significant bits have to be used to program the correct value.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>LPSYS_RCC</name>
      <description></description>
      <groupName>LPSYS_RCC</groupName>
      <baseAddress>0x50000000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>RSTR1</name>
          <displayName>RSTR1</displayName>
          <description>Reset Register 1</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>BUSMON2</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PTC2</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TSEN</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LPCOMP</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>AUDCODEC</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GPADC</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BTIM4</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BTIM3</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GPTIM5</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GPTIM4</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GPTIM3</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SYSCFG2</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>I2C7</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>I2C6</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>I2C5</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD5</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SPI4</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SPI3</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD6</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>USART6</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>USART5</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>USART4</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PATCH</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PINMUX2</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MAILBOX2</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMAC2</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LCPU</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSTR2</name>
          <displayName>RSTR2</displayName>
          <description>Reset Register 2</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>26</bitWidth>
            </field>
            <field>
              <name>CRC2</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MAC</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PHY</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RFC</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MPI5</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GPIO2</name>
              <description>
              0 - no reset; 1 - reset
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ENR1</name>
          <displayName>ENR1</displayName>
          <description>Enable Register 1</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>BUSMON2</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PTC2</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TSEN</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LPCOMP</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>AUDCODEC</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GPADC</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BTIM4</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BTIM3</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GPTIM5</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GPTIM4</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GPTIM3</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SYSCFG2</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>I2C7</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>I2C6</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>I2C5</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD5</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SPI4</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SPI3</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD6</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>USART6</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>USART5</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>USART4</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PATCH</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PINMUX2</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MAILBOX2</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMAC2</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD7</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ENR2</name>
          <displayName>ENR2</displayName>
          <description>Enable Register 2</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>26</bitWidth>
            </field>
            <field>
              <name>CRC2</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MAC</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PHY</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RFC</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MPI5</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GPIO2</name>
              <description>
              0 - disabled; 1 - enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CSR</name>
          <displayName>CSR</displayName>
          <description>Clock Select Register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>27</bitWidth>
            </field>
            <field>
              <name>SEL_PERI</name>
              <description>
              select clk_peri_lpsys source used by USART/SPI/I2C
              0 - clk_hrc48; 1 - clk_hxt48
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SEL_SYS_LP</name>
              <description>
              select clk_lpsys source
              0 - selected by SEL_SYS; 1 - clk_lp
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SEL_SYS</name>
              <description>
              select clk_lpsys source
              0 - clk_hrc48; 1 - clk_hxt48; 2 - clk_dbl96; 3 - reserved
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CFGR</name>
          <displayName>CFGR</displayName>
          <description>Clock Configuration Register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
            <field>
              <name>MACFREQ</name>
              <description>
              clock frequency of MAC clock
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>MACDIV</name>
              <description>
              MAC clock divider
              MACCLK = hclk_lpsys / MACDIV
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PDIV2</name>
              <description>
              pclk2_lpsys = hclk_lpsys / (2^PDIV2), by default divided by 32
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PDIV1</name>
              <description>
              pclk_lpsys = hclk_lpsys / (2^PDIV1), by default divided by 2
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HDIV2</name>
              <description>
              should set to 0 if hclk_lpsys frequency no higher than 24MHz
              should set to 1 if hclk_lpsys frequency higher than 24MHz
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HDIV1</name>
              <description>
              hclk_lpsys = clk_lpsys / HDIV1
              if HDIV1=0, hclk_lpsys = clk_lpsys
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD1</name>
          <displayName>RSVD1</displayName>
          <description></description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>DBGR</name>
          <displayName>DBGR</displayName>
          <description>Debug Register</description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>26</bitWidth>
            </field>
            <field>
              <name>SYSCLK_SWBT</name>
              <description>
              If set to 1, clk_lpsys will: 
              switch from clk_hrc48 to clk_hxt48 when MAC active; 
              switch from clk_hxt48 to clk_hrc48 when MAC sleep; 
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FORCE_GPIO</name>
              <description>
              for debug only
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FORCE_MAC</name>
              <description>
              for debug only
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FORCE_BUS</name>
              <description>
              for debug only
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SYSCLK_SWLP</name>
              <description>
              for debug only
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SYSCLK_AON</name>
              <description>
              for debug only
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>DMAC2</name>
      <description></description>
      <groupName>DMAC</groupName>
      <baseAddress>0x50001000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>ISR</name>
          <displayName>ISR</displayName>
          <description></description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>TEIF8</name>
              <description>
              channel transfer error flag
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HTIF8</name>
              <description>
              channel half transfer flag
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIF8</name>
              <description>
              channel transfer complete flag
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GIF8</name>
              <description>
              channel global interrupt flag
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIF7</name>
              <description>
              channel transfer error flag
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HTIF7</name>
              <description>
              channel half transfer flag
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIF7</name>
              <description>
              channel transfer complete flag
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GIF7</name>
              <description>
              channel global interrupt flag
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIF6</name>
              <description>
              channel transfer error flag
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HTIF6</name>
              <description>
              channel half transfer flag
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIF6</name>
              <description>
              channel transfer complete flag
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GIF6</name>
              <description>
              channel global interrupt flag
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIF5</name>
              <description>
              channel transfer error flag
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HTIF5</name>
              <description>
              channel half transfer flag
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIF5</name>
              <description>
              channel transfer complete flag
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GIF5</name>
              <description>
              channel global interrupt flag
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIF4</name>
              <description>
              channel transfer error flag
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HTIF4</name>
              <description>
              channel half transfer flag
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIF4</name>
              <description>
              channel transfer complete flag
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GIF4</name>
              <description>
              channel global interrupt flag
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIF3</name>
              <description>
              channel transfer error flag
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HTIF3</name>
              <description>
              channel half transfer flag
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIF3</name>
              <description>
              channel transfer complete flag
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GIF3</name>
              <description>
              channel global interrupt flag
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIF2</name>
              <description>
              channel transfer error flag
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HTIF2</name>
              <description>
              channel half transfer flag
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIF2</name>
              <description>
              channel transfer complete flag
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GIF2</name>
              <description>
              channel global interrupt flag
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIF1</name>
              <description>
              channel transfer error flag. Set when bus error detected. Cleared when write 1 to CTEIF or CGIF.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HTIF1</name>
              <description>
              channel half transfer flag. Set when half NDT are transferred. Cleared when write 1 to CHTIF or CGIF.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIF1</name>
              <description>
              channel transfer complete flag. Set when all NDT are transferred.  Cleared when write 1 to CTCIF or CGIF.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GIF1</name>
              <description>
              channel global interrupt flag. Set when any of TEIF/HTIF/TCIF asserted. Cleared when TEIF/HTIF/TCIF all cleared.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IFCR</name>
          <displayName>IFCR</displayName>
          <description></description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>CTEIF8</name>
              <description>
              CTEIF, transfer error flag clear
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CHTIF8</name>
              <description>
              CHTIF, half transfer flag clear
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTCIF8</name>
              <description>
              CTCIF, transfer complete flag clear
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CGIF8</name>
              <description>
              CGIF,  global interrupt flag clear
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTEIF7</name>
              <description>
              CTEIF, transfer error flag clear
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CHTIF7</name>
              <description>
              CHTIF, half transfer flag clear
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTCIF7</name>
              <description>
              CTCIF, transfer complete flag clear
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CGIF7</name>
              <description>
              CGIF,  global interrupt flag clear
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTEIF6</name>
              <description>
              CTEIF, transfer error flag clear
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CHTIF6</name>
              <description>
              CHTIF, half transfer flag clear
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTCIF6</name>
              <description>
              CTCIF, transfer complete flag clear
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CGIF6</name>
              <description>
              CGIF,  global interrupt flag clear
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTEIF5</name>
              <description>
              CTEIF, transfer error flag clear
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CHTIF5</name>
              <description>
              CHTIF, half transfer flag clear
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTCIF5</name>
              <description>
              CTCIF, transfer complete flag clear
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CGIF5</name>
              <description>
              CGIF,  global interrupt flag clear
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTEIF4</name>
              <description>
              CTEIF, transfer error flag clear
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CHTIF4</name>
              <description>
              CHTIF, half transfer flag clear
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTCIF4</name>
              <description>
              CTCIF, transfer complete flag clear
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CGIF4</name>
              <description>
              CGIF,  global interrupt flag clear
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTEIF3</name>
              <description>
              CTEIF, transfer error flag clear
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CHTIF3</name>
              <description>
              CHTIF, half transfer flag clear
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTCIF3</name>
              <description>
              CTCIF, transfer complete flag clear
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CGIF3</name>
              <description>
              CGIF,  global interrupt flag clear
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTEIF2</name>
              <description>
              CTEIF, transfer error flag clear
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CHTIF2</name>
              <description>
              CHTIF, half transfer flag clear
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTCIF2</name>
              <description>
              CTCIF, transfer complete flag clear
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CGIF2</name>
              <description>
              CGIF,  global interrupt flag clear
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTEIF1</name>
              <description>
              CTEIF, transfer error flag clear. Write 1 to clear TEIF.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CHTIF1</name>
              <description>
              CHTIF, half transfer flag clear. Write 1 to clear HTIF.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTCIF1</name>
              <description>
              CTCIF, transfer complete flag clear. Write 1 to clear TCIF.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CGIF1</name>
              <description>
              CGIF,  global interrupt flag clear. Write 1 to clear all TEIF/HTIF/TCIF.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR1</name>
          <displayName>CCR1</displayName>
          <description></description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
            <field>
              <name>MEM2MEM</name>
              <description>
              memory-to-memory mode
              0: disabled
              1: enabled
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PL</name>
              <description>
              priority level
              00: low
              01: medium
              10: high
              11: very high
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>MSIZE</name>
              <description>
              memory size
              Defines the data size of each DMA transfer to the identified memory.
              In memory-to-memory mode, this field identifies the memory source if DIR = 1 and the memory destination if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.
              00: 8 bits
              01: 16 bits
              10: 32 bits
              11: reserved
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>PSIZE</name>
              <description>
              peripheral size
              Defines the data size of each DMA transfer to the identified peripheral.
              In memory-to-memory mode, this field identifies the memory destination if DIR = 1 and the memory source if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR = 1 and the peripheral source if DIR = 0.
              00: 8 bits
              01: 16 bits
              10: 32 bits
              11: reserved
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>MINC</name>
              <description>
              memory increment mode
              Defines the increment mode for each DMA transfer to the identified memory.
              In memory-to-memory mode, this field identifies the memory source if DIR = 1 and the memory destination if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.
              0: disabled
              1: enabled
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PINC</name>
              <description>
              peripheral increment mode
              Defines the increment mode for each DMA transfer to the identified peripheral.
              n memory-to-memory mode, this field identifies the memory destination if DIR = 1 and the 
              memory source if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR = 1 and 
              the peripheral source if DIR = 0.
              0: disabled
              1: enabled
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CIRC</name>
              <description>
              circular mode
              0: disabled
              1: enabled
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DIR</name>
              <description>
              data transfer direction
              This bit must be set only in memory-to-peripheral and peripheral-to-memory modes.
              0: read from peripheral
                 Source attributes are defined by PSIZE and PINC, plus the CPARx register. This is still valid in a memory-to-memory mode.
                 Destination attributes are defined by MSIZE and MINC, plus the CM0ARx register. This is still valid in a peripheral-to-peripheral mode.
              1: read from memory
                 Destination attributes are defined by PSIZE and PINC, plus the CPARx register. This is still valid in a memory-to-memory mode.
                 Source attributes are defined by MSIZE and MINC, plus the CM0ARx register. This is still valid in a peripheral-to-peripheral mode.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIE</name>
              <description>
              transfer error interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HTIE</name>
              <description>
              half transfer interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIE</name>
              <description>
              transfer complete interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EN</name>
              <description>
              channel enable
              When a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the ISR register is cleared (by setting the CTEIFx bit of the IFCR register).
              0: disabled
              1: enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CNDTR1</name>
          <displayName>CNDTR1</displayName>
          <description></description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>NDT</name>
              <description>
              number of data to transfer (0 to 2^16 - 1)
              This field is updated by hardware when the channel is enabled:
                 It is decremented after each single DMA 'read followed by write' transfer, indicating the remaining amount of data items to transfer.
                 It is kept at zero when the programmed amount of data to transfer is reached, if the channel is not in circular mode (CIRC = 0 in the CCRx register).
                 It is reloaded automatically by the previously programmed value, when the transfer is complete, if the channel is in circular mode (CIRC = 1).
              If this field is zero, no transfer can be served whatever the channel status (enabled or not).
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CPAR1</name>
          <displayName>CPAR1</displayName>
          <description></description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>PA</name>
              <description>
              peripheral address
              It contains the base address of the peripheral data register from/to which the data will be read/written.
              In memory-to-memory mode, this register identifies the memory destination address if DIR = 1 and the memory source address if DIR = 0.
              In peripheral-to-peripheral mode, this register identifies the peripheral destination address DIR = 1 and the peripheral source address if DIR = 0.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0AR1</name>
          <displayName>CM0AR1</displayName>
          <description></description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>MA</name>
              <description>
              memory address
              It contains the base address of the memory from/to which the data will be read/written.
              In memory-to-memory mode, this register identifies the memory source address if DIR = 1 and the memory destination address if DIR = 0.
              In peripheral-to-peripheral mode, this register identifies the peripheral source address DIR = 1 and the peripheral destination address if DIR = 0.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CBSR1</name>
          <displayName>CBSR1</displayName>
          <description></description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>BS</name>
              <description>
              burst size in non-m2m mode
              When BS>1, DMA will transfer for BS times for each request if left NDT is larger than BS, or else transfer for left NDT times.
              When BS=0 or 1, DMA will always do single transfer for each request.
              In memory-to-memory mode, BS is ignored.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR2</name>
          <displayName>CCR2</displayName>
          <description></description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
            <field>
              <name>MEM2MEM</name>
              <description>
              memory-to-memory mode
              0: disabled
              1: enabled
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PL</name>
              <description>
              priority level
              00: low
              01: medium
              10: high
              11: very high
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>MSIZE</name>
              <description>
              memory size
              Defines the data size of each DMA transfer to the identified memory.
              In memory-to-memory mode, this field identifies the memory source if DIR = 1 and the memory destination if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.
              00: 8 bits
              01: 16 bits
              10: 32 bits
              11: reserved
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>PSIZE</name>
              <description>
              peripheral size
              Defines the data size of each DMA transfer to the identified peripheral.
              In memory-to-memory mode, this field identifies the memory destination if DIR = 1 and the memory source if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR = 1 and the peripheral source if DIR = 0.
              00: 8 bits
              01: 16 bits
              10: 32 bits
              11: reserved
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>MINC</name>
              <description>
              memory increment mode
              Defines the increment mode for each DMA transfer to the identified memory.
              In memory-to-memory mode, this field identifies the memory source if DIR = 1 and the memory destination if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.
              0: disabled
              1: enabled
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PINC</name>
              <description>
              peripheral increment mode
              Defines the increment mode for each DMA transfer to the identified peripheral.
              n memory-to-memory mode, this field identifies the memory destination if DIR = 1 and the 
              memory source if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR = 1 and 
              the peripheral source if DIR = 0.
              0: disabled
              1: enabled
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CIRC</name>
              <description>
              circular mode
              0: disabled
              1: enabled
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DIR</name>
              <description>
              data transfer direction
              This bit must be set only in memory-to-peripheral and peripheral-to-memory modes.
              0: read from peripheral
                 Source attributes are defined by PSIZE and PINC, plus the CPARx register. This is still valid in a memory-to-memory mode.
                 Destination attributes are defined by MSIZE and MINC, plus the CM0ARx register. This is still valid in a peripheral-to-peripheral mode.
              1: read from memory
                 Destination attributes are defined by PSIZE and PINC, plus the CPARx register. This is still valid in a memory-to-memory mode.
                 Source attributes are defined by MSIZE and MINC, plus the CM0ARx register. This is still valid in a peripheral-to-peripheral mode.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIE</name>
              <description>
              transfer error interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HTIE</name>
              <description>
              half transfer interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIE</name>
              <description>
              transfer complete interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EN</name>
              <description>
              channel enable
              When a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the ISR register is cleared (by setting the CTEIFx bit of the IFCR register).
              0: disabled
              1: enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CNDTR2</name>
          <displayName>CNDTR2</displayName>
          <description></description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>NDT</name>
              <description>
              number of data to transfer (0 to 2^16 - 1)
              This field is updated by hardware when the channel is enabled:
                 It is decremented after each single DMA 'read followed by write' transfer, indicating the remaining amount of data items to transfer.
                 It is kept at zero when the programmed amount of data to transfer is reached, if the channel is not in circular mode (CIRC = 0 in the CCRx register).
                 It is reloaded automatically by the previously programmed value, when the transfer is complete, if the channel is in circular mode (CIRC = 1).
              If this field is zero, no transfer can be served whatever the channel status (enabled or not).
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CPAR2</name>
          <displayName>CPAR2</displayName>
          <description></description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>PA</name>
              <description>
              peripheral address
              It contains the base address of the peripheral data register from/to which the data will be read/written.
              In memory-to-memory mode, this register identifies the memory destination address if DIR = 1 and the memory source address if DIR = 0.
              In peripheral-to-peripheral mode, this register identifies the peripheral destination address DIR = 1 and the peripheral source address if DIR = 0.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0AR2</name>
          <displayName>CM0AR2</displayName>
          <description></description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>MA</name>
              <description>
              peripheral address
              It contains the base address of the memory from/to which the data will be read/written.
              In memory-to-memory mode, this register identifies the memory source address if DIR = 1 and the memory destination address if DIR = 0.
              In peripheral-to-peripheral mode, this register identifies the peripheral source address DIR = 1 and the peripheral destination address if DIR = 0.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CBSR2</name>
          <displayName>CBSR2</displayName>
          <description></description>
          <addressOffset>0x2c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>BS</name>
              <description>
              burst size in non-m2m mode
              When BS>1, DMA will transfer for BS times for each request if left NDT is larger than BS, or else transfer for left NDT times.
              When BS=0 or 1, DMA will always do single transfer for each request.
              In memory-to-memory mode, BS is ignored.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR3</name>
          <displayName>CCR3</displayName>
          <description></description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
            <field>
              <name>MEM2MEM</name>
              <description>
              memory-to-memory mode
              0: disabled
              1: enabled
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PL</name>
              <description>
              priority level
              00: low
              01: medium
              10: high
              11: very high
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>MSIZE</name>
              <description>
              memory size
              Defines the data size of each DMA transfer to the identified memory.
              In memory-to-memory mode, this field identifies the memory source if DIR = 1 and the memory destination if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.
              00: 8 bits
              01: 16 bits
              10: 32 bits
              11: reserved
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>PSIZE</name>
              <description>
              peripheral size
              Defines the data size of each DMA transfer to the identified peripheral.
              In memory-to-memory mode, this field identifies the memory destination if DIR = 1 and the memory source if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR = 1 and the peripheral source if DIR = 0.
              00: 8 bits
              01: 16 bits
              10: 32 bits
              11: reserved
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>MINC</name>
              <description>
              memory increment mode
              Defines the increment mode for each DMA transfer to the identified memory.
              In memory-to-memory mode, this field identifies the memory source if DIR = 1 and the memory destination if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.
              0: disabled
              1: enabled
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PINC</name>
              <description>
              peripheral increment mode
              Defines the increment mode for each DMA transfer to the identified peripheral.
              n memory-to-memory mode, this field identifies the memory destination if DIR = 1 and the 
              memory source if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR = 1 and 
              the peripheral source if DIR = 0.
              0: disabled
              1: enabled
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CIRC</name>
              <description>
              circular mode
              0: disabled
              1: enabled
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DIR</name>
              <description>
              data transfer direction
              This bit must be set only in memory-to-peripheral and peripheral-to-memory modes.
              0: read from peripheral
                 Source attributes are defined by PSIZE and PINC, plus the CPARx register. This is still valid in a memory-to-memory mode.
                 Destination attributes are defined by MSIZE and MINC, plus the CM0ARx register. This is still valid in a peripheral-to-peripheral mode.
              1: read from memory
                 Destination attributes are defined by PSIZE and PINC, plus the CPARx register. This is still valid in a memory-to-memory mode.
                 Source attributes are defined by MSIZE and MINC, plus the CM0ARx register. This is still valid in a peripheral-to-peripheral mode.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIE</name>
              <description>
              transfer error interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HTIE</name>
              <description>
              half transfer interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIE</name>
              <description>
              transfer complete interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EN</name>
              <description>
              channel enable
              When a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the ISR register is cleared (by setting the CTEIFx bit of the IFCR register).
              0: disabled
              1: enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CNDTR3</name>
          <displayName>CNDTR3</displayName>
          <description></description>
          <addressOffset>0x34</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>NDT</name>
              <description>
              number of data to transfer (0 to 2^16 - 1)
              This field is updated by hardware when the channel is enabled:
                 It is decremented after each single DMA 'read followed by write' transfer, indicating the remaining amount of data items to transfer.
                 It is kept at zero when the programmed amount of data to transfer is reached, if the channel is not in circular mode (CIRC = 0 in the CCRx register).
                 It is reloaded automatically by the previously programmed value, when the transfer is complete, if the channel is in circular mode (CIRC = 1).
              If this field is zero, no transfer can be served whatever the channel status (enabled or not).
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CPAR3</name>
          <displayName>CPAR3</displayName>
          <description></description>
          <addressOffset>0x38</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>PA</name>
              <description>
              peripheral address
              It contains the base address of the peripheral data register from/to which the data will be read/written.
              In memory-to-memory mode, this register identifies the memory destination address if DIR = 1 and the memory source address if DIR = 0.
              In peripheral-to-peripheral mode, this register identifies the peripheral destination address DIR = 1 and the peripheral source address if DIR = 0.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0AR3</name>
          <displayName>CM0AR3</displayName>
          <description></description>
          <addressOffset>0x3c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>MA</name>
              <description>
              peripheral address
              It contains the base address of the memory from/to which the data will be read/written.
              In memory-to-memory mode, this register identifies the memory source address if DIR = 1 and the memory destination address if DIR = 0.
              In peripheral-to-peripheral mode, this register identifies the peripheral source address DIR = 1 and the peripheral destination address if DIR = 0.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CBSR3</name>
          <displayName>CBSR3</displayName>
          <description></description>
          <addressOffset>0x40</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>BS</name>
              <description>
              burst size in non-m2m mode
              When BS>1, DMA will transfer for BS times for each request if left NDT is larger than BS, or else transfer for left NDT times.
              When BS=0 or 1, DMA will always do single transfer for each request.
              In memory-to-memory mode, BS is ignored.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR4</name>
          <displayName>CCR4</displayName>
          <description></description>
          <addressOffset>0x44</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
            <field>
              <name>MEM2MEM</name>
              <description>
              memory-to-memory mode
              0: disabled
              1: enabled
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PL</name>
              <description>
              priority level
              00: low
              01: medium
              10: high
              11: very high
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>MSIZE</name>
              <description>
              memory size
              Defines the data size of each DMA transfer to the identified memory.
              In memory-to-memory mode, this field identifies the memory source if DIR = 1 and the memory destination if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.
              00: 8 bits
              01: 16 bits
              10: 32 bits
              11: reserved
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>PSIZE</name>
              <description>
              peripheral size
              Defines the data size of each DMA transfer to the identified peripheral.
              In memory-to-memory mode, this field identifies the memory destination if DIR = 1 and the memory source if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR = 1 and the peripheral source if DIR = 0.
              00: 8 bits
              01: 16 bits
              10: 32 bits
              11: reserved
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>MINC</name>
              <description>
              memory increment mode
              Defines the increment mode for each DMA transfer to the identified memory.
              In memory-to-memory mode, this field identifies the memory source if DIR = 1 and the memory destination if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.
              0: disabled
              1: enabled
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PINC</name>
              <description>
              peripheral increment mode
              Defines the increment mode for each DMA transfer to the identified peripheral.
              n memory-to-memory mode, this field identifies the memory destination if DIR = 1 and the 
              memory source if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR = 1 and 
              the peripheral source if DIR = 0.
              0: disabled
              1: enabled
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CIRC</name>
              <description>
              circular mode
              0: disabled
              1: enabled
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DIR</name>
              <description>
              data transfer direction
              This bit must be set only in memory-to-peripheral and peripheral-to-memory modes.
              0: read from peripheral
                 Source attributes are defined by PSIZE and PINC, plus the CPARx register. This is still valid in a memory-to-memory mode.
                 Destination attributes are defined by MSIZE and MINC, plus the CM0ARx register. This is still valid in a peripheral-to-peripheral mode.
              1: read from memory
                 Destination attributes are defined by PSIZE and PINC, plus the CPARx register. This is still valid in a memory-to-memory mode.
                 Source attributes are defined by MSIZE and MINC, plus the CM0ARx register. This is still valid in a peripheral-to-peripheral mode.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIE</name>
              <description>
              transfer error interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HTIE</name>
              <description>
              half transfer interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIE</name>
              <description>
              transfer complete interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EN</name>
              <description>
              channel enable
              When a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the ISR register is cleared (by setting the CTEIFx bit of the IFCR register).
              0: disabled
              1: enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CNDTR4</name>
          <displayName>CNDTR4</displayName>
          <description></description>
          <addressOffset>0x48</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>NDT</name>
              <description>
              number of data to transfer (0 to 2^16 - 1)
              This field is updated by hardware when the channel is enabled:
                 It is decremented after each single DMA 'read followed by write' transfer, indicating the remaining amount of data items to transfer.
                 It is kept at zero when the programmed amount of data to transfer is reached, if the channel is not in circular mode (CIRC = 0 in the CCRx register).
                 It is reloaded automatically by the previously programmed value, when the transfer is complete, if the channel is in circular mode (CIRC = 1).
              If this field is zero, no transfer can be served whatever the channel status (enabled or not).
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CPAR4</name>
          <displayName>CPAR4</displayName>
          <description></description>
          <addressOffset>0x4c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>PA</name>
              <description>
              peripheral address
              It contains the base address of the peripheral data register from/to which the data will be read/written.
              In memory-to-memory mode, this register identifies the memory destination address if DIR = 1 and the memory source address if DIR = 0.
              In peripheral-to-peripheral mode, this register identifies the peripheral destination address DIR = 1 and the peripheral source address if DIR = 0.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0AR4</name>
          <displayName>CM0AR4</displayName>
          <description></description>
          <addressOffset>0x50</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>MA</name>
              <description>
              peripheral address
              It contains the base address of the memory from/to which the data will be read/written.
              In memory-to-memory mode, this register identifies the memory source address if DIR = 1 and the memory destination address if DIR = 0.
              In peripheral-to-peripheral mode, this register identifies the peripheral source address DIR = 1 and the peripheral destination address if DIR = 0.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CBSR4</name>
          <displayName>CBSR4</displayName>
          <description></description>
          <addressOffset>0x54</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>BS</name>
              <description>
              burst size in non-m2m mode
              When BS>1, DMA will transfer for BS times for each request if left NDT is larger than BS, or else transfer for left NDT times.
              When BS=0 or 1, DMA will always do single transfer for each request.
              In memory-to-memory mode, BS is ignored.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR5</name>
          <displayName>CCR5</displayName>
          <description></description>
          <addressOffset>0x58</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
            <field>
              <name>MEM2MEM</name>
              <description>
              memory-to-memory mode
              0: disabled
              1: enabled
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PL</name>
              <description>
              priority level
              00: low
              01: medium
              10: high
              11: very high
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>MSIZE</name>
              <description>
              memory size
              Defines the data size of each DMA transfer to the identified memory.
              In memory-to-memory mode, this field identifies the memory source if DIR = 1 and the memory destination if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.
              00: 8 bits
              01: 16 bits
              10: 32 bits
              11: reserved
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>PSIZE</name>
              <description>
              peripheral size
              Defines the data size of each DMA transfer to the identified peripheral.
              In memory-to-memory mode, this field identifies the memory destination if DIR = 1 and the memory source if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR = 1 and the peripheral source if DIR = 0.
              00: 8 bits
              01: 16 bits
              10: 32 bits
              11: reserved
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>MINC</name>
              <description>
              memory increment mode
              Defines the increment mode for each DMA transfer to the identified memory.
              In memory-to-memory mode, this field identifies the memory source if DIR = 1 and the memory destination if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.
              0: disabled
              1: enabled
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PINC</name>
              <description>
              peripheral increment mode
              Defines the increment mode for each DMA transfer to the identified peripheral.
              n memory-to-memory mode, this field identifies the memory destination if DIR = 1 and the 
              memory source if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR = 1 and 
              the peripheral source if DIR = 0.
              0: disabled
              1: enabled
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CIRC</name>
              <description>
              circular mode
              0: disabled
              1: enabled
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DIR</name>
              <description>
              data transfer direction
              This bit must be set only in memory-to-peripheral and peripheral-to-memory modes.
              0: read from peripheral
                 Source attributes are defined by PSIZE and PINC, plus the CPARx register. This is still valid in a memory-to-memory mode.
                 Destination attributes are defined by MSIZE and MINC, plus the CM0ARx register. This is still valid in a peripheral-to-peripheral mode.
              1: read from memory
                 Destination attributes are defined by PSIZE and PINC, plus the CPARx register. This is still valid in a memory-to-memory mode.
                 Source attributes are defined by MSIZE and MINC, plus the CM0ARx register. This is still valid in a peripheral-to-peripheral mode.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIE</name>
              <description>
              transfer error interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HTIE</name>
              <description>
              half transfer interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIE</name>
              <description>
              transfer complete interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EN</name>
              <description>
              channel enable
              When a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the ISR register is cleared (by setting the CTEIFx bit of the IFCR register).
              0: disabled
              1: enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CNDTR5</name>
          <displayName>CNDTR5</displayName>
          <description></description>
          <addressOffset>0x5c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>NDT</name>
              <description>
              number of data to transfer (0 to 2^16 - 1)
              This field is updated by hardware when the channel is enabled:
                 It is decremented after each single DMA 'read followed by write' transfer, indicating the remaining amount of data items to transfer.
                 It is kept at zero when the programmed amount of data to transfer is reached, if the channel is not in circular mode (CIRC = 0 in the CCRx register).
                 It is reloaded automatically by the previously programmed value, when the transfer is complete, if the channel is in circular mode (CIRC = 1).
              If this field is zero, no transfer can be served whatever the channel status (enabled or not).
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CPAR5</name>
          <displayName>CPAR5</displayName>
          <description></description>
          <addressOffset>0x60</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>PA</name>
              <description>
              peripheral address
              It contains the base address of the peripheral data register from/to which the data will be read/written.
              In memory-to-memory mode, this register identifies the memory destination address if DIR = 1 and the memory source address if DIR = 0.
              In peripheral-to-peripheral mode, this register identifies the peripheral destination address DIR = 1 and the peripheral source address if DIR = 0.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0AR5</name>
          <displayName>CM0AR5</displayName>
          <description></description>
          <addressOffset>0x64</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>MA</name>
              <description>
              peripheral address
              It contains the base address of the memory from/to which the data will be read/written.
              In memory-to-memory mode, this register identifies the memory source address if DIR = 1 and the memory destination address if DIR = 0.
              In peripheral-to-peripheral mode, this register identifies the peripheral source address DIR = 1 and the peripheral destination address if DIR = 0.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CBSR5</name>
          <displayName>CBSR5</displayName>
          <description></description>
          <addressOffset>0x68</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>BS</name>
              <description>
              burst size in non-m2m mode
              When BS>1, DMA will transfer for BS times for each request if left NDT is larger than BS, or else transfer for left NDT times.
              When BS=0 or 1, DMA will always do single transfer for each request.
              In memory-to-memory mode, BS is ignored.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR6</name>
          <displayName>CCR6</displayName>
          <description></description>
          <addressOffset>0x6c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
            <field>
              <name>MEM2MEM</name>
              <description>
              memory-to-memory mode
              0: disabled
              1: enabled
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PL</name>
              <description>
              priority level
              00: low
              01: medium
              10: high
              11: very high
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>MSIZE</name>
              <description>
              memory size
              Defines the data size of each DMA transfer to the identified memory.
              In memory-to-memory mode, this field identifies the memory source if DIR = 1 and the memory destination if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.
              00: 8 bits
              01: 16 bits
              10: 32 bits
              11: reserved
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>PSIZE</name>
              <description>
              peripheral size
              Defines the data size of each DMA transfer to the identified peripheral.
              In memory-to-memory mode, this field identifies the memory destination if DIR = 1 and the memory source if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR = 1 and the peripheral source if DIR = 0.
              00: 8 bits
              01: 16 bits
              10: 32 bits
              11: reserved
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>MINC</name>
              <description>
              memory increment mode
              Defines the increment mode for each DMA transfer to the identified memory.
              In memory-to-memory mode, this field identifies the memory source if DIR = 1 and the memory destination if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.
              0: disabled
              1: enabled
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PINC</name>
              <description>
              peripheral increment mode
              Defines the increment mode for each DMA transfer to the identified peripheral.
              n memory-to-memory mode, this field identifies the memory destination if DIR = 1 and the 
              memory source if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR = 1 and 
              the peripheral source if DIR = 0.
              0: disabled
              1: enabled
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CIRC</name>
              <description>
              circular mode
              0: disabled
              1: enabled
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DIR</name>
              <description>
              data transfer direction
              This bit must be set only in memory-to-peripheral and peripheral-to-memory modes.
              0: read from peripheral
                 Source attributes are defined by PSIZE and PINC, plus the CPARx register. This is still valid in a memory-to-memory mode.
                 Destination attributes are defined by MSIZE and MINC, plus the CM0ARx register. This is still valid in a peripheral-to-peripheral mode.
              1: read from memory
                 Destination attributes are defined by PSIZE and PINC, plus the CPARx register. This is still valid in a memory-to-memory mode.
                 Source attributes are defined by MSIZE and MINC, plus the CM0ARx register. This is still valid in a peripheral-to-peripheral mode.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIE</name>
              <description>
              transfer error interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HTIE</name>
              <description>
              half transfer interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIE</name>
              <description>
              transfer complete interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EN</name>
              <description>
              channel enable
              When a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the ISR register is cleared (by setting the CTEIFx bit of the IFCR register).
              0: disabled
              1: enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CNDTR6</name>
          <displayName>CNDTR6</displayName>
          <description></description>
          <addressOffset>0x70</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>NDT</name>
              <description>
              number of data to transfer (0 to 2^16 - 1)
              This field is updated by hardware when the channel is enabled:
                 It is decremented after each single DMA 'read followed by write' transfer, indicating the remaining amount of data items to transfer.
                 It is kept at zero when the programmed amount of data to transfer is reached, if the channel is not in circular mode (CIRC = 0 in the CCRx register).
                 It is reloaded automatically by the previously programmed value, when the transfer is complete, if the channel is in circular mode (CIRC = 1).
              If this field is zero, no transfer can be served whatever the channel status (enabled or not).
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CPAR6</name>
          <displayName>CPAR6</displayName>
          <description></description>
          <addressOffset>0x74</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>PA</name>
              <description>
              peripheral address
              It contains the base address of the peripheral data register from/to which the data will be read/written.
              In memory-to-memory mode, this register identifies the memory destination address if DIR = 1 and the memory source address if DIR = 0.
              In peripheral-to-peripheral mode, this register identifies the peripheral destination address DIR = 1 and the peripheral source address if DIR = 0.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0AR6</name>
          <displayName>CM0AR6</displayName>
          <description></description>
          <addressOffset>0x78</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>MA</name>
              <description>
              peripheral address
              It contains the base address of the memory from/to which the data will be read/written.
              In memory-to-memory mode, this register identifies the memory source address if DIR = 1 and the memory destination address if DIR = 0.
              In peripheral-to-peripheral mode, this register identifies the peripheral source address DIR = 1 and the peripheral destination address if DIR = 0.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CBSR6</name>
          <displayName>CBSR6</displayName>
          <description></description>
          <addressOffset>0x7c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>BS</name>
              <description>
              burst size in non-m2m mode
              When BS>1, DMA will transfer for BS times for each request if left NDT is larger than BS, or else transfer for left NDT times.
              When BS=0 or 1, DMA will always do single transfer for each request.
              In memory-to-memory mode, BS is ignored.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR7</name>
          <displayName>CCR7</displayName>
          <description></description>
          <addressOffset>0x80</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
            <field>
              <name>MEM2MEM</name>
              <description>
              memory-to-memory mode
              0: disabled
              1: enabled
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PL</name>
              <description>
              priority level
              00: low
              01: medium
              10: high
              11: very high
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>MSIZE</name>
              <description>
              memory size
              Defines the data size of each DMA transfer to the identified memory.
              In memory-to-memory mode, this field identifies the memory source if DIR = 1 and the memory destination if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.
              00: 8 bits
              01: 16 bits
              10: 32 bits
              11: reserved
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>PSIZE</name>
              <description>
              peripheral size
              Defines the data size of each DMA transfer to the identified peripheral.
              In memory-to-memory mode, this field identifies the memory destination if DIR = 1 and the memory source if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR = 1 and the peripheral source if DIR = 0.
              00: 8 bits
              01: 16 bits
              10: 32 bits
              11: reserved
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>MINC</name>
              <description>
              memory increment mode
              Defines the increment mode for each DMA transfer to the identified memory.
              In memory-to-memory mode, this field identifies the memory source if DIR = 1 and the memory destination if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.
              0: disabled
              1: enabled
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PINC</name>
              <description>
              peripheral increment mode
              Defines the increment mode for each DMA transfer to the identified peripheral.
              n memory-to-memory mode, this field identifies the memory destination if DIR = 1 and the 
              memory source if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR = 1 and 
              the peripheral source if DIR = 0.
              0: disabled
              1: enabled
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CIRC</name>
              <description>
              circular mode
              0: disabled
              1: enabled
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DIR</name>
              <description>
              data transfer direction
              This bit must be set only in memory-to-peripheral and peripheral-to-memory modes.
              0: read from peripheral
                 Source attributes are defined by PSIZE and PINC, plus the CPARx register. This is still valid in a memory-to-memory mode.
                 Destination attributes are defined by MSIZE and MINC, plus the CM0ARx register. This is still valid in a peripheral-to-peripheral mode.
              1: read from memory
                 Destination attributes are defined by PSIZE and PINC, plus the CPARx register. This is still valid in a memory-to-memory mode.
                 Source attributes are defined by MSIZE and MINC, plus the CM0ARx register. This is still valid in a peripheral-to-peripheral mode.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIE</name>
              <description>
              transfer error interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HTIE</name>
              <description>
              half transfer interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIE</name>
              <description>
              transfer complete interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EN</name>
              <description>
              channel enable
              When a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the ISR register is cleared (by setting the CTEIFx bit of the IFCR register).
              0: disabled
              1: enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CNDTR7</name>
          <displayName>CNDTR7</displayName>
          <description></description>
          <addressOffset>0x84</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>NDT</name>
              <description>
              number of data to transfer (0 to 2^16 - 1)
              This field is updated by hardware when the channel is enabled:
                 It is decremented after each single DMA 'read followed by write' transfer, indicating the remaining amount of data items to transfer.
                 It is kept at zero when the programmed amount of data to transfer is reached, if the channel is not in circular mode (CIRC = 0 in the CCRx register).
                 It is reloaded automatically by the previously programmed value, when the transfer is complete, if the channel is in circular mode (CIRC = 1).
              If this field is zero, no transfer can be served whatever the channel status (enabled or not).
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CPAR7</name>
          <displayName>CPAR7</displayName>
          <description></description>
          <addressOffset>0x88</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>PA</name>
              <description>
              peripheral address
              It contains the base address of the peripheral data register from/to which the data will be read/written.
              In memory-to-memory mode, this register identifies the memory destination address if DIR = 1 and the memory source address if DIR = 0.
              In peripheral-to-peripheral mode, this register identifies the peripheral destination address DIR = 1 and the peripheral source address if DIR = 0.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0AR7</name>
          <displayName>CM0AR7</displayName>
          <description></description>
          <addressOffset>0x8c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>MA</name>
              <description>
              peripheral address
              It contains the base address of the memory from/to which the data will be read/written.
              In memory-to-memory mode, this register identifies the memory source address if DIR = 1 and the memory destination address if DIR = 0.
              In peripheral-to-peripheral mode, this register identifies the peripheral source address DIR = 1 and the peripheral destination address if DIR = 0.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CBSR7</name>
          <displayName>CBSR7</displayName>
          <description></description>
          <addressOffset>0x90</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>BS</name>
              <description>
              burst size in non memory-to-memory mode
              When BS>1, DMA will transfer for BS times for each request if left NDT is larger than BS, or else transfer for left NDT times.
              When BS=0 or 1, DMA will always do single transfer for each request.
              In memory-to-memory mode, BS is ignored.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR8</name>
          <displayName>CCR8</displayName>
          <description></description>
          <addressOffset>0x94</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
            <field>
              <name>MEM2MEM</name>
              <description>
              memory-to-memory mode
              0: disabled
              1: enabled
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PL</name>
              <description>
              priority level
              00: low
              01: medium
              10: high
              11: very high
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>MSIZE</name>
              <description>
              memory size
              Defines the data size of each DMA transfer to the identified memory.
              In memory-to-memory mode, this field identifies the memory source if DIR = 1 and the memory destination if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.
              00: 8 bits
              01: 16 bits
              10: 32 bits
              11: reserved
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>PSIZE</name>
              <description>
              peripheral size
              Defines the data size of each DMA transfer to the identified peripheral.
              In memory-to-memory mode, this field identifies the memory destination if DIR = 1 and the memory source if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR = 1 and the peripheral source if DIR = 0.
              00: 8 bits
              01: 16 bits
              10: 32 bits
              11: reserved
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>MINC</name>
              <description>
              memory increment mode
              Defines the increment mode for each DMA transfer to the identified memory.
              In memory-to-memory mode, this field identifies the memory source if DIR = 1 and the memory destination if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.
              0: disabled
              1: enabled
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PINC</name>
              <description>
              peripheral increment mode
              Defines the increment mode for each DMA transfer to the identified peripheral.
              n memory-to-memory mode, this field identifies the memory destination if DIR = 1 and the 
              memory source if DIR = 0.
              In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR = 1 and 
              the peripheral source if DIR = 0.
              0: disabled
              1: enabled
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CIRC</name>
              <description>
              circular mode
              0: disabled
              1: enabled
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DIR</name>
              <description>
              data transfer direction
              This bit must be set only in memory-to-peripheral and peripheral-to-memory modes.
              0: read from peripheral
                 Source attributes are defined by PSIZE and PINC, plus the CPARx register. This is still valid in a memory-to-memory mode.
                 Destination attributes are defined by MSIZE and MINC, plus the CM0ARx register. This is still valid in a peripheral-to-peripheral mode.
              1: read from memory
                 Destination attributes are defined by PSIZE and PINC, plus the CPARx register. This is still valid in a memory-to-memory mode.
                 Source attributes are defined by MSIZE and MINC, plus the CM0ARx register. This is still valid in a peripheral-to-peripheral mode.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIE</name>
              <description>
              transfer error interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HTIE</name>
              <description>
              half transfer interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIE</name>
              <description>
              transfer complete interrupt enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EN</name>
              <description>
              channel enable
              When a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the ISR register is cleared (by setting the CTEIFx bit of the IFCR register).
              0: disabled
              1: enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CNDTR8</name>
          <displayName>CNDTR8</displayName>
          <description></description>
          <addressOffset>0x98</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>NDT</name>
              <description>
              number of data to transfer (0 to 2^16 - 1)
              This field is updated by hardware when the channel is enabled:
                 It is decremented after each single DMA 'read followed by write' transfer, indicating the remaining amount of data items to transfer.
                 It is kept at zero when the programmed amount of data to transfer is reached, if the channel is not in circular mode (CIRC = 0 in the CCRx register).
                 It is reloaded automatically by the previously programmed value, when the transfer is complete, if the channel is in circular mode (CIRC = 1).
              If this field is zero, no transfer can be served whatever the channel status (enabled or not).
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CPAR8</name>
          <displayName>CPAR8</displayName>
          <description></description>
          <addressOffset>0x9c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>PA</name>
              <description>
              peripheral address
              It contains the base address of the peripheral data register from/to which the data will be read/written.
              In memory-to-memory mode, this register identifies the memory destination address if DIR = 1 and the memory source address if DIR = 0.
              In peripheral-to-peripheral mode, this register identifies the peripheral destination address DIR = 1 and the peripheral source address if DIR = 0.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0AR8</name>
          <displayName>CM0AR8</displayName>
          <description></description>
          <addressOffset>0xa0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>MA</name>
              <description>
              peripheral address
              It contains the base address of the memory from/to which the data will be read/written.
              In memory-to-memory mode, this register identifies the memory source address if DIR = 1 and the memory destination address if DIR = 0.
              In peripheral-to-peripheral mode, this register identifies the peripheral source address DIR = 1 and the peripheral destination address if DIR = 0.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CBSR8</name>
          <displayName>CBSR8</displayName>
          <description></description>
          <addressOffset>0xa4</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>BS</name>
              <description>
              burst size in non-m2m mode
              When BS>1, DMA will transfer for BS times for each request if left NDT is larger than BS, or else transfer for left NDT times.
              When BS=0 or 1, DMA will always do single transfer for each request.
              In memory-to-memory mode, BS is ignored.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CSELR1</name>
          <displayName>CSELR1</displayName>
          <description></description>
          <addressOffset>0xa8</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>C4S</name>
              <description>
              DMA channel 4 selection
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>C3S</name>
              <description>
              DMA channel 3 selection
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>C2S</name>
              <description>
              DMA channel 2 selection
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>C1S</name>
              <description>
              DMA channel 1 selection
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CSELR2</name>
          <displayName>CSELR2</displayName>
          <description></description>
          <addressOffset>0xac</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>C8S</name>
              <description>
              DMA channel 8 selection
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>C7S</name>
              <description>
              DMA channel 7 selection
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>C6S</name>
              <description>
              DMA channel 6 selection
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>C5S</name>
              <description>
              DMA channel 5 selection
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>LPSYS_PINMUX</name>
      <description></description>
      <groupName>LPSYS_PINMUX</groupName>
      <baseAddress>0x50003000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>PAD_SC00</name>
          <displayName>PAD_SC00</displayName>
          <description></description>
          <addressOffset>0x0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_SC01</name>
          <displayName>PAD_SC01</displayName>
          <description></description>
          <addressOffset>0x4</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_SC02</name>
          <displayName>PAD_SC02</displayName>
          <description></description>
          <addressOffset>0x8</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_SC03</name>
          <displayName>PAD_SC03</displayName>
          <description></description>
          <addressOffset>0xc</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_SC04</name>
          <displayName>PAD_SC04</displayName>
          <description></description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_SC05</name>
          <displayName>PAD_SC05</displayName>
          <description></description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PB00</name>
          <displayName>PAD_PB00</displayName>
          <description></description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS</name>
              <description>
              Drive Select. Logic LOW selects 4mA drive,logic HIGH selects 20mA drive
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MODE</name>
              <description>
              Mode Select. Logic LOW enables GPIO mode,logic HIGH enables I2C mode
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PB01</name>
          <displayName>PAD_PB01</displayName>
          <description></description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS</name>
              <description>
              Drive Select. Logic LOW selects 4mA drive,logic HIGH selects 20mA drive
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MODE</name>
              <description>
              Mode Select. Logic LOW enables GPIO mode,logic HIGH enables I2C mode
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PB02</name>
          <displayName>PAD_PB02</displayName>
          <description></description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PB03</name>
          <displayName>PAD_PB03</displayName>
          <description></description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PB04</name>
          <displayName>PAD_PB04</displayName>
          <description></description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PB05</name>
          <displayName>PAD_PB05</displayName>
          <description></description>
          <addressOffset>0x2c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PB06</name>
          <displayName>PAD_PB06</displayName>
          <description></description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PB07</name>
          <displayName>PAD_PB07</displayName>
          <description></description>
          <addressOffset>0x34</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PB08</name>
          <displayName>PAD_PB08</displayName>
          <description></description>
          <addressOffset>0x38</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PB09</name>
          <displayName>PAD_PB09</displayName>
          <description></description>
          <addressOffset>0x3c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PB10</name>
          <displayName>PAD_PB10</displayName>
          <description></description>
          <addressOffset>0x40</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PB11</name>
          <displayName>PAD_PB11</displayName>
          <description></description>
          <addressOffset>0x44</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PB12</name>
          <displayName>PAD_PB12</displayName>
          <description></description>
          <addressOffset>0x48</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PB13</name>
          <displayName>PAD_PB13</displayName>
          <description></description>
          <addressOffset>0x4c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PB14</name>
          <displayName>PAD_PB14</displayName>
          <description></description>
          <addressOffset>0x50</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PB15</name>
          <displayName>PAD_PB15</displayName>
          <description></description>
          <addressOffset>0x54</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PB16</name>
          <displayName>PAD_PB16</displayName>
          <description></description>
          <addressOffset>0x58</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PB17</name>
          <displayName>PAD_PB17</displayName>
          <description></description>
          <addressOffset>0x5c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PB18</name>
          <displayName>PAD_PB18</displayName>
          <description></description>
          <addressOffset>0x60</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PB19</name>
          <displayName>PAD_PB19</displayName>
          <description></description>
          <addressOffset>0x64</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PB20</name>
          <displayName>PAD_PB20</displayName>
          <description></description>
          <addressOffset>0x68</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PB21</name>
          <displayName>PAD_PB21</displayName>
          <description></description>
          <addressOffset>0x6c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PB22</name>
          <displayName>PAD_PB22</displayName>
          <description></description>
          <addressOffset>0x70</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PB23</name>
          <displayName>PAD_PB23</displayName>
          <description></description>
          <addressOffset>0x74</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS</name>
              <description>
              Drive Select. Logic LOW selects 4mA drive,logic HIGH selects 20mA drive
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MODE</name>
              <description>
              Mode Select. Logic LOW enables GPIO mode,logic HIGH enables I2C mode
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PB24</name>
          <displayName>PAD_PB24</displayName>
          <description></description>
          <addressOffset>0x78</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS</name>
              <description>
              Drive Select. Logic LOW selects 4mA drive,logic HIGH selects 20mA drive
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MODE</name>
              <description>
              Mode Select. Logic LOW enables GPIO mode,logic HIGH enables I2C mode
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PB25</name>
          <displayName>PAD_PB25</displayName>
          <description></description>
          <addressOffset>0x7c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PB26</name>
          <displayName>PAD_PB26</displayName>
          <description></description>
          <addressOffset>0x80</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PB27</name>
          <displayName>PAD_PB27</displayName>
          <description></description>
          <addressOffset>0x84</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PB28</name>
          <displayName>PAD_PB28</displayName>
          <description></description>
          <addressOffset>0x88</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PB29</name>
          <displayName>PAD_PB29</displayName>
          <description></description>
          <addressOffset>0x8c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PB30</name>
          <displayName>PAD_PB30</displayName>
          <description></description>
          <addressOffset>0x90</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PB31</name>
          <displayName>PAD_PB31</displayName>
          <description></description>
          <addressOffset>0x94</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PB32</name>
          <displayName>PAD_PB32</displayName>
          <description></description>
          <addressOffset>0x98</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PB33</name>
          <displayName>PAD_PB33</displayName>
          <description></description>
          <addressOffset>0x9c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PB34</name>
          <displayName>PAD_PB34</displayName>
          <description></description>
          <addressOffset>0xa0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PB35</name>
          <displayName>PAD_PB35</displayName>
          <description></description>
          <addressOffset>0xa4</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAD_PB36</name>
          <displayName>PAD_PB36</displayName>
          <description></description>
          <addressOffset>0xa8</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>POE</name>
              <description>
              Reserved. Always set to logic LOW
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              Drive Select 1. Used to select output drive strength
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              Drive Select 0. Used to select output drive strength
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              Slew Rate. Logic HIGH selects slow slew rate, logic LOW selects fast slew rate
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Input Select. Logic LOW selects CMOS input, logic HIGH selects Schmitt input
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              Input Enable. Logic HIGH enables the input buffer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Pull Select. Logic HIGH selects pull-up, logic LOW select pull-down
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Pull Enable. Logic HIGH enables week pull device
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FSEL</name>
              <description>
              Function Select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>USART4</name>
      <description></description>
      <groupName>USART</groupName>
      <baseAddress>0x50005000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CR1</name>
          <displayName>CR1</displayName>
          <description>Control Register 1</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>M</name>
              <description>
              Mode bit indicates the length of the packet, including data bits and parity. Stop bits not included.
              0: 6 bits (e.g. 6 data bits + no parity bit)
              1: 7 bits (e.g. 6 data bits + 1 parity bit)
              2: 8 bits (e.g. 7 data bits + 1 parity bit, or 6 data bits + 2 parity bits)
              3: 9 bits (e.g. 8 data bits + 1 parity bit, or 7 data bits + 2 parity bits)
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>RSVD5</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>OVER8</name>
              <description>
              Oversampling mode
              0: Oversampling by 16
              1: Oversampling by 8
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD6</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD7</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD8</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PCE</name>
              <description>
              Parity check enable. If enabled, parity bit is inserted at the MSB position 
              0: parity check disabled
              1: parity check enabled
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Parity select
              0: even parity
              1: odd parity
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PEIE</name>
              <description>
              Parity error interrupt enable
              0: interrupt disabled
              1: interrupt is generated whenever PE=1 in the ISR register
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TXEIE</name>
              <description>
              Tx empty interrupt enable
              0: interrupt disabled
              1: interrupt is generated whenver TXE=1 in the ISR register
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIE</name>
              <description>
              Transfer compelete interrupt enable
              0: interrupt disabled
              1: interrupt is generated whenever TC=1 in the ISR register
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RXNEIE</name>
              <description>
              Rx not empty interrupt enable
              0: interrupt disabled
              1: interrupt is generated whenever RXNE=1 in the ISR register
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IDLEIE</name>
              <description>
              Idle line interrupt enable
              0: interrupt disabled
              1: interrupt is generated whenever IDLE=1 in the ISR  register
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TE</name>
              <description>
              Transmitter enable
              0: transmitter is disabled
              1: transmitter is enabled
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RE</name>
              <description>
              Receiver enable
              0: receiver is disabled
              1: receiver is enabled
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD9</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UE</name>
              <description>
              USART enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CR2</name>
          <displayName>CR2</displayName>
          <description>Control Register 2</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD5</name>
              <description>
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD6</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD7</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD8</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD9</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD10</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>STOP</name>
              <description>
              Stop bits
              0/1: 1 stop bit
              2/3: 2 stop bits
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD11</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD12</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD13</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD14</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD15</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD16</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD17</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD18</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD19</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CR3</name>
          <displayName>CR3</displayName>
          <description>Control Register 3</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD5</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD6</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD7</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD8</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD9</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD10</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OVRDIS</name>
              <description>
              Overrun disable
              0: overrun error flag (ORE) will be set if new data received but previous data not read. New data will not overwrite the content in RDR register.
              1: overrun disabled. If new data is received before previous data is read, the new data will overwrite the content in RDR register and ORE flag remains unset.
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ONEBIT</name>
              <description>
              One bit sampling mode
              0: 3-bit sampling mode, the sampling value is determined by the voted result out of 3 bits
              1: 1-bit sampling mode
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTSIE</name>
              <description>
              CTS interrupt enable
              0: interrupt disabled
              1: interrupt is generated whenever CTSIF=1 in the ISR register
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTSE</name>
              <description>
              CTS enable
              0: CTS hardware flow control disabled
              1: CTS hardware flow control enabled, data is transmitted only when CTS input is asserted low
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RTSE</name>
              <description>
              RTS enable
              0: RTS hardware flow control disabled
              1: RTS hardware flow control enabled, RTS output is asserted low when new data can be received
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMAT</name>
              <description>
              Transmitter DMA enable
              0: DMA mode disabled for transmission
              1: DMA mode enabled for transmission
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMAR</name>
              <description>
              Receiver DMA enable
              0: DMA mode disabled for reception
              1: DMA mode enabled for reception
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD11</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD12</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD13</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD14</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD15</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EIE</name>
              <description>
              Error interrupt enable
              0: interrupt disabled
              1: interrupt is generated whenever FE=1 or ORE=1 or NF=1 in the ISR register
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BRR</name>
          <displayName>BRR</displayName>
          <description>Baud Rate Register</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>INT</name>
              <description>
              Integer part of baud rate prescaler
              If OVER8 = 0, Baud Rate = 48000000 / (INT + FRAC/16) / 16
              If OVER8 = 1, Baud Rate = 48000000 / (INT + FRAC/16) / 8
              For example:
              OVER=0, INT=3, FRAC=0, Baud Rate = 48000000/(3+0)/16 = 1Mbps
              OVER=0, INT=3, FRAC=4, Baud Rate = 48000000/(3+4/16)/16 = 923077 = 921600 + 1.6
              OVER=1, INT=52, FRAC=1, Baud Rate = 48000000/(52+1/16)/8 = 115246 = 115200 + 0.4
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
            <field>
              <name>FRAC</name>
              <description>
              Fractional part of baud rate prescaler
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD1</name>
          <displayName>RSVD1</displayName>
          <description></description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>RQR</name>
          <displayName>RQR</displayName>
          <description>Request Register</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>27</bitWidth>
            </field>
            <field>
              <name>TXFRQ</name>
              <description>
              Tx data flush requestReserved-Do not modify
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RXFRQ</name>
              <description>
              Rx data flush request. Write 1 to clear the RXNE flag and discard the current data in RDR
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ISR</name>
          <displayName>ISR</displayName>
          <description>Interrupt and Status Register</description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x020000C0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD5</name>
              <description>
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD6</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD7</name>
              <description>
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD8</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD9</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD10</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD11</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD12</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD13</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD14</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD15</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTS</name>
              <description>
              CTS input. Read this bit to get the raw status of the CTS line.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTSIF</name>
              <description>
              CTS interrupt flag. This bit is set by hardware whenever CTS input toggles.
              0: no change on the CTS line
              1: there is a change on the CTS line
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD16</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TXE</name>
              <description>
              Tx data empty
              0: data is ready in TDR
              1: data is already transferred to shift register, i.e. transmission is in progress or complete
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TC</name>
              <description>
              transmission complete. This bit is set by hardware if the transmission is complete
              0: transmission is not complete
              1: transmission is complete
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RXNE</name>
              <description>
              Rx data not empty. This bit is set by hardware when the received data is transferred into RDR register.
              0: data is not received
              1: data is ready in RDR to be read
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IDLE</name>
              <description>
              Idle line detected
              0: no idle line is detected
              1: idle line is detected
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ORE</name>
              <description>
              Overrun error. When new data is received but Rx buffer is not empty (i.e. previous data is not read yet), ORE is asserted and current RDR content is not lost. This feature can be disabled by set CR3_OVRDIS to 1.
              0: no overrun error
              1: overrun error is detected
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>NF</name>
              <description>
              Noise flag. Noise means the samping values in the 3-bit sampling mode are not the same.
              0: no noise is detected
              1: noise is detected
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FE</name>
              <description>
              Framing error. This bit is set by hardware when stop bit is not correctly received
              0: no framing error is detected
              1: framing error is detected
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Parity error. This bit is set when a parity error is detected in the received packet.
              0: no parity error
              1: parity error detected
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ICR</name>
          <displayName>ICR</displayName>
          <description>Interrupt flag Clear Register</description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD5</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>RSVD6</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD7</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD8</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTSCF</name>
              <description>
              CTS clear flag. Writing 1 to this bit clears the CTSIF flag in the ISR register.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD9</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD10</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCCF</name>
              <description>
              Transmission complete clear flag. Writing 1 to this bit clears the TC flag in the ISR register.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD11</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IDLECF</name>
              <description>
              Idle line detected clear flag. Writing 1 to this bit clears the IDLECF flag in the ISR register.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ORECF</name>
              <description>
              Overrun error clear flag. Writing 1 to this bit clears the ORE flag in the ISR register.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>NCF</name>
              <description>
              Noise detected clear flag. Writing 1 to this bit clears the NF flag in the ISR register.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FECF</name>
              <description>
              Framing error clear flag. Writing 1 to this bit clears the FE flag in the ISR register.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PECF</name>
              <description>
              Parity error clear flag. Wriring 1 to this bit clears the PE flag in the ISR register.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RDR</name>
          <displayName>RDR</displayName>
          <description>Receive Data Register</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>RDR</name>
              <description>
              Received data
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TDR</name>
          <displayName>TDR</displayName>
          <description>Transmit Data Register</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>TDR</name>
              <description>
              Transmit data
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>MISCR</name>
          <displayName>MISCR</displayName>
          <description>Miscellaneous Register</description>
          <addressOffset>0x2c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>AUTOCAL</name>
              <description>
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>RTSBIT</name>
              <description>
              assert RTS ahead of the frame completion (in number of bits)Reserved-Do not modify
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>SMPLINI</name>
              <description>
              initial sample count, count down from this value to zero to reach the middle of the start bit in RxReserved-Do not modify
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DRDR</name>
          <displayName>DRDR</displayName>
          <description>Debug Receive Data Register</description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              DbgUART is still a preliminary version in this project. 
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DTDR</name>
          <displayName>DTDR</displayName>
          <description>Debug Receive Data Register</description>
          <addressOffset>0x34</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>EXR</name>
          <displayName>EXR</displayName>
          <description>Mutual Exclusive Register</description>
          <addressOffset>0x38</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>27</bitWidth>
            </field>
            <field>
              <name>ID</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>BUSY</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>USART5</name>
      <description></description>
      <groupName>USART</groupName>
      <baseAddress>0x50006000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CR1</name>
          <displayName>CR1</displayName>
          <description>Control Register 1</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>M</name>
              <description>
              Mode bit indicates the length of the packet, including data bits and parity. Stop bits not included.
              0: 6 bits (e.g. 6 data bits + no parity bit)
              1: 7 bits (e.g. 6 data bits + 1 parity bit)
              2: 8 bits (e.g. 7 data bits + 1 parity bit, or 6 data bits + 2 parity bits)
              3: 9 bits (e.g. 8 data bits + 1 parity bit, or 7 data bits + 2 parity bits)
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>RSVD5</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>OVER8</name>
              <description>
              Oversampling mode
              0: Oversampling by 16
              1: Oversampling by 8
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD6</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD7</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD8</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PCE</name>
              <description>
              Parity check enable. If enabled, parity bit is inserted at the MSB position 
              0: parity check disabled
              1: parity check enabled
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Parity select
              0: even parity
              1: odd parity
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PEIE</name>
              <description>
              Parity error interrupt enable
              0: interrupt disabled
              1: interrupt is generated whenever PE=1 in the ISR register
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TXEIE</name>
              <description>
              Tx empty interrupt enable
              0: interrupt disabled
              1: interrupt is generated whenver TXE=1 in the ISR register
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIE</name>
              <description>
              Transfer compelete interrupt enable
              0: interrupt disabled
              1: interrupt is generated whenever TC=1 in the ISR register
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RXNEIE</name>
              <description>
              Rx not empty interrupt enable
              0: interrupt disabled
              1: interrupt is generated whenever RXNE=1 in the ISR register
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IDLEIE</name>
              <description>
              Idle line interrupt enable
              0: interrupt disabled
              1: interrupt is generated whenever IDLE=1 in the ISR  register
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TE</name>
              <description>
              Transmitter enable
              0: transmitter is disabled
              1: transmitter is enabled
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RE</name>
              <description>
              Receiver enable
              0: receiver is disabled
              1: receiver is enabled
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD9</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UE</name>
              <description>
              USART enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CR2</name>
          <displayName>CR2</displayName>
          <description>Control Register 2</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD5</name>
              <description>
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD6</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD7</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD8</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD9</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD10</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>STOP</name>
              <description>
              Stop bits
              0/1: 1 stop bit
              2/3: 2 stop bits
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD11</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD12</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD13</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD14</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD15</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD16</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD17</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD18</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD19</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CR3</name>
          <displayName>CR3</displayName>
          <description>Control Register 3</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD5</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD6</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD7</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD8</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD9</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD10</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OVRDIS</name>
              <description>
              Overrun disable
              0: overrun error flag (ORE) will be set if new data received but previous data not read. New data will not overwrite the content in RDR register.
              1: overrun disabled. If new data is received before previous data is read, the new data will overwrite the content in RDR register and ORE flag remains unset.
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ONEBIT</name>
              <description>
              One bit sampling mode
              0: 3-bit sampling mode, the sampling value is determined by the voted result out of 3 bits
              1: 1-bit sampling mode
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTSIE</name>
              <description>
              CTS interrupt enable
              0: interrupt disabled
              1: interrupt is generated whenever CTSIF=1 in the ISR register
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTSE</name>
              <description>
              CTS enable
              0: CTS hardware flow control disabled
              1: CTS hardware flow control enabled, data is transmitted only when CTS input is asserted low
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RTSE</name>
              <description>
              RTS enable
              0: RTS hardware flow control disabled
              1: RTS hardware flow control enabled, RTS output is asserted low when new data can be received
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMAT</name>
              <description>
              Transmitter DMA enable
              0: DMA mode disabled for transmission
              1: DMA mode enabled for transmission
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMAR</name>
              <description>
              Receiver DMA enable
              0: DMA mode disabled for reception
              1: DMA mode enabled for reception
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD11</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD12</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD13</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD14</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD15</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EIE</name>
              <description>
              Error interrupt enable
              0: interrupt disabled
              1: interrupt is generated whenever FE=1 or ORE=1 or NF=1 in the ISR register
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BRR</name>
          <displayName>BRR</displayName>
          <description>Baud Rate Register</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>INT</name>
              <description>
              Integer part of baud rate prescaler
              If OVER8 = 0, Baud Rate = 48000000 / (INT + FRAC/16) / 16
              If OVER8 = 1, Baud Rate = 48000000 / (INT + FRAC/16) / 8
              For example:
              OVER=0, INT=3, FRAC=0, Baud Rate = 48000000/(3+0)/16 = 1Mbps
              OVER=0, INT=3, FRAC=4, Baud Rate = 48000000/(3+4/16)/16 = 923077 = 921600 + 1.6
              OVER=1, INT=52, FRAC=1, Baud Rate = 48000000/(52+1/16)/8 = 115246 = 115200 + 0.4
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
            <field>
              <name>FRAC</name>
              <description>
              Fractional part of baud rate prescaler
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD1</name>
          <displayName>RSVD1</displayName>
          <description></description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>RQR</name>
          <displayName>RQR</displayName>
          <description>Request Register</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>27</bitWidth>
            </field>
            <field>
              <name>TXFRQ</name>
              <description>
              Tx data flush requestReserved-Do not modify
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RXFRQ</name>
              <description>
              Rx data flush request. Write 1 to clear the RXNE flag and discard the current data in RDR
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ISR</name>
          <displayName>ISR</displayName>
          <description>Interrupt and Status Register</description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x020000C0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD5</name>
              <description>
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD6</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD7</name>
              <description>
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD8</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD9</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD10</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD11</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD12</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD13</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD14</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD15</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTS</name>
              <description>
              CTS input. Read this bit to get the raw status of the CTS line.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTSIF</name>
              <description>
              CTS interrupt flag. This bit is set by hardware whenever CTS input toggles.
              0: no change on the CTS line
              1: there is a change on the CTS line
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD16</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TXE</name>
              <description>
              Tx data empty
              0: data is ready in TDR
              1: data is already transferred to shift register, i.e. transmission is in progress or complete
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TC</name>
              <description>
              transmission complete. This bit is set by hardware if the transmission is complete
              0: transmission is not complete
              1: transmission is complete
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RXNE</name>
              <description>
              Rx data not empty. This bit is set by hardware when the received data is transferred into RDR register.
              0: data is not received
              1: data is ready in RDR to be read
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IDLE</name>
              <description>
              Idle line detected
              0: no idle line is detected
              1: idle line is detected
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ORE</name>
              <description>
              Overrun error. When new data is received but Rx buffer is not empty (i.e. previous data is not read yet), ORE is asserted and current RDR content is not lost. This feature can be disabled by set CR3_OVRDIS to 1.
              0: no overrun error
              1: overrun error is detected
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>NF</name>
              <description>
              Noise flag. Noise means the samping values in the 3-bit sampling mode are not the same.
              0: no noise is detected
              1: noise is detected
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FE</name>
              <description>
              Framing error. This bit is set by hardware when stop bit is not correctly received
              0: no framing error is detected
              1: framing error is detected
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Parity error. This bit is set when a parity error is detected in the received packet.
              0: no parity error
              1: parity error detected
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ICR</name>
          <displayName>ICR</displayName>
          <description>Interrupt flag Clear Register</description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD5</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>RSVD6</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD7</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD8</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTSCF</name>
              <description>
              CTS clear flag. Writing 1 to this bit clears the CTSIF flag in the ISR register.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD9</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD10</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCCF</name>
              <description>
              Transmission complete clear flag. Writing 1 to this bit clears the TC flag in the ISR register.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD11</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IDLECF</name>
              <description>
              Idle line detected clear flag. Writing 1 to this bit clears the IDLECF flag in the ISR register.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ORECF</name>
              <description>
              Overrun error clear flag. Writing 1 to this bit clears the ORE flag in the ISR register.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>NCF</name>
              <description>
              Noise detected clear flag. Writing 1 to this bit clears the NF flag in the ISR register.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FECF</name>
              <description>
              Framing error clear flag. Writing 1 to this bit clears the FE flag in the ISR register.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PECF</name>
              <description>
              Parity error clear flag. Wriring 1 to this bit clears the PE flag in the ISR register.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RDR</name>
          <displayName>RDR</displayName>
          <description>Receive Data Register</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>RDR</name>
              <description>
              Received data
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TDR</name>
          <displayName>TDR</displayName>
          <description>Transmit Data Register</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>TDR</name>
              <description>
              Transmit data
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>MISCR</name>
          <displayName>MISCR</displayName>
          <description>Miscellaneous Register</description>
          <addressOffset>0x2c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>AUTOCAL</name>
              <description>
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>RTSBIT</name>
              <description>
              assert RTS ahead of the frame completion (in number of bits)Reserved-Do not modify
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>SMPLINI</name>
              <description>
              initial sample count, count down from this value to zero to reach the middle of the start bit in RxReserved-Do not modify
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DRDR</name>
          <displayName>DRDR</displayName>
          <description>Debug Receive Data Register</description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              DbgUART is still a preliminary version in this project. 
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DTDR</name>
          <displayName>DTDR</displayName>
          <description>Debug Receive Data Register</description>
          <addressOffset>0x34</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>EXR</name>
          <displayName>EXR</displayName>
          <description>Mutual Exclusive Register</description>
          <addressOffset>0x38</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>27</bitWidth>
            </field>
            <field>
              <name>ID</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>BUSY</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>USART6</name>
      <description></description>
      <groupName>USART</groupName>
      <baseAddress>0x50007000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CR1</name>
          <displayName>CR1</displayName>
          <description>Control Register 1</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>M</name>
              <description>
              Mode bit indicates the length of the packet, including data bits and parity. Stop bits not included.
              0: 6 bits (e.g. 6 data bits + no parity bit)
              1: 7 bits (e.g. 6 data bits + 1 parity bit)
              2: 8 bits (e.g. 7 data bits + 1 parity bit, or 6 data bits + 2 parity bits)
              3: 9 bits (e.g. 8 data bits + 1 parity bit, or 7 data bits + 2 parity bits)
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>RSVD5</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>OVER8</name>
              <description>
              Oversampling mode
              0: Oversampling by 16
              1: Oversampling by 8
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD6</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD7</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD8</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PCE</name>
              <description>
              Parity check enable. If enabled, parity bit is inserted at the MSB position 
              0: parity check disabled
              1: parity check enabled
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              Parity select
              0: even parity
              1: odd parity
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PEIE</name>
              <description>
              Parity error interrupt enable
              0: interrupt disabled
              1: interrupt is generated whenever PE=1 in the ISR register
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TXEIE</name>
              <description>
              Tx empty interrupt enable
              0: interrupt disabled
              1: interrupt is generated whenver TXE=1 in the ISR register
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIE</name>
              <description>
              Transfer compelete interrupt enable
              0: interrupt disabled
              1: interrupt is generated whenever TC=1 in the ISR register
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RXNEIE</name>
              <description>
              Rx not empty interrupt enable
              0: interrupt disabled
              1: interrupt is generated whenever RXNE=1 in the ISR register
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IDLEIE</name>
              <description>
              Idle line interrupt enable
              0: interrupt disabled
              1: interrupt is generated whenever IDLE=1 in the ISR  register
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TE</name>
              <description>
              Transmitter enable
              0: transmitter is disabled
              1: transmitter is enabled
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RE</name>
              <description>
              Receiver enable
              0: receiver is disabled
              1: receiver is enabled
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD9</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UE</name>
              <description>
              USART enable
              0: disabled
              1: enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CR2</name>
          <displayName>CR2</displayName>
          <description>Control Register 2</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD5</name>
              <description>
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD6</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD7</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD8</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD9</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD10</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>STOP</name>
              <description>
              Stop bits
              0/1: 1 stop bit
              2/3: 2 stop bits
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD11</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD12</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD13</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD14</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD15</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD16</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD17</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD18</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD19</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CR3</name>
          <displayName>CR3</displayName>
          <description>Control Register 3</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD5</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD6</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD7</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD8</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD9</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD10</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OVRDIS</name>
              <description>
              Overrun disable
              0: overrun error flag (ORE) will be set if new data received but previous data not read. New data will not overwrite the content in RDR register.
              1: overrun disabled. If new data is received before previous data is read, the new data will overwrite the content in RDR register and ORE flag remains unset.
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ONEBIT</name>
              <description>
              One bit sampling mode
              0: 3-bit sampling mode, the sampling value is determined by the voted result out of 3 bits
              1: 1-bit sampling mode
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTSIE</name>
              <description>
              CTS interrupt enable
              0: interrupt disabled
              1: interrupt is generated whenever CTSIF=1 in the ISR register
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTSE</name>
              <description>
              CTS enable
              0: CTS hardware flow control disabled
              1: CTS hardware flow control enabled, data is transmitted only when CTS input is asserted low
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RTSE</name>
              <description>
              RTS enable
              0: RTS hardware flow control disabled
              1: RTS hardware flow control enabled, RTS output is asserted low when new data can be received
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMAT</name>
              <description>
              Transmitter DMA enable
              0: DMA mode disabled for transmission
              1: DMA mode enabled for transmission
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMAR</name>
              <description>
              Receiver DMA enable
              0: DMA mode disabled for reception
              1: DMA mode enabled for reception
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD11</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD12</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD13</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD14</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD15</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EIE</name>
              <description>
              Error interrupt enable
              0: interrupt disabled
              1: interrupt is generated whenever FE=1 or ORE=1 or NF=1 in the ISR register
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BRR</name>
          <displayName>BRR</displayName>
          <description>Baud Rate Register</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>INT</name>
              <description>
              Integer part of baud rate prescaler
              If OVER8 = 0, Baud Rate = 48000000 / (INT + FRAC/16) / 16
              If OVER8 = 1, Baud Rate = 48000000 / (INT + FRAC/16) / 8
              For example:
              OVER=0, INT=3, FRAC=0, Baud Rate = 48000000/(3+0)/16 = 1Mbps
              OVER=0, INT=3, FRAC=4, Baud Rate = 48000000/(3+4/16)/16 = 923077 = 921600 + 1.6
              OVER=1, INT=52, FRAC=1, Baud Rate = 48000000/(52+1/16)/8 = 115246 = 115200 + 0.4
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
            <field>
              <name>FRAC</name>
              <description>
              Fractional part of baud rate prescaler
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD1</name>
          <displayName>RSVD1</displayName>
          <description></description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>RQR</name>
          <displayName>RQR</displayName>
          <description>Request Register</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>27</bitWidth>
            </field>
            <field>
              <name>TXFRQ</name>
              <description>
              Tx data flush requestReserved-Do not modify
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RXFRQ</name>
              <description>
              Rx data flush request. Write 1 to clear the RXNE flag and discard the current data in RDR
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ISR</name>
          <displayName>ISR</displayName>
          <description>Interrupt and Status Register</description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x020000C0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD5</name>
              <description>
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD6</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD7</name>
              <description>
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD8</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD9</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD10</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD11</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD12</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD13</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD14</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD15</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTS</name>
              <description>
              CTS input. Read this bit to get the raw status of the CTS line.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTSIF</name>
              <description>
              CTS interrupt flag. This bit is set by hardware whenever CTS input toggles.
              0: no change on the CTS line
              1: there is a change on the CTS line
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD16</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TXE</name>
              <description>
              Tx data empty
              0: data is ready in TDR
              1: data is already transferred to shift register, i.e. transmission is in progress or complete
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TC</name>
              <description>
              transmission complete. This bit is set by hardware if the transmission is complete
              0: transmission is not complete
              1: transmission is complete
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RXNE</name>
              <description>
              Rx data not empty. This bit is set by hardware when the received data is transferred into RDR register.
              0: data is not received
              1: data is ready in RDR to be read
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IDLE</name>
              <description>
              Idle line detected
              0: no idle line is detected
              1: idle line is detected
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ORE</name>
              <description>
              Overrun error. When new data is received but Rx buffer is not empty (i.e. previous data is not read yet), ORE is asserted and current RDR content is not lost. This feature can be disabled by set CR3_OVRDIS to 1.
              0: no overrun error
              1: overrun error is detected
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>NF</name>
              <description>
              Noise flag. Noise means the samping values in the 3-bit sampling mode are not the same.
              0: no noise is detected
              1: noise is detected
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FE</name>
              <description>
              Framing error. This bit is set by hardware when stop bit is not correctly received
              0: no framing error is detected
              1: framing error is detected
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Parity error. This bit is set when a parity error is detected in the received packet.
              0: no parity error
              1: parity error detected
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ICR</name>
          <displayName>ICR</displayName>
          <description>Interrupt flag Clear Register</description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD5</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>RSVD6</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD7</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD8</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTSCF</name>
              <description>
              CTS clear flag. Writing 1 to this bit clears the CTSIF flag in the ISR register.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD9</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD10</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCCF</name>
              <description>
              Transmission complete clear flag. Writing 1 to this bit clears the TC flag in the ISR register.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD11</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IDLECF</name>
              <description>
              Idle line detected clear flag. Writing 1 to this bit clears the IDLECF flag in the ISR register.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ORECF</name>
              <description>
              Overrun error clear flag. Writing 1 to this bit clears the ORE flag in the ISR register.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>NCF</name>
              <description>
              Noise detected clear flag. Writing 1 to this bit clears the NF flag in the ISR register.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FECF</name>
              <description>
              Framing error clear flag. Writing 1 to this bit clears the FE flag in the ISR register.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PECF</name>
              <description>
              Parity error clear flag. Wriring 1 to this bit clears the PE flag in the ISR register.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RDR</name>
          <displayName>RDR</displayName>
          <description>Receive Data Register</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>RDR</name>
              <description>
              Received data
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TDR</name>
          <displayName>TDR</displayName>
          <description>Transmit Data Register</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>TDR</name>
              <description>
              Transmit data
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>MISCR</name>
          <displayName>MISCR</displayName>
          <description>Miscellaneous Register</description>
          <addressOffset>0x2c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>AUTOCAL</name>
              <description>
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>RTSBIT</name>
              <description>
              assert RTS ahead of the frame completion (in number of bits)Reserved-Do not modify
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>SMPLINI</name>
              <description>
              initial sample count, count down from this value to zero to reach the middle of the start bit in RxReserved-Do not modify
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DRDR</name>
          <displayName>DRDR</displayName>
          <description>Debug Receive Data Register</description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              DbgUART is still a preliminary version in this project. 
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DTDR</name>
          <displayName>DTDR</displayName>
          <description>Debug Receive Data Register</description>
          <addressOffset>0x34</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>EXR</name>
          <displayName>EXR</displayName>
          <description>Mutual Exclusive Register</description>
          <addressOffset>0x38</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>27</bitWidth>
            </field>
            <field>
              <name>ID</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>BUSY</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>SPI3</name>
      <description></description>
      <groupName>SPI</groupName>
      <baseAddress>0x50009000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>TOP_CTRL</name>
          <displayName>TOP_CTRL</displayName>
          <description>Top Control Register</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>13</bitWidth>
            </field>
            <field>
              <name>TTELP</name>
              <description>
              SPI_DO Three-state Enable On Last Phase (can be set only when TI-SSP)
              0: SPI_DO is three-stated 1/2 clock cycle after the beginning of the LSB 
              1: SPI_DO output signal is three-stated on the clock edge that ends the LSB
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TTE</name>
              <description>
              SPI_DO Three-State Enable 
              0: SPI_DO output signal is not three-stated 
              1: SPI_DO is three-stated when not transmitting data
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IFS</name>
              <description>
              Invert Frame Signal 
              0: SPI_CS polarity is as defined in protocol
              1: SPI_CS will be inverted from normal-SPI_CS
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HOLD_FRAME_LOW</name>
              <description>
              Hold Frame Low Control 
              0:After this field is set to 1 and the SPI controller is operating in master mode,the output frame signal SPI_CS will be determined by control FSM.
              1:After this field is set to 1 and the SPI controller is operating in master mode, the output frame signal SPI_CS will hold low. 
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TRAIL</name>
              <description>
              Trailing Byte 
              0: Trailing bytes are handled by CPU 
              1: Trailing bytes are handled by DMA bursts
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              Reserved
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SPH</name>
              <description>
              Motorola SPI SPI_CLK phase setting 
              0: SPI_CLK is inactive until one cycle after the start of a frame and active until 1/2 cycle before the end of a frame 
              1: SPI_CLK is inactive until 1/2 cycle after the start of a frame and active until one cycle before the end of a frame
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SPO</name>
              <description>
              Motorola SPI SPI_CLK Polarity Setting 
              0: The inactive or idle state of SPI_CLK is low 
              1: The inactive or idle state of SPI_CLK is high
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DSS</name>
              <description>
              SPI controller Work data size,  register bits value 0~31 indicated data size 1~32 bits,  usually use data size 8bits, 16bits, 24bits, 32bits
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>SFRMDIR</name>
              <description>
              SPI_CS Direction 
              0: Master mode, SPI controller drives SPI_CS 
              1: Slave mode, SPI controller receives SPI_CS
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SCLKDIR</name>
              <description>
              SPI_CLK Direction 
              0: Master mode, SPI controller drives SPI_CLK 
              1: Slave mode, SPI controller receives SPI_CLK
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FRF</name>
              <description>
              Frame Format 
              0x0: Motorola* Serial Peripheral Interface (SPI)  
              0x1: Texas Instruments* Synchronous Serial Protocol (SSP) 
              0x2: National Semiconductor Microwire* 
              0x3: RSVD 
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>SSE</name>
              <description>
              SPI controller Enable 
              0: SPI controller is disabled  
              1: SPI controller is enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>FIFO_CTRL</name>
          <displayName>FIFO_CTRL</displayName>
          <description>FIFO Control Register</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>14</bitWidth>
            </field>
            <field>
              <name>RXFIFO_AUTO_FULL_CTRL</name>
              <description>
              Rx FIFO Auto Full Control: After this field is set to 1 and the SPI controller is operating in master mode, the controller FSM returns to IDLE state and stops the SPI_CLK. 
              When Rx FIFO is full, the controller FSM continues transferring data after the RxFIFO is not full. 
              This field is used to avoid an RxFIFO overrun issue. 
              1: Enable Rx FIFO auto full control
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FPCKE</name>
              <description>
              FIFO Packing Enable 
              0: FIFO packing mode disabled 
              1: FIFO packing mode enabled
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TXFIFO_WR_ENDIAN</name>
              <description>
              apb_pwdata Write to TxFIFO Endian 
              0x0: txfifo_wdata[31:0] = apb_pwdata[31:0] 
              0x1: fifo_wdata[31:0] = {apb_pwdata[15:0], apb_pwdata[31:16]} 
              0x2: txfifo_wdata[31:0] = {apb_pwdata[7:0], apb_pwdata[15:8], apb_pwdata[23:16], apb_pwdata[31:24]} 
              0x3: txfifo_wdata[31:0] = {apb_pwdata[23:16], apb_pwdata[31:24], apb_pwdata[7:0], apb_pwdata[15:8]}
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RXFIFO_RD_ENDIAN</name>
              <description>
              apb_prdata Read from Rx FIFO Endian 
              0x0 = apb_prdata[31:0] = rxfifo_wdata[31:0] 
              0x1 = apb_prdata[31:0] = {rxfifo_wdata[15:0], rxfifo_wdata[31:16]} 
              0x2 = apb_prdata[31:0]= {rxfifo_wdata[7:0], rxfifo_wdata[15:8], rxfifo_wdata[23:16], rxfifo_wdata[31:24]} 
              0x3 = apb_prdata[31:0]= {rxfifo_wdata[23:16], rxfifo_wdata[31:24], rxfifo_wdata[7:0], rxfifo_wdata[15:8]}
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSRE</name>
              <description>
              Receive Service Request Enable 
              0: RxFIFO DMA service request is disabled 
              1: RxFIFO DMA service request is enabled
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TSRE</name>
              <description>
              Transmit Service Request Enable 
              0: TxFIFO DMA service request is disabled 
              1: TxFIFO DMA service request is enabled
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RFT</name>
              <description>
              RXFIFO Trigger Threshold This field sets the threshold level at which RXFIFO asserts interrupt. The level should be set to the preferred threshold value minus 1.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>TFT</name>
              <description>
              TXFIFO Trigger Threshold This field sets the threshold level at which TXFIFO asserts interrupt. The level should be set to the preferred threshold value minus 1. 
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>INTE</name>
          <displayName>INTE</displayName>
          <description>Interrupt Enable Register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>26</bitWidth>
            </field>
            <field>
              <name>TIM</name>
              <description>
              Transmit FIFO Underrun Interrupt Mask
              0 : TUR events generate an SPI interrupt 
              1 : TUR events do NOT generate an SPI interrupt 
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RIM</name>
              <description>
              Receive FIFO Overrun Interrupt Mask 
              0: ROR events generate an SPI interrupt 
              1: ROR events do NOT generate an SPI interrupt 
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TIE</name>
              <description>
              Transmit FIFO Interrupt Enable 
              0: TxFIFO threshold-level-reached interrupt is disabled 
              1: TxFIFO threshold-level-reached interrupt is enabled
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RIE</name>
              <description>
              Receive FIFO Interrupt Enable 
              0: RxFIFO threshold-level-reached interrupt is disabled 
              1: RxFIFO threshold-level-reached interrupt is enabled
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TINTE</name>
              <description>
              Receiver Time-out Interrupt Enable 
              0: Receiver time-out interrupt is disabled 
              1: Receiver time-out interrupt is enabled
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TO</name>
          <displayName>TO</displayName>
          <description>SPI Time Out Register</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>TIMEOUT</name>
              <description>
              Timeout Value TIMEOUT value is the value (0 to 2^24-1) that defines the time-out interval. The time-out interval is given by the equation shown in the TIMEOUT Interval Equation.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DATA</name>
          <displayName>DATA</displayName>
          <description>SPI DATA Register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              DATA This field is used for data to be written to the TXFIFO read from the RXFIFO.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS</name>
          <displayName>STATUS</displayName>
          <description>Status Register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>OSS</name>
              <description>
              Odd Sample Status 
              0: RxFIFO entry has two samples 
              1: RxFIFO entry has one sample  
              Note that this bit needs to be looked at only when FIFO Packing is enabled (FPCKE field in FIFO Control Register is set). Otherwise, this bit is zero. When SPI controller is in Packed mode and the CPU is used instead of DMA to read the RxFIFO, the CPU should make sure that [Receive FIFO Not Empty] = 1 AND this field = 0 before it attempts to read the RxFIFO.
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TX_OSS</name>
              <description>
              TX FIFO Odd Sample Status When SPI controller is in packed mode, 
              the number of samples in the TX FIFO is:  ([Transmit FIFO Level]*2 + this field), when [Transmit FIFO Not Full] = 1 32, when [Transmit FIFO Not Full] = 0.
              The TX FIFO cannot accept new data when [Transmit FIFO Not Full] = 1 and [Transmit FIFO Level] = 15 and this field = 1. (The TX FIFO has 31 samples).  
              0: TxFIFO entry has an even number of samples 
              1: TxFIFO entry has an odd number of samples Note that this bit needs to be read only when FIFO Packing is enabled ([FIFO Packing Enable] in the FIFO Control Register is set). Otherwise, this bit is zero.
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ROR</name>
              <description>
              Receive FIFO Overrun 
              0: RXFIFO has not experienced an overrun 
              1: Attempted data write to full RXFIFO, causes an interrupt request
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RFL</name>
              <description>
              Receive FIFO Level This field is the number of entries minus one in RXFIFO. When the value 0xF is read, the RXFIFO is either empty or full, and software should read the [Receive FIFO Not Empty] field.
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>RNE</name>
              <description>
              Receive FIFO Not Empty 
              0: RXFIFO is empty 
              1: RXFIFO is not empty
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RFS</name>
              <description>
              Receive FIFO Service Request 
              0: RXFIFO level is at or below RFT threshold (RFT) or SPI controller is disabled 
              1: RXFIFO level exceeds RFT threshold (RFT), causes an interrupt request
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TUR</name>
              <description>
              Transmit FIFO Underrun 
              0: The TXFIFO has not experienced an underrun 
              1: A read from the TXFIFO was attempted when the TXFIFO was empty, causes an interrupt if it is enabled ([Transmit FIFO Underrun Interrupt Mask] in the INT EN Register  is 0)
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TFL</name>
              <description>
              Transmit FIFO Level This field is the number of entries in TXFIFO.When the value 0x0 is read, the TXFIFO is either empty or full, and software should read the [Transmit FIFO Not Full] field.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>TNF</name>
              <description>
              Transmit FIFO Not Full 
              0: TXFIFO is full 
              1: TXFIFO is not full
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TFS</name>
              <description>
              Transmit FIFO Service Request 
              0: TX FIFO level exceeds the TFT threshold (TFT + 1) or SPI controller is disabled 
              1: TXFIFO level is at or below TFT threshold (TFT + 1), causes an interrupt request
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD5</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TINT</name>
              <description>
              Receiver Time-out Interrupt 
              0: No receiver time-out is pending 
              1: Receiver time-out pending, causes an interrupt request
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD6</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CSS</name>
              <description>
              Clock Synchronization Status 
              0: SPI controller is ready for slave clock operations 
              1: SPI controller is currently busy synchronizing slave mode signals
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BSY</name>
              <description>
              SPI controller Busy 
              0: SPI controller is idle or disabled 
              1: SPI controller is currently transmitting or receiving framed data
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD3</name>
          <displayName>RSVD3</displayName>
          <description></description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>RWOT_CTRL</name>
          <displayName>RWOT_CTRL</displayName>
          <description>RWOT Control Register</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>27</bitWidth>
            </field>
            <field>
              <name>MASK_RWOT_LAST_SAMPLE</name>
              <description>
              Mask last_sample_flag in RWOT Mode 
              1: Mask 
              0: Unmask
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CLR_RWOT_CYCLE</name>
              <description>
              Clear Internal rwot_counter This field clears the rwot_counter to 0. This field is self cleared after SSE = 1. 
              1: Clear rwot_counter
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SET_RWOT_CYCLE</name>
              <description>
              Set RWOT Cycle This field is used to set the value of the RWOT_CCM register to the internal rwot_counter. This field is self-cleared after SSE = 1. 
              1: Set rwot_counter
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CYCLE_RWOT_EN</name>
              <description>
              Enable RWOT Cycle Counter Mode 
              1: Enable
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RWOT</name>
              <description>
              Receive Without Transmit 
              0: Transmit/receive mode 
              1: Receive without transmit mode
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RWOT_CCM</name>
          <displayName>RWOT_CCM</displayName>
          <description>RWOT Counter Cycles Match Register</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RWOTCCM</name>
              <description>
              It's just total SPI_CLK Cycles. 
              The value of this register defines the total number of SPI_CLK cycles when SPI controller works in master and RWOT mode. 
              When the rwot_counter matches this value, SPI controller returns to IDLE state and does not output SPI_CLK anymore.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RWOT_CVWRN</name>
          <displayName>RWOT_CVWRN</displayName>
          <description>RWOT Counter Value Write for Red Request Register</description>
          <addressOffset>0x2c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RWOTCVWR</name>
              <description>
              RWOTCVWR This register prevents the risk of instability on rwot_counter value reading, it's only valid after SPI controller has been enabled Write 0 = No effect Write 1 = Capture value of rwot_counter Read: Returns the captured value of rwot_counter
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD2</name>
          <displayName>RSVD2</displayName>
          <description></description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>CLK_CTRL</name>
          <displayName>CLK_CTRL</displayName>
          <description>CLK  Control Register</description>
          <addressOffset>0x3c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>CLK_EN</name>
              <description>
              enable clk for internal logic
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CLK_SEL</name>
              <description>
              0: select clk_div as clk for SPI controller
              1: select clk_sys as clk for SPI controller
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CLK_DIV</name>
              <description>
              div ratio from clk_sys
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD1</name>
          <displayName>RSVD1</displayName>
          <description></description>
          <addressOffset>0x40</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>TRIWIRE_CTRL</name>
          <displayName>TRIWIRE_CTRL</displayName>
          <description>Three Wire Mode  Control Register</description>
          <addressOffset>0x54</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>29</bitWidth>
            </field>
            <field>
              <name>WORK_WIDTH_DYN_CHANGE</name>
              <description>
              WORK_WIDTH_DYN_CHNAGE 
              1: SW can dynamicly change TOP_CTRL[9:5] without disabling TOP_CTRL[0] and re-enabling TOP_CTRL[0]   
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TXD_OEN</name>
              <description>
              TXD_OEN control when TRI-WIRE mode
              1: SPI_DIO is input  
              0: SPI_DIO is output
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SPI_TRI_WIRE_EN</name>
              <description>
              SPI_THREE_WIRE_MODE_EN 
              0: normal mode
              1: enable TRI-WIRE mode
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>SPI4</name>
      <description></description>
      <groupName>SPI</groupName>
      <baseAddress>0x5000a000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>TOP_CTRL</name>
          <displayName>TOP_CTRL</displayName>
          <description>Top Control Register</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>13</bitWidth>
            </field>
            <field>
              <name>TTELP</name>
              <description>
              SPI_DO Three-state Enable On Last Phase (can be set only when TI-SSP)
              0: SPI_DO is three-stated 1/2 clock cycle after the beginning of the LSB 
              1: SPI_DO output signal is three-stated on the clock edge that ends the LSB
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TTE</name>
              <description>
              SPI_DO Three-State Enable 
              0: SPI_DO output signal is not three-stated 
              1: SPI_DO is three-stated when not transmitting data
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IFS</name>
              <description>
              Invert Frame Signal 
              0: SPI_CS polarity is as defined in protocol
              1: SPI_CS will be inverted from normal-SPI_CS
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HOLD_FRAME_LOW</name>
              <description>
              Hold Frame Low Control 
              0:After this field is set to 1 and the SPI controller is operating in master mode,the output frame signal SPI_CS will be determined by control FSM.
              1:After this field is set to 1 and the SPI controller is operating in master mode, the output frame signal SPI_CS will hold low. 
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TRAIL</name>
              <description>
              Trailing Byte 
              0: Trailing bytes are handled by CPU 
              1: Trailing bytes are handled by DMA bursts
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              Reserved
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SPH</name>
              <description>
              Motorola SPI SPI_CLK phase setting 
              0: SPI_CLK is inactive until one cycle after the start of a frame and active until 1/2 cycle before the end of a frame 
              1: SPI_CLK is inactive until 1/2 cycle after the start of a frame and active until one cycle before the end of a frame
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SPO</name>
              <description>
              Motorola SPI SPI_CLK Polarity Setting 
              0: The inactive or idle state of SPI_CLK is low 
              1: The inactive or idle state of SPI_CLK is high
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DSS</name>
              <description>
              SPI controller Work data size,  register bits value 0~31 indicated data size 1~32 bits,  usually use data size 8bits, 16bits, 24bits, 32bits
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>SFRMDIR</name>
              <description>
              SPI_CS Direction 
              0: Master mode, SPI controller drives SPI_CS 
              1: Slave mode, SPI controller receives SPI_CS
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SCLKDIR</name>
              <description>
              SPI_CLK Direction 
              0: Master mode, SPI controller drives SPI_CLK 
              1: Slave mode, SPI controller receives SPI_CLK
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FRF</name>
              <description>
              Frame Format 
              0x0: Motorola* Serial Peripheral Interface (SPI)  
              0x1: Texas Instruments* Synchronous Serial Protocol (SSP) 
              0x2: National Semiconductor Microwire* 
              0x3: RSVD 
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>SSE</name>
              <description>
              SPI controller Enable 
              0: SPI controller is disabled  
              1: SPI controller is enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>FIFO_CTRL</name>
          <displayName>FIFO_CTRL</displayName>
          <description>FIFO Control Register</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>14</bitWidth>
            </field>
            <field>
              <name>RXFIFO_AUTO_FULL_CTRL</name>
              <description>
              Rx FIFO Auto Full Control: After this field is set to 1 and the SPI controller is operating in master mode, the controller FSM returns to IDLE state and stops the SPI_CLK. 
              When Rx FIFO is full, the controller FSM continues transferring data after the RxFIFO is not full. 
              This field is used to avoid an RxFIFO overrun issue. 
              1: Enable Rx FIFO auto full control
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FPCKE</name>
              <description>
              FIFO Packing Enable 
              0: FIFO packing mode disabled 
              1: FIFO packing mode enabled
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TXFIFO_WR_ENDIAN</name>
              <description>
              apb_pwdata Write to TxFIFO Endian 
              0x0: txfifo_wdata[31:0] = apb_pwdata[31:0] 
              0x1: fifo_wdata[31:0] = {apb_pwdata[15:0], apb_pwdata[31:16]} 
              0x2: txfifo_wdata[31:0] = {apb_pwdata[7:0], apb_pwdata[15:8], apb_pwdata[23:16], apb_pwdata[31:24]} 
              0x3: txfifo_wdata[31:0] = {apb_pwdata[23:16], apb_pwdata[31:24], apb_pwdata[7:0], apb_pwdata[15:8]}
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RXFIFO_RD_ENDIAN</name>
              <description>
              apb_prdata Read from Rx FIFO Endian 
              0x0 = apb_prdata[31:0] = rxfifo_wdata[31:0] 
              0x1 = apb_prdata[31:0] = {rxfifo_wdata[15:0], rxfifo_wdata[31:16]} 
              0x2 = apb_prdata[31:0]= {rxfifo_wdata[7:0], rxfifo_wdata[15:8], rxfifo_wdata[23:16], rxfifo_wdata[31:24]} 
              0x3 = apb_prdata[31:0]= {rxfifo_wdata[23:16], rxfifo_wdata[31:24], rxfifo_wdata[7:0], rxfifo_wdata[15:8]}
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSRE</name>
              <description>
              Receive Service Request Enable 
              0: RxFIFO DMA service request is disabled 
              1: RxFIFO DMA service request is enabled
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TSRE</name>
              <description>
              Transmit Service Request Enable 
              0: TxFIFO DMA service request is disabled 
              1: TxFIFO DMA service request is enabled
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RFT</name>
              <description>
              RXFIFO Trigger Threshold This field sets the threshold level at which RXFIFO asserts interrupt. The level should be set to the preferred threshold value minus 1.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>TFT</name>
              <description>
              TXFIFO Trigger Threshold This field sets the threshold level at which TXFIFO asserts interrupt. The level should be set to the preferred threshold value minus 1. 
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>INTE</name>
          <displayName>INTE</displayName>
          <description>Interrupt Enable Register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>26</bitWidth>
            </field>
            <field>
              <name>TIM</name>
              <description>
              Transmit FIFO Underrun Interrupt Mask
              0 : TUR events generate an SPI interrupt 
              1 : TUR events do NOT generate an SPI interrupt 
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RIM</name>
              <description>
              Receive FIFO Overrun Interrupt Mask 
              0: ROR events generate an SPI interrupt 
              1: ROR events do NOT generate an SPI interrupt 
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TIE</name>
              <description>
              Transmit FIFO Interrupt Enable 
              0: TxFIFO threshold-level-reached interrupt is disabled 
              1: TxFIFO threshold-level-reached interrupt is enabled
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RIE</name>
              <description>
              Receive FIFO Interrupt Enable 
              0: RxFIFO threshold-level-reached interrupt is disabled 
              1: RxFIFO threshold-level-reached interrupt is enabled
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TINTE</name>
              <description>
              Receiver Time-out Interrupt Enable 
              0: Receiver time-out interrupt is disabled 
              1: Receiver time-out interrupt is enabled
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TO</name>
          <displayName>TO</displayName>
          <description>SPI Time Out Register</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>TIMEOUT</name>
              <description>
              Timeout Value TIMEOUT value is the value (0 to 2^24-1) that defines the time-out interval. The time-out interval is given by the equation shown in the TIMEOUT Interval Equation.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DATA</name>
          <displayName>DATA</displayName>
          <description>SPI DATA Register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              DATA This field is used for data to be written to the TXFIFO read from the RXFIFO.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS</name>
          <displayName>STATUS</displayName>
          <description>Status Register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>OSS</name>
              <description>
              Odd Sample Status 
              0: RxFIFO entry has two samples 
              1: RxFIFO entry has one sample  
              Note that this bit needs to be looked at only when FIFO Packing is enabled (FPCKE field in FIFO Control Register is set). Otherwise, this bit is zero. When SPI controller is in Packed mode and the CPU is used instead of DMA to read the RxFIFO, the CPU should make sure that [Receive FIFO Not Empty] = 1 AND this field = 0 before it attempts to read the RxFIFO.
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TX_OSS</name>
              <description>
              TX FIFO Odd Sample Status When SPI controller is in packed mode, 
              the number of samples in the TX FIFO is:  ([Transmit FIFO Level]*2 + this field), when [Transmit FIFO Not Full] = 1 32, when [Transmit FIFO Not Full] = 0.
              The TX FIFO cannot accept new data when [Transmit FIFO Not Full] = 1 and [Transmit FIFO Level] = 15 and this field = 1. (The TX FIFO has 31 samples).  
              0: TxFIFO entry has an even number of samples 
              1: TxFIFO entry has an odd number of samples Note that this bit needs to be read only when FIFO Packing is enabled ([FIFO Packing Enable] in the FIFO Control Register is set). Otherwise, this bit is zero.
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ROR</name>
              <description>
              Receive FIFO Overrun 
              0: RXFIFO has not experienced an overrun 
              1: Attempted data write to full RXFIFO, causes an interrupt request
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RFL</name>
              <description>
              Receive FIFO Level This field is the number of entries minus one in RXFIFO. When the value 0xF is read, the RXFIFO is either empty or full, and software should read the [Receive FIFO Not Empty] field.
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>RNE</name>
              <description>
              Receive FIFO Not Empty 
              0: RXFIFO is empty 
              1: RXFIFO is not empty
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RFS</name>
              <description>
              Receive FIFO Service Request 
              0: RXFIFO level is at or below RFT threshold (RFT) or SPI controller is disabled 
              1: RXFIFO level exceeds RFT threshold (RFT), causes an interrupt request
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TUR</name>
              <description>
              Transmit FIFO Underrun 
              0: The TXFIFO has not experienced an underrun 
              1: A read from the TXFIFO was attempted when the TXFIFO was empty, causes an interrupt if it is enabled ([Transmit FIFO Underrun Interrupt Mask] in the INT EN Register  is 0)
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TFL</name>
              <description>
              Transmit FIFO Level This field is the number of entries in TXFIFO.When the value 0x0 is read, the TXFIFO is either empty or full, and software should read the [Transmit FIFO Not Full] field.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>TNF</name>
              <description>
              Transmit FIFO Not Full 
              0: TXFIFO is full 
              1: TXFIFO is not full
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TFS</name>
              <description>
              Transmit FIFO Service Request 
              0: TX FIFO level exceeds the TFT threshold (TFT + 1) or SPI controller is disabled 
              1: TXFIFO level is at or below TFT threshold (TFT + 1), causes an interrupt request
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD5</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TINT</name>
              <description>
              Receiver Time-out Interrupt 
              0: No receiver time-out is pending 
              1: Receiver time-out pending, causes an interrupt request
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD6</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CSS</name>
              <description>
              Clock Synchronization Status 
              0: SPI controller is ready for slave clock operations 
              1: SPI controller is currently busy synchronizing slave mode signals
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BSY</name>
              <description>
              SPI controller Busy 
              0: SPI controller is idle or disabled 
              1: SPI controller is currently transmitting or receiving framed data
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD3</name>
          <displayName>RSVD3</displayName>
          <description></description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>RWOT_CTRL</name>
          <displayName>RWOT_CTRL</displayName>
          <description>RWOT Control Register</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>27</bitWidth>
            </field>
            <field>
              <name>MASK_RWOT_LAST_SAMPLE</name>
              <description>
              Mask last_sample_flag in RWOT Mode 
              1: Mask 
              0: Unmask
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CLR_RWOT_CYCLE</name>
              <description>
              Clear Internal rwot_counter This field clears the rwot_counter to 0. This field is self cleared after SSE = 1. 
              1: Clear rwot_counter
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SET_RWOT_CYCLE</name>
              <description>
              Set RWOT Cycle This field is used to set the value of the RWOT_CCM register to the internal rwot_counter. This field is self-cleared after SSE = 1. 
              1: Set rwot_counter
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CYCLE_RWOT_EN</name>
              <description>
              Enable RWOT Cycle Counter Mode 
              1: Enable
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RWOT</name>
              <description>
              Receive Without Transmit 
              0: Transmit/receive mode 
              1: Receive without transmit mode
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RWOT_CCM</name>
          <displayName>RWOT_CCM</displayName>
          <description>RWOT Counter Cycles Match Register</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RWOTCCM</name>
              <description>
              It's just total SPI_CLK Cycles. 
              The value of this register defines the total number of SPI_CLK cycles when SPI controller works in master and RWOT mode. 
              When the rwot_counter matches this value, SPI controller returns to IDLE state and does not output SPI_CLK anymore.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RWOT_CVWRN</name>
          <displayName>RWOT_CVWRN</displayName>
          <description>RWOT Counter Value Write for Red Request Register</description>
          <addressOffset>0x2c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RWOTCVWR</name>
              <description>
              RWOTCVWR This register prevents the risk of instability on rwot_counter value reading, it's only valid after SPI controller has been enabled Write 0 = No effect Write 1 = Capture value of rwot_counter Read: Returns the captured value of rwot_counter
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD2</name>
          <displayName>RSVD2</displayName>
          <description></description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>CLK_CTRL</name>
          <displayName>CLK_CTRL</displayName>
          <description>CLK  Control Register</description>
          <addressOffset>0x3c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>CLK_EN</name>
              <description>
              enable clk for internal logic
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CLK_SEL</name>
              <description>
              0: select clk_div as clk for SPI controller
              1: select clk_sys as clk for SPI controller
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CLK_DIV</name>
              <description>
              div ratio from clk_sys
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD1</name>
          <displayName>RSVD1</displayName>
          <description></description>
          <addressOffset>0x40</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>TRIWIRE_CTRL</name>
          <displayName>TRIWIRE_CTRL</displayName>
          <description>Three Wire Mode  Control Register</description>
          <addressOffset>0x54</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>29</bitWidth>
            </field>
            <field>
              <name>WORK_WIDTH_DYN_CHANGE</name>
              <description>
              WORK_WIDTH_DYN_CHNAGE 
              1: SW can dynamicly change TOP_CTRL[9:5] without disabling TOP_CTRL[0] and re-enabling TOP_CTRL[0]   
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TXD_OEN</name>
              <description>
              TXD_OEN control when TRI-WIRE mode
              1: SPI_DIO is input  
              0: SPI_DIO is output
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SPI_TRI_WIRE_EN</name>
              <description>
              SPI_THREE_WIRE_MODE_EN 
              0: normal mode
              1: enable TRI-WIRE mode
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>WDT2</name>
      <description></description>
      <groupName>WDT</groupName>
      <baseAddress>0x5000b000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>WDT_CVR0</name>
          <displayName>WDT_CVR0</displayName>
          <description>WatchDog Counter Value 0</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>COUNT_VALUE_0</name>
              <description>
              Count Value for 1st TimeOut
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_CVR1</name>
          <displayName>WDT_CVR1</displayName>
          <description>WatchDog Counter Value 1</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>COUNT_VALUE_1</name>
              <description>
              Count Value for 2nd TimeOut
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_CR</name>
          <displayName>WDT_CR</displayName>
          <description>WatchDog Control Register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>27</bitWidth>
            </field>
            <field>
              <name>RESPONSE_MODE</name>
              <description>
              0:reset only, 1:interrupt and reset
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RESET_LENGTH</name>
              <description>
              reset pulse length in number of wdt clock cycles
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_CCR</name>
          <displayName>WDT_CCR</displayName>
          <description>WatchDog Counter Control Register</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>COUNTER_CONTROL</name>
              <description>
              SinglePulse /Write 8'h76 to restart, write8'h34 to stop, else do nothing
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_ICR</name>
          <displayName>WDT_ICR</displayName>
          <description>WatchDog Interrupt Clear Register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>31</bitWidth>
            </field>
            <field>
              <name>INT_CLR</name>
              <description>
              SinglePulse /A pulse to clear interrupt
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_SR</name>
          <displayName>WDT_SR</displayName>
          <description>WatchDog Status Register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>30</bitWidth>
            </field>
            <field>
              <name>WDT_ACTIVE</name>
              <description>
              Watchdog runs when 1, else 0
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>INT_ASSERT</name>
              <description>
              Interrupt assert when 1
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_WP</name>
          <displayName>WDT_WP</displayName>
          <description>WatchDog Write Protect Register</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>WRPT_ST</name>
              <description>
              1 indicates write protect is active
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>WRPT</name>
              <description>
              write 0x58ab99fc generate write_protect, write 0x51ff8621 to release
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>31</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_FG</name>
          <displayName>WDT_FG</displayName>
          <description>WatchDog Flag Register</description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>28</bitWidth>
            </field>
            <field>
              <name>SYNC_FG</name>
              <description>
              1 indicates one transition from system clk to wdt clk has complicated
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SYNC_FG_CLR</name>
              <description>
              SinglePulse/A pulse to clear sync flag
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RST_FG</name>
              <description>
              1 indicates wdt has already reset system
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RST_FG_CLR</name>
              <description>
              SinglePulse/A pulse to clear reset flag
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>I2C5</name>
      <description></description>
      <groupName>I2C</groupName>
      <baseAddress>0x5000c000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CR</name>
          <displayName>CR</displayName>
          <description>Control register</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>UR</name>
              <description>
              Unit Reset. Software need first assert to reset then deassert to release.
              0 = No reset.
              1 = Reset I2C module.
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSTREQ</name>
              <description>
              I2C will do bus reset upon this bit set. Will be cleared by HW automatically after RSTCYC cycles of SCL generated.
              1 = request for i2c bus reset
              0 = bus reset finished
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BRGRST</name>
              <description>
              Reset bus related state machine and signals. Will be cleared by HW automatically
              1 = request for reset
              0 = reset finished
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>14</bitWidth>
            </field>
            <field>
              <name>DNF</name>
              <description>
              Digital noise filter
              These bits are used to configure the digital noise filter on SDA and SCL input. The digital filter will filter spikes with a length of up to DNF*Tfclk.
              0: Digital filter disabled 
              1: Digital filter enabled and filtering capability up to 1 Tfclk
              ...
              7: digital filter enabled and filtering capability up to 7 Tfclk
              Digital filter is added to analog filter. Digital filter will introduce delay on SCL and SDA processing, which is essential in hs-mode. 
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>SLVEN</name>
              <description>
              Slave mode Enable for SCL.
              0 = Disable slave mode. Will not monitor slave address on I2C bus.
              1 = Enable slave mode. Will monitor slave address on I2C bus.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SCLPP</name>
              <description>
              Push-pull mode Enable for SCL.
              0 = open drain output for SCL.
              1 = Push-pull output for SCL
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MSDE</name>
              <description>
              Master Stop Detected Enable:
              0 = Master Stop Detect (MSD) status is not enabled.
              1 = Master Stop Detect (MSD) status is enabled.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LASTSTOP</name>
              <description>
              Generate STOP for last DMA transfer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LASTNACK</name>
              <description>
              Generate NACK for last DMA Read transfer
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMAEN</name>
              <description>
              DMA Enable for both TX and RX
              0 = DMA mode is NOT enabled
              1 = DMA mode enabled
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SCLE</name>
              <description>
              SCL Enable:
              0 = Disables the I2C from driving the SCL line.
              1 = Enables the I2C clock output for master-mode operation.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IUE</name>
              <description>
              I2C Unit Enable:
              0 = Disables the unit and does not master any transactions or respond to any slave transactions.
              1 = Enables the I2C (defaults to slave-receive mode).
              Software must guarantee the I2C bus is idle before setting this bit.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MODE</name>
              <description>
              Bus Mode (Master operation):
              2'b00: standard-mode
              2'b01: fast-mode and fast-mode plus
              2'b10: HS-mode (standard mode when not doing a high speed transfer)
              2'b11: HS-mode (fast mode when not doing a high speed transfer)
              Bus Mode (Slave operation):
              2'b0x: HS-mode is disabled. I2C unit uses Standard/Fast mode timing on the SDA pin.
              2'b1x: HS-mode is enabled. I2C unit uses HS-mode timing on the SDA pin when a master code is received.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TCR</name>
          <displayName>TCR</displayName>
          <description>Transfer Control register</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>ABORTDMA</name>
              <description>
              Abort DMA operation. Will be cleared by HW automatically
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RXREQ</name>
              <description>
              Request DMA RX. Will be cleared by HW automatically
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TXREQ</name>
              <description>
              Request DMA TX. Will be cleared by HW automatically
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MA</name>
              <description>
              Master Abort:
              Used by the I2C in master mode to generate a Stop without transmitting another data byte:
              0 = The I2C transmits Stop on if TCR[STOP] is set.
              1 = The I2C sends Stop without data transmission.
              When in master-transmit mode, after transmitting a data byte, the TCR[TB] bit is cleared. When no more data bytes need to be sent, setting master abort bit sends the Stop. The TCR[TB] bit must remain clear.
              In master-receive mode, when a NAK is sent without a Stop (TCR[STOP] bit was not set) and CPU does not send a repeated Start, setting this bit sends the Stop. Once again, the TCR[TB] bit must remain clear. Master Abort can be done immediately after the address phase (Master Transmit mode only).
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>NACK</name>
              <description>
              The positive/negative acknowledge control bit, defines the type of acknowledge pulse sent by the I2C when in master receive mode:
              0 = Send a positive acknowledge (ACK) pulse after receiving a data byte.
              1 = Send a negative acknowledge (NACK) pulse after receiving a data byte.
              The I2C automatically sends an ACK pulse when responding to its slave address or when responding in slave-receive mode, regardless of the NACK control-bit setting.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>STOP</name>
              <description>
              Stop:
              Used to initiate a Stop condition after transferring the next data byte on the I2C bus when in master mode. In master-receive mode, the NACK control bit must be set in conjunction with the STOP bit. 
              0 = Do not send a Stop.
              1 = Send a Stop.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>START</name>
              <description>
              Start:
              Used to initiate a Start condition to the I2C unit when in master mode. 
              0 = Do not send a Start pulse.
              1 = Send a Start pulse.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TB</name>
              <description>
              Transfer Byte:
              Used to send or receive a byte on the I2C bus:
              0 = Cleared by I2C when the byte is sent/received.
              1 = Send/receive a byte. 
              CPU can monitor this bit to determine when the byte transfer has completed. In master or slave mode, after each byte transfer including acknowledge pulse, the I2C holds the SCL line low (inserting wait states) until TB is set.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IER</name>
          <displayName>IER</displayName>
          <description>Interrupt Enable register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>UFIE</name>
              <description>
              FIFO Underflow Interrupt Enable
              0 = FIFO Underflow interrupt is not enabled
              1 = FIFO Underflow interrupt is enabled
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OFIE</name>
              <description>
              FIFO Overflow Interrupt Enable
              0 = FIFO Overflow interrupt is not enabled
              1 = FIFO Overflow interrupt is enabled
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMADONEIE</name>
              <description>
              DMA Transaction Done Interrupt Enable
              0 = DMA Transaction done interrupt is not enabled.
              1 = DMA Transaction done interrupt is enabled.
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MSDIE</name>
              <description>
              Master Stop Detected Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C unit to interrupt upon detecting a Master Stop sent by the I2C unit.
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BEDIE</name>
              <description>
              Bus Error Detected Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C to interrupt for the following I2C bus errors:
              As a master transmitter, no ACK was detected after a byte was sent.
              As a slave receiver, the I2C generated a NACK pulse.
              Software is responsible for guaranteeing that misplaced Start and Stop conditions do not occur.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SADIE</name>
              <description>
              Slave Address Detected Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C to interrupt upon detecting a slave address match or a general call address.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RFIE</name>
              <description>
              DBR Receive Full Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C to interrupt when the DBR has received a data byte from the I2C bus.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIE</name>
              <description>
              DBR Transmit Empty Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C to interrupt after transmitting a byte onto the I2C bus.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ALDIE</name>
              <description>
              Arbitration Loss Detected Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C to interrupt upon losing arbitration while in master mode.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SSDIE</name>
              <description>
              Slave Stop Detected Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C to interrupt when it detects a Stop condition while in slave mode.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SR</name>
          <displayName>SR</displayName>
          <description>Status register</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>UF</name>
              <description>
              FIFO Underflow Flag. Asserted when FIFO is empty and a POP request generated without a PUSH. Cleared if write 1
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OF</name>
              <description>
              FIFO Overflow Flag. Asserted when FIFO is full and a PUSH request generated without a POP. Cleared if write 1
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMADONE</name>
              <description>
              DMA Transaction Done. Asserted when both APB and I2C bus have finished transfer. Cleared if write 1
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MSD</name>
              <description>
              Master Stop Detected:
              0 = No Master Stop Detected.
              1 = This bit is set by the I2C unit when all of the following are true:
              This bit is enabled (CR[MSDE] = 1);
              I2C unit is configured as a master;
              I2C transmits a STOP signal
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EBB</name>
              <description>
              Early Bus Busy
              0 = I2C bus is idle or the I2C is using the bus (that is, unit busy).
              1 = Set when the unit detects that the SCL or SDA line is low without a START condition. Bit will remain set until the I2C unit detects the bus is idle by detecting a STOP condition. Bit will also be set whenever the IBB bit is set.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BED</name>
              <description>
              Bus Error Detected:
              0 = No error detected.
              1 = The I2C sets this bit when it detects one of the following error conditions:
              As a master transmitter, no ACK was detected on the interface after a byte was sent.
              As a slave receiver, the I2C generates a NACK pulse.
              When an error occurs, I2C bus transactions continue. Software must guarantee that misplaced Start and Stop conditions do not occur. 
              Cleared if write 1
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SAD</name>
              <description>
              Slave Address Detected:
              0 = No slave address was detected.
              1 = The I2C detected a seven-bit address that matches the general call address or SAR. An interrupt is signalled when enabled in the CR. 
              Cleared if write 1
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RF</name>
              <description>
              DBR Receive Full:
              0 = The DBR has not received a new data byte or the I2C is idle.
              1 = The DBR register received a new data byte from the I2C bus. An interrupt is signalled when enabled in the CR. 
              Cleared if write 1
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TE</name>
              <description>
              DBR Transmit Empty:
              0 = The data byte is still being transmitted.
              1 = The I2C has finished transmitting a data byte on the I2C bus. An interrupt is signalled when enabled in the CR.
              Cleared if write 1
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ALD</name>
              <description>
              Arbitration Loss Detected:
              Used during multi-master operation:
              0 = Cleared when arbitration is won or never took place.
              1 = Set when the I2C loses arbitration. 
              Cleared if write 1
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SSD</name>
              <description>
              Slave Stop Detected:
              0 = No Stop detected.
              1 = Set when the I2C detects a Stop while in slave-receive or slave-transmit mode. 
              Cleared if write 1
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IBB</name>
              <description>
              I2C Bus Busy:
              0 = I2C bus is idle or the I2C is using the bus (that is, unit busy).
              1 = Set when the I2C bus is busy but local I2C is not involved in the transaction.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UB</name>
              <description>
              Unit Busy:
              0 = I2C not busy.
              1 = Set when local I2C is busy. This is defined as the time between the first Start and Stop. 
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>NACK</name>
              <description>
              ACK/NACK Status:
              0 = The I2C received or sent an ACK on the bus. 
              1 = The I2C received or sent a NACK.on the bus.
              This bit is used in slave-transmit mode to determine when the byte transferred is the last one. This bit is updated after each byte and ACK/NACK information is received.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RWM</name>
              <description>
              Read/write Mode:
              0 = The I2C is in master-transmit or slave-receive mode. 
              1 = The I2C is in master-receive or slave-transmit mode. 
              This is the R/nW bit of the slave address. It is cleared automatically by hardware after a Stop state.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DBR</name>
          <displayName>DBR</displayName>
          <description>Data Buffer register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>DATA</name>
              <description>
              use the I2C Data Buffer register to transmit and receive data from the I2C bus. The DBR is accessed by software on one Side and by the I2C Shift register on the other. The DBR receives data coming into the I2C unit after a full byte is received and acknowledged. CPU writes data going out of the I2C to the DBR and sends it to the serial bus. 
              When the I2C is in transmit mode (master or slave), CPU writes data to the DBR over the internal bus. CPU write data to the DBR when a master transaction is initiated or when the DBR transmit-empty interrupt is signalled. Data moves from the DBR to the Shift register when the transfer byte bit is set. The DBR transmit-empty interrupt is signalled (if enabled) when a byte is transferred on the I2C bus and the acknowledge cycle is complete. If the DBR is not written, and a Stop condition is not in place before the I2C bus is ready to transfer the next byte packet, the I2C unit inserts wait states until CPU writes the DBR and sets the transfer byte bit.
              When the I2C is in receive mode (master or slave), CPU reads DBR data over the internal bus. CPU reads data from the DBR when the DBR receive-full interrupt is signalled. The data moves from the Shift register to the DBR when the acknowledge cycle is complete. The I2C inserts wait states until the DBR is read. After the software reads the DBR, CR[NACK] are written by the software, allowing the next byte transfer to proceed to the I2C bus.
              In DMA mode, DBR is automatically filled from FIFO in master transmit mode, or fetched and stored in FIFO in master receive mode until DMA done or aborted.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SAR</name>
          <displayName>SAR</displayName>
          <description>Slave Address Register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000047</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>25</bitWidth>
            </field>
            <field>
              <name>ADDR</name>
              <description>
              The seven-bit address to which the I2C responds when in slave-receive mode
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>LCR</name>
          <displayName>LCR</displayName>
          <description>Load Count Register</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x081C72ED</resetValue>
          <fields>
            <field>
              <name>HLVH</name>
              <description>
              Decrementer Load value for High Speed Mode SCL (master mode) for high phase. 
              Thigh=Tfclk*(HLVH+4+DNF)
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>HLVL</name>
              <description>
              Decrementer Load value for High Speed Mode SCL (master mode) for low phase. 
              Tlow=Tfclk*(HLVL+3+DNF). Data rate is generated as 1/(Thigh+Tlow), or Ffclk/(HLVH+HLVL+7+2*DNF). 
              3.2Mbps data rate is generated by default if fclk is 48MHz.
              HLVL also controls setup time and hold time for START and STOP condition in High Speed Mode(master mode). 
              Thdsta=Tsusta=Tsusto=Tfclk*(HLVL+1)
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
            <field>
              <name>FLV</name>
              <description>
              Decrementer Load value for Fast Mode (or Fast Mode Plus) SCL (master mode) for both high and low phase. 
              Data rate is generated as Ffclk/(FLV+max(FLV,CNT*2+6)+7+DNF) approximately. 
              400kbps data rate is generated by default if fclk is 48MHz.
              FLV also controls setup time and hold time for START and STOP condition in Fast Mode(master mode). 
              Thdsta=Tsusta=Tsusto=Tfclk*FLV
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
            <field>
              <name>SLV</name>
              <description>
              Decrementer Load value for Standard Mode SCL (master mode) for both high and low phase. 
              Data rate is generated as Ffclk/(SLV+max(SLV,CNT*2+6)+7+DNF) approximately. 
              100kbps data rate is generated by default if fclk is 48MHz.
              SLV also controls setup time and hold time for START and STOP condition in Standard Mode(master mode). 
              Thdsta=Tsusta=Tsusto=Tfclk*SLV
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>WCR</name>
          <displayName>WCR</displayName>
          <description>Wait Count Register</description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0000000A</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>CNT</name>
              <description>
              Controls the counter values defining the setup and hold times in standard and fast mode
              Tvddat=Thddat=Tfclk*(CNT+2)
              Tsudat=max(Tlow-Thddat,Thddat)
              Lower counter values may violate setup and hold times.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RCCR</name>
          <displayName>RCCR</displayName>
          <description>Bus Reset Cycle Counter Register</description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000009</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>28</bitWidth>
            </field>
            <field>
              <name>RSTCYC</name>
              <description>
              The cycles of SCL during bus reset
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BMR</name>
          <displayName>BMR</displayName>
          <description>Bus Monitor Register</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000003</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>30</bitWidth>
            </field>
            <field>
              <name>SCL</name>
              <description>
              value of the SCL pin. Software can check bus level when the I2C bus is hung and the I2C unit must be reset.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SDA</name>
              <description>
              value of the SDA pin.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DNR</name>
          <displayName>DNR</displayName>
          <description>DMA number register</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>NDT</name>
              <description>
              Write as number of data to transfer in byte. Read as left data number to transfer
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD1</name>
          <displayName>RSVD1</displayName>
          <description></description>
          <addressOffset>0x2C</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>FIFO</name>
          <displayName>FIFO</displayName>
          <description>FIFO Register</description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>DATA</name>
              <description>
              Write to push send data into FIFO. Read to pop received data from FIFO
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>I2C6</name>
      <description></description>
      <groupName>I2C</groupName>
      <baseAddress>0x5000d000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CR</name>
          <displayName>CR</displayName>
          <description>Control register</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>UR</name>
              <description>
              Unit Reset. Software need first assert to reset then deassert to release.
              0 = No reset.
              1 = Reset I2C module.
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSTREQ</name>
              <description>
              I2C will do bus reset upon this bit set. Will be cleared by HW automatically after RSTCYC cycles of SCL generated.
              1 = request for i2c bus reset
              0 = bus reset finished
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BRGRST</name>
              <description>
              Reset bus related state machine and signals. Will be cleared by HW automatically
              1 = request for reset
              0 = reset finished
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>14</bitWidth>
            </field>
            <field>
              <name>DNF</name>
              <description>
              Digital noise filter
              These bits are used to configure the digital noise filter on SDA and SCL input. The digital filter will filter spikes with a length of up to DNF*Tfclk.
              0: Digital filter disabled 
              1: Digital filter enabled and filtering capability up to 1 Tfclk
              ...
              7: digital filter enabled and filtering capability up to 7 Tfclk
              Digital filter is added to analog filter. Digital filter will introduce delay on SCL and SDA processing, which is essential in hs-mode. 
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>SLVEN</name>
              <description>
              Slave mode Enable for SCL.
              0 = Disable slave mode. Will not monitor slave address on I2C bus.
              1 = Enable slave mode. Will monitor slave address on I2C bus.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SCLPP</name>
              <description>
              Push-pull mode Enable for SCL.
              0 = open drain output for SCL.
              1 = Push-pull output for SCL
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MSDE</name>
              <description>
              Master Stop Detected Enable:
              0 = Master Stop Detect (MSD) status is not enabled.
              1 = Master Stop Detect (MSD) status is enabled.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LASTSTOP</name>
              <description>
              Generate STOP for last DMA transfer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LASTNACK</name>
              <description>
              Generate NACK for last DMA Read transfer
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMAEN</name>
              <description>
              DMA Enable for both TX and RX
              0 = DMA mode is NOT enabled
              1 = DMA mode enabled
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SCLE</name>
              <description>
              SCL Enable:
              0 = Disables the I2C from driving the SCL line.
              1 = Enables the I2C clock output for master-mode operation.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IUE</name>
              <description>
              I2C Unit Enable:
              0 = Disables the unit and does not master any transactions or respond to any slave transactions.
              1 = Enables the I2C (defaults to slave-receive mode).
              Software must guarantee the I2C bus is idle before setting this bit.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MODE</name>
              <description>
              Bus Mode (Master operation):
              2'b00: standard-mode
              2'b01: fast-mode and fast-mode plus
              2'b10: HS-mode (standard mode when not doing a high speed transfer)
              2'b11: HS-mode (fast mode when not doing a high speed transfer)
              Bus Mode (Slave operation):
              2'b0x: HS-mode is disabled. I2C unit uses Standard/Fast mode timing on the SDA pin.
              2'b1x: HS-mode is enabled. I2C unit uses HS-mode timing on the SDA pin when a master code is received.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TCR</name>
          <displayName>TCR</displayName>
          <description>Transfer Control register</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>ABORTDMA</name>
              <description>
              Abort DMA operation. Will be cleared by HW automatically
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RXREQ</name>
              <description>
              Request DMA RX. Will be cleared by HW automatically
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TXREQ</name>
              <description>
              Request DMA TX. Will be cleared by HW automatically
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MA</name>
              <description>
              Master Abort:
              Used by the I2C in master mode to generate a Stop without transmitting another data byte:
              0 = The I2C transmits Stop on if TCR[STOP] is set.
              1 = The I2C sends Stop without data transmission.
              When in master-transmit mode, after transmitting a data byte, the TCR[TB] bit is cleared. When no more data bytes need to be sent, setting master abort bit sends the Stop. The TCR[TB] bit must remain clear.
              In master-receive mode, when a NAK is sent without a Stop (TCR[STOP] bit was not set) and CPU does not send a repeated Start, setting this bit sends the Stop. Once again, the TCR[TB] bit must remain clear. Master Abort can be done immediately after the address phase (Master Transmit mode only).
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>NACK</name>
              <description>
              The positive/negative acknowledge control bit, defines the type of acknowledge pulse sent by the I2C when in master receive mode:
              0 = Send a positive acknowledge (ACK) pulse after receiving a data byte.
              1 = Send a negative acknowledge (NACK) pulse after receiving a data byte.
              The I2C automatically sends an ACK pulse when responding to its slave address or when responding in slave-receive mode, regardless of the NACK control-bit setting.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>STOP</name>
              <description>
              Stop:
              Used to initiate a Stop condition after transferring the next data byte on the I2C bus when in master mode. In master-receive mode, the NACK control bit must be set in conjunction with the STOP bit. 
              0 = Do not send a Stop.
              1 = Send a Stop.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>START</name>
              <description>
              Start:
              Used to initiate a Start condition to the I2C unit when in master mode. 
              0 = Do not send a Start pulse.
              1 = Send a Start pulse.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TB</name>
              <description>
              Transfer Byte:
              Used to send or receive a byte on the I2C bus:
              0 = Cleared by I2C when the byte is sent/received.
              1 = Send/receive a byte. 
              CPU can monitor this bit to determine when the byte transfer has completed. In master or slave mode, after each byte transfer including acknowledge pulse, the I2C holds the SCL line low (inserting wait states) until TB is set.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IER</name>
          <displayName>IER</displayName>
          <description>Interrupt Enable register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>UFIE</name>
              <description>
              FIFO Underflow Interrupt Enable
              0 = FIFO Underflow interrupt is not enabled
              1 = FIFO Underflow interrupt is enabled
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OFIE</name>
              <description>
              FIFO Overflow Interrupt Enable
              0 = FIFO Overflow interrupt is not enabled
              1 = FIFO Overflow interrupt is enabled
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMADONEIE</name>
              <description>
              DMA Transaction Done Interrupt Enable
              0 = DMA Transaction done interrupt is not enabled.
              1 = DMA Transaction done interrupt is enabled.
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MSDIE</name>
              <description>
              Master Stop Detected Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C unit to interrupt upon detecting a Master Stop sent by the I2C unit.
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BEDIE</name>
              <description>
              Bus Error Detected Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C to interrupt for the following I2C bus errors:
              As a master transmitter, no ACK was detected after a byte was sent.
              As a slave receiver, the I2C generated a NACK pulse.
              Software is responsible for guaranteeing that misplaced Start and Stop conditions do not occur.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SADIE</name>
              <description>
              Slave Address Detected Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C to interrupt upon detecting a slave address match or a general call address.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RFIE</name>
              <description>
              DBR Receive Full Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C to interrupt when the DBR has received a data byte from the I2C bus.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIE</name>
              <description>
              DBR Transmit Empty Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C to interrupt after transmitting a byte onto the I2C bus.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ALDIE</name>
              <description>
              Arbitration Loss Detected Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C to interrupt upon losing arbitration while in master mode.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SSDIE</name>
              <description>
              Slave Stop Detected Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C to interrupt when it detects a Stop condition while in slave mode.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SR</name>
          <displayName>SR</displayName>
          <description>Status register</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>UF</name>
              <description>
              FIFO Underflow Flag. Asserted when FIFO is empty and a POP request generated without a PUSH. Cleared if write 1
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OF</name>
              <description>
              FIFO Overflow Flag. Asserted when FIFO is full and a PUSH request generated without a POP. Cleared if write 1
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMADONE</name>
              <description>
              DMA Transaction Done. Asserted when both APB and I2C bus have finished transfer. Cleared if write 1
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MSD</name>
              <description>
              Master Stop Detected:
              0 = No Master Stop Detected.
              1 = This bit is set by the I2C unit when all of the following are true:
              This bit is enabled (CR[MSDE] = 1);
              I2C unit is configured as a master;
              I2C transmits a STOP signal
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EBB</name>
              <description>
              Early Bus Busy
              0 = I2C bus is idle or the I2C is using the bus (that is, unit busy).
              1 = Set when the unit detects that the SCL or SDA line is low without a START condition. Bit will remain set until the I2C unit detects the bus is idle by detecting a STOP condition. Bit will also be set whenever the IBB bit is set.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BED</name>
              <description>
              Bus Error Detected:
              0 = No error detected.
              1 = The I2C sets this bit when it detects one of the following error conditions:
              As a master transmitter, no ACK was detected on the interface after a byte was sent.
              As a slave receiver, the I2C generates a NACK pulse.
              When an error occurs, I2C bus transactions continue. Software must guarantee that misplaced Start and Stop conditions do not occur. 
              Cleared if write 1
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SAD</name>
              <description>
              Slave Address Detected:
              0 = No slave address was detected.
              1 = The I2C detected a seven-bit address that matches the general call address or SAR. An interrupt is signalled when enabled in the CR. 
              Cleared if write 1
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RF</name>
              <description>
              DBR Receive Full:
              0 = The DBR has not received a new data byte or the I2C is idle.
              1 = The DBR register received a new data byte from the I2C bus. An interrupt is signalled when enabled in the CR. 
              Cleared if write 1
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TE</name>
              <description>
              DBR Transmit Empty:
              0 = The data byte is still being transmitted.
              1 = The I2C has finished transmitting a data byte on the I2C bus. An interrupt is signalled when enabled in the CR.
              Cleared if write 1
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ALD</name>
              <description>
              Arbitration Loss Detected:
              Used during multi-master operation:
              0 = Cleared when arbitration is won or never took place.
              1 = Set when the I2C loses arbitration. 
              Cleared if write 1
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SSD</name>
              <description>
              Slave Stop Detected:
              0 = No Stop detected.
              1 = Set when the I2C detects a Stop while in slave-receive or slave-transmit mode. 
              Cleared if write 1
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IBB</name>
              <description>
              I2C Bus Busy:
              0 = I2C bus is idle or the I2C is using the bus (that is, unit busy).
              1 = Set when the I2C bus is busy but local I2C is not involved in the transaction.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UB</name>
              <description>
              Unit Busy:
              0 = I2C not busy.
              1 = Set when local I2C is busy. This is defined as the time between the first Start and Stop. 
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>NACK</name>
              <description>
              ACK/NACK Status:
              0 = The I2C received or sent an ACK on the bus. 
              1 = The I2C received or sent a NACK.on the bus.
              This bit is used in slave-transmit mode to determine when the byte transferred is the last one. This bit is updated after each byte and ACK/NACK information is received.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RWM</name>
              <description>
              Read/write Mode:
              0 = The I2C is in master-transmit or slave-receive mode. 
              1 = The I2C is in master-receive or slave-transmit mode. 
              This is the R/nW bit of the slave address. It is cleared automatically by hardware after a Stop state.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DBR</name>
          <displayName>DBR</displayName>
          <description>Data Buffer register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>DATA</name>
              <description>
              use the I2C Data Buffer register to transmit and receive data from the I2C bus. The DBR is accessed by software on one Side and by the I2C Shift register on the other. The DBR receives data coming into the I2C unit after a full byte is received and acknowledged. CPU writes data going out of the I2C to the DBR and sends it to the serial bus. 
              When the I2C is in transmit mode (master or slave), CPU writes data to the DBR over the internal bus. CPU write data to the DBR when a master transaction is initiated or when the DBR transmit-empty interrupt is signalled. Data moves from the DBR to the Shift register when the transfer byte bit is set. The DBR transmit-empty interrupt is signalled (if enabled) when a byte is transferred on the I2C bus and the acknowledge cycle is complete. If the DBR is not written, and a Stop condition is not in place before the I2C bus is ready to transfer the next byte packet, the I2C unit inserts wait states until CPU writes the DBR and sets the transfer byte bit.
              When the I2C is in receive mode (master or slave), CPU reads DBR data over the internal bus. CPU reads data from the DBR when the DBR receive-full interrupt is signalled. The data moves from the Shift register to the DBR when the acknowledge cycle is complete. The I2C inserts wait states until the DBR is read. After the software reads the DBR, CR[NACK] are written by the software, allowing the next byte transfer to proceed to the I2C bus.
              In DMA mode, DBR is automatically filled from FIFO in master transmit mode, or fetched and stored in FIFO in master receive mode until DMA done or aborted.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SAR</name>
          <displayName>SAR</displayName>
          <description>Slave Address Register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000047</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>25</bitWidth>
            </field>
            <field>
              <name>ADDR</name>
              <description>
              The seven-bit address to which the I2C responds when in slave-receive mode
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>LCR</name>
          <displayName>LCR</displayName>
          <description>Load Count Register</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x081C72ED</resetValue>
          <fields>
            <field>
              <name>HLVH</name>
              <description>
              Decrementer Load value for High Speed Mode SCL (master mode) for high phase. 
              Thigh=Tfclk*(HLVH+4+DNF)
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>HLVL</name>
              <description>
              Decrementer Load value for High Speed Mode SCL (master mode) for low phase. 
              Tlow=Tfclk*(HLVL+3+DNF). Data rate is generated as 1/(Thigh+Tlow), or Ffclk/(HLVH+HLVL+7+2*DNF). 
              3.2Mbps data rate is generated by default if fclk is 48MHz.
              HLVL also controls setup time and hold time for START and STOP condition in High Speed Mode(master mode). 
              Thdsta=Tsusta=Tsusto=Tfclk*(HLVL+1)
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
            <field>
              <name>FLV</name>
              <description>
              Decrementer Load value for Fast Mode (or Fast Mode Plus) SCL (master mode) for both high and low phase. 
              Data rate is generated as Ffclk/(FLV+max(FLV,CNT*2+6)+7+DNF) approximately. 
              400kbps data rate is generated by default if fclk is 48MHz.
              FLV also controls setup time and hold time for START and STOP condition in Fast Mode(master mode). 
              Thdsta=Tsusta=Tsusto=Tfclk*FLV
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
            <field>
              <name>SLV</name>
              <description>
              Decrementer Load value for Standard Mode SCL (master mode) for both high and low phase. 
              Data rate is generated as Ffclk/(SLV+max(SLV,CNT*2+6)+7+DNF) approximately. 
              100kbps data rate is generated by default if fclk is 48MHz.
              SLV also controls setup time and hold time for START and STOP condition in Standard Mode(master mode). 
              Thdsta=Tsusta=Tsusto=Tfclk*SLV
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>WCR</name>
          <displayName>WCR</displayName>
          <description>Wait Count Register</description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0000000A</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>CNT</name>
              <description>
              Controls the counter values defining the setup and hold times in standard and fast mode
              Tvddat=Thddat=Tfclk*(CNT+2)
              Tsudat=max(Tlow-Thddat,Thddat)
              Lower counter values may violate setup and hold times.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RCCR</name>
          <displayName>RCCR</displayName>
          <description>Bus Reset Cycle Counter Register</description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000009</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>28</bitWidth>
            </field>
            <field>
              <name>RSTCYC</name>
              <description>
              The cycles of SCL during bus reset
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BMR</name>
          <displayName>BMR</displayName>
          <description>Bus Monitor Register</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000003</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>30</bitWidth>
            </field>
            <field>
              <name>SCL</name>
              <description>
              value of the SCL pin. Software can check bus level when the I2C bus is hung and the I2C unit must be reset.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SDA</name>
              <description>
              value of the SDA pin.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DNR</name>
          <displayName>DNR</displayName>
          <description>DMA number register</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>NDT</name>
              <description>
              Write as number of data to transfer in byte. Read as left data number to transfer
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD1</name>
          <displayName>RSVD1</displayName>
          <description></description>
          <addressOffset>0x2C</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>FIFO</name>
          <displayName>FIFO</displayName>
          <description>FIFO Register</description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>DATA</name>
              <description>
              Write to push send data into FIFO. Read to pop received data from FIFO
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>I2C7</name>
      <description></description>
      <groupName>I2C</groupName>
      <baseAddress>0x5000e000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CR</name>
          <displayName>CR</displayName>
          <description>Control register</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>UR</name>
              <description>
              Unit Reset. Software need first assert to reset then deassert to release.
              0 = No reset.
              1 = Reset I2C module.
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSTREQ</name>
              <description>
              I2C will do bus reset upon this bit set. Will be cleared by HW automatically after RSTCYC cycles of SCL generated.
              1 = request for i2c bus reset
              0 = bus reset finished
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BRGRST</name>
              <description>
              Reset bus related state machine and signals. Will be cleared by HW automatically
              1 = request for reset
              0 = reset finished
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>14</bitWidth>
            </field>
            <field>
              <name>DNF</name>
              <description>
              Digital noise filter
              These bits are used to configure the digital noise filter on SDA and SCL input. The digital filter will filter spikes with a length of up to DNF*Tfclk.
              0: Digital filter disabled 
              1: Digital filter enabled and filtering capability up to 1 Tfclk
              ...
              7: digital filter enabled and filtering capability up to 7 Tfclk
              Digital filter is added to analog filter. Digital filter will introduce delay on SCL and SDA processing, which is essential in hs-mode. 
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>SLVEN</name>
              <description>
              Slave mode Enable for SCL.
              0 = Disable slave mode. Will not monitor slave address on I2C bus.
              1 = Enable slave mode. Will monitor slave address on I2C bus.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SCLPP</name>
              <description>
              Push-pull mode Enable for SCL.
              0 = open drain output for SCL.
              1 = Push-pull output for SCL
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MSDE</name>
              <description>
              Master Stop Detected Enable:
              0 = Master Stop Detect (MSD) status is not enabled.
              1 = Master Stop Detect (MSD) status is enabled.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LASTSTOP</name>
              <description>
              Generate STOP for last DMA transfer
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LASTNACK</name>
              <description>
              Generate NACK for last DMA Read transfer
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMAEN</name>
              <description>
              DMA Enable for both TX and RX
              0 = DMA mode is NOT enabled
              1 = DMA mode enabled
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SCLE</name>
              <description>
              SCL Enable:
              0 = Disables the I2C from driving the SCL line.
              1 = Enables the I2C clock output for master-mode operation.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IUE</name>
              <description>
              I2C Unit Enable:
              0 = Disables the unit and does not master any transactions or respond to any slave transactions.
              1 = Enables the I2C (defaults to slave-receive mode).
              Software must guarantee the I2C bus is idle before setting this bit.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MODE</name>
              <description>
              Bus Mode (Master operation):
              2'b00: standard-mode
              2'b01: fast-mode and fast-mode plus
              2'b10: HS-mode (standard mode when not doing a high speed transfer)
              2'b11: HS-mode (fast mode when not doing a high speed transfer)
              Bus Mode (Slave operation):
              2'b0x: HS-mode is disabled. I2C unit uses Standard/Fast mode timing on the SDA pin.
              2'b1x: HS-mode is enabled. I2C unit uses HS-mode timing on the SDA pin when a master code is received.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TCR</name>
          <displayName>TCR</displayName>
          <description>Transfer Control register</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>ABORTDMA</name>
              <description>
              Abort DMA operation. Will be cleared by HW automatically
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RXREQ</name>
              <description>
              Request DMA RX. Will be cleared by HW automatically
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TXREQ</name>
              <description>
              Request DMA TX. Will be cleared by HW automatically
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MA</name>
              <description>
              Master Abort:
              Used by the I2C in master mode to generate a Stop without transmitting another data byte:
              0 = The I2C transmits Stop on if TCR[STOP] is set.
              1 = The I2C sends Stop without data transmission.
              When in master-transmit mode, after transmitting a data byte, the TCR[TB] bit is cleared. When no more data bytes need to be sent, setting master abort bit sends the Stop. The TCR[TB] bit must remain clear.
              In master-receive mode, when a NAK is sent without a Stop (TCR[STOP] bit was not set) and CPU does not send a repeated Start, setting this bit sends the Stop. Once again, the TCR[TB] bit must remain clear. Master Abort can be done immediately after the address phase (Master Transmit mode only).
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>NACK</name>
              <description>
              The positive/negative acknowledge control bit, defines the type of acknowledge pulse sent by the I2C when in master receive mode:
              0 = Send a positive acknowledge (ACK) pulse after receiving a data byte.
              1 = Send a negative acknowledge (NACK) pulse after receiving a data byte.
              The I2C automatically sends an ACK pulse when responding to its slave address or when responding in slave-receive mode, regardless of the NACK control-bit setting.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>STOP</name>
              <description>
              Stop:
              Used to initiate a Stop condition after transferring the next data byte on the I2C bus when in master mode. In master-receive mode, the NACK control bit must be set in conjunction with the STOP bit. 
              0 = Do not send a Stop.
              1 = Send a Stop.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>START</name>
              <description>
              Start:
              Used to initiate a Start condition to the I2C unit when in master mode. 
              0 = Do not send a Start pulse.
              1 = Send a Start pulse.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TB</name>
              <description>
              Transfer Byte:
              Used to send or receive a byte on the I2C bus:
              0 = Cleared by I2C when the byte is sent/received.
              1 = Send/receive a byte. 
              CPU can monitor this bit to determine when the byte transfer has completed. In master or slave mode, after each byte transfer including acknowledge pulse, the I2C holds the SCL line low (inserting wait states) until TB is set.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IER</name>
          <displayName>IER</displayName>
          <description>Interrupt Enable register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>UFIE</name>
              <description>
              FIFO Underflow Interrupt Enable
              0 = FIFO Underflow interrupt is not enabled
              1 = FIFO Underflow interrupt is enabled
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OFIE</name>
              <description>
              FIFO Overflow Interrupt Enable
              0 = FIFO Overflow interrupt is not enabled
              1 = FIFO Overflow interrupt is enabled
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMADONEIE</name>
              <description>
              DMA Transaction Done Interrupt Enable
              0 = DMA Transaction done interrupt is not enabled.
              1 = DMA Transaction done interrupt is enabled.
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MSDIE</name>
              <description>
              Master Stop Detected Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C unit to interrupt upon detecting a Master Stop sent by the I2C unit.
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BEDIE</name>
              <description>
              Bus Error Detected Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C to interrupt for the following I2C bus errors:
              As a master transmitter, no ACK was detected after a byte was sent.
              As a slave receiver, the I2C generated a NACK pulse.
              Software is responsible for guaranteeing that misplaced Start and Stop conditions do not occur.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SADIE</name>
              <description>
              Slave Address Detected Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C to interrupt upon detecting a slave address match or a general call address.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RFIE</name>
              <description>
              DBR Receive Full Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C to interrupt when the DBR has received a data byte from the I2C bus.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIE</name>
              <description>
              DBR Transmit Empty Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C to interrupt after transmitting a byte onto the I2C bus.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ALDIE</name>
              <description>
              Arbitration Loss Detected Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C to interrupt upon losing arbitration while in master mode.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SSDIE</name>
              <description>
              Slave Stop Detected Interrupt Enable:
              0 = Disable interrupt.
              1 = Enables the I2C to interrupt when it detects a Stop condition while in slave mode.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SR</name>
          <displayName>SR</displayName>
          <description>Status register</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>UF</name>
              <description>
              FIFO Underflow Flag. Asserted when FIFO is empty and a POP request generated without a PUSH. Cleared if write 1
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OF</name>
              <description>
              FIFO Overflow Flag. Asserted when FIFO is full and a PUSH request generated without a POP. Cleared if write 1
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMADONE</name>
              <description>
              DMA Transaction Done. Asserted when both APB and I2C bus have finished transfer. Cleared if write 1
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MSD</name>
              <description>
              Master Stop Detected:
              0 = No Master Stop Detected.
              1 = This bit is set by the I2C unit when all of the following are true:
              This bit is enabled (CR[MSDE] = 1);
              I2C unit is configured as a master;
              I2C transmits a STOP signal
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EBB</name>
              <description>
              Early Bus Busy
              0 = I2C bus is idle or the I2C is using the bus (that is, unit busy).
              1 = Set when the unit detects that the SCL or SDA line is low without a START condition. Bit will remain set until the I2C unit detects the bus is idle by detecting a STOP condition. Bit will also be set whenever the IBB bit is set.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BED</name>
              <description>
              Bus Error Detected:
              0 = No error detected.
              1 = The I2C sets this bit when it detects one of the following error conditions:
              As a master transmitter, no ACK was detected on the interface after a byte was sent.
              As a slave receiver, the I2C generates a NACK pulse.
              When an error occurs, I2C bus transactions continue. Software must guarantee that misplaced Start and Stop conditions do not occur. 
              Cleared if write 1
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SAD</name>
              <description>
              Slave Address Detected:
              0 = No slave address was detected.
              1 = The I2C detected a seven-bit address that matches the general call address or SAR. An interrupt is signalled when enabled in the CR. 
              Cleared if write 1
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RF</name>
              <description>
              DBR Receive Full:
              0 = The DBR has not received a new data byte or the I2C is idle.
              1 = The DBR register received a new data byte from the I2C bus. An interrupt is signalled when enabled in the CR. 
              Cleared if write 1
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TE</name>
              <description>
              DBR Transmit Empty:
              0 = The data byte is still being transmitted.
              1 = The I2C has finished transmitting a data byte on the I2C bus. An interrupt is signalled when enabled in the CR.
              Cleared if write 1
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ALD</name>
              <description>
              Arbitration Loss Detected:
              Used during multi-master operation:
              0 = Cleared when arbitration is won or never took place.
              1 = Set when the I2C loses arbitration. 
              Cleared if write 1
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SSD</name>
              <description>
              Slave Stop Detected:
              0 = No Stop detected.
              1 = Set when the I2C detects a Stop while in slave-receive or slave-transmit mode. 
              Cleared if write 1
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IBB</name>
              <description>
              I2C Bus Busy:
              0 = I2C bus is idle or the I2C is using the bus (that is, unit busy).
              1 = Set when the I2C bus is busy but local I2C is not involved in the transaction.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UB</name>
              <description>
              Unit Busy:
              0 = I2C not busy.
              1 = Set when local I2C is busy. This is defined as the time between the first Start and Stop. 
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>NACK</name>
              <description>
              ACK/NACK Status:
              0 = The I2C received or sent an ACK on the bus. 
              1 = The I2C received or sent a NACK.on the bus.
              This bit is used in slave-transmit mode to determine when the byte transferred is the last one. This bit is updated after each byte and ACK/NACK information is received.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RWM</name>
              <description>
              Read/write Mode:
              0 = The I2C is in master-transmit or slave-receive mode. 
              1 = The I2C is in master-receive or slave-transmit mode. 
              This is the R/nW bit of the slave address. It is cleared automatically by hardware after a Stop state.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DBR</name>
          <displayName>DBR</displayName>
          <description>Data Buffer register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>DATA</name>
              <description>
              use the I2C Data Buffer register to transmit and receive data from the I2C bus. The DBR is accessed by software on one Side and by the I2C Shift register on the other. The DBR receives data coming into the I2C unit after a full byte is received and acknowledged. CPU writes data going out of the I2C to the DBR and sends it to the serial bus. 
              When the I2C is in transmit mode (master or slave), CPU writes data to the DBR over the internal bus. CPU write data to the DBR when a master transaction is initiated or when the DBR transmit-empty interrupt is signalled. Data moves from the DBR to the Shift register when the transfer byte bit is set. The DBR transmit-empty interrupt is signalled (if enabled) when a byte is transferred on the I2C bus and the acknowledge cycle is complete. If the DBR is not written, and a Stop condition is not in place before the I2C bus is ready to transfer the next byte packet, the I2C unit inserts wait states until CPU writes the DBR and sets the transfer byte bit.
              When the I2C is in receive mode (master or slave), CPU reads DBR data over the internal bus. CPU reads data from the DBR when the DBR receive-full interrupt is signalled. The data moves from the Shift register to the DBR when the acknowledge cycle is complete. The I2C inserts wait states until the DBR is read. After the software reads the DBR, CR[NACK] are written by the software, allowing the next byte transfer to proceed to the I2C bus.
              In DMA mode, DBR is automatically filled from FIFO in master transmit mode, or fetched and stored in FIFO in master receive mode until DMA done or aborted.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SAR</name>
          <displayName>SAR</displayName>
          <description>Slave Address Register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000047</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>25</bitWidth>
            </field>
            <field>
              <name>ADDR</name>
              <description>
              The seven-bit address to which the I2C responds when in slave-receive mode
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>LCR</name>
          <displayName>LCR</displayName>
          <description>Load Count Register</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x081C72ED</resetValue>
          <fields>
            <field>
              <name>HLVH</name>
              <description>
              Decrementer Load value for High Speed Mode SCL (master mode) for high phase. 
              Thigh=Tfclk*(HLVH+4+DNF)
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>HLVL</name>
              <description>
              Decrementer Load value for High Speed Mode SCL (master mode) for low phase. 
              Tlow=Tfclk*(HLVL+3+DNF). Data rate is generated as 1/(Thigh+Tlow), or Ffclk/(HLVH+HLVL+7+2*DNF). 
              3.2Mbps data rate is generated by default if fclk is 48MHz.
              HLVL also controls setup time and hold time for START and STOP condition in High Speed Mode(master mode). 
              Thdsta=Tsusta=Tsusto=Tfclk*(HLVL+1)
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
            <field>
              <name>FLV</name>
              <description>
              Decrementer Load value for Fast Mode (or Fast Mode Plus) SCL (master mode) for both high and low phase. 
              Data rate is generated as Ffclk/(FLV+max(FLV,CNT*2+6)+7+DNF) approximately. 
              400kbps data rate is generated by default if fclk is 48MHz.
              FLV also controls setup time and hold time for START and STOP condition in Fast Mode(master mode). 
              Thdsta=Tsusta=Tsusto=Tfclk*FLV
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
            <field>
              <name>SLV</name>
              <description>
              Decrementer Load value for Standard Mode SCL (master mode) for both high and low phase. 
              Data rate is generated as Ffclk/(SLV+max(SLV,CNT*2+6)+7+DNF) approximately. 
              100kbps data rate is generated by default if fclk is 48MHz.
              SLV also controls setup time and hold time for START and STOP condition in Standard Mode(master mode). 
              Thdsta=Tsusta=Tsusto=Tfclk*SLV
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>WCR</name>
          <displayName>WCR</displayName>
          <description>Wait Count Register</description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0000000A</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>CNT</name>
              <description>
              Controls the counter values defining the setup and hold times in standard and fast mode
              Tvddat=Thddat=Tfclk*(CNT+2)
              Tsudat=max(Tlow-Thddat,Thddat)
              Lower counter values may violate setup and hold times.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RCCR</name>
          <displayName>RCCR</displayName>
          <description>Bus Reset Cycle Counter Register</description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000009</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>28</bitWidth>
            </field>
            <field>
              <name>RSTCYC</name>
              <description>
              The cycles of SCL during bus reset
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BMR</name>
          <displayName>BMR</displayName>
          <description>Bus Monitor Register</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000003</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>30</bitWidth>
            </field>
            <field>
              <name>SCL</name>
              <description>
              value of the SCL pin. Software can check bus level when the I2C bus is hung and the I2C unit must be reset.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SDA</name>
              <description>
              value of the SDA pin.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DNR</name>
          <displayName>DNR</displayName>
          <description>DMA number register</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>NDT</name>
              <description>
              Write as number of data to transfer in byte. Read as left data number to transfer
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD1</name>
          <displayName>RSVD1</displayName>
          <description></description>
          <addressOffset>0x2C</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>FIFO</name>
          <displayName>FIFO</displayName>
          <description>FIFO Register</description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>DATA</name>
              <description>
              Write to push send data into FIFO. Read to pop received data from FIFO
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>LPSYS_CFG</name>
      <description></description>
      <groupName>LPSYS_CFG</groupName>
      <baseAddress>0x5000f000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>SWCR</name>
          <displayName>SWCR</displayName>
          <description>SW Control Register</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>31</bitWidth>
            </field>
            <field>
              <name>SWSEL</name>
              <description>
              0: SWD connected to HCPU
              1: SWD connected to LCPU
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ULPMCR</name>
          <displayName>ULPMCR</displayName>
          <description>ULP Memory Control register</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>FORCE_ON</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ROM_DIS</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
            <field>
              <name>ROM_RME</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>ROM_RM</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RAM_WPULSE</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RAM_WA</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RAM_RA</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RAM_RME</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RAM_RM</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RTC_TR</name>
          <displayName>RTC_TR</displayName>
          <description>Mirrored RTC Time Register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>PM</name>
              <description>
              AM/PM notation
              0: AM
              1: PM
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HT</name>
              <description>
              Hour tens in BCD format
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>HU</name>
              <description>
              Hour units in BCD format
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>MNT</name>
              <description>
              Minute tens in BCD format
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>MNU</name>
              <description>
              Minute units in BCD format
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>ST</name>
              <description>
              Second tens in BCD format
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>SU</name>
              <description>
              Second units in BCD format
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SS</name>
              <description>
              Sub-second counter
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RTC_DR</name>
          <displayName>RTC_DR</displayName>
          <description>Mirrored RTC Date Register</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>ERR</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>CB</name>
              <description>
              Century flag
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>YT</name>
              <description>
              Year tens in BCD format
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>YU</name>
              <description>
              Year units in BCD format
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>WD</name>
              <description>
              Week day units
              000: forbidden
              001: Monday
              ...
              111: Sunday
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>MT</name>
              <description>
              Month tens in BCD format
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MU</name>
              <description>
              Month units in BCD format
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>DT</name>
              <description>
              Date tens in BCD format
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>DU</name>
              <description>
              Date units in BCD format
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>MDBGR</name>
          <displayName>MDBGR</displayName>
          <description>Memory Debug Register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>PD_CACHE</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS_CACHE</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LS_ROM</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LS_CACHE</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LS_DTCM</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LS_ITCM</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LS_RAM2</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LS_RAM1</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LS_RAM0</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DBGR</name>
          <displayName>DBGR</displayName>
          <description>Debug Register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>READY</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HP2LP_NMIF</name>
              <description>
              HP2LP NMI interrupt flag
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HP2LP_NMIE</name>
              <description>
              HP2LP NMI interrupt enable
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LP2HP_NMI</name>
              <description>
              set 1 to send NMI interrupt to HCPU
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CLK_EN</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CLK_SEL</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>BITEN_H</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>BITEN_L</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>SEL_H</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>SEL_L</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD1</name>
          <displayName>RSVD1</displayName>
          <description></description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>SYSCR</name>
          <displayName>SYSCR</displayName>
          <description>System Configure Register</description>
          <addressOffset>0x38</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>SCIO</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>DBG_SWAP</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>WDT2_REBOOT</name>
              <description>
              If set to 1, WDT2 reset will reboot the whole chip
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ANATR</name>
          <displayName>ANATR</displayName>
          <description>Analog Test Register</description>
          <addressOffset>0x3c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>DC_UR_ATEST1</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>DC_TE_ATEST1</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DC_UR_ATEST0</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>DC_TE_ATEST0</name>
              <description>
              reserved for debug
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C5_PINR</name>
          <displayName>I2C5_PINR</displayName>
          <description>I2C5 Pin Register</description>
          <addressOffset>0x40</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>18</bitWidth>
            </field>
            <field>
              <name>SDA_PIN</name>
              <description>
              Connect function pin to selected IO(PB). 
              0 to 31 for PB00 to PB31.
              Other values for floating.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>SCL_PIN</name>
              <description>
              Connect function pin to selected IO(PB). 
              0 to 31 for PB00 to PB31.
              Other values for floating.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C6_PINR</name>
          <displayName>I2C6_PINR</displayName>
          <description>I2C6 Pin Register</description>
          <addressOffset>0x44</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>18</bitWidth>
            </field>
            <field>
              <name>SDA_PIN</name>
              <description>
              Connect function pin to selected IO(PB). 
              0 to 31 for PB00 to PB31.
              Other values for floating.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>SCL_PIN</name>
              <description>
              Connect function pin to selected IO(PB). 
              0 to 31 for PB00 to PB31.
              Other values for floating.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C7_PINR</name>
          <displayName>I2C7_PINR</displayName>
          <description>I2C7 Pin Register</description>
          <addressOffset>0x48</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>18</bitWidth>
            </field>
            <field>
              <name>SDA_PIN</name>
              <description>
              Connect function pin to selected IO(PB). 
              0 to 31 for PB00 to PB31.
              Other values for floating.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>SCL_PIN</name>
              <description>
              Connect function pin to selected IO(PB). 
              0 to 31 for PB00 to PB31.
              Other values for floating.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>USART4_PINR</name>
          <displayName>USART4_PINR</displayName>
          <description>USART4 Pin Register</description>
          <addressOffset>0x4c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>CTS_PIN</name>
              <description>
              Connect function pin to selected IO(PB). 
              0 to 31 for PB00 to PB31.
              Other values for floating.
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RTS_PIN</name>
              <description>
              Connect function pin to selected IO(PB). 
              0 to 31 for PB00 to PB31.
              Other values for floating.
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RXD_PIN</name>
              <description>
              Connect function pin to selected IO(PB). 
              0 to 31 for PB00 to PB31.
              Other values for floating.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>TXD_PIN</name>
              <description>
              Connect function pin to selected IO(PB). 
              0 to 31 for PB00 to PB31.
              Other values for floating.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>USART5_PINR</name>
          <displayName>USART5_PINR</displayName>
          <description>USART5 Pin Register</description>
          <addressOffset>0x50</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>CTS_PIN</name>
              <description>
              Connect function pin to selected IO(PB). 
              0 to 31 for PB00 to PB31.
              Other values for floating.
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RTS_PIN</name>
              <description>
              Connect function pin to selected IO(PB). 
              0 to 31 for PB00 to PB31.
              Other values for floating.
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RXD_PIN</name>
              <description>
              Connect function pin to selected IO(PB). 
              0 to 31 for PB00 to PB31.
              Other values for floating.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>TXD_PIN</name>
              <description>
              Connect function pin to selected IO(PB). 
              0 to 31 for PB00 to PB31.
              Other values for floating.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>USART6_PINR</name>
          <displayName>USART6_PINR</displayName>
          <description>USART6 Pin Register</description>
          <addressOffset>0x54</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>CTS_PIN</name>
              <description>
              Connect function pin to selected IO(PB). 
              0 to 31 for PB00 to PB31.
              Other values for floating.
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RTS_PIN</name>
              <description>
              Connect function pin to selected IO(PB). 
              0 to 31 for PB00 to PB31.
              Other values for floating.
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RXD_PIN</name>
              <description>
              Connect function pin to selected IO(PB). 
              0 to 31 for PB00 to PB31.
              Other values for floating.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>TXD_PIN</name>
              <description>
              Connect function pin to selected IO(PB). 
              0 to 31 for PB00 to PB31.
              Other values for floating.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>GPTIM3_PINR</name>
          <displayName>GPTIM3_PINR</displayName>
          <description>GPTIM3 Pin Register</description>
          <addressOffset>0x58</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>CH4_PIN</name>
              <description>
              Connect function pin to selected IO(PB). 
              0 to 31 for PB00 to PB31.
              Other values for floating.
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>CH3_PIN</name>
              <description>
              Connect function pin to selected IO(PB). 
              0 to 31 for PB00 to PB31.
              Other values for floating.
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>CH2_PIN</name>
              <description>
              Connect function pin to selected IO(PB). 
              0 to 31 for PB00 to PB31.
              Other values for floating.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>CH1_PIN</name>
              <description>
              Connect function pin to selected IO(PB). 
              0 to 31 for PB00 to PB31.
              Other values for floating.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>GPTIM4_PINR</name>
          <displayName>GPTIM4_PINR</displayName>
          <description>GPTIM4 Pin Register</description>
          <addressOffset>0x5c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>CH4_PIN</name>
              <description>
              Connect function pin to selected IO(PB). 
              0 to 31 for PB00 to PB31.
              Other values for floating.
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>CH3_PIN</name>
              <description>
              Connect function pin to selected IO(PB). 
              0 to 31 for PB00 to PB31.
              Other values for floating.
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>CH2_PIN</name>
              <description>
              Connect function pin to selected IO(PB). 
              0 to 31 for PB00 to PB31.
              Other values for floating.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>CH1_PIN</name>
              <description>
              Connect function pin to selected IO(PB). 
              0 to 31 for PB00 to PB31.
              Other values for floating.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>GPTIM5_PINR</name>
          <displayName>GPTIM5_PINR</displayName>
          <description>GPTIM5 Pin Register</description>
          <addressOffset>0x60</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>CH4_PIN</name>
              <description>
              Connect function pin to selected IO(PB). 
              0 to 31 for PB00 to PB31.
              Other values for floating.
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>CH3_PIN</name>
              <description>
              Connect function pin to selected IO(PB). 
              0 to 31 for PB00 to PB31.
              Other values for floating.
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>CH2_PIN</name>
              <description>
              Connect function pin to selected IO(PB). 
              0 to 31 for PB00 to PB31.
              Other values for floating.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>CH1_PIN</name>
              <description>
              Connect function pin to selected IO(PB). 
              0 to 31 for PB00 to PB31.
              Other values for floating.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ETR_PINR</name>
          <displayName>ETR_PINR</displayName>
          <description>ETR Pin Register</description>
          <addressOffset>0x64</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
            <field>
              <name>ETR5_PIN</name>
              <description>
              Connect GPTIM5_ETR to selected IO(PB). 
              0 to 31 for PB00 to PB31.
              Other values for floating.
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>ETR4_PIN</name>
              <description>
              Connect GPTIM4_ETR to selected IO(PB). 
              0 to 31 for PB00 to PB31.
              Other values for floating.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>ETR3_PIN</name>
              <description>
              Connect GPTIM3_ETR to selected IO(PB). 
              0 to 31 for PB00 to PB31.
              Other values for floating.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>LPTIM3_PINR</name>
          <displayName>LPTIM3_PINR</displayName>
          <description>LPTIM3 Pin Register</description>
          <addressOffset>0x68</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
            <field>
              <name>ETR_PIN</name>
              <description>
              Connect function pin to selected IO(PB). 
              0 to 31 for PB00 to PB31.
              Other values for floating.
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>OUT_PIN</name>
              <description>
              Connect function pin to selected IO(PB). 
              0 to 31 for PB00 to PB31.
              Other values for floating.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>IN_PIN</name>
              <description>
              Connect function pin to selected IO(PB). 
              0 to 31 for PB00 to PB31.
              Other values for floating.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>GPTIM3</name>
      <description></description>
      <groupName>GPTIM</groupName>
      <baseAddress>0x50010000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CR1</name>
          <displayName>CR1</displayName>
          <description>TIM control register 1</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>UIFREMAP</name>
              <description>
              UIF status bit remapping
              0: No remapping. UIF status bit is not copied to CNT register bit 31
              1: Remapping enabled. UIF status bit is copied to CNT register bit 31
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>ARPE</name>
              <description>
              Auto-reload preload enable
              0: ARR register is not buffered
              1: ARR register is buffered
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CMS</name>
              <description>
              Center-aligned mode selection
              00: Edge-aligned mode. The counter counts up or down depending on the direction bit (DIR).
              01: Center-aligned mode 1. The counter counts up and down alternatively. Output compare interrupt flags of channels configured in output (CCxS=00 in CCMRx register) are set only when the counter is counting down.
              10: Center-aligned mode 2. The counter counts up and down alternatively. Output compare interrupt flags of channels configured in output (CCxS=00 in CCMRx register) are set only when the counter is counting up.
              11: Center-aligned mode 3. The counter counts up and down alternatively. Output compare interrupt flags of channels configured in output (CCxS=00 in CCMRx register) are set both when the counter is counting up or down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>DIR</name>
              <description>
              Direction
              0: Counter used as upcounter
              1: Counter used as downcounter
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OPM</name>
              <description>
              One-pulse mode
              0: Counter is not stopped at update event
              1: Counter stops counting at the next update event (clearing the bit CEN)
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>URS</name>
              <description>
              Update request source
              This bit is set and cleared by software to select the UEV event sources.
              0: Any of the following events generate an update interrupt or DMA request if enabled. 
              These events can be: 
                 Counter overflow/underflow
                 Setting the UG bit
                 Update generation through the slave mode controller
              1: Only counter overflow/underflow generates an update interrupt or DMA request if enabled.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UDIS</name>
              <description>
              Update disable
              This bit is set and cleared by software to enable/disable UEV event generation.
              0: UEV enabled. The Update (UEV) event is generated by one of the following events:
                 Counter overflow/underflow
                 Setting the UG bit
                 Update generation through the slave mode controller
              Buffered registers are then loaded with their preload values.
              1: UEV disabled. The Update event is not generated, shadow registers keep their value (ARR, PSC, CCRx). However the counter and the prescaler are reinitialized if the UG bit is set or if a hardware reset is received from the slave mode controller.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CEN</name>
              <description>
              Counter enable
              0: Counter disabled
              1: Counter enabled
              Note: External clock, gated mode and encoder mode can work only if the CEN bit has been previously set by software. However trigger mode can set the CEN bit automatically by hardware. 
              CEN is cleared automatically in one-pulse mode, when an update event occurs.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CR2</name>
          <displayName>CR2</displayName>
          <description>TIM control register 2</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>TI1S</name>
              <description>
              TI1 selection
              0: The CH1 pin is connected to TI1 input
              1: The CH1, CH2 and CH3 pins are connected to the TI1 input (XOR combination) 
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MMS</name>
              <description>
              Master mode selection
              These bits allow to select the information to be sent in master mode to slave timers for synchronization (TRGO). The combination is as follows:
              000: Reset - the UG bit from the EGR register is used as trigger output (TRGO). If the reset is generated by the trigger input (slave mode controller configured in reset mode) then the signal on TRGO is delayed compared to the actual reset.
              001: Enable - the Counter enable signal is used as trigger output (TRGO). It is useful to start several timers at the same time or to control a window in which a slave timer is enabled. The Counter Enable signal is generated by a logic OR between CEN control bit and the trigger input when configured in gated mode. 
              When the Counter Enable signal is controlled by the trigger input, there is a delay on TRGO, except if the master/slave mode is selected.
              010: Update - The update event is selected as trigger output (TRGO). For instance a master timer can then be used as a prescaler for a slave timer.
              011: Compare Pulse - The trigger output send a positive pulse when the CC1IF flag is to be set (even if it was already high), as soon as a capture or a compare match occurred. (TRGO)
              100: Compare - OC1REF signal is used as trigger output (TRGO)
              101: Compare - OC2REF signal is used as trigger output (TRGO)
              110: Compare - OC3REF signal is used as trigger output (TRGO)
              111: Compare - OC4REF signal is used as trigger output (TRGO)
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>CCDS</name>
              <description>
              Capture/compare DMA selection
              0: CCx DMA request sent when CCx event occurs
              1: CCx DMA requests sent when update event occurs
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SMCR</name>
          <displayName>SMCR</displayName>
          <description>TIM slave mode control register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
            <field>
              <name>SMS</name>
              <description>
              Slave mode selection
              When external signals are selected the active edge of the trigger signal (TRGI) is linked to the polarity selected on the external input.
              0000: Slave mode disabled.
              0001: Encoder mode 1 - Counter counts up/down on TI1FP1 edge depending on TI2FP2 level.
              0010: Encoder mode 2 - Counter counts up/down on TI2FP2 edge depending on TI1FP1 level.
              0011: Encoder mode 3 - Counter counts up/down on both TI1FP1 and TI2FP2 edges depending on the level of the other input.
              0100: Reset Mode - Rising edge of the selected trigger input (TRGI) reinitializes the counter and generates an update of the registers.
              0101: Gated Mode - The counter clock is enabled when the trigger input (TRGI) is high. The counter stops (but is not reset) as soon as the trigger becomes low. Both start and stop of the counter are controlled.
              0110: Trigger Mode - The counter starts at a rising edge of the trigger TRGI (but it is not reset). Only the start of the counter is controlled.
              0111: External Clock Mode 1 - Rising edges of the selected trigger (TRGI) clock the counter.
              1000: Combined reset + trigger mode - Rising edge of the selected trigger input (TRGI) reinitializes the counter, generates an update of the registers and starts the counter.
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>ETP</name>
              <description>
              External trigger polarity
              0: ETR is non-inverted, active at high level or rising edge
              1: ETR is inverted, active at low level or falling edge
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ECE</name>
              <description>
              External clock enable
              This bit enables External clock mode 2.
              0: External clock mode 2 disabled
              1: External clock mode 2 enabled. The counter is clocked by any active edge on the ETRF signal.
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ETPS</name>
              <description>
              External trigger prescaler
              External trigger signal ETRP frequency must be at most 1/4 of CK_INT frequency. A prescaler can be enabled to reduce ETRP frequency. It is useful when inputting fast external clocks.
              00: Prescaler OFF
              01: ETRP frequency divided by 2
              10: ETRP frequency divided by 4
              11: ETRP frequency divided by 8
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>ETF</name>
              <description>
              External trigger filter
              This bit-field then defines the frequency used to sample ETRP signal and the length of the digital filter applied to ETRP. The digital filter is made of an event counter in which N 
              consecutive events are needed to validate a transition on the output:
              0000: No filter
              0001:   fSAMPLING=fCLK, N=2
              0010:   fSAMPLING=fCLK, N=4
              0011:   fSAMPLING=fCLK, N=8
              0100:   fSAMPLING=fCLK/2, N=6
              0101:   fSAMPLING=fCLK/2, N=8
              0110:   fSAMPLING=fCLK/4, N=6
              0111:   fSAMPLING=fCLK/4, N=8
              1000:   fSAMPLING=fCLK/8, N=6
              1001:   fSAMPLING=fCLK/8, N=8
              1010:   fSAMPLING=fCLK/16, N=5
              1011:   fSAMPLING=fCLK/16, N=6
              1100:   fSAMPLING=fCLK/16, N=8
              1101:   fSAMPLING=fCLK/32, N=5
              1110:   fSAMPLING=fCLK/32, N=6
              1111:   fSAMPLING=fCLK/32, N=8
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>MSM</name>
              <description>
              Master/Slave mode
              0: No action
              1: The effect of an event on the trigger input (TRGI) is delayed to allow a perfect synchronization between the current timer and its slaves (through TRGO). It is useful if we want to synchronize several timers on a single external event.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TS</name>
              <description>
              Trigger selection
              This bit-field selects the trigger input to be used to synchronize the counter.
              000: Internal Trigger 0 (ITR0)
              001: Internal Trigger 1 (ITR1) 
              010: Internal Trigger 2 (ITR2)
              011: Internal Trigger 3 (ITR3)
              100: TI1 Edge Detector (TI1F_ED)
              101: Filtered Timer Input 1 (TI1FP1)
              110: Filtered Timer Input 2 (TI2FP2)
              111: External Trigger input (ETRF)
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DIER</name>
          <displayName>DIER</displayName>
          <description>TIM DMA/Interrupt enable register</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
            <field>
              <name>TDE</name>
              <description>
              Trigger DMA request enable
              0: Trigger DMA request disabled.
              1: Trigger DMA request enabled.
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC4DE</name>
              <description>
              Capture/Compare 4 DMA request enable
              0: CC4 DMA request disabled.
              1: CC4 DMA request enabled
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC3DE</name>
              <description>
              Capture/Compare 3 DMA request enable
              0: CC3 DMA request disabled.
              1: CC3 DMA request enabled.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC2DE</name>
              <description>
              Capture/Compare 2 DMA request enable
              0: CC2 DMA request disabled.
              1: CC2 DMA request enabled.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC1DE</name>
              <description>
              Capture/Compare 1 DMA request enable
              0: CC1 DMA request disabled.
              1: CC1 DMA request enabled.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UDE</name>
              <description>
              Update DMA request enable
              0: Update DMA request disabled.
              1: Update DMA request enabled
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TIE</name>
              <description>
              Trigger interrupt enable
              0: Trigger interrupt disabled.
              1: Trigger interrupt enabled
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC4IE</name>
              <description>
              Capture/Compare 4 interrupt enable
              0: CC4 interrupt disabled.
              1: CC4 interrupt enabled
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC3IE</name>
              <description>
              Capture/Compare 3 interrupt enable
              0: CC3 interrupt disabled.
              1: CC3 interrupt enabled
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC2IE</name>
              <description>
              Capture/Compare 2 interrupt enable
              0: CC2 interrupt disabled.
              1: CC2 interrupt enabled.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC1IE</name>
              <description>
              Capture/Compare 1 interrupt enable
              0: CC1 interrupt disabled.
              1: CC1 interrupt enabled
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UIE</name>
              <description>
              Update interrupt enable
              0: Update interrupt disabled.
              1: Update interrupt enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SR</name>
          <displayName>SR</displayName>
          <description>TIM status register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>19</bitWidth>
            </field>
            <field>
              <name>CC4OF</name>
              <description>
              Capture/Compare 4 overcapture flag
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC3OF</name>
              <description>
              Capture/Compare 3 overcapture flag
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC2OF</name>
              <description>
              Capture/Compare 2 overcapture flag
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC1OF</name>
              <description>
              Capture/Compare 1 overcapture flag
              This flag is set by hardware only when the corresponding channel is configured in input capture mode. It is cleared by software by writing it to '0'.
              0: No overcapture has been detected.
              1: The counter value has been captured in CCR1 register while CC1IF flag was already set
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>TIF</name>
              <description>
              Trigger interrupt flag
              This flag is set by hardware on trigger event (active edge detected on TRGI input when the slave mode controller is enabled in all modes but gated mode). It is set when the counter starts or stops when gated mode is selected. It is cleared by software.
              0: No trigger event occurred.
              1: Trigger interrupt pending.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC4IF</name>
              <description>
              Capture/Compare 4 interrupt flag
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC3IF</name>
              <description>
              Capture/Compare 3 interrupt flag
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC2IF</name>
              <description>
              Capture/Compare 2 interrupt flag
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC1IF</name>
              <description>
              Capture/Compare 1 interrupt flag
              If channel CC1 is configured as output: This flag is set by hardware when the counter matches the compare value. It is cleared by software.
              0: No match.
              1: The content of the counter CNT has matched the content of the CCR1 register.
              If channel CC1 is configured as input: This bit is set by hardware on a capture. It is cleared by software or by reading the CCR1 register.
              0: No input capture occurred.
              1: The counter value has been captured in CCR1 register (An edge has been detected on IC1 which matches the selected polarity).
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UIF</name>
              <description>
              Update interrupt flag
              This bit is set by hardware on an update event. It is cleared by software.
              0: No update occurred
              1: Update interrupt pending. This bit is set by hardware when the registers are updated:
              At overflow or underflow and if UDIS=0 in the CR1 register.
              When CNT is reinitialized by software using the UG bit in EGR register, if URS=0 and UDIS=0 in the CR1 register.
              When CNT is reinitialized by a trigger event, if URS=0 and UDIS=0 in the CR1 register.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>EGR</name>
          <displayName>EGR</displayName>
          <description>Event generation register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>25</bitWidth>
            </field>
            <field>
              <name>TG</name>
              <description>
              Trigger generation
              This bit is set by software in order to generate an event, it is automatically cleared by hardware.
              0: No action
              1: The TIF flag is set in SR register. Related interrupt or DMA transfer can occur if enabled.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC4G</name>
              <description>
              Capture/compare 4 generation
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC3G</name>
              <description>
              Capture/compare 3 generation
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC2G</name>
              <description>
              Capture/compare 2 generation
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC1G</name>
              <description>
              Capture/compare 1 generation
              This bit is set by software in order to generate an event, it is automatically cleared by hardware.
              0: No action
              1: A capture/compare event is generated on channel 1:
              If channel CC1 is configured as output:
              CC1IF flag is set, Corresponding interrupt or DMA request is sent if enabled.
              If channel CC1 is configured as input:
              The current value of the counter is captured in CCR1 register. The CC1IF flag is set, the corresponding interrupt or DMA request is sent if enabled. The CC1OF flag is set if the CC1IF flag was already high.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UG</name>
              <description>
              Update generation
              This bit can be set by software, it is automatically cleared by hardware.
              0: No action
              1: Re-initialize the counter and generates an update of the registers. Note that the prescaler counter is cleared too (anyway the prescaler ratio is not affected). The counter is cleared if the center-aligned mode is selected or if DIR=0 (upcounting), else it takes the auto-reload value (ARR) if DIR=1 (downcounting).
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCMR1</name>
          <displayName>CCMR1</displayName>
          <description>TIM capture/compare mode register 1</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>OC2M</name>
              <description>
              Output compare 2 mode
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>OC2PE</name>
              <description>
              Output compare 2 preload enable
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>OC2CE</name>
              <description>
              Output compare 2 clear enable
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OC1M</name>
              <description>
              Output compare 1 mode
              These bits define the behavior of the output reference signal OC1REF from which OC1 and OC1N are derived. OC1REF is active high whereas OC1 and OC1N active level depends on CC1P and CC1NP bits.
              0000: Frozen - The comparison between the output compare register CCR1 and the counter CNT has no effect on the outputs.(this mode is used to generate a timing base).
              0001: Set channel 1 to active level on match. OC1REF signal is forced high when the counter CNT matches the capture/compare register 1 (CCR1).
              0010: Set channel 1 to inactive level on match. OC1REF signal is forced low when the counter CNT matches the capture/compare register 1 (CCR1).
              0011: Toggle - OC1REF toggles when CNT=CCR1.
              0100: Force inactive level - OC1REF is forced low.
              0101: Force active level - OC1REF is forced high.
              0110: PWM mode 1 - In upcounting, channel 1 is active as long as CNTltCCR1 else inactive. In downcounting, channel 1 is inactive (OC1REF='0) as long as CNT>CCR1 else active (OC1REF=1).
              0111: PWM mode 2 - In upcounting, channel 1 is inactive as long as CNTltCCR1 else active. In downcounting, channel 1 is active as long as CNT>CCR1 else inactive.
              1000: Retriggerable OPM mode 1 - In up-counting mode, the channel is active until a trigger event is detected (on TRGI signal). Then, a comparison is performed as in PWM mode 1 and the channels becomes inactive again at the next update. In down-counting mode, the channel is inactive until a trigger event is detected (on TRGI signal). Then, a comparison is performed as in PWM mode 1 and the channels becomes inactive again at the next update.
              1001: Retriggerable OPM mode 2 - In up-counting mode, the channel is inactive until a trigger event is detected (on TRGI signal). Then, a comparison is performed as in PWM mode 2 and the channels becomes inactive again at the next update. In down-counting mode, the channel is active until a trigger event is detected (on TRGI signal). Then, a comparison is performed as in PWM mode 1 and the channels becomes active again at the next update.
              1010: Reserved,
              1011: Reserved,
              1100: Combined PWM mode 1 - OC1REF has the same behavior as in PWM mode 1. OC1REFC is the logical OR between OC1REF and OC2REF.
              1101: Combined PWM mode 2 - OC1REF has the same behavior as in PWM mode 2. OC1REFC is the logical AND between OC1REF and OC2REF.
              1110: Asymmetric PWM mode 1 - OC1REF has the same behavior as in PWM mode 1. OC1REFC outputs OC1REF when the counter is counting up, OC2REF when it is counting down.
              1111: Asymmetric PWM mode 2 - OC1REF has the same behavior as in PWM mode 2. OC1REFC outputs OC1REF when the counter is counting up, OC2REF when it is counting down.
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>OC1PE</name>
              <description>
              Output compare 1 preload enable
              0: Preload register on CCR1 disabled. CCR1 can be written at anytime, the new value is taken in account immediately.
              1: Preload register on CCR1 enabled. Read/Write operations access the preload register. CCR1 preload value is loaded in the active register at each update event.
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>OC1CE</name>
              <description>
              Output compare 1 clear enable
              0: OC1Ref is not affected by the ETRF input
              1: OC1Ref is cleared as soon as a High level is detected on ETRF input
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IC2F</name>
              <description>
              Input capture 2 filter
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>IC2PSC</name>
              <description>
              Input capture 2 prescaler
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>CC2S</name>
              <description>
              Capture/Compare 2 selection
              This bit-field defines the direction of the channel (input/output) as well as the used input. 
              00: CC2 channel is configured as output
              01: CC2 channel is configured as input, IC2 is mapped on TI2
              10: CC2 channel is configured as input, IC2 is mapped on TI1
              11: CC2 channel is configured as input, IC2 is mapped on TRC. This mode is working only if an internal trigger input is selected through the TS bit (SMCR register)
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>IC1F</name>
              <description>
              Input capture 1 filter
              This bit-field defines the frequency used to sample TI1 input and the length of the digital filter applied to TI1. The digital filter is made of an event counter in which N consecutive events are needed to validate a transition on the output:
              0000: No filter, sampling is done at fCLK
              0001: fSAMPLING=fCLK, N=2
              0010: fSAMPLING=fCLK, N=4
              0011: fSAMPLING=fCLK, N=8
              0100: fSAMPLING=fCLK/2, N=6
              0101: fSAMPLING=fCLK/2, N=8
              0110: fSAMPLING=fCLK/4, N=6
              0111: fSAMPLING=fCLK/4, N=8
              1000: fSAMPLING=fCLK/8, N=6
              1001: fSAMPLING=fCLK/8, N=8
              1010: fSAMPLING=fCLK/16, N=5
              1011: fSAMPLING=fCLK/16, N=6
              1100: fSAMPLING=fCLK/16, N=8
              1101: fSAMPLING=fCLK/32, N=5
              1110: fSAMPLING=fCLK/32, N=6
              1111: fSAMPLING=fCLK/32, N=8
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>IC1PSC</name>
              <description>
              Input capture 1 prescaler
              This bit-field defines the ratio of the prescaler acting on CC1 input (IC1). The prescaler is reset as soon as CC1E=0.
              00: no prescaler, capture is done each time an edge is detected on the capture input
              01: capture is done once every 2 events
              10: capture is done once every 4 events
              11: capture is done once every 8 events
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>CC1S</name>
              <description>
              Capture/Compare 1 selection
              This bit-field defines the direction of the channel (input/output) as well as the used input. 
              00: CC1 channel is configured as output
              01: CC1 channel is configured as input, IC1 is mapped on TI1
              10: CC1 channel is configured as input, IC1 is mapped on TI2
              11: CC1 channel is configured as input, IC1 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (SMCR register)
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCMR2</name>
          <displayName>CCMR2</displayName>
          <description>TIM capture/compare mode register 2</description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>OC4M</name>
              <description>
              Output compare 4 mode
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>OC4PE</name>
              <description>
              Output compare 4 preload enable
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>OC4CE</name>
              <description>
              Output compare 4 clear enable
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OC3M</name>
              <description>
              Output compare 3 mode
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>OC3PE</name>
              <description>
              Output compare 3 preload enable
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>OC3CE</name>
              <description>
              Output compare 3 clear enable
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IC4F</name>
              <description>
              Input capture 4 filter
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>IC4PSC</name>
              <description>
              Input capture 4 prescaler
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>CC4S</name>
              <description>
              Capture/Compare 4 selection
              This bit-field defines the direction of the channel (input/output) as well as the used input. 
              00: CC4 channel is configured as output
              01: CC4 channel is configured as input, IC4 is mapped on TI4
              10: CC4 channel is configured as input, IC4 is mapped on TI3
              11: CC4 channel is configured as input, IC4 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (SMCR register)
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>IC3F</name>
              <description>
              Input capture 3 filter
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>IC3PSC</name>
              <description>
              Input capture 3 prescaler
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>CC3S</name>
              <description>
              Capture/Compare 3 selection
              This bit-field defines the direction of the channel (input/output) as well as the used input. 
              00: CC3 channel is configured as output
              01: CC3 channel is configured as input, IC3 is mapped on TI3
              10: CC3 channel is configured as input, IC3 is mapped on TI4
              11: CC3 channel is configured as input, IC3 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (SMCR register)
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCER</name>
          <displayName>CCER</displayName>
          <description>Capture/Compare enable register</description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>CC4NP</name>
              <description>
              Capture/Compare 4 output Polarity.
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC4P</name>
              <description>
              Capture/Compare 4 output Polarity.
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC4E</name>
              <description>
              Capture/Compare 4 output enable.
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC3NP</name>
              <description>
              Capture/Compare 3 output Polarity.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC3P</name>
              <description>
              Capture/Compare 3 output Polarity.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC3E</name>
              <description>
              Capture/Compare 3 output enable.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC2NP</name>
              <description>
              Capture/Compare 2 output Polarity.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC2P</name>
              <description>
              Capture/Compare 2 output Polarity.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC2E</name>
              <description>
              Capture/Compare 2 output enable.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC1NP</name>
              <description>
              Capture/Compare 1 output Polarity.
              CC1 channel configured as output: CC1NP must be kept cleared in this case.
              CC1 channel configured as input: This bit is used in conjunction with CC1P to define TI1FP1/TI2FP1 polarity. refer to CC1P description.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD5</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC1P</name>
              <description>
              Capture/Compare 1 output Polarity.
              CC1 channel configured as output:
              0: OC1 active high
              1: OC1 active low
              CC1 channel configured as input: CC1NP/CC1P bits select TI1FP1 and TI2FP1 polarity for trigger or capture operations.
              00: noninverted/rising edge
              Circuit is sensitive to TIxFP1 rising edge (capture, trigger in reset, external clock or trigger mode), TIxFP1 is not inverted (trigger in gated mode, encoder mode).
              01: inverted/falling edge
              Circuit is sensitive to TIxFP1 falling edge (capture, trigger in reset, external clock or trigger mode), TIxFP1 is inverted (trigger in gated mode, encoder mode).
              10: reserved, do not use this configuration.
              11: noninverted/both edges
              Circuit is sensitive to both TIxFP1 rising and falling edges (capture, trigger in reset, external clock or trigger mode), TIxFP1 is not inverted (trigger in gated mode). This configuration must not be used for encoder mode.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC1E</name>
              <description>
              Capture/Compare 1 output enable.
              CC1 channel configured as output:
              0: Off - OC1 is not active
              1: On - OC1 signal is output on the corresponding output pin
              CC1 channel configured as input: This bit determines if a capture of the counter value can actually be done into the input capture/compare register 1 (CCR1) or not.
              0: Capture disabled
              1: Capture enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CNT</name>
          <displayName>CNT</displayName>
          <description>Counter</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>UIFCPY</name>
              <description>
              Value depends on IUFREMAP in CR1.
              If UIFREMAP = 1
              UIFCPY: UIF Copy
              This bit is a read-only copy of the UIF bit of the ISR register
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>15</bitWidth>
            </field>
            <field>
              <name>CNT</name>
              <description>
              counter value
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PSC</name>
          <displayName>PSC</displayName>
          <description>Prescaler</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>PSC</name>
              <description>
              Prescaler value
              The counter clock frequency is equal to fCLK / (PSC[15:0] + 1).
              PSC contains the value to be loaded in the active prescaler register at each update event (including when the counter is cleared through UG bit of EGR register or through trigger controller when configured in 'reset mode').
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ARR</name>
          <displayName>ARR</displayName>
          <description>Auto-reload register</description>
          <addressOffset>0x2c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>ARR</name>
              <description>
              Auto-reload value
              ARR is the value to be loaded in the actual auto-reload register.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RCR</name>
          <displayName>RCR</displayName>
          <description>Repetition counter register</description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>REP</name>
              <description>
              Repetition counter value
              These bits allow the user to set-up the update rate of the compare registers (i.e. periodic transfers from preload to active registers) when preload registers are enable, as well as the update interrupt generation rate, if this interrupt is enable.
              Each time the REP_CNT related downcounter reaches zero, an update event is generated and it restarts counting from REP value. As REP_CNT is reloaded with REP value only at the repetition update event, any write to the RCR register is not taken in account until the next repetition update event.
              It means in PWM mode (REP+1) corresponds to the number of PWM periods in edge-aligned mode.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR1</name>
          <displayName>CCR1</displayName>
          <description>Capture/Compare register 1</description>
          <addressOffset>0x34</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>CCR1</name>
              <description>
              Capture/Compare 1 value
              If channel CC1 is configured as output:
              CCR1 is the value to be loaded in the actual capture/compare 1 register (preload value).It is loaded permanently if the preload feature is not selected in the CCMR1 register (bit OC1PE). Else the preload value is copied in the active capture/compare 1 register when an update event occurs.
              The active capture/compare register contains the value to be compared to the counter CNT and signaled on OC1 output.
              If channel CC1is configured as input:
              CCR1 is the counter value transferred by the last input capture 1 event (IC1). The CCR1 register is read-only and cannot be programmed.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR2</name>
          <displayName>CCR2</displayName>
          <description>Capture/Compare register 2</description>
          <addressOffset>0x38</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>CCR2</name>
              <description>
              Capture/Compare 2 value
              If channel CC2 is configured as output:
              CCR2 is the value to be loaded in the actual capture/compare 2 register (preload value).It is loaded permanently if the preload feature is not selected in the CCMR1 register (bit OC2PE). Else the preload value is copied in the active capture/compare 2 register when an update event occurs.
              The active capture/compare register contains the value to be compared to the counter CNT and signalled on OC2 output.
              If channel CC2 is configured as input:
              CCR2 is the counter value transferred by the last input capture 2 event (IC2). The CCR2 register is read-only and cannot be programmed.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR3</name>
          <displayName>CCR3</displayName>
          <description>Capture/Compare register 3</description>
          <addressOffset>0x3c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>CCR3</name>
              <description>
              Capture/Compare value
              If channel CC3 is configured as output:
              CCR3 is the value to be loaded in the actual capture/compare 3 register (preload value).It is loaded permanently if the preload feature is not selected in the CCMR2 register (bit OC3PE). Else the preload value is copied in the active capture/compare 3 register when an update event occurs.
              The active capture/compare register contains the value to be compared to the counter CNT and signalled on OC3 output.
              If channel CC3is configured as input:
              CCR3 is the counter value transferred by the last input capture 3 event (IC3). The CCR3 register is read-only and cannot be programmed.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR4</name>
          <displayName>CCR4</displayName>
          <description>Capture/Compare register 4</description>
          <addressOffset>0x40</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>CCR4</name>
              <description>
              Capture/Compare value
              1. if CC4 channel is configured as output:
              CCR4 is the value to be loaded in the actual capture/compare 4 register (preload value).It is loaded permanently if the preload feature is not selected in the CCMR2 register (bit OC4PE). Else the preload value is copied in the active capture/compare 4 register when an update event occurs.
              The active capture/compare register contains the value to be compared to the counter CNT and signalled on OC4 output.
              2.  if CC4 channel is configured as input:
              CCR4 is the counter value transferred by the last input capture 4 event (IC4). The CCR4 register is read-only and cannot be programmed.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>GPTIM4</name>
      <description></description>
      <groupName>GPTIM</groupName>
      <baseAddress>0x50011000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CR1</name>
          <displayName>CR1</displayName>
          <description>TIM control register 1</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>UIFREMAP</name>
              <description>
              UIF status bit remapping
              0: No remapping. UIF status bit is not copied to CNT register bit 31
              1: Remapping enabled. UIF status bit is copied to CNT register bit 31
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>ARPE</name>
              <description>
              Auto-reload preload enable
              0: ARR register is not buffered
              1: ARR register is buffered
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CMS</name>
              <description>
              Center-aligned mode selection
              00: Edge-aligned mode. The counter counts up or down depending on the direction bit (DIR).
              01: Center-aligned mode 1. The counter counts up and down alternatively. Output compare interrupt flags of channels configured in output (CCxS=00 in CCMRx register) are set only when the counter is counting down.
              10: Center-aligned mode 2. The counter counts up and down alternatively. Output compare interrupt flags of channels configured in output (CCxS=00 in CCMRx register) are set only when the counter is counting up.
              11: Center-aligned mode 3. The counter counts up and down alternatively. Output compare interrupt flags of channels configured in output (CCxS=00 in CCMRx register) are set both when the counter is counting up or down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>DIR</name>
              <description>
              Direction
              0: Counter used as upcounter
              1: Counter used as downcounter
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OPM</name>
              <description>
              One-pulse mode
              0: Counter is not stopped at update event
              1: Counter stops counting at the next update event (clearing the bit CEN)
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>URS</name>
              <description>
              Update request source
              This bit is set and cleared by software to select the UEV event sources.
              0: Any of the following events generate an update interrupt or DMA request if enabled. 
              These events can be: 
                 Counter overflow/underflow
                 Setting the UG bit
                 Update generation through the slave mode controller
              1: Only counter overflow/underflow generates an update interrupt or DMA request if enabled.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UDIS</name>
              <description>
              Update disable
              This bit is set and cleared by software to enable/disable UEV event generation.
              0: UEV enabled. The Update (UEV) event is generated by one of the following events:
                 Counter overflow/underflow
                 Setting the UG bit
                 Update generation through the slave mode controller
              Buffered registers are then loaded with their preload values.
              1: UEV disabled. The Update event is not generated, shadow registers keep their value (ARR, PSC, CCRx). However the counter and the prescaler are reinitialized if the UG bit is set or if a hardware reset is received from the slave mode controller.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CEN</name>
              <description>
              Counter enable
              0: Counter disabled
              1: Counter enabled
              Note: External clock, gated mode and encoder mode can work only if the CEN bit has been previously set by software. However trigger mode can set the CEN bit automatically by hardware. 
              CEN is cleared automatically in one-pulse mode, when an update event occurs.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CR2</name>
          <displayName>CR2</displayName>
          <description>TIM control register 2</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>TI1S</name>
              <description>
              TI1 selection
              0: The CH1 pin is connected to TI1 input
              1: The CH1, CH2 and CH3 pins are connected to the TI1 input (XOR combination) 
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MMS</name>
              <description>
              Master mode selection
              These bits allow to select the information to be sent in master mode to slave timers for synchronization (TRGO). The combination is as follows:
              000: Reset - the UG bit from the EGR register is used as trigger output (TRGO). If the reset is generated by the trigger input (slave mode controller configured in reset mode) then the signal on TRGO is delayed compared to the actual reset.
              001: Enable - the Counter enable signal is used as trigger output (TRGO). It is useful to start several timers at the same time or to control a window in which a slave timer is enabled. The Counter Enable signal is generated by a logic OR between CEN control bit and the trigger input when configured in gated mode. 
              When the Counter Enable signal is controlled by the trigger input, there is a delay on TRGO, except if the master/slave mode is selected.
              010: Update - The update event is selected as trigger output (TRGO). For instance a master timer can then be used as a prescaler for a slave timer.
              011: Compare Pulse - The trigger output send a positive pulse when the CC1IF flag is to be set (even if it was already high), as soon as a capture or a compare match occurred. (TRGO)
              100: Compare - OC1REF signal is used as trigger output (TRGO)
              101: Compare - OC2REF signal is used as trigger output (TRGO)
              110: Compare - OC3REF signal is used as trigger output (TRGO)
              111: Compare - OC4REF signal is used as trigger output (TRGO)
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>CCDS</name>
              <description>
              Capture/compare DMA selection
              0: CCx DMA request sent when CCx event occurs
              1: CCx DMA requests sent when update event occurs
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SMCR</name>
          <displayName>SMCR</displayName>
          <description>TIM slave mode control register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
            <field>
              <name>SMS</name>
              <description>
              Slave mode selection
              When external signals are selected the active edge of the trigger signal (TRGI) is linked to the polarity selected on the external input.
              0000: Slave mode disabled.
              0001: Encoder mode 1 - Counter counts up/down on TI1FP1 edge depending on TI2FP2 level.
              0010: Encoder mode 2 - Counter counts up/down on TI2FP2 edge depending on TI1FP1 level.
              0011: Encoder mode 3 - Counter counts up/down on both TI1FP1 and TI2FP2 edges depending on the level of the other input.
              0100: Reset Mode - Rising edge of the selected trigger input (TRGI) reinitializes the counter and generates an update of the registers.
              0101: Gated Mode - The counter clock is enabled when the trigger input (TRGI) is high. The counter stops (but is not reset) as soon as the trigger becomes low. Both start and stop of the counter are controlled.
              0110: Trigger Mode - The counter starts at a rising edge of the trigger TRGI (but it is not reset). Only the start of the counter is controlled.
              0111: External Clock Mode 1 - Rising edges of the selected trigger (TRGI) clock the counter.
              1000: Combined reset + trigger mode - Rising edge of the selected trigger input (TRGI) reinitializes the counter, generates an update of the registers and starts the counter.
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>ETP</name>
              <description>
              External trigger polarity
              0: ETR is non-inverted, active at high level or rising edge
              1: ETR is inverted, active at low level or falling edge
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ECE</name>
              <description>
              External clock enable
              This bit enables External clock mode 2.
              0: External clock mode 2 disabled
              1: External clock mode 2 enabled. The counter is clocked by any active edge on the ETRF signal.
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ETPS</name>
              <description>
              External trigger prescaler
              External trigger signal ETRP frequency must be at most 1/4 of CK_INT frequency. A prescaler can be enabled to reduce ETRP frequency. It is useful when inputting fast external clocks.
              00: Prescaler OFF
              01: ETRP frequency divided by 2
              10: ETRP frequency divided by 4
              11: ETRP frequency divided by 8
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>ETF</name>
              <description>
              External trigger filter
              This bit-field then defines the frequency used to sample ETRP signal and the length of the digital filter applied to ETRP. The digital filter is made of an event counter in which N 
              consecutive events are needed to validate a transition on the output:
              0000: No filter
              0001:   fSAMPLING=fCLK, N=2
              0010:   fSAMPLING=fCLK, N=4
              0011:   fSAMPLING=fCLK, N=8
              0100:   fSAMPLING=fCLK/2, N=6
              0101:   fSAMPLING=fCLK/2, N=8
              0110:   fSAMPLING=fCLK/4, N=6
              0111:   fSAMPLING=fCLK/4, N=8
              1000:   fSAMPLING=fCLK/8, N=6
              1001:   fSAMPLING=fCLK/8, N=8
              1010:   fSAMPLING=fCLK/16, N=5
              1011:   fSAMPLING=fCLK/16, N=6
              1100:   fSAMPLING=fCLK/16, N=8
              1101:   fSAMPLING=fCLK/32, N=5
              1110:   fSAMPLING=fCLK/32, N=6
              1111:   fSAMPLING=fCLK/32, N=8
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>MSM</name>
              <description>
              Master/Slave mode
              0: No action
              1: The effect of an event on the trigger input (TRGI) is delayed to allow a perfect synchronization between the current timer and its slaves (through TRGO). It is useful if we want to synchronize several timers on a single external event.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TS</name>
              <description>
              Trigger selection
              This bit-field selects the trigger input to be used to synchronize the counter.
              000: Internal Trigger 0 (ITR0)
              001: Internal Trigger 1 (ITR1) 
              010: Internal Trigger 2 (ITR2)
              011: Internal Trigger 3 (ITR3)
              100: TI1 Edge Detector (TI1F_ED)
              101: Filtered Timer Input 1 (TI1FP1)
              110: Filtered Timer Input 2 (TI2FP2)
              111: External Trigger input (ETRF)
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DIER</name>
          <displayName>DIER</displayName>
          <description>TIM DMA/Interrupt enable register</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
            <field>
              <name>TDE</name>
              <description>
              Trigger DMA request enable
              0: Trigger DMA request disabled.
              1: Trigger DMA request enabled.
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC4DE</name>
              <description>
              Capture/Compare 4 DMA request enable
              0: CC4 DMA request disabled.
              1: CC4 DMA request enabled
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC3DE</name>
              <description>
              Capture/Compare 3 DMA request enable
              0: CC3 DMA request disabled.
              1: CC3 DMA request enabled.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC2DE</name>
              <description>
              Capture/Compare 2 DMA request enable
              0: CC2 DMA request disabled.
              1: CC2 DMA request enabled.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC1DE</name>
              <description>
              Capture/Compare 1 DMA request enable
              0: CC1 DMA request disabled.
              1: CC1 DMA request enabled.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UDE</name>
              <description>
              Update DMA request enable
              0: Update DMA request disabled.
              1: Update DMA request enabled
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TIE</name>
              <description>
              Trigger interrupt enable
              0: Trigger interrupt disabled.
              1: Trigger interrupt enabled
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC4IE</name>
              <description>
              Capture/Compare 4 interrupt enable
              0: CC4 interrupt disabled.
              1: CC4 interrupt enabled
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC3IE</name>
              <description>
              Capture/Compare 3 interrupt enable
              0: CC3 interrupt disabled.
              1: CC3 interrupt enabled
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC2IE</name>
              <description>
              Capture/Compare 2 interrupt enable
              0: CC2 interrupt disabled.
              1: CC2 interrupt enabled.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC1IE</name>
              <description>
              Capture/Compare 1 interrupt enable
              0: CC1 interrupt disabled.
              1: CC1 interrupt enabled
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UIE</name>
              <description>
              Update interrupt enable
              0: Update interrupt disabled.
              1: Update interrupt enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SR</name>
          <displayName>SR</displayName>
          <description>TIM status register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>19</bitWidth>
            </field>
            <field>
              <name>CC4OF</name>
              <description>
              Capture/Compare 4 overcapture flag
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC3OF</name>
              <description>
              Capture/Compare 3 overcapture flag
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC2OF</name>
              <description>
              Capture/Compare 2 overcapture flag
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC1OF</name>
              <description>
              Capture/Compare 1 overcapture flag
              This flag is set by hardware only when the corresponding channel is configured in input capture mode. It is cleared by software by writing it to '0'.
              0: No overcapture has been detected.
              1: The counter value has been captured in CCR1 register while CC1IF flag was already set
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>TIF</name>
              <description>
              Trigger interrupt flag
              This flag is set by hardware on trigger event (active edge detected on TRGI input when the slave mode controller is enabled in all modes but gated mode). It is set when the counter starts or stops when gated mode is selected. It is cleared by software.
              0: No trigger event occurred.
              1: Trigger interrupt pending.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC4IF</name>
              <description>
              Capture/Compare 4 interrupt flag
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC3IF</name>
              <description>
              Capture/Compare 3 interrupt flag
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC2IF</name>
              <description>
              Capture/Compare 2 interrupt flag
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC1IF</name>
              <description>
              Capture/Compare 1 interrupt flag
              If channel CC1 is configured as output: This flag is set by hardware when the counter matches the compare value. It is cleared by software.
              0: No match.
              1: The content of the counter CNT has matched the content of the CCR1 register.
              If channel CC1 is configured as input: This bit is set by hardware on a capture. It is cleared by software or by reading the CCR1 register.
              0: No input capture occurred.
              1: The counter value has been captured in CCR1 register (An edge has been detected on IC1 which matches the selected polarity).
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UIF</name>
              <description>
              Update interrupt flag
              This bit is set by hardware on an update event. It is cleared by software.
              0: No update occurred
              1: Update interrupt pending. This bit is set by hardware when the registers are updated:
              At overflow or underflow and if UDIS=0 in the CR1 register.
              When CNT is reinitialized by software using the UG bit in EGR register, if URS=0 and UDIS=0 in the CR1 register.
              When CNT is reinitialized by a trigger event, if URS=0 and UDIS=0 in the CR1 register.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>EGR</name>
          <displayName>EGR</displayName>
          <description>Event generation register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>25</bitWidth>
            </field>
            <field>
              <name>TG</name>
              <description>
              Trigger generation
              This bit is set by software in order to generate an event, it is automatically cleared by hardware.
              0: No action
              1: The TIF flag is set in SR register. Related interrupt or DMA transfer can occur if enabled.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC4G</name>
              <description>
              Capture/compare 4 generation
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC3G</name>
              <description>
              Capture/compare 3 generation
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC2G</name>
              <description>
              Capture/compare 2 generation
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC1G</name>
              <description>
              Capture/compare 1 generation
              This bit is set by software in order to generate an event, it is automatically cleared by hardware.
              0: No action
              1: A capture/compare event is generated on channel 1:
              If channel CC1 is configured as output:
              CC1IF flag is set, Corresponding interrupt or DMA request is sent if enabled.
              If channel CC1 is configured as input:
              The current value of the counter is captured in CCR1 register. The CC1IF flag is set, the corresponding interrupt or DMA request is sent if enabled. The CC1OF flag is set if the CC1IF flag was already high.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UG</name>
              <description>
              Update generation
              This bit can be set by software, it is automatically cleared by hardware.
              0: No action
              1: Re-initialize the counter and generates an update of the registers. Note that the prescaler counter is cleared too (anyway the prescaler ratio is not affected). The counter is cleared if the center-aligned mode is selected or if DIR=0 (upcounting), else it takes the auto-reload value (ARR) if DIR=1 (downcounting).
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCMR1</name>
          <displayName>CCMR1</displayName>
          <description>TIM capture/compare mode register 1</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>OC2M</name>
              <description>
              Output compare 2 mode
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>OC2PE</name>
              <description>
              Output compare 2 preload enable
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>OC2CE</name>
              <description>
              Output compare 2 clear enable
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OC1M</name>
              <description>
              Output compare 1 mode
              These bits define the behavior of the output reference signal OC1REF from which OC1 and OC1N are derived. OC1REF is active high whereas OC1 and OC1N active level depends on CC1P and CC1NP bits.
              0000: Frozen - The comparison between the output compare register CCR1 and the counter CNT has no effect on the outputs.(this mode is used to generate a timing base).
              0001: Set channel 1 to active level on match. OC1REF signal is forced high when the counter CNT matches the capture/compare register 1 (CCR1).
              0010: Set channel 1 to inactive level on match. OC1REF signal is forced low when the counter CNT matches the capture/compare register 1 (CCR1).
              0011: Toggle - OC1REF toggles when CNT=CCR1.
              0100: Force inactive level - OC1REF is forced low.
              0101: Force active level - OC1REF is forced high.
              0110: PWM mode 1 - In upcounting, channel 1 is active as long as CNTltCCR1 else inactive. In downcounting, channel 1 is inactive (OC1REF='0) as long as CNT>CCR1 else active (OC1REF=1).
              0111: PWM mode 2 - In upcounting, channel 1 is inactive as long as CNTltCCR1 else active. In downcounting, channel 1 is active as long as CNT>CCR1 else inactive.
              1000: Retriggerable OPM mode 1 - In up-counting mode, the channel is active until a trigger event is detected (on TRGI signal). Then, a comparison is performed as in PWM mode 1 and the channels becomes inactive again at the next update. In down-counting mode, the channel is inactive until a trigger event is detected (on TRGI signal). Then, a comparison is performed as in PWM mode 1 and the channels becomes inactive again at the next update.
              1001: Retriggerable OPM mode 2 - In up-counting mode, the channel is inactive until a trigger event is detected (on TRGI signal). Then, a comparison is performed as in PWM mode 2 and the channels becomes inactive again at the next update. In down-counting mode, the channel is active until a trigger event is detected (on TRGI signal). Then, a comparison is performed as in PWM mode 1 and the channels becomes active again at the next update.
              1010: Reserved,
              1011: Reserved,
              1100: Combined PWM mode 1 - OC1REF has the same behavior as in PWM mode 1. OC1REFC is the logical OR between OC1REF and OC2REF.
              1101: Combined PWM mode 2 - OC1REF has the same behavior as in PWM mode 2. OC1REFC is the logical AND between OC1REF and OC2REF.
              1110: Asymmetric PWM mode 1 - OC1REF has the same behavior as in PWM mode 1. OC1REFC outputs OC1REF when the counter is counting up, OC2REF when it is counting down.
              1111: Asymmetric PWM mode 2 - OC1REF has the same behavior as in PWM mode 2. OC1REFC outputs OC1REF when the counter is counting up, OC2REF when it is counting down.
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>OC1PE</name>
              <description>
              Output compare 1 preload enable
              0: Preload register on CCR1 disabled. CCR1 can be written at anytime, the new value is taken in account immediately.
              1: Preload register on CCR1 enabled. Read/Write operations access the preload register. CCR1 preload value is loaded in the active register at each update event.
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>OC1CE</name>
              <description>
              Output compare 1 clear enable
              0: OC1Ref is not affected by the ETRF input
              1: OC1Ref is cleared as soon as a High level is detected on ETRF input
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IC2F</name>
              <description>
              Input capture 2 filter
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>IC2PSC</name>
              <description>
              Input capture 2 prescaler
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>CC2S</name>
              <description>
              Capture/Compare 2 selection
              This bit-field defines the direction of the channel (input/output) as well as the used input. 
              00: CC2 channel is configured as output
              01: CC2 channel is configured as input, IC2 is mapped on TI2
              10: CC2 channel is configured as input, IC2 is mapped on TI1
              11: CC2 channel is configured as input, IC2 is mapped on TRC. This mode is working only if an internal trigger input is selected through the TS bit (SMCR register)
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>IC1F</name>
              <description>
              Input capture 1 filter
              This bit-field defines the frequency used to sample TI1 input and the length of the digital filter applied to TI1. The digital filter is made of an event counter in which N consecutive events are needed to validate a transition on the output:
              0000: No filter, sampling is done at fCLK
              0001: fSAMPLING=fCLK, N=2
              0010: fSAMPLING=fCLK, N=4
              0011: fSAMPLING=fCLK, N=8
              0100: fSAMPLING=fCLK/2, N=6
              0101: fSAMPLING=fCLK/2, N=8
              0110: fSAMPLING=fCLK/4, N=6
              0111: fSAMPLING=fCLK/4, N=8
              1000: fSAMPLING=fCLK/8, N=6
              1001: fSAMPLING=fCLK/8, N=8
              1010: fSAMPLING=fCLK/16, N=5
              1011: fSAMPLING=fCLK/16, N=6
              1100: fSAMPLING=fCLK/16, N=8
              1101: fSAMPLING=fCLK/32, N=5
              1110: fSAMPLING=fCLK/32, N=6
              1111: fSAMPLING=fCLK/32, N=8
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>IC1PSC</name>
              <description>
              Input capture 1 prescaler
              This bit-field defines the ratio of the prescaler acting on CC1 input (IC1). The prescaler is reset as soon as CC1E=0.
              00: no prescaler, capture is done each time an edge is detected on the capture input
              01: capture is done once every 2 events
              10: capture is done once every 4 events
              11: capture is done once every 8 events
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>CC1S</name>
              <description>
              Capture/Compare 1 selection
              This bit-field defines the direction of the channel (input/output) as well as the used input. 
              00: CC1 channel is configured as output
              01: CC1 channel is configured as input, IC1 is mapped on TI1
              10: CC1 channel is configured as input, IC1 is mapped on TI2
              11: CC1 channel is configured as input, IC1 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (SMCR register)
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCMR2</name>
          <displayName>CCMR2</displayName>
          <description>TIM capture/compare mode register 2</description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>OC4M</name>
              <description>
              Output compare 4 mode
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>OC4PE</name>
              <description>
              Output compare 4 preload enable
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>OC4CE</name>
              <description>
              Output compare 4 clear enable
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OC3M</name>
              <description>
              Output compare 3 mode
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>OC3PE</name>
              <description>
              Output compare 3 preload enable
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>OC3CE</name>
              <description>
              Output compare 3 clear enable
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IC4F</name>
              <description>
              Input capture 4 filter
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>IC4PSC</name>
              <description>
              Input capture 4 prescaler
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>CC4S</name>
              <description>
              Capture/Compare 4 selection
              This bit-field defines the direction of the channel (input/output) as well as the used input. 
              00: CC4 channel is configured as output
              01: CC4 channel is configured as input, IC4 is mapped on TI4
              10: CC4 channel is configured as input, IC4 is mapped on TI3
              11: CC4 channel is configured as input, IC4 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (SMCR register)
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>IC3F</name>
              <description>
              Input capture 3 filter
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>IC3PSC</name>
              <description>
              Input capture 3 prescaler
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>CC3S</name>
              <description>
              Capture/Compare 3 selection
              This bit-field defines the direction of the channel (input/output) as well as the used input. 
              00: CC3 channel is configured as output
              01: CC3 channel is configured as input, IC3 is mapped on TI3
              10: CC3 channel is configured as input, IC3 is mapped on TI4
              11: CC3 channel is configured as input, IC3 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (SMCR register)
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCER</name>
          <displayName>CCER</displayName>
          <description>Capture/Compare enable register</description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>CC4NP</name>
              <description>
              Capture/Compare 4 output Polarity.
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC4P</name>
              <description>
              Capture/Compare 4 output Polarity.
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC4E</name>
              <description>
              Capture/Compare 4 output enable.
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC3NP</name>
              <description>
              Capture/Compare 3 output Polarity.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC3P</name>
              <description>
              Capture/Compare 3 output Polarity.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC3E</name>
              <description>
              Capture/Compare 3 output enable.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC2NP</name>
              <description>
              Capture/Compare 2 output Polarity.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC2P</name>
              <description>
              Capture/Compare 2 output Polarity.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC2E</name>
              <description>
              Capture/Compare 2 output enable.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC1NP</name>
              <description>
              Capture/Compare 1 output Polarity.
              CC1 channel configured as output: CC1NP must be kept cleared in this case.
              CC1 channel configured as input: This bit is used in conjunction with CC1P to define TI1FP1/TI2FP1 polarity. refer to CC1P description.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD5</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC1P</name>
              <description>
              Capture/Compare 1 output Polarity.
              CC1 channel configured as output:
              0: OC1 active high
              1: OC1 active low
              CC1 channel configured as input: CC1NP/CC1P bits select TI1FP1 and TI2FP1 polarity for trigger or capture operations.
              00: noninverted/rising edge
              Circuit is sensitive to TIxFP1 rising edge (capture, trigger in reset, external clock or trigger mode), TIxFP1 is not inverted (trigger in gated mode, encoder mode).
              01: inverted/falling edge
              Circuit is sensitive to TIxFP1 falling edge (capture, trigger in reset, external clock or trigger mode), TIxFP1 is inverted (trigger in gated mode, encoder mode).
              10: reserved, do not use this configuration.
              11: noninverted/both edges
              Circuit is sensitive to both TIxFP1 rising and falling edges (capture, trigger in reset, external clock or trigger mode), TIxFP1 is not inverted (trigger in gated mode). This configuration must not be used for encoder mode.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC1E</name>
              <description>
              Capture/Compare 1 output enable.
              CC1 channel configured as output:
              0: Off - OC1 is not active
              1: On - OC1 signal is output on the corresponding output pin
              CC1 channel configured as input: This bit determines if a capture of the counter value can actually be done into the input capture/compare register 1 (CCR1) or not.
              0: Capture disabled
              1: Capture enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CNT</name>
          <displayName>CNT</displayName>
          <description>Counter</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>UIFCPY</name>
              <description>
              Value depends on IUFREMAP in CR1.
              If UIFREMAP = 1
              UIFCPY: UIF Copy
              This bit is a read-only copy of the UIF bit of the ISR register
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>15</bitWidth>
            </field>
            <field>
              <name>CNT</name>
              <description>
              counter value
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PSC</name>
          <displayName>PSC</displayName>
          <description>Prescaler</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>PSC</name>
              <description>
              Prescaler value
              The counter clock frequency is equal to fCLK / (PSC[15:0] + 1).
              PSC contains the value to be loaded in the active prescaler register at each update event (including when the counter is cleared through UG bit of EGR register or through trigger controller when configured in 'reset mode').
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ARR</name>
          <displayName>ARR</displayName>
          <description>Auto-reload register</description>
          <addressOffset>0x2c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>ARR</name>
              <description>
              Auto-reload value
              ARR is the value to be loaded in the actual auto-reload register.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RCR</name>
          <displayName>RCR</displayName>
          <description>Repetition counter register</description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>REP</name>
              <description>
              Repetition counter value
              These bits allow the user to set-up the update rate of the compare registers (i.e. periodic transfers from preload to active registers) when preload registers are enable, as well as the update interrupt generation rate, if this interrupt is enable.
              Each time the REP_CNT related downcounter reaches zero, an update event is generated and it restarts counting from REP value. As REP_CNT is reloaded with REP value only at the repetition update event, any write to the RCR register is not taken in account until the next repetition update event.
              It means in PWM mode (REP+1) corresponds to the number of PWM periods in edge-aligned mode.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR1</name>
          <displayName>CCR1</displayName>
          <description>Capture/Compare register 1</description>
          <addressOffset>0x34</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>CCR1</name>
              <description>
              Capture/Compare 1 value
              If channel CC1 is configured as output:
              CCR1 is the value to be loaded in the actual capture/compare 1 register (preload value).It is loaded permanently if the preload feature is not selected in the CCMR1 register (bit OC1PE). Else the preload value is copied in the active capture/compare 1 register when an update event occurs.
              The active capture/compare register contains the value to be compared to the counter CNT and signaled on OC1 output.
              If channel CC1is configured as input:
              CCR1 is the counter value transferred by the last input capture 1 event (IC1). The CCR1 register is read-only and cannot be programmed.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR2</name>
          <displayName>CCR2</displayName>
          <description>Capture/Compare register 2</description>
          <addressOffset>0x38</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>CCR2</name>
              <description>
              Capture/Compare 2 value
              If channel CC2 is configured as output:
              CCR2 is the value to be loaded in the actual capture/compare 2 register (preload value).It is loaded permanently if the preload feature is not selected in the CCMR1 register (bit OC2PE). Else the preload value is copied in the active capture/compare 2 register when an update event occurs.
              The active capture/compare register contains the value to be compared to the counter CNT and signalled on OC2 output.
              If channel CC2 is configured as input:
              CCR2 is the counter value transferred by the last input capture 2 event (IC2). The CCR2 register is read-only and cannot be programmed.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR3</name>
          <displayName>CCR3</displayName>
          <description>Capture/Compare register 3</description>
          <addressOffset>0x3c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>CCR3</name>
              <description>
              Capture/Compare value
              If channel CC3 is configured as output:
              CCR3 is the value to be loaded in the actual capture/compare 3 register (preload value).It is loaded permanently if the preload feature is not selected in the CCMR2 register (bit OC3PE). Else the preload value is copied in the active capture/compare 3 register when an update event occurs.
              The active capture/compare register contains the value to be compared to the counter CNT and signalled on OC3 output.
              If channel CC3is configured as input:
              CCR3 is the counter value transferred by the last input capture 3 event (IC3). The CCR3 register is read-only and cannot be programmed.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR4</name>
          <displayName>CCR4</displayName>
          <description>Capture/Compare register 4</description>
          <addressOffset>0x40</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>CCR4</name>
              <description>
              Capture/Compare value
              1. if CC4 channel is configured as output:
              CCR4 is the value to be loaded in the actual capture/compare 4 register (preload value).It is loaded permanently if the preload feature is not selected in the CCMR2 register (bit OC4PE). Else the preload value is copied in the active capture/compare 4 register when an update event occurs.
              The active capture/compare register contains the value to be compared to the counter CNT and signalled on OC4 output.
              2.  if CC4 channel is configured as input:
              CCR4 is the counter value transferred by the last input capture 4 event (IC4). The CCR4 register is read-only and cannot be programmed.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>GPTIM5</name>
      <description></description>
      <groupName>GPTIM</groupName>
      <baseAddress>0x50012000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CR1</name>
          <displayName>CR1</displayName>
          <description>TIM control register 1</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>UIFREMAP</name>
              <description>
              UIF status bit remapping
              0: No remapping. UIF status bit is not copied to CNT register bit 31
              1: Remapping enabled. UIF status bit is copied to CNT register bit 31
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>ARPE</name>
              <description>
              Auto-reload preload enable
              0: ARR register is not buffered
              1: ARR register is buffered
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CMS</name>
              <description>
              Center-aligned mode selection
              00: Edge-aligned mode. The counter counts up or down depending on the direction bit (DIR).
              01: Center-aligned mode 1. The counter counts up and down alternatively. Output compare interrupt flags of channels configured in output (CCxS=00 in CCMRx register) are set only when the counter is counting down.
              10: Center-aligned mode 2. The counter counts up and down alternatively. Output compare interrupt flags of channels configured in output (CCxS=00 in CCMRx register) are set only when the counter is counting up.
              11: Center-aligned mode 3. The counter counts up and down alternatively. Output compare interrupt flags of channels configured in output (CCxS=00 in CCMRx register) are set both when the counter is counting up or down.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>DIR</name>
              <description>
              Direction
              0: Counter used as upcounter
              1: Counter used as downcounter
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OPM</name>
              <description>
              One-pulse mode
              0: Counter is not stopped at update event
              1: Counter stops counting at the next update event (clearing the bit CEN)
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>URS</name>
              <description>
              Update request source
              This bit is set and cleared by software to select the UEV event sources.
              0: Any of the following events generate an update interrupt or DMA request if enabled. 
              These events can be: 
                 Counter overflow/underflow
                 Setting the UG bit
                 Update generation through the slave mode controller
              1: Only counter overflow/underflow generates an update interrupt or DMA request if enabled.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UDIS</name>
              <description>
              Update disable
              This bit is set and cleared by software to enable/disable UEV event generation.
              0: UEV enabled. The Update (UEV) event is generated by one of the following events:
                 Counter overflow/underflow
                 Setting the UG bit
                 Update generation through the slave mode controller
              Buffered registers are then loaded with their preload values.
              1: UEV disabled. The Update event is not generated, shadow registers keep their value (ARR, PSC, CCRx). However the counter and the prescaler are reinitialized if the UG bit is set or if a hardware reset is received from the slave mode controller.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CEN</name>
              <description>
              Counter enable
              0: Counter disabled
              1: Counter enabled
              Note: External clock, gated mode and encoder mode can work only if the CEN bit has been previously set by software. However trigger mode can set the CEN bit automatically by hardware. 
              CEN is cleared automatically in one-pulse mode, when an update event occurs.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CR2</name>
          <displayName>CR2</displayName>
          <description>TIM control register 2</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>TI1S</name>
              <description>
              TI1 selection
              0: The CH1 pin is connected to TI1 input
              1: The CH1, CH2 and CH3 pins are connected to the TI1 input (XOR combination) 
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MMS</name>
              <description>
              Master mode selection
              These bits allow to select the information to be sent in master mode to slave timers for synchronization (TRGO). The combination is as follows:
              000: Reset - the UG bit from the EGR register is used as trigger output (TRGO). If the reset is generated by the trigger input (slave mode controller configured in reset mode) then the signal on TRGO is delayed compared to the actual reset.
              001: Enable - the Counter enable signal is used as trigger output (TRGO). It is useful to start several timers at the same time or to control a window in which a slave timer is enabled. The Counter Enable signal is generated by a logic OR between CEN control bit and the trigger input when configured in gated mode. 
              When the Counter Enable signal is controlled by the trigger input, there is a delay on TRGO, except if the master/slave mode is selected.
              010: Update - The update event is selected as trigger output (TRGO). For instance a master timer can then be used as a prescaler for a slave timer.
              011: Compare Pulse - The trigger output send a positive pulse when the CC1IF flag is to be set (even if it was already high), as soon as a capture or a compare match occurred. (TRGO)
              100: Compare - OC1REF signal is used as trigger output (TRGO)
              101: Compare - OC2REF signal is used as trigger output (TRGO)
              110: Compare - OC3REF signal is used as trigger output (TRGO)
              111: Compare - OC4REF signal is used as trigger output (TRGO)
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>CCDS</name>
              <description>
              Capture/compare DMA selection
              0: CCx DMA request sent when CCx event occurs
              1: CCx DMA requests sent when update event occurs
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SMCR</name>
          <displayName>SMCR</displayName>
          <description>TIM slave mode control register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
            <field>
              <name>SMS</name>
              <description>
              Slave mode selection
              When external signals are selected the active edge of the trigger signal (TRGI) is linked to the polarity selected on the external input.
              0000: Slave mode disabled.
              0001: Encoder mode 1 - Counter counts up/down on TI1FP1 edge depending on TI2FP2 level.
              0010: Encoder mode 2 - Counter counts up/down on TI2FP2 edge depending on TI1FP1 level.
              0011: Encoder mode 3 - Counter counts up/down on both TI1FP1 and TI2FP2 edges depending on the level of the other input.
              0100: Reset Mode - Rising edge of the selected trigger input (TRGI) reinitializes the counter and generates an update of the registers.
              0101: Gated Mode - The counter clock is enabled when the trigger input (TRGI) is high. The counter stops (but is not reset) as soon as the trigger becomes low. Both start and stop of the counter are controlled.
              0110: Trigger Mode - The counter starts at a rising edge of the trigger TRGI (but it is not reset). Only the start of the counter is controlled.
              0111: External Clock Mode 1 - Rising edges of the selected trigger (TRGI) clock the counter.
              1000: Combined reset + trigger mode - Rising edge of the selected trigger input (TRGI) reinitializes the counter, generates an update of the registers and starts the counter.
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>ETP</name>
              <description>
              External trigger polarity
              0: ETR is non-inverted, active at high level or rising edge
              1: ETR is inverted, active at low level or falling edge
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ECE</name>
              <description>
              External clock enable
              This bit enables External clock mode 2.
              0: External clock mode 2 disabled
              1: External clock mode 2 enabled. The counter is clocked by any active edge on the ETRF signal.
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ETPS</name>
              <description>
              External trigger prescaler
              External trigger signal ETRP frequency must be at most 1/4 of CK_INT frequency. A prescaler can be enabled to reduce ETRP frequency. It is useful when inputting fast external clocks.
              00: Prescaler OFF
              01: ETRP frequency divided by 2
              10: ETRP frequency divided by 4
              11: ETRP frequency divided by 8
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>ETF</name>
              <description>
              External trigger filter
              This bit-field then defines the frequency used to sample ETRP signal and the length of the digital filter applied to ETRP. The digital filter is made of an event counter in which N 
              consecutive events are needed to validate a transition on the output:
              0000: No filter
              0001:   fSAMPLING=fCLK, N=2
              0010:   fSAMPLING=fCLK, N=4
              0011:   fSAMPLING=fCLK, N=8
              0100:   fSAMPLING=fCLK/2, N=6
              0101:   fSAMPLING=fCLK/2, N=8
              0110:   fSAMPLING=fCLK/4, N=6
              0111:   fSAMPLING=fCLK/4, N=8
              1000:   fSAMPLING=fCLK/8, N=6
              1001:   fSAMPLING=fCLK/8, N=8
              1010:   fSAMPLING=fCLK/16, N=5
              1011:   fSAMPLING=fCLK/16, N=6
              1100:   fSAMPLING=fCLK/16, N=8
              1101:   fSAMPLING=fCLK/32, N=5
              1110:   fSAMPLING=fCLK/32, N=6
              1111:   fSAMPLING=fCLK/32, N=8
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>MSM</name>
              <description>
              Master/Slave mode
              0: No action
              1: The effect of an event on the trigger input (TRGI) is delayed to allow a perfect synchronization between the current timer and its slaves (through TRGO). It is useful if we want to synchronize several timers on a single external event.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TS</name>
              <description>
              Trigger selection
              This bit-field selects the trigger input to be used to synchronize the counter.
              000: Internal Trigger 0 (ITR0)
              001: Internal Trigger 1 (ITR1) 
              010: Internal Trigger 2 (ITR2)
              011: Internal Trigger 3 (ITR3)
              100: TI1 Edge Detector (TI1F_ED)
              101: Filtered Timer Input 1 (TI1FP1)
              110: Filtered Timer Input 2 (TI2FP2)
              111: External Trigger input (ETRF)
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DIER</name>
          <displayName>DIER</displayName>
          <description>TIM DMA/Interrupt enable register</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
            <field>
              <name>TDE</name>
              <description>
              Trigger DMA request enable
              0: Trigger DMA request disabled.
              1: Trigger DMA request enabled.
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC4DE</name>
              <description>
              Capture/Compare 4 DMA request enable
              0: CC4 DMA request disabled.
              1: CC4 DMA request enabled
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC3DE</name>
              <description>
              Capture/Compare 3 DMA request enable
              0: CC3 DMA request disabled.
              1: CC3 DMA request enabled.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC2DE</name>
              <description>
              Capture/Compare 2 DMA request enable
              0: CC2 DMA request disabled.
              1: CC2 DMA request enabled.
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC1DE</name>
              <description>
              Capture/Compare 1 DMA request enable
              0: CC1 DMA request disabled.
              1: CC1 DMA request enabled.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UDE</name>
              <description>
              Update DMA request enable
              0: Update DMA request disabled.
              1: Update DMA request enabled
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TIE</name>
              <description>
              Trigger interrupt enable
              0: Trigger interrupt disabled.
              1: Trigger interrupt enabled
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC4IE</name>
              <description>
              Capture/Compare 4 interrupt enable
              0: CC4 interrupt disabled.
              1: CC4 interrupt enabled
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC3IE</name>
              <description>
              Capture/Compare 3 interrupt enable
              0: CC3 interrupt disabled.
              1: CC3 interrupt enabled
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC2IE</name>
              <description>
              Capture/Compare 2 interrupt enable
              0: CC2 interrupt disabled.
              1: CC2 interrupt enabled.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC1IE</name>
              <description>
              Capture/Compare 1 interrupt enable
              0: CC1 interrupt disabled.
              1: CC1 interrupt enabled
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UIE</name>
              <description>
              Update interrupt enable
              0: Update interrupt disabled.
              1: Update interrupt enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SR</name>
          <displayName>SR</displayName>
          <description>TIM status register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>19</bitWidth>
            </field>
            <field>
              <name>CC4OF</name>
              <description>
              Capture/Compare 4 overcapture flag
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC3OF</name>
              <description>
              Capture/Compare 3 overcapture flag
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC2OF</name>
              <description>
              Capture/Compare 2 overcapture flag
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC1OF</name>
              <description>
              Capture/Compare 1 overcapture flag
              This flag is set by hardware only when the corresponding channel is configured in input capture mode. It is cleared by software by writing it to '0'.
              0: No overcapture has been detected.
              1: The counter value has been captured in CCR1 register while CC1IF flag was already set
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>TIF</name>
              <description>
              Trigger interrupt flag
              This flag is set by hardware on trigger event (active edge detected on TRGI input when the slave mode controller is enabled in all modes but gated mode). It is set when the counter starts or stops when gated mode is selected. It is cleared by software.
              0: No trigger event occurred.
              1: Trigger interrupt pending.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC4IF</name>
              <description>
              Capture/Compare 4 interrupt flag
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC3IF</name>
              <description>
              Capture/Compare 3 interrupt flag
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC2IF</name>
              <description>
              Capture/Compare 2 interrupt flag
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC1IF</name>
              <description>
              Capture/Compare 1 interrupt flag
              If channel CC1 is configured as output: This flag is set by hardware when the counter matches the compare value. It is cleared by software.
              0: No match.
              1: The content of the counter CNT has matched the content of the CCR1 register.
              If channel CC1 is configured as input: This bit is set by hardware on a capture. It is cleared by software or by reading the CCR1 register.
              0: No input capture occurred.
              1: The counter value has been captured in CCR1 register (An edge has been detected on IC1 which matches the selected polarity).
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UIF</name>
              <description>
              Update interrupt flag
              This bit is set by hardware on an update event. It is cleared by software.
              0: No update occurred
              1: Update interrupt pending. This bit is set by hardware when the registers are updated:
              At overflow or underflow and if UDIS=0 in the CR1 register.
              When CNT is reinitialized by software using the UG bit in EGR register, if URS=0 and UDIS=0 in the CR1 register.
              When CNT is reinitialized by a trigger event, if URS=0 and UDIS=0 in the CR1 register.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>EGR</name>
          <displayName>EGR</displayName>
          <description>Event generation register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>25</bitWidth>
            </field>
            <field>
              <name>TG</name>
              <description>
              Trigger generation
              This bit is set by software in order to generate an event, it is automatically cleared by hardware.
              0: No action
              1: The TIF flag is set in SR register. Related interrupt or DMA transfer can occur if enabled.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC4G</name>
              <description>
              Capture/compare 4 generation
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC3G</name>
              <description>
              Capture/compare 3 generation
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC2G</name>
              <description>
              Capture/compare 2 generation
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC1G</name>
              <description>
              Capture/compare 1 generation
              This bit is set by software in order to generate an event, it is automatically cleared by hardware.
              0: No action
              1: A capture/compare event is generated on channel 1:
              If channel CC1 is configured as output:
              CC1IF flag is set, Corresponding interrupt or DMA request is sent if enabled.
              If channel CC1 is configured as input:
              The current value of the counter is captured in CCR1 register. The CC1IF flag is set, the corresponding interrupt or DMA request is sent if enabled. The CC1OF flag is set if the CC1IF flag was already high.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UG</name>
              <description>
              Update generation
              This bit can be set by software, it is automatically cleared by hardware.
              0: No action
              1: Re-initialize the counter and generates an update of the registers. Note that the prescaler counter is cleared too (anyway the prescaler ratio is not affected). The counter is cleared if the center-aligned mode is selected or if DIR=0 (upcounting), else it takes the auto-reload value (ARR) if DIR=1 (downcounting).
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCMR1</name>
          <displayName>CCMR1</displayName>
          <description>TIM capture/compare mode register 1</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>OC2M</name>
              <description>
              Output compare 2 mode
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>OC2PE</name>
              <description>
              Output compare 2 preload enable
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>OC2CE</name>
              <description>
              Output compare 2 clear enable
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OC1M</name>
              <description>
              Output compare 1 mode
              These bits define the behavior of the output reference signal OC1REF from which OC1 and OC1N are derived. OC1REF is active high whereas OC1 and OC1N active level depends on CC1P and CC1NP bits.
              0000: Frozen - The comparison between the output compare register CCR1 and the counter CNT has no effect on the outputs.(this mode is used to generate a timing base).
              0001: Set channel 1 to active level on match. OC1REF signal is forced high when the counter CNT matches the capture/compare register 1 (CCR1).
              0010: Set channel 1 to inactive level on match. OC1REF signal is forced low when the counter CNT matches the capture/compare register 1 (CCR1).
              0011: Toggle - OC1REF toggles when CNT=CCR1.
              0100: Force inactive level - OC1REF is forced low.
              0101: Force active level - OC1REF is forced high.
              0110: PWM mode 1 - In upcounting, channel 1 is active as long as CNTltCCR1 else inactive. In downcounting, channel 1 is inactive (OC1REF='0) as long as CNT>CCR1 else active (OC1REF=1).
              0111: PWM mode 2 - In upcounting, channel 1 is inactive as long as CNTltCCR1 else active. In downcounting, channel 1 is active as long as CNT>CCR1 else inactive.
              1000: Retriggerable OPM mode 1 - In up-counting mode, the channel is active until a trigger event is detected (on TRGI signal). Then, a comparison is performed as in PWM mode 1 and the channels becomes inactive again at the next update. In down-counting mode, the channel is inactive until a trigger event is detected (on TRGI signal). Then, a comparison is performed as in PWM mode 1 and the channels becomes inactive again at the next update.
              1001: Retriggerable OPM mode 2 - In up-counting mode, the channel is inactive until a trigger event is detected (on TRGI signal). Then, a comparison is performed as in PWM mode 2 and the channels becomes inactive again at the next update. In down-counting mode, the channel is active until a trigger event is detected (on TRGI signal). Then, a comparison is performed as in PWM mode 1 and the channels becomes active again at the next update.
              1010: Reserved,
              1011: Reserved,
              1100: Combined PWM mode 1 - OC1REF has the same behavior as in PWM mode 1. OC1REFC is the logical OR between OC1REF and OC2REF.
              1101: Combined PWM mode 2 - OC1REF has the same behavior as in PWM mode 2. OC1REFC is the logical AND between OC1REF and OC2REF.
              1110: Asymmetric PWM mode 1 - OC1REF has the same behavior as in PWM mode 1. OC1REFC outputs OC1REF when the counter is counting up, OC2REF when it is counting down.
              1111: Asymmetric PWM mode 2 - OC1REF has the same behavior as in PWM mode 2. OC1REFC outputs OC1REF when the counter is counting up, OC2REF when it is counting down.
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>OC1PE</name>
              <description>
              Output compare 1 preload enable
              0: Preload register on CCR1 disabled. CCR1 can be written at anytime, the new value is taken in account immediately.
              1: Preload register on CCR1 enabled. Read/Write operations access the preload register. CCR1 preload value is loaded in the active register at each update event.
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>OC1CE</name>
              <description>
              Output compare 1 clear enable
              0: OC1Ref is not affected by the ETRF input
              1: OC1Ref is cleared as soon as a High level is detected on ETRF input
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IC2F</name>
              <description>
              Input capture 2 filter
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>IC2PSC</name>
              <description>
              Input capture 2 prescaler
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>CC2S</name>
              <description>
              Capture/Compare 2 selection
              This bit-field defines the direction of the channel (input/output) as well as the used input. 
              00: CC2 channel is configured as output
              01: CC2 channel is configured as input, IC2 is mapped on TI2
              10: CC2 channel is configured as input, IC2 is mapped on TI1
              11: CC2 channel is configured as input, IC2 is mapped on TRC. This mode is working only if an internal trigger input is selected through the TS bit (SMCR register)
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>IC1F</name>
              <description>
              Input capture 1 filter
              This bit-field defines the frequency used to sample TI1 input and the length of the digital filter applied to TI1. The digital filter is made of an event counter in which N consecutive events are needed to validate a transition on the output:
              0000: No filter, sampling is done at fCLK
              0001: fSAMPLING=fCLK, N=2
              0010: fSAMPLING=fCLK, N=4
              0011: fSAMPLING=fCLK, N=8
              0100: fSAMPLING=fCLK/2, N=6
              0101: fSAMPLING=fCLK/2, N=8
              0110: fSAMPLING=fCLK/4, N=6
              0111: fSAMPLING=fCLK/4, N=8
              1000: fSAMPLING=fCLK/8, N=6
              1001: fSAMPLING=fCLK/8, N=8
              1010: fSAMPLING=fCLK/16, N=5
              1011: fSAMPLING=fCLK/16, N=6
              1100: fSAMPLING=fCLK/16, N=8
              1101: fSAMPLING=fCLK/32, N=5
              1110: fSAMPLING=fCLK/32, N=6
              1111: fSAMPLING=fCLK/32, N=8
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>IC1PSC</name>
              <description>
              Input capture 1 prescaler
              This bit-field defines the ratio of the prescaler acting on CC1 input (IC1). The prescaler is reset as soon as CC1E=0.
              00: no prescaler, capture is done each time an edge is detected on the capture input
              01: capture is done once every 2 events
              10: capture is done once every 4 events
              11: capture is done once every 8 events
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>CC1S</name>
              <description>
              Capture/Compare 1 selection
              This bit-field defines the direction of the channel (input/output) as well as the used input. 
              00: CC1 channel is configured as output
              01: CC1 channel is configured as input, IC1 is mapped on TI1
              10: CC1 channel is configured as input, IC1 is mapped on TI2
              11: CC1 channel is configured as input, IC1 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (SMCR register)
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCMR2</name>
          <displayName>CCMR2</displayName>
          <description>TIM capture/compare mode register 2</description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>OC4M</name>
              <description>
              Output compare 4 mode
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>OC4PE</name>
              <description>
              Output compare 4 preload enable
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>OC4CE</name>
              <description>
              Output compare 4 clear enable
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OC3M</name>
              <description>
              Output compare 3 mode
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>OC3PE</name>
              <description>
              Output compare 3 preload enable
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>OC3CE</name>
              <description>
              Output compare 3 clear enable
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IC4F</name>
              <description>
              Input capture 4 filter
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>IC4PSC</name>
              <description>
              Input capture 4 prescaler
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>CC4S</name>
              <description>
              Capture/Compare 4 selection
              This bit-field defines the direction of the channel (input/output) as well as the used input. 
              00: CC4 channel is configured as output
              01: CC4 channel is configured as input, IC4 is mapped on TI4
              10: CC4 channel is configured as input, IC4 is mapped on TI3
              11: CC4 channel is configured as input, IC4 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (SMCR register)
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>IC3F</name>
              <description>
              Input capture 3 filter
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>IC3PSC</name>
              <description>
              Input capture 3 prescaler
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>CC3S</name>
              <description>
              Capture/Compare 3 selection
              This bit-field defines the direction of the channel (input/output) as well as the used input. 
              00: CC3 channel is configured as output
              01: CC3 channel is configured as input, IC3 is mapped on TI3
              10: CC3 channel is configured as input, IC3 is mapped on TI4
              11: CC3 channel is configured as input, IC3 is mapped on TRC. This mode is working only if an internal trigger input is selected through TS bit (SMCR register)
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCER</name>
          <displayName>CCER</displayName>
          <description>Capture/Compare enable register</description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>CC4NP</name>
              <description>
              Capture/Compare 4 output Polarity.
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC4P</name>
              <description>
              Capture/Compare 4 output Polarity.
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC4E</name>
              <description>
              Capture/Compare 4 output enable.
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC3NP</name>
              <description>
              Capture/Compare 3 output Polarity.
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC3P</name>
              <description>
              Capture/Compare 3 output Polarity.
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC3E</name>
              <description>
              Capture/Compare 3 output enable.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC2NP</name>
              <description>
              Capture/Compare 2 output Polarity.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC2P</name>
              <description>
              Capture/Compare 2 output Polarity.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC2E</name>
              <description>
              Capture/Compare 2 output enable.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC1NP</name>
              <description>
              Capture/Compare 1 output Polarity.
              CC1 channel configured as output: CC1NP must be kept cleared in this case.
              CC1 channel configured as input: This bit is used in conjunction with CC1P to define TI1FP1/TI2FP1 polarity. refer to CC1P description.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD5</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC1P</name>
              <description>
              Capture/Compare 1 output Polarity.
              CC1 channel configured as output:
              0: OC1 active high
              1: OC1 active low
              CC1 channel configured as input: CC1NP/CC1P bits select TI1FP1 and TI2FP1 polarity for trigger or capture operations.
              00: noninverted/rising edge
              Circuit is sensitive to TIxFP1 rising edge (capture, trigger in reset, external clock or trigger mode), TIxFP1 is not inverted (trigger in gated mode, encoder mode).
              01: inverted/falling edge
              Circuit is sensitive to TIxFP1 falling edge (capture, trigger in reset, external clock or trigger mode), TIxFP1 is inverted (trigger in gated mode, encoder mode).
              10: reserved, do not use this configuration.
              11: noninverted/both edges
              Circuit is sensitive to both TIxFP1 rising and falling edges (capture, trigger in reset, external clock or trigger mode), TIxFP1 is not inverted (trigger in gated mode). This configuration must not be used for encoder mode.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC1E</name>
              <description>
              Capture/Compare 1 output enable.
              CC1 channel configured as output:
              0: Off - OC1 is not active
              1: On - OC1 signal is output on the corresponding output pin
              CC1 channel configured as input: This bit determines if a capture of the counter value can actually be done into the input capture/compare register 1 (CCR1) or not.
              0: Capture disabled
              1: Capture enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CNT</name>
          <displayName>CNT</displayName>
          <description>Counter</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>UIFCPY</name>
              <description>
              Value depends on IUFREMAP in CR1.
              If UIFREMAP = 1
              UIFCPY: UIF Copy
              This bit is a read-only copy of the UIF bit of the ISR register
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>15</bitWidth>
            </field>
            <field>
              <name>CNT</name>
              <description>
              counter value
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PSC</name>
          <displayName>PSC</displayName>
          <description>Prescaler</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>PSC</name>
              <description>
              Prescaler value
              The counter clock frequency is equal to fCLK / (PSC[15:0] + 1).
              PSC contains the value to be loaded in the active prescaler register at each update event (including when the counter is cleared through UG bit of EGR register or through trigger controller when configured in 'reset mode').
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ARR</name>
          <displayName>ARR</displayName>
          <description>Auto-reload register</description>
          <addressOffset>0x2c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>ARR</name>
              <description>
              Auto-reload value
              ARR is the value to be loaded in the actual auto-reload register.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RCR</name>
          <displayName>RCR</displayName>
          <description>Repetition counter register</description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>REP</name>
              <description>
              Repetition counter value
              These bits allow the user to set-up the update rate of the compare registers (i.e. periodic transfers from preload to active registers) when preload registers are enable, as well as the update interrupt generation rate, if this interrupt is enable.
              Each time the REP_CNT related downcounter reaches zero, an update event is generated and it restarts counting from REP value. As REP_CNT is reloaded with REP value only at the repetition update event, any write to the RCR register is not taken in account until the next repetition update event.
              It means in PWM mode (REP+1) corresponds to the number of PWM periods in edge-aligned mode.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR1</name>
          <displayName>CCR1</displayName>
          <description>Capture/Compare register 1</description>
          <addressOffset>0x34</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>CCR1</name>
              <description>
              Capture/Compare 1 value
              If channel CC1 is configured as output:
              CCR1 is the value to be loaded in the actual capture/compare 1 register (preload value).It is loaded permanently if the preload feature is not selected in the CCMR1 register (bit OC1PE). Else the preload value is copied in the active capture/compare 1 register when an update event occurs.
              The active capture/compare register contains the value to be compared to the counter CNT and signaled on OC1 output.
              If channel CC1is configured as input:
              CCR1 is the counter value transferred by the last input capture 1 event (IC1). The CCR1 register is read-only and cannot be programmed.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR2</name>
          <displayName>CCR2</displayName>
          <description>Capture/Compare register 2</description>
          <addressOffset>0x38</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>CCR2</name>
              <description>
              Capture/Compare 2 value
              If channel CC2 is configured as output:
              CCR2 is the value to be loaded in the actual capture/compare 2 register (preload value).It is loaded permanently if the preload feature is not selected in the CCMR1 register (bit OC2PE). Else the preload value is copied in the active capture/compare 2 register when an update event occurs.
              The active capture/compare register contains the value to be compared to the counter CNT and signalled on OC2 output.
              If channel CC2 is configured as input:
              CCR2 is the counter value transferred by the last input capture 2 event (IC2). The CCR2 register is read-only and cannot be programmed.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR3</name>
          <displayName>CCR3</displayName>
          <description>Capture/Compare register 3</description>
          <addressOffset>0x3c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>CCR3</name>
              <description>
              Capture/Compare value
              If channel CC3 is configured as output:
              CCR3 is the value to be loaded in the actual capture/compare 3 register (preload value).It is loaded permanently if the preload feature is not selected in the CCMR2 register (bit OC3PE). Else the preload value is copied in the active capture/compare 3 register when an update event occurs.
              The active capture/compare register contains the value to be compared to the counter CNT and signalled on OC3 output.
              If channel CC3is configured as input:
              CCR3 is the counter value transferred by the last input capture 3 event (IC3). The CCR3 register is read-only and cannot be programmed.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR4</name>
          <displayName>CCR4</displayName>
          <description>Capture/Compare register 4</description>
          <addressOffset>0x40</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>CCR4</name>
              <description>
              Capture/Compare value
              1. if CC4 channel is configured as output:
              CCR4 is the value to be loaded in the actual capture/compare 4 register (preload value).It is loaded permanently if the preload feature is not selected in the CCMR2 register (bit OC4PE). Else the preload value is copied in the active capture/compare 4 register when an update event occurs.
              The active capture/compare register contains the value to be compared to the counter CNT and signalled on OC4 output.
              2.  if CC4 channel is configured as input:
              CCR4 is the counter value transferred by the last input capture 4 event (IC4). The CCR4 register is read-only and cannot be programmed.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>BTIM3</name>
      <description></description>
      <groupName>BTIM</groupName>
      <baseAddress>0x50013000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CR1</name>
          <displayName>CR1</displayName>
          <description>TIM control register 1</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>ARPE</name>
              <description>
              Auto-reload preload enable
              0: ARR register is not buffered
              1: ARR register is buffered
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>OPM</name>
              <description>
              One-pulse mode
              0: Counter is not stopped at update event
              1: Counter stops counting at the next update event (clearing the bit CEN)
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>URS</name>
              <description>
              Update request source
              This bit is set and cleared by software to select the UEV event sources.
              0: Any of the following events generate an update interrupt or DMA request if enabled. 
              These events can be: 
                 Counter overflow
                 Setting the UG bit
                 Update generation through the slave mode controller
              1: Only counter overflow generates an update interrupt or DMA request if enabled.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UDIS</name>
              <description>
              Update disable
              This bit is set and cleared by software to enable/disable UEV event generation.
              0: UEV enabled. The Update (UEV) event is generated by one of the following events:
                 Counter overflow
                 Setting the UG bit
                 Update generation through the slave mode controller
              Buffered registers are then loaded with their preload values.
              1: UEV disabled. The Update event is not generated, shadow registers keep their value (ARR, PSC). However the counter and the prescaler are reinitialized if the UG bit is set or if a hardware reset is received from the slave mode controller.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CEN</name>
              <description>
              Counter enable
              0: Counter disabled
              1: Counter enabled
              Note: Gated mode can work only if the CEN bit has been previously set by software. However trigger mode can set the CEN bit automatically by hardware. 
              CEN is cleared automatically in one-pulse mode, when an update event occurs.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CR2</name>
          <displayName>CR2</displayName>
          <description>TIM control register 2</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>26</bitWidth>
            </field>
            <field>
              <name>MMS</name>
              <description>
              Master mode selection
              These bits allow to select the information to be sent in master mode to slave timers for synchronization (TRGO). The combination is as follows:
              00: Reset:the UG bit from the EGR register is used as trigger output (TRGO). If the reset is generated by the trigger input (slave mode controller configured in reset mode) then the signal on TRGO is delayed compared to the actual reset.
              01: Enable :the Counter enable signal, CNT_EN, is used as trigger output (TRGO). It is useful to start several timers at the same time or to control a window in which a slave timer is enabled. The Counter Enable signal is generated by a logic OR between CEN control bit and the trigger input when configured in gated mode. 
              When the Counter Enable signal is controlled by the trigger input, there is a delay on TRGO, except if the master/slave mode is selected (see the MSM bit description in SMCR register).
              10: Update:The update event is selected as trigger output (TRGO). For instance a master timer can then be used as a prescaler for a slave timer.
              11: Gating:The delayed gating trigger is selected as trigger output (TRGO). 
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SMCR</name>
          <displayName>SMCR</displayName>
          <description>TIM slave mode control register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>GM</name>
              <description>
              Gated Mode. The counter clock is enabled when the selected trigger input (TRGI) is active (according to gating trigger polarity). The counter stops (but is not reset) as soon as the trigger becomes inactive. Both start and stop of the counter are controlled. Gated mode and slave mode can be enabled simutanuously with different trigger selection.
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GTP</name>
              <description>
              Gating trigger polarity invert
              0: active at high level
              1: active at low level
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GTS</name>
              <description>
              Gating trigger selection in gated mode
              This bit-field selects the trigger input to be used to enable the counter gating.
              00: Internal Trigger 0 (ITR0)
              01: Internal Trigger 1 (ITR1) 
              10: Internal Trigger 2 (ITR2)
              11: Internal Trigger 3 (ITR3)
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SMS</name>
              <description>
              Slave mode selection
              When external signals are selected the active edge of the trigger signal (TRGI) is linked to the polarity selected on the external input.
              000: Slave mode disabled.
              001: Reset Mode - Rising edge of the selected trigger input (TRGI) reinitializes the counter and generates an update of the registers.
              010: Trigger Mode - The counter starts at a rising edge of the trigger TRGI (but it is not reset). Only the start of the counter is controlled.
              011: Combined reset + trigger mode - Rising edge of the selected trigger input (TRGI) reinitializes the counter, generates an update of the registers and starts the counter.
              100: External Clock Mode - Rising edges of the selected trigger (TRGI) clock the counter.
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>MSM</name>
              <description>
              Master/Slave mode. This bit should be asserted on master timer if synchronization if needed.
              0: No action
              1: The effect of an event on the trigger input (TRGI) is delayed to allow a perfect synchronization between the current timer and its slaves (through TRGO). It is useful if we want to synchronize several timers on a single external event.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TS</name>
              <description>
              Trigger selection
              This bit-field selects the trigger input to be used to synchronize the counter.
              00: Internal Trigger 0 (ITR0)
              01: Internal Trigger 1 (ITR1) 
              10: Internal Trigger 2 (ITR2)
              11: Internal Trigger 3 (ITR3)
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD5</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DIER</name>
          <displayName>DIER</displayName>
          <description>TIM DMA/Interrupt enable register</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>UDE</name>
              <description>
              Update DMA request enable
              0: Update DMA request disabled.
              1: Update DMA request enabled
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
            <field>
              <name>UIE</name>
              <description>
              Update interrupt enable
              0: Update interrupt disabled.
              1: Update interrupt enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SR</name>
          <displayName>SR</displayName>
          <description>TIM status register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>31</bitWidth>
            </field>
            <field>
              <name>UIF</name>
              <description>
              Update interrupt flag
              This bit is set by hardware on an update event. It is cleared by software.
              0: No update occurred
              1: Update interrupt pending. This bit is set by hardware when the registers are updated:
              At overflow and if UDIS=0 in the CR1 register.
              When CNT is reinitialized by software using the UG bit in EGR register, if URS=0 and UDIS=0 in the CR1 register.
              When CNT is reinitialized by a trigger event (refer to the synchro control register description), if URS=0 and UDIS=0 in the CR1 register.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>EGR</name>
          <displayName>EGR</displayName>
          <description>Event generation register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>31</bitWidth>
            </field>
            <field>
              <name>UG</name>
              <description>
              Update generation
              This bit can be set by software, it is automatically cleared by hardware.
              0: No action
              1: Re-initialize the counter and generates an update of the registers. Note that the prescaler counter is cleared too (anyway the prescaler ratio is not affected). The counter is cleared if the center-aligned mode is selected or if DIR=0 (upcounting), else it takes the auto-reload value (ARR) if DIR=1 (downcounting).
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD1</name>
          <displayName>RSVD1</displayName>
          <description></description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>CNT</name>
          <displayName>CNT</displayName>
          <description>Counter</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>CNT</name>
              <description>
              counter value
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PSC</name>
          <displayName>PSC</displayName>
          <description>Prescaler</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>PSC</name>
              <description>
              Prescaler value
              The counter clock frequency is equal to fCLK / (PSC[15:0] + 1).
              PSC contains the value to be loaded in the active prescaler register at each update event (including when the counter is cleared through UG bit of EGR register or through trigger controller when configured in "reset mode").
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ARR</name>
          <displayName>ARR</displayName>
          <description>Auto-reload register</description>
          <addressOffset>0x2c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ARR</name>
              <description>
              Auto-reload value
              ARR is the value to be loaded in the actual auto-reload register. The counter is blocked while the auto-reload value is null.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>BTIM4</name>
      <description></description>
      <groupName>BTIM</groupName>
      <baseAddress>0x50014000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CR1</name>
          <displayName>CR1</displayName>
          <description>TIM control register 1</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>ARPE</name>
              <description>
              Auto-reload preload enable
              0: ARR register is not buffered
              1: ARR register is buffered
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>OPM</name>
              <description>
              One-pulse mode
              0: Counter is not stopped at update event
              1: Counter stops counting at the next update event (clearing the bit CEN)
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>URS</name>
              <description>
              Update request source
              This bit is set and cleared by software to select the UEV event sources.
              0: Any of the following events generate an update interrupt or DMA request if enabled. 
              These events can be: 
                 Counter overflow
                 Setting the UG bit
                 Update generation through the slave mode controller
              1: Only counter overflow generates an update interrupt or DMA request if enabled.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UDIS</name>
              <description>
              Update disable
              This bit is set and cleared by software to enable/disable UEV event generation.
              0: UEV enabled. The Update (UEV) event is generated by one of the following events:
                 Counter overflow
                 Setting the UG bit
                 Update generation through the slave mode controller
              Buffered registers are then loaded with their preload values.
              1: UEV disabled. The Update event is not generated, shadow registers keep their value (ARR, PSC). However the counter and the prescaler are reinitialized if the UG bit is set or if a hardware reset is received from the slave mode controller.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CEN</name>
              <description>
              Counter enable
              0: Counter disabled
              1: Counter enabled
              Note: Gated mode can work only if the CEN bit has been previously set by software. However trigger mode can set the CEN bit automatically by hardware. 
              CEN is cleared automatically in one-pulse mode, when an update event occurs.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CR2</name>
          <displayName>CR2</displayName>
          <description>TIM control register 2</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>26</bitWidth>
            </field>
            <field>
              <name>MMS</name>
              <description>
              Master mode selection
              These bits allow to select the information to be sent in master mode to slave timers for synchronization (TRGO). The combination is as follows:
              00: Reset:the UG bit from the EGR register is used as trigger output (TRGO). If the reset is generated by the trigger input (slave mode controller configured in reset mode) then the signal on TRGO is delayed compared to the actual reset.
              01: Enable :the Counter enable signal, CNT_EN, is used as trigger output (TRGO). It is useful to start several timers at the same time or to control a window in which a slave timer is enabled. The Counter Enable signal is generated by a logic OR between CEN control bit and the trigger input when configured in gated mode. 
              When the Counter Enable signal is controlled by the trigger input, there is a delay on TRGO, except if the master/slave mode is selected (see the MSM bit description in SMCR register).
              10: Update:The update event is selected as trigger output (TRGO). For instance a master timer can then be used as a prescaler for a slave timer.
              11: Gating:The delayed gating trigger is selected as trigger output (TRGO). 
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SMCR</name>
          <displayName>SMCR</displayName>
          <description>TIM slave mode control register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>GM</name>
              <description>
              Gated Mode. The counter clock is enabled when the selected trigger input (TRGI) is active (according to gating trigger polarity). The counter stops (but is not reset) as soon as the trigger becomes inactive. Both start and stop of the counter are controlled. Gated mode and slave mode can be enabled simutanuously with different trigger selection.
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GTP</name>
              <description>
              Gating trigger polarity invert
              0: active at high level
              1: active at low level
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GTS</name>
              <description>
              Gating trigger selection in gated mode
              This bit-field selects the trigger input to be used to enable the counter gating.
              00: Internal Trigger 0 (ITR0)
              01: Internal Trigger 1 (ITR1) 
              10: Internal Trigger 2 (ITR2)
              11: Internal Trigger 3 (ITR3)
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SMS</name>
              <description>
              Slave mode selection
              When external signals are selected the active edge of the trigger signal (TRGI) is linked to the polarity selected on the external input.
              000: Slave mode disabled.
              001: Reset Mode - Rising edge of the selected trigger input (TRGI) reinitializes the counter and generates an update of the registers.
              010: Trigger Mode - The counter starts at a rising edge of the trigger TRGI (but it is not reset). Only the start of the counter is controlled.
              011: Combined reset + trigger mode - Rising edge of the selected trigger input (TRGI) reinitializes the counter, generates an update of the registers and starts the counter.
              100: External Clock Mode - Rising edges of the selected trigger (TRGI) clock the counter.
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>MSM</name>
              <description>
              Master/Slave mode. This bit should be asserted on master timer if synchronization if needed.
              0: No action
              1: The effect of an event on the trigger input (TRGI) is delayed to allow a perfect synchronization between the current timer and its slaves (through TRGO). It is useful if we want to synchronize several timers on a single external event.
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TS</name>
              <description>
              Trigger selection
              This bit-field selects the trigger input to be used to synchronize the counter.
              00: Internal Trigger 0 (ITR0)
              01: Internal Trigger 1 (ITR1) 
              10: Internal Trigger 2 (ITR2)
              11: Internal Trigger 3 (ITR3)
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD5</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DIER</name>
          <displayName>DIER</displayName>
          <description>TIM DMA/Interrupt enable register</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>UDE</name>
              <description>
              Update DMA request enable
              0: Update DMA request disabled.
              1: Update DMA request enabled
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
            <field>
              <name>UIE</name>
              <description>
              Update interrupt enable
              0: Update interrupt disabled.
              1: Update interrupt enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SR</name>
          <displayName>SR</displayName>
          <description>TIM status register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>31</bitWidth>
            </field>
            <field>
              <name>UIF</name>
              <description>
              Update interrupt flag
              This bit is set by hardware on an update event. It is cleared by software.
              0: No update occurred
              1: Update interrupt pending. This bit is set by hardware when the registers are updated:
              At overflow and if UDIS=0 in the CR1 register.
              When CNT is reinitialized by software using the UG bit in EGR register, if URS=0 and UDIS=0 in the CR1 register.
              When CNT is reinitialized by a trigger event (refer to the synchro control register description), if URS=0 and UDIS=0 in the CR1 register.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>EGR</name>
          <displayName>EGR</displayName>
          <description>Event generation register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>31</bitWidth>
            </field>
            <field>
              <name>UG</name>
              <description>
              Update generation
              This bit can be set by software, it is automatically cleared by hardware.
              0: No action
              1: Re-initialize the counter and generates an update of the registers. Note that the prescaler counter is cleared too (anyway the prescaler ratio is not affected). The counter is cleared if the center-aligned mode is selected or if DIR=0 (upcounting), else it takes the auto-reload value (ARR) if DIR=1 (downcounting).
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD1</name>
          <displayName>RSVD1</displayName>
          <description></description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>CNT</name>
          <displayName>CNT</displayName>
          <description>Counter</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>CNT</name>
              <description>
              counter value
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PSC</name>
          <displayName>PSC</displayName>
          <description>Prescaler</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>PSC</name>
              <description>
              Prescaler value
              The counter clock frequency is equal to fCLK / (PSC[15:0] + 1).
              PSC contains the value to be loaded in the active prescaler register at each update event (including when the counter is cleared through UG bit of EGR register or through trigger controller when configured in "reset mode").
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ARR</name>
          <displayName>ARR</displayName>
          <description>Auto-reload register</description>
          <addressOffset>0x2c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ARR</name>
              <description>
              Auto-reload value
              ARR is the value to be loaded in the actual auto-reload register. The counter is blocked while the auto-reload value is null.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>GPADC</name>
      <description></description>
      <groupName>GPADC</groupName>
      <baseAddress>0x50016000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>ADC_CFG_REG1</name>
          <displayName>ADC_CFG_REG1</displayName>
          <description>ADC Analog Config Register 1</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x04714A44</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>ANAU_GPADC_CMM</name>
              <description>
              Tune CDAC CM voltage 375mV range (increasing) / 25mV step, 8: for 0.5V Vcm,in
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>ANAU_GPADC_CMPCL</name>
              <description>
              Tune ADC comparator CL= 3: 40f, range: 10fF (0) ~ 80fF (7) / 10fF step
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>ANAU_GPADC_VSP</name>
              <description>
              Set comparator input CM in sampling phase, 0.539V (0) / 0.578V (1) / 0.642V (2) / 0.784V (3)
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>ANAU_GPADC_LDOREF_EN</name>
              <description>
              Enable LDORF for ADC VREF
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ANAU_GPADC_LDOVREF_SEL</name>
              <description>
              Set reference voltage for LDOREF, range = 0.35V(0) ~ 0.65V(15), step = 20mV
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>ANAU_GPADC_SEL_PCH</name>
              <description>
              Select P-side input channel for GPADC, 0 for channel 0, 7 for channel 7, effective when force on
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>ANAU_GPADC_SEL_NCH</name>
              <description>
              Select N-side input channel for GPADC, 0 for channel 0, 7 for channel 7, effective when force on
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>ANAU_GPADC_MUTE</name>
              <description>
              Short GPADC P  and  N input to CMREF, i.e., VREF/2
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ANAU_GPADC_SE</name>
              <description>
              Set GPADC in single-ended mode, signal range at P-input: 0 ~ VREF
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ANAU_GPADC_EN_V18</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ANAU_GPADC_CL_DLY</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>ANAU_GPADC_P_INT_EN</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ANAU_GPADC_CMREF_FAST_EN</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ADC_SLOT0_REG</name>
          <displayName>ADC_SLOT0_REG</displayName>
          <description>ADC Slot0 Config Register </description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00020801</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>18</bitWidth>
            </field>
            <field>
              <name>NCHNL_SEL</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>PCHNL_SEL</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
            <field>
              <name>SLOT_EN</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ADC_SLOT1_REG</name>
          <displayName>ADC_SLOT1_REG</displayName>
          <description>ADC Slot1 Config Register </description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00020801</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>18</bitWidth>
            </field>
            <field>
              <name>NCHNL_SEL</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>PCHNL_SEL</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
            <field>
              <name>SLOT_EN</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ADC_SLOT2_REG</name>
          <displayName>ADC_SLOT2_REG</displayName>
          <description>ADC Slot2 Config Register </description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00020801</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>18</bitWidth>
            </field>
            <field>
              <name>NCHNL_SEL</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>PCHNL_SEL</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
            <field>
              <name>SLOT_EN</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ADC_SLOT3_REG</name>
          <displayName>ADC_SLOT3_REG</displayName>
          <description>ADC Slot3 Config Register </description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00020801</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>18</bitWidth>
            </field>
            <field>
              <name>NCHNL_SEL</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>PCHNL_SEL</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
            <field>
              <name>SLOT_EN</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ADC_SLOT4_REG</name>
          <displayName>ADC_SLOT4_REG</displayName>
          <description>ADC Slot4 Config Register </description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00020801</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>18</bitWidth>
            </field>
            <field>
              <name>NCHNL_SEL</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>PCHNL_SEL</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
            <field>
              <name>SLOT_EN</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ADC_SLOT5_REG</name>
          <displayName>ADC_SLOT5_REG</displayName>
          <description>ADC Slot5 Config Register </description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00020801</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>18</bitWidth>
            </field>
            <field>
              <name>NCHNL_SEL</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>PCHNL_SEL</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
            <field>
              <name>SLOT_EN</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ADC_SLOT6_REG</name>
          <displayName>ADC_SLOT6_REG</displayName>
          <description>ADC Slot6 Config Register </description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00020801</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>18</bitWidth>
            </field>
            <field>
              <name>NCHNL_SEL</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>PCHNL_SEL</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
            <field>
              <name>SLOT_EN</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ADC_SLOT7_REG</name>
          <displayName>ADC_SLOT7_REG</displayName>
          <description>ADC Slot7 Config Register </description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00020801</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>18</bitWidth>
            </field>
            <field>
              <name>NCHNL_SEL</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>PCHNL_SEL</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
            <field>
              <name>SLOT_EN</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ADC_RDATA0</name>
          <displayName>ADC_RDATA0</displayName>
          <description>ADC Read Data0</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>SLOT1_RDATA</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>SLOT0_RDATA</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ADC_RDATA1</name>
          <displayName>ADC_RDATA1</displayName>
          <description>ADC Read Data1</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>SLOT3_RDATA</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>SLOT2_RDATA</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ADC_RDATA2</name>
          <displayName>ADC_RDATA2</displayName>
          <description>ADC Read Data2</description>
          <addressOffset>0x2c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>SLOT5_RDATA</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>SLOT4_RDATA</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ADC_RDATA3</name>
          <displayName>ADC_RDATA3</displayName>
          <description>ADC Read Data3</description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>SLOT7_RDATA</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>SLOT6_RDATA</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ADC_DMA_RDATA</name>
          <displayName>ADC_DMA_RDATA</displayName>
          <description>ADC Read Data For DMA</description>
          <addressOffset>0x34</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>DMA_RDATA_RAW</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>13</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>DMA_RDATA</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>13</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ADC_CTRL_REG</name>
          <displayName>ADC_CTRL_REG</displayName>
          <description>ADC Control Register</description>
          <addressOffset>0x38</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000130</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
            <field>
              <name>DATA_SAMP_DLY</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>DMA_DATA_SEL</name>
              <description>
              0: combined data 1: raw data
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TIMER_TRIG_TYP</name>
              <description>
              0: pulse no edge detect needed  1: level,need edge detect
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TIMER_TRIG_SRC_SEL</name>
              <description>
              Timer trigger source select
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>FRC_EN_ADC</name>
              <description>
               Enable GPADC core
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CHNL_SEL_FRC_EN</name>
              <description>
              Enable input channel setting in ADC_CFG_REG1
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TIMER_TRIG_EN</name>
              <description>
              Enable timer trigger function 
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMA_EN</name>
              <description>
              Enable DMA interface
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>INIT_TIME</name>
              <description>
              GPADC will wait INIT_TIME ADCCLK cycles to start sample/conversion after being trigged 
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>ADC_STOP</name>
              <description>
              Write 1 to stop GPADC in continuous mode(need write 0 to clear)
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ADC_START</name>
              <description>
              Write 1 to start GPADC,(don't need clear )
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ADC_OP_MODE</name>
              <description>
              0: single conversion mode 1: continuous conversion mode
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ADC_CTRL_REG2</name>
          <displayName>ADC_CTRL_REG2</displayName>
          <description>ADC Control Register2</description>
          <addressOffset>0x3c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000130</resetValue>
          <fields>
            <field>
              <name>CONV_WIDTH</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>SAMP_WIDTH</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>GPADC_STATUS</name>
          <displayName>GPADC_STATUS</displayName>
          <description>GPADC Status Register</description>
          <addressOffset>0x40</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>CUR_SLOT</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>SLOT_DONE</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>ADC_DONE</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>GPADC_IRQ</name>
          <displayName>GPADC_IRQ</displayName>
          <description>GPADC IRQ Register</description>
          <addressOffset>0x44</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>28</bitWidth>
            </field>
            <field>
              <name>GPADC_ISR</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GPADC_IRSR</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GPADC_IMR</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GPADC_ICR</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>AUDCODEC_LP</name>
      <description></description>
      <groupName>AUDCODEC_LP</groupName>
      <baseAddress>0x50018000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>ID</name>
          <displayName>ID</displayName>
          <description></description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0xC0DEC001</resetValue>
          <fields>
            <field>
              <name>FUNC</name>
              <description>
              function id
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CFG</name>
          <displayName>CFG</displayName>
          <description></description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>29</bitWidth>
            </field>
            <field>
              <name>EN_DLY_SEL</name>
              <description>
              codec enable delay count
              0: no delay
              1: 32 pclk
              2: 64 pclk
              3: 128 pclk
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>ENABLE</name>
              <description>
              codec enable
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IRQ</name>
          <displayName>IRQ</displayName>
          <description></description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
            <field>
              <name>ADC_CH1_SAT_MSK</name>
              <description>
              interrupt mask. 0: mask the interrupt.
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ADC_CH1_APB_UF_MSK</name>
              <description>
              interrupt mask. 0: mask the interrupt.
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ADC_CH1_APB_OF_MSK</name>
              <description>
              interrupt mask. 0: mask the interrupt.
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ADC_CH0_SAT_MSK</name>
              <description>
              interrupt mask. 0: mask the interrupt.
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ADC_CH0_APB_UF_MSK</name>
              <description>
              interrupt mask. 0: mask the interrupt.
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ADC_CH0_APB_OF_MSK</name>
              <description>
              interrupt mask. 0: mask the interrupt.
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
            <field>
              <name>ADC_CH1_SAT</name>
              <description>
              adc ch1 saturation interrupt
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ADC_CH1_APB_UF</name>
              <description>
              adc ch1 apb fifo underflow interrupt status. Write 1 to clear.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ADC_CH1_APB_OF</name>
              <description>
              adc ch1 apb fifo overflow interrupt status. Write 1 to clear.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ADC_CH0_SAT</name>
              <description>
              adc ch0 saturation interrupt
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ADC_CH0_APB_UF</name>
              <description>
              adc ch0 apb fifo underflow interrupt status. Write 1 to clear.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ADC_CH0_APB_OF</name>
              <description>
              adc ch0 apb fifo overflow interrupt status. Write 1 to clear.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ADC_CFG</name>
          <displayName>ADC_CFG</displayName>
          <description></description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>CLK_DIV</name>
              <description>
              adc clock divider
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CLK_SRC_SEL</name>
              <description>
              adc clock source select
              1: pll
              0: xtal
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PATH_RESET</name>
              <description>
              adc path reset, set 1 to reset adc path
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OP_MODE</name>
              <description>
              adc operation mode
              2'h0: normal mode: send adc data out through rx interface
              2'h1: apb mode: send adc data out through apb interface
              2'h2: raw data apb mode: send adc raw data out through apb interface
              2'h3: reserved
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>OSR_SEL</name>
              <description>
              ADC oversample rate
              3'b000: 200
              3'b001: 300
              3'b010: 400
              3'b011: 600
              other: reserved
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD4</name>
          <displayName>RSVD4</displayName>
          <description></description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>APB_STAT</name>
          <displayName>APB_STAT</displayName>
          <description></description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>ADC_CH1_FIFO_CNT</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>ADC_CH0_FIFO_CNT</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD3</name>
          <displayName>RSVD3</displayName>
          <description></description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>ADC_CH0_CFG</name>
          <displayName>ADC_CH0_CFG</displayName>
          <description></description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
            <field>
              <name>SAT_DET_LEN</name>
              <description>
              adc saturation detect pattern length
              2'b00: 16
              2'b01: 24
              2'b10: 32
              2'b11: 48
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>SAT_DET_EN</name>
              <description>
              adc saturation detect
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DATA_FORMAT</name>
              <description>
              adc data format
              1: 16-bit
              0: 24-bit
              this bit only affect the data format accessed by apb interface. For 24-bit, every 24-bit data occupied 32-bit word. Bit[31:24] are zeros. For 16-bit mode, every 32-bit word contains two 16-bit audio data{D1, D0}
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FINE_VOL</name>
              <description>
              adc fine volume control
              range from 0dB to 6dB
              step is 0.5dB
              4'h0: 0dB
              4'h1: 0.5dB
              ......
              4'hb: 5.5dB
              4'hc, 4'hd, 4'he, 4'hf: mute
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>ROUGH_VOL</name>
              <description>
              adc rough volume control
              range from -60dB to 30dB
              step is 6dB
              4'h0: -60dB
              4'h1: -54dB
              ......
              4'ha: 0dB
              ......
              4'he: 24dB
              4'hf: 30dB
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>DMA_EN</name>
              <description>
              dma interface enable in apb mode and raw data apb mode
              1: enable adc ch0 dma request interface
              0: disable adc ch0 dma request interface
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>STB_INV</name>
              <description>
              adc strobe inverter
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HPF_COEF</name>
              <description>
              high-pass filter coefficient
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>HPF_BYPASS</name>
              <description>
              high-pass filter bypass
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ENABLE</name>
              <description>
              adc channel enable
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ADC_CH1_CFG</name>
          <displayName>ADC_CH1_CFG</displayName>
          <description></description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
            <field>
              <name>SAT_DET_LEN</name>
              <description>
              adc saturation detect pattern length
              2'b00: 16
              2'b01: 24
              2'b10: 32
              2'b11: 48
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>SAT_DET_EN</name>
              <description>
              adc saturation detect
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DATA_FORMAT</name>
              <description>
              adc data format
              1: 16-bit
              0: 24-bit
              this bit only affect the data format accessed by apb interface. For 24-bit, every 24-bit data occupied 32-bit word. Bit[31:24] are zeros. For 16-bit mode, every 32-bit word contains two 16-bit audio data{D1, D0}
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FINE_VOL</name>
              <description>
              adc fine volume control
              range from 0dB to 6dB
              step is 0.5dB
              4'h0: 0dB
              4'h1: 0.5dB
              ......
              4'hb: 5.5dB
              4'hc, 4'hd, 4'he, 4'hf: mute
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>ROUGH_VOL</name>
              <description>
              adc rough volume control
              range from -60dB to 30dB
              step is 6dB
              4'h0: -60dB
              4'h1: -54dB
              ......
              4'ha: 0dB
              ......
              4'he: 24dB
              4'hf: 30dB
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>DMA_EN</name>
              <description>
              dma interface enable in apb mode and raw data apb mode
              1: enable adc ch0 dma request interface
              0: disable adc ch0 dma request interface
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>STB_INV</name>
              <description>
              adc strobe inverter
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HPF_COEF</name>
              <description>
              high-pass filter coefficient
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>HPF_BYPASS</name>
              <description>
              high-pass filter bypass
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ENABLE</name>
              <description>
              adc channel enable
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD2</name>
          <displayName>RSVD2</displayName>
          <description></description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>ADC_CH0_ENTRY</name>
          <displayName>ADC_CH0_ENTRY</displayName>
          <description></description>
          <addressOffset>0x40</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              adc channel0 data output
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ADC_CH1_ENTRY</name>
          <displayName>ADC_CH1_ENTRY</displayName>
          <description></description>
          <addressOffset>0x44</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              adc channel1 data output
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD1</name>
          <displayName>RSVD1</displayName>
          <description></description>
          <addressOffset>0x48</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>COMMON_CFG</name>
          <displayName>COMMON_CFG</displayName>
          <description></description>
          <addressOffset>0x60</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>DC_MR</name>
              <description>
              DC test Macro select
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>DC_BR</name>
              <description>
              DC test Block select
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>DC_TR</name>
              <description>
              DC test point select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BG_CFG0</name>
          <displayName>BG_CFG0</displayName>
          <description></description>
          <addressOffset>0x64</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>21</bitWidth>
            </field>
            <field>
              <name>MIC_VREF_SEL</name>
              <description>
              select mic vref
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>EN_RCFLT</name>
              <description>
              enable bandgap rc filter
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EN_SMPL</name>
              <description>
              enable bandgap sample
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EN_CHOP</name>
              <description>
              enable bandgap chop
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>VREF_SEL</name>
              <description>
              set vref, 7: 2.8V
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>LP_MODE</name>
              <description>
              1: bandgap lp mode
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EN</name>
              <description>
              enable bandgap
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BG_CFG1</name>
          <displayName>BG_CFG1</displayName>
          <description></description>
          <addressOffset>0x68</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>SAMPCLK_HI</name>
              <description>
              bg sample clock high cycle width, based on  0: stop bg sample clock
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BG_CFG2</name>
          <displayName>BG_CFG2</displayName>
          <description></description>
          <addressOffset>0x6c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>SAMPCLK_LO</name>
              <description>
              bg sample clock low cycle width. 0: stop bg sample clock
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>REFGEN_CFG</name>
          <displayName>REFGEN_CFG</displayName>
          <description></description>
          <addressOffset>0x70</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>DISCHG</name>
              <description>
              discharge vref
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RZSEL</name>
              <description>
              sel Rz, 0: 1uF cap
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>LV_MODE</name>
              <description>
              low vol mode
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LP_MODE</name>
              <description>
              1: lpmode(adc), 0:dac
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BM</name>
              <description>
              bias mode
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>EN_CHOP</name>
              <description>
              enable ref gen chop
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EN</name>
              <description>
              enable ref gen
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PLL_CFG0</name>
          <displayName>PLL_CFG0</displayName>
          <description></description>
          <addressOffset>0x74</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SEL_CKREF</name>
              <description>
              select ref clock, 2: 24MHz
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>EN_IARY</name>
              <description>
              enable I array
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EN_VCO</name>
              <description>
              enable vco
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SEL_VREF_VCO</name>
              <description>
              ldo vref, 7:1.1V
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>EN_VCO_FLT</name>
              <description>
              vco bais filter
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FC_VCO</name>
              <description>
              VCO Fcode
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>VCO_LP_MODE</name>
              <description>
              1: lp mode
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EN_ANA</name>
              <description>
              enable ana block
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SEL_VREF_ANA</name>
              <description>
              ldo vref, 7:1.1V
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>ICP_SEL</name>
              <description>
              select Icp, 1:1.25u
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>OPEN</name>
              <description>
              1: pll open
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ICP_OS_SEL</name>
              <description>
              Icp os
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PLL_CFG1</name>
          <displayName>PLL_CFG1</displayName>
          <description></description>
          <addressOffset>0x78</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>CSD_EN</name>
              <description>
              enable CSD
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CSD_RST</name>
              <description>
              reset CSD, high active
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CZ_SEL</name>
              <description>
              select Cz
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>C2_SEL</name>
              <description>
              select C2
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RZ_SEL</name>
              <description>
              select Rz
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>R3_SEL</name>
              <description>
              select R3
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PLL_CFG2</name>
          <displayName>PLL_CFG2</displayName>
          <description></description>
          <addressOffset>0x7c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>13</bitWidth>
            </field>
            <field>
              <name>EN_LF_VCIN</name>
              <description>
              enable vcin for vco
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SEL_LF_VCIN</name>
              <description>
              select vcin, 4: 550mV
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>EN_LF_TSTBUF</name>
              <description>
              enable vctrl buf
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EN_DIG</name>
              <description>
              enable dig block
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SEL_VREF_DIG</name>
              <description>
              ldo vref, 7:1.1V
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>RSTB</name>
              <description>
              resetb
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSTB_SYNC_EN</name>
              <description>
              resetb sync
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TE_DTEST</name>
              <description>
              enable dtest
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TR_DTEST</name>
              <description>
              select dtest
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>MMD_STG</name>
              <description>
              mmd stg
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PLL_CFG3</name>
          <displayName>PLL_CFG3</displayName>
          <description></description>
          <addressOffset>0x80</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>SDMCLK_POL</name>
              <description>
              sdm dig clk polarity
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EN_SDM</name>
              <description>
              enable sdm
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SDM_DITHER</name>
              <description>
              sdm dither
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EN_SDM_DITHER</name>
              <description>
              enable sdm dither
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SDM_MODE</name>
              <description>
              sdm mode
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SDMIN_BYPASS</name>
              <description>
              1: bypass FCW and SDIN sdm control signal
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SDM_UPDATE</name>
              <description>
              write 1 to update FCW and SDIN value
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FCW</name>
              <description>
              FCW
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>SDIN</name>
              <description>
              sdm input
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PLL_CFG4</name>
          <displayName>PLL_CFG4</displayName>
          <description></description>
          <addressOffset>0x84</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
            <field>
              <name>EN_CLK_DIG</name>
              <description>
              enable dig clk 
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DIVA_CLK_DIG</name>
              <description>
              DIVA dig clk
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>CLK_DIG_STR</name>
              <description>
              strength
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>SEL_CLK_DIG</name>
              <description>
              select dig clk 0: pll  1: 24MHz from xtal
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SEL_CLK_DAC_SOURCE</name>
              <description>
              0: xtal 1: pll
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>EN_CLK_DAC</name>
              <description>
              enable dac clk
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DIVA_CLK_DAC</name>
              <description>
              DIVA dac clk
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>EN_CLK_CHOP_DAC</name>
              <description>
              enable dac chop clk
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DIVA_CLK_CHOP_DAC</name>
              <description>
              DIVA dac chop clk
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>DIVB_CLK_CHOP_DAC</name>
              <description>
              DIVB dac chop clk
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PLL_CFG5</name>
          <displayName>PLL_CFG5</displayName>
          <description></description>
          <addressOffset>0x88</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>EN_CLK_DAC2</name>
              <description>
              enable dac2 clk
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DIVA_CLK_DAC2</name>
              <description>
              DIVA dac2 clk
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>EN_CLK_CHOP_DAC2</name>
              <description>
              enable dac2 chop clk
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DIVA_CLK_CHOP_DAC2</name>
              <description>
              DIVA dac2 chop clk
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>DIVB_CLK_CHOP_DAC2</name>
              <description>
              DIVB dac2 chop clk
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>EN_CLK_CHOP_REFGEN</name>
              <description>
              enable ref chop clk
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DIVA_CLK_CHOP_REFGEN</name>
              <description>
              DIVA ref chop clk
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>DIVB_CLK_CHOP_REFGEN</name>
              <description>
              DIVB ref chop clk
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>EN_CLK_CHOP_BG</name>
              <description>
              enable bg chop clk
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DIVA_CLK_CHOP_BG</name>
              <description>
              DIVA bg chop clk
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>DIVB_CLK_CHOP_BG</name>
              <description>
              DIVB bg chop clk
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PLL_CFG6</name>
          <displayName>PLL_CFG6</displayName>
          <description></description>
          <addressOffset>0x8c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>SEL_CLK_ADC_SOURCE</name>
              <description>
              0: xtal, 1: pll
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>EN_CLK_ADC0</name>
              <description>
              enable adc0 clk
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DIVA_CLK_ADC0</name>
              <description>
              DIVA adc0 clk
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>SEL_CLK_ADC0</name>
              <description>
              select adc0 clk
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EN_CLK_ADC1</name>
              <description>
              enable adc1 clk
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DIVA_CLK_ADC1</name>
              <description>
              DIVA adc1 clk
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>SEL_CLK_ADC1</name>
              <description>
              select adc1 clk
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EN_CLK_ADC2</name>
              <description>
              enable adc2 clk
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DIVA_CLK_ADC2</name>
              <description>
              DIVA adc2 clk
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>SEL_CLK_ADC2</name>
              <description>
              select adc2 clk
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EN_CLK_CHOP_MICBIAS</name>
              <description>
              enable micbias chop clk
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SEL_CLK_CHOP_MICBIAS</name>
              <description>
              select micbias chop clk
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>EN_CLK_RCCAL</name>
              <description>
              enable RC CAL clk
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EN_TST_CLK</name>
              <description>
              enable test clk
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SEL_TST_CLK</name>
              <description>
              select clk to test
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PLL_STAT</name>
          <displayName>PLL_STAT</displayName>
          <description></description>
          <addressOffset>0x90</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>29</bitWidth>
            </field>
            <field>
              <name>SLIPPED_DN</name>
              <description>
              slip dn
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SLIPPED_UP</name>
              <description>
              slip up
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UNLOCK</name>
              <description>
              1:pll unlock
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PLL_CAL_CFG</name>
          <displayName>PLL_CAL_CFG</displayName>
          <description></description>
          <addressOffset>0x94</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>LEN</name>
              <description>
              calibration length
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>14</bitWidth>
            </field>
            <field>
              <name>DONE</name>
              <description>
              calibration done
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EN</name>
              <description>
              calibration enable
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PLL_CAL_RESULT</name>
          <displayName>PLL_CAL_RESULT</displayName>
          <description></description>
          <addressOffset>0x98</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>PLL_CNT</name>
              <description>
              pll calibration counter result
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>XTAL_CNT</name>
              <description>
              xtal calibration counter result
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ADC_ANA_CFG</name>
          <displayName>ADC_ANA_CFG</displayName>
          <description></description>
          <addressOffset>0x9c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>25</bitWidth>
            </field>
            <field>
              <name>CAPCODE</name>
              <description>
              ADC cap code
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>MICBIAS_EN</name>
              <description>
              micbias enable
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MICBIAS_CHOP_EN</name>
              <description>
              micbias chopping enable
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ADC1_CFG1</name>
          <displayName>ADC1_CFG1</displayName>
          <description></description>
          <addressOffset>0xa0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
            <field>
              <name>FSP</name>
              <description>
              sampling frequency:
              0x0:9.6M
              0x1:8.82M
              0x2:4.8M
              0x3:4.41M
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>GC</name>
              <description>
              gaincode:
              0x0:-10dB
              0xa:0dB
              0x1e:20dB
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>VST_SEL</name>
              <description>
              start voltage
              0x0:VCM+200mV
              0x7:VCM+550mV
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>BM_INT1</name>
              <description>
              bias mode of first opamp
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>BM_INT2</name>
              <description>
              bias mode of 2nd and 3rd opamp
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>VREF_SEL</name>
              <description>
              vref code from proper vcm in flash7
              0x0:1.2V
              0x1:1.4V
              0x7:2.6V
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>FCHOP_SEL</name>
              <description>
              chopping frequncy
              0x0:8
              0x1:16
              0x2:32
              0x3:64
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>VCMST</name>
              <description>
              VCM quick settling
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CLKOUT_INV</name>
              <description>
              inverse output clock
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PERI_BM</name>
              <description>
              peripheral circuits biasmode
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ADC1_CFG2</name>
          <displayName>ADC1_CFG2</displayName>
          <description></description>
          <addressOffset>0xa4</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>28</bitWidth>
            </field>
            <field>
              <name>EN</name>
              <description>
              enable adc
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSTB</name>
              <description>
              reset adc
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CHOP_EN</name>
              <description>
              chopping enable
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CLEAR</name>
              <description>
              clear adc
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ADC2_CFG1</name>
          <displayName>ADC2_CFG1</displayName>
          <description></description>
          <addressOffset>0xa8</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
            <field>
              <name>FSP</name>
              <description>
              sampling frequency:
              0x0:9.6M
              0x1:8.82M
              0x2:4.8M
              0x3:4.41M
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>GC</name>
              <description>
              gaincode:
              0x0:-10dB
              0xa:0dB
              0x1e:20dB
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>VST_SEL</name>
              <description>
              start voltage
              0x0:VCM+200mV
              0x7:VCM+550mV
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>BM_INT1</name>
              <description>
              bias mode of first opamp
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>BM_INT2</name>
              <description>
              bias mode of 2nd and 3rd opamp
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>VREF_SEL</name>
              <description>
              vref code from proper vcm in flash7
              0x0:1.2V
              0x1:1.4V
              0x7:2.6V
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>FCHOP_SEL</name>
              <description>
              chopping frequncy
              0x0:8
              0x1:16
              0x2:32
              0x3:64
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>VCMST</name>
              <description>
              VCM quick settling
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CLKOUT_INV</name>
              <description>
              inverse output clock
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PERI_BM</name>
              <description>
              peripheral circuits biasmode
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ADC2_CFG2</name>
          <displayName>ADC2_CFG2</displayName>
          <description></description>
          <addressOffset>0xac</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>28</bitWidth>
            </field>
            <field>
              <name>EN</name>
              <description>
              enable adc
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSTB</name>
              <description>
              reset adc
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CHOP_EN</name>
              <description>
              chopping enable
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CLEAR</name>
              <description>
              clear adc
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DAC1_CFG</name>
          <displayName>DAC1_CFG</displayName>
          <description></description>
          <addressOffset>0xb0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>SEL_VSTART</name>
              <description>
              select Vstart
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>EN_DAC</name>
              <description>
              enable dac
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EN_VCM</name>
              <description>
              enable vcm
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EN_AMP</name>
              <description>
              enable amp
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EN_CHOP</name>
              <description>
              enable chop
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BM</name>
              <description>
              bias mode
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>SEL_VCM</name>
              <description>
              select vcm
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>LP_MODE</name>
              <description>
              0: 3.3V sup, 1: 1.8V supply
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>POL_CLK</name>
              <description>
              dac clk polarity
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              dac short switch 
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GAIN</name>
              <description>
              dac gain
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>OS_DAC</name>
              <description>
              os dac
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
            <field>
              <name>EN_OS_DAC</name>
              <description>
              enable os dac
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DAC2_CFG</name>
          <displayName>DAC2_CFG</displayName>
          <description></description>
          <addressOffset>0xb4</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>SEL_VSTART</name>
              <description>
              select Vstart
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>EN_DAC</name>
              <description>
              enable dac
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EN_VCM</name>
              <description>
              enable vcm
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EN_AMP</name>
              <description>
              enable amp
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EN_CHOP</name>
              <description>
              enable chop
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BM</name>
              <description>
              bias mode
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>SEL_VCM</name>
              <description>
              select vcm
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>LP_MODE</name>
              <description>
              0: 3.3V sup, 1: 1.8V supply
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>POL_CLK</name>
              <description>
              dac clk polarity
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SR</name>
              <description>
              dac short switch 
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GAIN</name>
              <description>
              dac gain
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>OS_DAC</name>
              <description>
              os dac
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
            <field>
              <name>EN_OS_DAC</name>
              <description>
              enable os dac
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RESERVED_IN0</name>
          <displayName>RESERVED_IN0</displayName>
          <description></description>
          <addressOffset>0xb8</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>CTRL3</name>
              <description>
              reserved control 3
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>CTRL2</name>
              <description>
              reserved control 2
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>CTRL1</name>
              <description>
              reserved control 1
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>CTRL0</name>
              <description>
              reserved control 0
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RESERVED_IN1</name>
          <displayName>RESERVED_IN1</displayName>
          <description></description>
          <addressOffset>0xbc</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>CTRL5</name>
              <description>
              reserved control 5
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>CTRL4</name>
              <description>
              reserved control 4
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RESERVED_OUT</name>
          <displayName>RESERVED_OUT</displayName>
          <description></description>
          <addressOffset>0xc0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>STAT1</name>
              <description>
              reserved status1
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>STAT0</name>
              <description>
              reserved status0
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>TSEN</name>
      <description></description>
      <groupName>TSEN</groupName>
      <baseAddress>0x5001a000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>TSEN_CTRL_REG</name>
          <displayName>TSEN_CTRL_REG</displayName>
          <description>TSEN Analog Control Register </description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x04714A44</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>14</bitWidth>
            </field>
            <field>
              <name>ANAU_TSEN_CLK_DIV</name>
              <description>
              gen tsen clk by divide hclk by anau_tsen_clk_div
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>ANAU_TSEN_EN</name>
              <description>
              Enable tsen digital module
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ANAU_TSEN_RDY</name>
              <description>
              tsen ready
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ANAU_TSEN_SER_PAR_SEL</name>
              <description>
              serial-parallel output selection
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ANAU_TSEN_SGN_EN</name>
              <description>
              signature-mode enable
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ANAU_TSEN_FCK_SEL</name>
              <description>
              select internal clock frequency
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>ANAU_TSEN_IG_VBE</name>
              <description>
              bias current selection to tune vba
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>ANAU_TSEN_RUN</name>
              <description>
              enable tsen run
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ANAU_TSEN_RSTB</name>
              <description>
              resetb for tsen
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ANAU_TSEN_PU</name>
              <description>
              power up tsen
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TSEN_RDATA</name>
          <displayName>TSEN_RDATA</displayName>
          <description>Tsen Read Data</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>TSEN_RDATA</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TSEN_IRQ</name>
          <displayName>TSEN_IRQ</displayName>
          <description>Tsen IRQ Register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>28</bitWidth>
            </field>
            <field>
              <name>TSEN_ISR</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TSEN_IRSR</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TSEN_IMR</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TSEN_ICR</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD1</name>
          <displayName>RSVD1</displayName>
          <description></description>
          <addressOffset>0xC</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>ANAU_ANA_TP</name>
          <displayName>ANAU_ANA_TP</displayName>
          <description>Tsen IRQ Register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>25</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>ANAU_IARY_EN</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BGR</name>
          <displayName>BGR</displayName>
          <description>Bandgap registers</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000CC0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
            <field>
              <name>VREF12</name>
              <description>
              select VREF 1.2V
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>VREF06</name>
              <description>
              select VREF 0.6V
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>EN</name>
              <description>
              Bandgap enable
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PTC2</name>
      <description></description>
      <groupName>PTC</groupName>
      <baseAddress>0x5001b000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>ISR</name>
          <displayName>ISR</displayName>
          <description>interrupt status register</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>TEIF8</name>
              <description>
              transfer error flag for task 8
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIF7</name>
              <description>
              transfer error flag for task 7
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIF6</name>
              <description>
              transfer error flag for task 6
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIF5</name>
              <description>
              transfer error flag for task 5
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIF4</name>
              <description>
              transfer error flag for task 4
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIF3</name>
              <description>
              transfer error flag for task 3
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIF2</name>
              <description>
              transfer error flag for task 2
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TEIF1</name>
              <description>
              transfer error flag for task 1
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>TCIF8</name>
              <description>
              task complete interrupt flag for task 8
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIF7</name>
              <description>
              task complete interrupt flag for task 7
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIF6</name>
              <description>
              task complete interrupt flag for task 6
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIF5</name>
              <description>
              task complete interrupt flag for task 5
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIF4</name>
              <description>
              task complete interrupt flag for task 4
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIF3</name>
              <description>
              task complete interrupt flag for task 3
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIF2</name>
              <description>
              task complete interrupt flag for task 2
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIF1</name>
              <description>
              task complete interrupt flag for task 1
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ICR</name>
          <displayName>ICR</displayName>
          <description>interrupt clear register</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>15</bitWidth>
            </field>
            <field>
              <name>CTEIF</name>
              <description>
              clear transfer error flag
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>CTCIF8</name>
              <description>
              clear task complete interrupt flag for task 8
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTCIF7</name>
              <description>
              clear task complete interrupt flag for task 7
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTCIF6</name>
              <description>
              clear task complete interrupt flag for task 6
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTCIF5</name>
              <description>
              clear task complete interrupt flag for task 5
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTCIF4</name>
              <description>
              clear task complete interrupt flag for task 4
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTCIF3</name>
              <description>
              clear task complete interrupt flag for task 3
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTCIF2</name>
              <description>
              clear task complete interrupt flag for task 2
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTCIF1</name>
              <description>
              clear task complete interrupt flag for task 1
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IER</name>
          <displayName>IER</displayName>
          <description>interrupt enable register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>15</bitWidth>
            </field>
            <field>
              <name>TEIE</name>
              <description>
              enable transfer error flag
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>TCIE8</name>
              <description>
              enable task complete interrupt for task 8
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIE7</name>
              <description>
              enable task complete interrupt for task 7
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIE6</name>
              <description>
              enable task complete interrupt for task 6
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIE5</name>
              <description>
              enable task complete interrupt for task 5
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIE4</name>
              <description>
              enable task complete interrupt for task 4
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIE3</name>
              <description>
              enable task complete interrupt for task 3
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIE2</name>
              <description>
              enable task complete interrupt for task 2
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIE1</name>
              <description>
              enable task complete interrupt for task 1
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD2</name>
          <displayName>RSVD2</displayName>
          <description></description>
          <addressOffset>0xC</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>TCR1</name>
          <displayName>TCR1</displayName>
          <description>task 1 control register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>REPIRQ</name>
              <description>
              repetition interrupt
              0: interrupt will be generated after each operation
              1: interrupt will be generated after operation for REP times
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>REPTRIG</name>
              <description>
              repetition trigger
              0: ptc trigger will be generated after each operation
              1: ptc trigger will be generated after operation for REP times
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>REPEN</name>
              <description>
              repetition enable
              0: task will be triggerd no matter what value REP is
              1: task will only be triggerd when REP is not 0
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SWTRIG</name>
              <description>
              software trigger
              task will be triggerd at once after SWTRIG set. SWTRIG will be cleared automatically.
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TRIGPOL</name>
              <description>
              trigger polarity
              0: select positive edge of trigger
              1: select negative edge of trigger
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OP</name>
              <description>
              task operation
              3'b000: direct write data
              3'b100: read then XOR with data and write back
              3'b101: read then OR with data and write back
              3'b110: read then AND with data and write back
              3'b111: read then add with data and write back
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>TRIGSEL</name>
              <description>
              select trigger source
              0: task will only be triggered by SWTRIG
              others: task will be triggered by selected source or SWTRIG
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TAR1</name>
          <displayName>TAR1</displayName>
          <description>task 1 address register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ADDR</name>
              <description>
              peripheral address to access to
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TDR1</name>
          <displayName>TDR1</displayName>
          <description>task 1 data register</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              data value for task operation
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RCR1</name>
          <displayName>RCR1</displayName>
          <description>task 1 repetition and delay counter register</description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DLY</name>
              <description>
              Delay time before task operation after triggered
              0: no delay
              others: delay DLY HCLK cycles before task operation
              DLY is read as left delay time. DLY will be reloaded automatically after each operation.
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>REP</name>
              <description>
              Repetition counter value
              if REPEN is 1, task will only be triggerd when REP is not 0. 
              when REP is larger than 0, it will be decrease by 1 automatically each time task triggered.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TCR2</name>
          <displayName>TCR2</displayName>
          <description></description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>REPIRQ</name>
              <description>
              repetition interrupt
              0: interrupt will be generated after each operation
              1: interrupt will be generated after operation for REP times
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>REPTRIG</name>
              <description>
              repetition trigger
              0: ptc trigger will be generated after each operation
              1: ptc trigger will be generated after operation for REP times
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>REPEN</name>
              <description>
              repetition enable
              0: task will be triggerd no matter what value REP is
              1: task will only be triggerd when REP is not 0
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SWTRIG</name>
              <description>
              software trigger
              task will be triggerd at once after SWTRIG set. SWTRIG will be cleared automatically.
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TRIGPOL</name>
              <description>
              trigger polarity
              0: select positive edge of trigger
              1: select negative edge of trigger
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OP</name>
              <description>
              task operation
              3'b000: direct write data
              3'b100: read then XOR with data and write back
              3'b101: read then OR with data and write back
              3'b110: read then AND with data and write back
              3'b111: read then add with data and write back
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>TRIGSEL</name>
              <description>
              select trigger source
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TAR2</name>
          <displayName>TAR2</displayName>
          <description></description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ADDR</name>
              <description>
              peripheral address to access to
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TDR2</name>
          <displayName>TDR2</displayName>
          <description></description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              data value for task operation
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RCR2</name>
          <displayName>RCR2</displayName>
          <description>task 2 repetition and delay counter register</description>
          <addressOffset>0x2c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DLY</name>
              <description>
              Delay time before task operation after triggered
              0: no delay
              others: delay DLY HCLK cycles before task operation
              DLY is read as left delay time. DLY will be reloaded automatically after each operation.
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>REP</name>
              <description>
              Repetition counter value
              if REPEN is 1, task will only be triggerd when REP is not 0. 
              when REP is larger than 0, it will be decrease by 1 automatically each time task triggered.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TCR3</name>
          <displayName>TCR3</displayName>
          <description></description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>REPIRQ</name>
              <description>
              repetition interrupt
              0: interrupt will be generated after each operation
              1: interrupt will be generated after operation for REP times
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>REPTRIG</name>
              <description>
              repetition trigger
              0: ptc trigger will be generated after each operation
              1: ptc trigger will be generated after operation for REP times
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>REPEN</name>
              <description>
              repetition enable
              0: task will be triggerd no matter what value REP is
              1: task will only be triggerd when REP is not 0
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SWTRIG</name>
              <description>
              software trigger
              task will be triggerd at once after SWTRIG set. SWTRIG will be cleared automatically.
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TRIGPOL</name>
              <description>
              trigger polarity
              0: select positive edge of trigger
              1: select negative edge of trigger
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OP</name>
              <description>
              task operation
              3'b000: direct write data
              3'b100: read then XOR with data and write back
              3'b101: read then OR with data and write back
              3'b110: read then AND with data and write back
              3'b111: read then add with data and write back
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>TRIGSEL</name>
              <description>
              select trigger source
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TAR3</name>
          <displayName>TAR3</displayName>
          <description></description>
          <addressOffset>0x34</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ADDR</name>
              <description>
              peripheral address to access to
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TDR3</name>
          <displayName>TDR3</displayName>
          <description></description>
          <addressOffset>0x38</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              data value for task operation
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RCR3</name>
          <displayName>RCR3</displayName>
          <description>task 3 repetition and delay counter register</description>
          <addressOffset>0x3c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DLY</name>
              <description>
              Delay time before task operation after triggered
              0: no delay
              others: delay DLY HCLK cycles before task operation
              DLY is read as left delay time. DLY will be reloaded automatically after each operation.
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>REP</name>
              <description>
              Repetition counter value
              if REPEN is 1, task will only be triggerd when REP is not 0. 
              when REP is larger than 0, it will be decrease by 1 automatically each time task triggered.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TCR4</name>
          <displayName>TCR4</displayName>
          <description></description>
          <addressOffset>0x40</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>REPIRQ</name>
              <description>
              repetition interrupt
              0: interrupt will be generated after each operation
              1: interrupt will be generated after operation for REP times
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>REPTRIG</name>
              <description>
              repetition trigger
              0: ptc trigger will be generated after each operation
              1: ptc trigger will be generated after operation for REP times
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>REPEN</name>
              <description>
              repetition enable
              0: task will be triggerd no matter what value REP is
              1: task will only be triggerd when REP is not 0
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SWTRIG</name>
              <description>
              software trigger
              task will be triggerd at once after SWTRIG set. SWTRIG will be cleared automatically.
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TRIGPOL</name>
              <description>
              trigger polarity
              0: select positive edge of trigger
              1: select negative edge of trigger
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OP</name>
              <description>
              task operation
              3'b000: direct write data
              3'b100: read then XOR with data and write back
              3'b101: read then OR with data and write back
              3'b110: read then AND with data and write back
              3'b111: read then add with data and write back
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>TRIGSEL</name>
              <description>
              select trigger source
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TAR4</name>
          <displayName>TAR4</displayName>
          <description></description>
          <addressOffset>0x44</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ADDR</name>
              <description>
              peripheral address to access to
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TDR4</name>
          <displayName>TDR4</displayName>
          <description></description>
          <addressOffset>0x48</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              data value for task operation
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RCR4</name>
          <displayName>RCR4</displayName>
          <description>task 4 repetition and delay counter register</description>
          <addressOffset>0x4c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DLY</name>
              <description>
              Delay time before task operation after triggered
              0: no delay
              others: delay DLY HCLK cycles before task operation
              DLY is read as left delay time. DLY will be reloaded automatically after each operation.
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>REP</name>
              <description>
              Repetition counter value
              if REPEN is 1, task will only be triggerd when REP is not 0. 
              when REP is larger than 0, it will be decrease by 1 automatically each time task triggered.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TCR5</name>
          <displayName>TCR5</displayName>
          <description></description>
          <addressOffset>0x50</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>REPIRQ</name>
              <description>
              repetition interrupt
              0: interrupt will be generated after each operation
              1: interrupt will be generated after operation for REP times
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>REPTRIG</name>
              <description>
              repetition trigger
              0: ptc trigger will be generated after each operation
              1: ptc trigger will be generated after operation for REP times
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>REPEN</name>
              <description>
              repetition enable
              0: task will be triggerd no matter what value REP is
              1: task will only be triggerd when REP is not 0
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SWTRIG</name>
              <description>
              software trigger
              task will be triggerd at once after SWTRIG set. SWTRIG will be cleared automatically.
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TRIGPOL</name>
              <description>
              trigger polarity
              0: select positive edge of trigger
              1: select negative edge of trigger
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OP</name>
              <description>
              task operation
              3'b000: direct write data
              3'b100: read then XOR with data and write back
              3'b101: read then OR with data and write back
              3'b110: read then AND with data and write back
              3'b111: read then add with data and write back
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>TRIGSEL</name>
              <description>
              select trigger source
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TAR5</name>
          <displayName>TAR5</displayName>
          <description></description>
          <addressOffset>0x54</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ADDR</name>
              <description>
              peripheral address to access to
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TDR5</name>
          <displayName>TDR5</displayName>
          <description></description>
          <addressOffset>0x58</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              data value for task operation
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RCR5</name>
          <displayName>RCR5</displayName>
          <description>task 5 repetition counter register</description>
          <addressOffset>0x5c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>22</bitWidth>
            </field>
            <field>
              <name>REP</name>
              <description>
              Repetition counter value
              if REPEN is 1, task will only be triggerd when REP is not 0. 
              when REP is larger than 0, it will be decrease by 1 automatically each time task triggered.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TCR6</name>
          <displayName>TCR6</displayName>
          <description></description>
          <addressOffset>0x60</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>REPIRQ</name>
              <description>
              repetition interrupt
              0: interrupt will be generated after each operation
              1: interrupt will be generated after operation for REP times
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>REPTRIG</name>
              <description>
              repetition trigger
              0: ptc trigger will be generated after each operation
              1: ptc trigger will be generated after operation for REP times
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>REPEN</name>
              <description>
              repetition enable
              0: task will be triggerd no matter what value REP is
              1: task will only be triggerd when REP is not 0
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SWTRIG</name>
              <description>
              software trigger
              task will be triggerd at once after SWTRIG set. SWTRIG will be cleared automatically.
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TRIGPOL</name>
              <description>
              trigger polarity
              0: select positive edge of trigger
              1: select negative edge of trigger
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OP</name>
              <description>
              task operation
              3'b000: direct write data
              3'b100: read then XOR with data and write back
              3'b101: read then OR with data and write back
              3'b110: read then AND with data and write back
              3'b111: read then add with data and write back
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>TRIGSEL</name>
              <description>
              select trigger source
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TAR6</name>
          <displayName>TAR6</displayName>
          <description></description>
          <addressOffset>0x64</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ADDR</name>
              <description>
              peripheral address to access to
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TDR6</name>
          <displayName>TDR6</displayName>
          <description></description>
          <addressOffset>0x68</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              data value for task operation
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RCR6</name>
          <displayName>RCR6</displayName>
          <description>task 6 repetition counter register</description>
          <addressOffset>0x6c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>22</bitWidth>
            </field>
            <field>
              <name>REP</name>
              <description>
              Repetition counter value
              if REPEN is 1, task will only be triggerd when REP is not 0. 
              when REP is larger than 0, it will be decrease by 1 automatically each time task triggered.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TCR7</name>
          <displayName>TCR7</displayName>
          <description></description>
          <addressOffset>0x70</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>REPIRQ</name>
              <description>
              repetition interrupt
              0: interrupt will be generated after each operation
              1: interrupt will be generated after operation for REP times
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>REPTRIG</name>
              <description>
              repetition trigger
              0: ptc trigger will be generated after each operation
              1: ptc trigger will be generated after operation for REP times
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>REPEN</name>
              <description>
              repetition enable
              0: task will be triggerd no matter what value REP is
              1: task will only be triggerd when REP is not 0
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SWTRIG</name>
              <description>
              software trigger
              task will be triggerd at once after SWTRIG set. SWTRIG will be cleared automatically.
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TRIGPOL</name>
              <description>
              trigger polarity
              0: select positive edge of trigger
              1: select negative edge of trigger
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OP</name>
              <description>
              task operation
              3'b000: direct write data
              3'b100: read then XOR with data and write back
              3'b101: read then OR with data and write back
              3'b110: read then AND with data and write back
              3'b111: read then add with data and write back
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>TRIGSEL</name>
              <description>
              select trigger source
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TAR7</name>
          <displayName>TAR7</displayName>
          <description></description>
          <addressOffset>0x74</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ADDR</name>
              <description>
              peripheral address to access to
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TDR7</name>
          <displayName>TDR7</displayName>
          <description></description>
          <addressOffset>0x78</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              data value for task operation
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RCR7</name>
          <displayName>RCR7</displayName>
          <description>task 7 repetition counter register</description>
          <addressOffset>0x7c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>22</bitWidth>
            </field>
            <field>
              <name>REP</name>
              <description>
              Repetition counter value
              if REPEN is 1, task will only be triggerd when REP is not 0. 
              when REP is larger than 0, it will be decrease by 1 automatically each time task triggered.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TCR8</name>
          <displayName>TCR8</displayName>
          <description></description>
          <addressOffset>0x80</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>REPIRQ</name>
              <description>
              repetition interrupt
              0: interrupt will be generated after each operation
              1: interrupt will be generated after operation for REP times
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>REPTRIG</name>
              <description>
              repetition trigger
              0: ptc trigger will be generated after each operation
              1: ptc trigger will be generated after operation for REP times
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>REPEN</name>
              <description>
              repetition enable
              0: task will be triggerd no matter what value REP is
              1: task will only be triggerd when REP is not 0
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SWTRIG</name>
              <description>
              software trigger
              task will be triggerd at once after SWTRIG set. SWTRIG will be cleared automatically.
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TRIGPOL</name>
              <description>
              trigger polarity
              0: select positive edge of trigger
              1: select negative edge of trigger
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OP</name>
              <description>
              task operation
              3'b000: direct write data
              3'b100: read then XOR with data and write back
              3'b101: read then OR with data and write back
              3'b110: read then AND with data and write back
              3'b111: read then add with data and write back
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>TRIGSEL</name>
              <description>
              select trigger source
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TAR8</name>
          <displayName>TAR8</displayName>
          <description></description>
          <addressOffset>0x84</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ADDR</name>
              <description>
              peripheral address to access to
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TDR8</name>
          <displayName>TDR8</displayName>
          <description></description>
          <addressOffset>0x88</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              data value for task operation
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RCR8</name>
          <displayName>RCR8</displayName>
          <description>task 8 repetition counter register</description>
          <addressOffset>0x8c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>22</bitWidth>
            </field>
            <field>
              <name>REP</name>
              <description>
              Repetition counter value
              if REPEN is 1, task will only be triggerd when REP is not 0. 
              when REP is larger than 0, it will be decrease by 1 automatically each time task triggered.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD1</name>
          <displayName>RSVD1</displayName>
          <description></description>
          <addressOffset>0x90</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>MEM1</name>
          <displayName>MEM1</displayName>
          <description>temporary memory 1</description>
          <addressOffset>0xd0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              memory to store temporary variables
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>MEM2</name>
          <displayName>MEM2</displayName>
          <description>temporary memory 2</description>
          <addressOffset>0xd4</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              memory to store temporary variables
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>MEM3</name>
          <displayName>MEM3</displayName>
          <description>temporary memory 3</description>
          <addressOffset>0xd8</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              memory to store temporary variables
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>MEM4</name>
          <displayName>MEM4</displayName>
          <description>temporary memory 4</description>
          <addressOffset>0xdc</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              memory to store temporary variables
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>GPIO31_0</name>
          <displayName>GPIO31_0</displayName>
          <description></description>
          <addressOffset>0xe0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>SELD</name>
              <description>
              select trigger D of GPIO 31~0
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>SELC</name>
              <description>
              select trigger C of GPIO 31~0
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>SELB</name>
              <description>
              select trigger B of GPIO 31~0
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>SELA</name>
              <description>
              select trigger A of GPIO 31~0
              0: select GPIO 0
              1: select GPIO 1
              ......
              31: select GPIO 31
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>GPIO63_32</name>
          <displayName>GPIO63_32</displayName>
          <description></description>
          <addressOffset>0xe4</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>SELD</name>
              <description>
              select trigger D of GPIO 63~32
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>SELC</name>
              <description>
              select trigger C of GPIO 63~32
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>SELB</name>
              <description>
              select trigger B of GPIO 63~32
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>SELA</name>
              <description>
              select trigger A of GPIO 63~32
              0: select GPIO 32
              1: select GPIO 33
              ......
              31: select GPIO 63
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>GPIO95_64</name>
          <displayName>GPIO95_64</displayName>
          <description></description>
          <addressOffset>0xe8</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>SELD</name>
              <description>
              select trigger D of GPIO 95~64
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>SELC</name>
              <description>
              select trigger C of GPIO 95~64
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>SELB</name>
              <description>
              select trigger B of GPIO 95~64
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>SELA</name>
              <description>
              select trigger A of GPIO 95~64
              0: select GPIO 64
              1: select GPIO 65
              ......
              31: select GPIO 95
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>LPSYS_AON</name>
      <description></description>
      <groupName>LPSYS_AON</groupName>
      <baseAddress>0x50040000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>PMR</name>
          <displayName>PMR</displayName>
          <description>Power Mode Register</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>FORCE_SLEEP</name>
              <description>
              Set 1 to force enter low power mode. Will be cleared automatically
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FORCE_LCPU</name>
              <description>
              0: SWD connected to HCPU
              1: SWD connected to LCPU
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>27</bitWidth>
            </field>
            <field>
              <name>CPUWAIT</name>
              <description>
              Stall CPU out of reset. Should be cleared before LCPU run
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MODE</name>
              <description>
              Power Mode: 2'h0 - active; 2'h1 - light sleep; 2'h2 - deep sleep; 2'h3 - standby
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CR1</name>
          <displayName>CR1</displayName>
          <description>Control Register 1</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>GTIM_EN</name>
              <description>
              Enable global timer
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PBR_SEL1</name>
              <description>
              for debug only
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>PBR_SEL0</name>
              <description>
              for debug only
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN7_MODE</name>
              <description>
              mode for wakeup PIN7 (PA52)
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>PIN6_MODE</name>
              <description>
              mode for wakeup PIN6 (PA51)
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>PIN5_MODE</name>
              <description>
              mode for wakeup PIN5 (PA50)
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>PIN4_MODE</name>
              <description>
              mode for wakeup PIN4 (PB36)
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>PIN3_MODE</name>
              <description>
              mode for wakeup PIN3 (PB35)
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>PIN2_MODE</name>
              <description>
              mode for wakeup PIN2 (PB34)
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>PIN1_MODE</name>
              <description>
              mode for wakeup PIN1 (PB33)
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>PIN0_MODE</name>
              <description>
              mode for wakeup PIN0 (PB32)
              0 - high level, 1 - low level, 2 - pos edge, 3 - neg edge, 4/5/6/7: pos or neg edge
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CR2</name>
          <displayName>CR2</displayName>
          <description>Control Register 2</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>14</bitWidth>
            </field>
            <field>
              <name>PIN13_MODE</name>
              <description>
              mode for wakeup PIN13 (PBR3)
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>PIN12_MODE</name>
              <description>
              mode for wakeup PIN12 (PBR2)
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>PIN11_MODE</name>
              <description>
              mode for wakeup PIN11 (PBR1)
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>PIN10_MODE</name>
              <description>
              mode for wakeup PIN10 (PBR0)
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>PIN9_MODE</name>
              <description>
              mode for wakeup PIN9 (PA54)
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>PIN8_MODE</name>
              <description>
              mode for wakeup PIN8 (PA53)
              0 - high level, 1 - low level, 2 - pos edge, 3 - neg edge, 4/5/6/7: pos or neg edge
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ACR</name>
          <displayName>ACR</displayName>
          <description>Active Mode Control register</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>HXT48_RDY</name>
              <description>
              Indicate hxt48 is ready
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HRC48_RDY</name>
              <description>
              Indicate hrc48 is ready
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>19</bitWidth>
            </field>
            <field>
              <name>DS_DTCM</name>
              <description>
              for debug only
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS_ITCM</name>
              <description>
              for debug only
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS_RAM2</name>
              <description>
              for debug only
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS_RAM1</name>
              <description>
              for debug only
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS_RAM0</name>
              <description>
              for debug only
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EXTPWR_REQ</name>
              <description>
              Request power for HPSYS during Active mode
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PWR_REQ</name>
              <description>
              Request power for LPSYS during Active mode
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HXT48_REQ</name>
              <description>
              Request hxt48 in active mode
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HRC48_REQ</name>
              <description>
              Request hrc48 in active mode
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>LSCR</name>
          <displayName>LSCR</displayName>
          <description>Light Sleep Ctrl Register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>27</bitWidth>
            </field>
            <field>
              <name>EXTPWR_REQ</name>
              <description>
              Request power for HPSYS during Light Sleep mode
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PWR_REQ</name>
              <description>
              Request power for LPSYS during Light Sleep mode
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HXT48_REQ</name>
              <description>
              Request hxt48 in Light Sleep mode
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HRC48_REQ</name>
              <description>
              Request hrc48 in Light Sleep mode
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DSCR</name>
          <displayName>DSCR</displayName>
          <description>Deep Sleep Ctrl Register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>27</bitWidth>
            </field>
            <field>
              <name>EXTPWR_REQ</name>
              <description>
              Request power for HPSYS during Deep Sleep mode
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PWR_REQ</name>
              <description>
              Request power for LPSYS during Deep Sleep mode
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HXT48_REQ</name>
              <description>
              Request hxt48 in Deep Sleep mode
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HRC48_REQ</name>
              <description>
              Request hrc48 in Deep Sleep mode
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SBCR</name>
          <displayName>SBCR</displayName>
          <description>Standby Mode Ctrl Register</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>21</bitWidth>
            </field>
            <field>
              <name>PD_DTCM</name>
              <description>
              for debug only
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PD_ITCM</name>
              <description>
              for debug only
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PD_RAM2</name>
              <description>
              for debug only
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PD_RAM1</name>
              <description>
              for debug only
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PD_RAM0</name>
              <description>
              for debug only
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EXTPWR_REQ</name>
              <description>
              Request power for HPSYS during Standby mode
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PWR_REQ</name>
              <description>
              Request power for LPSYS during Standby mode
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HXT48_REQ</name>
              <description>
              Request hxt48 in Standby mode
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HRC48_REQ</name>
              <description>
              Request hrc48 in Standby mode
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>WER</name>
          <displayName>WER</displayName>
          <description>Wakeup Enable register</description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
            <field>
              <name>PIN13</name>
              <description>
              Set 1 to enable PBR3 as wakeup source
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN12</name>
              <description>
              Set 1 to enable PBR2 as wakeup source
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN11</name>
              <description>
              Set 1 to enable PBR1 as wakeup source
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN10</name>
              <description>
              Set 1 to enable PBR0 as wakeup source
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN9</name>
              <description>
              Set 1 to enable PA54 as wakeup source
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN8</name>
              <description>
              Set 1 to enable PA53 as wakeup source
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN7</name>
              <description>
              Set 1 to enable PA52 as wakeup source
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN6</name>
              <description>
              Set 1 to enable PA51 as wakeup source
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN5</name>
              <description>
              Set 1 to enable PA50 as wakeup source
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN4</name>
              <description>
              Set 1 to enable PB36 as wakeup source
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN3</name>
              <description>
              Set 1 to enable PB35 as wakeup source
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN2</name>
              <description>
              Set 1 to enable PB34 as wakeup source
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN1</name>
              <description>
              Set 1 to enable PB33 as wakeup source
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN0</name>
              <description>
              Set 1 to enable PB32 as wakeup source
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HP2LP_IRQ</name>
              <description>
              Set 1 to enable MAILBOX1 as wakeup source
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HP2LP_REQ</name>
              <description>
              Set 1 to enable HPSYS request as wakeup source
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BT</name>
              <description>
              Set 1 to enable BT as wakeup source
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LPCOMP2</name>
              <description>
              Set 1 to enable LPCOMP2 as wakeup source
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LPCOMP1</name>
              <description>
              Set 1 to enable LPCOMP1 as wakeup source
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LPTIM2</name>
              <description>
              Set 1 to enable LPTIM2 as wakeup source
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GPIO2</name>
              <description>
              Set 1 to enable IO(PB) as wakeup source
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RTC</name>
              <description>
              Set 1 to enable RTC as wakeup source
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>WSR</name>
          <displayName>WSR</displayName>
          <description>Wakeup Status register</description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
            <field>
              <name>PIN13</name>
              <description>
              Indicates the wakeup status from PBR3 request. Note: the status is masked by WER
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN12</name>
              <description>
              Indicates the wakeup status from PBR2 request. Note: the status is masked by WER
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN11</name>
              <description>
              Indicates the wakeup status from PBR1 request. Note: the status is masked by WER
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN10</name>
              <description>
              Indicates the wakeup status from PBR0 request. Note: the status is masked by WER
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN9</name>
              <description>
              Indicates the wakeup status from PA54 request. Note: the status is masked by WER
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN8</name>
              <description>
              Indicates the wakeup status from PA53 request. Note: the status is masked by WER
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN7</name>
              <description>
              Indicates the wakeup status from PA52 request. Note: the status is masked by WER
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN6</name>
              <description>
              Indicates the wakeup status from PA51 request. Note: the status is masked by WER
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN5</name>
              <description>
              Indicates the wakeup status from PA50 request. Note: the status is masked by WER
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN4</name>
              <description>
              Indicates the wakeup status from PB36 request. Note: the status is masked by WER
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN3</name>
              <description>
              Indicates the wakeup status from PB35 request. Note: the status is masked by WER
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN2</name>
              <description>
              Indicates the wakeup status from PB34 request. Note: the status is masked by WER
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN1</name>
              <description>
              Indicates the wakeup status from PB33 request. Note: the status is masked by WER
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN0</name>
              <description>
              Indicates the wakeup status from PB32 request. Note: the status is masked by WER
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HP2LP_IRQ</name>
              <description>
              Indicates the wakeup status from MAILBOX1. Note: the status is masked by WER
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HP2LP_REQ</name>
              <description>
              Indicates the wakeup status from HPSYS request. Note: the status is masked by WER
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BT</name>
              <description>
              Indicates the wakeup status from BT. Note: the status is masked by WER
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LPCOMP2</name>
              <description>
              Indicates the wakeup status from LPCOMP2. Note: the status is masked by WER
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LPCOMP1</name>
              <description>
              Indicates the wakeup status from LPCOMP1. Note: the status is masked by WER
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LPTIM2</name>
              <description>
              Indicates the wakeup status from LPTIM2. Note: the status is masked by WER
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>GPIO2</name>
              <description>
              Indicates the wakeup status from IO(PB). Note: the status is masked by WER
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RTC</name>
              <description>
              Indicates the wakeup status from RTC. Note: the status is masked by WER
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>WCR</name>
          <displayName>WCR</displayName>
          <description>Wakeup Clear register</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>AON</name>
              <description>
              Write 1 to clear the AON wakeup IRQ status
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
            <field>
              <name>PIN13</name>
              <description>
              Write 1 to clear PBR3 wakeup source. Only valid if PIN wakeup is configured as edge trigger
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN12</name>
              <description>
              Write 1 to clear PBR2 wakeup source. Only valid if PIN wakeup is configured as edge trigger
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN11</name>
              <description>
              Write 1 to clear PBR1 wakeup source. Only valid if PIN wakeup is configured as edge trigger
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN10</name>
              <description>
              Write 1 to clear PBR0 wakeup source. Only valid if PIN wakeup is configured as edge trigger
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN9</name>
              <description>
              Write 1 to clear PA54 wakeup source. Only valid if PIN wakeup is configured as edge trigger
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN8</name>
              <description>
              Write 1 to clear PA53 wakeup source. Only valid if PIN wakeup is configured as edge trigger
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN7</name>
              <description>
              Write 1 to clear PA52 wakeup source. Only valid if PIN wakeup is configured as edge trigger
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN6</name>
              <description>
              Write 1 to clear PA51 wakeup source. Only valid if PIN wakeup is configured as edge trigger
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN5</name>
              <description>
              Write 1 to clear PA50 wakeup source. Only valid if PIN wakeup is configured as edge trigger
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN4</name>
              <description>
              Write 1 to clear PB36 wakeup source. Only valid if PIN wakeup is configured as edge trigger
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN3</name>
              <description>
              Write 1 to clear PB35 wakeup source. Only valid if PIN wakeup is configured as edge trigger
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN2</name>
              <description>
              Write 1 to clear PB34 wakeup source. Only valid if PIN wakeup is configured as edge trigger
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN1</name>
              <description>
              Write 1 to clear PB33 wakeup source. Only valid if PIN wakeup is configured as edge trigger
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN0</name>
              <description>
              Write 1 to clear PB32 wakeup source. Only valid if PIN wakeup is configured as edge trigger
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              Note: for RTC/GPIO/LPTIM/LPCOMP/BT, clear the wakeup status directly in the corresponding module
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ISSR</name>
          <displayName>ISSR</displayName>
          <description>Inter System Status Register</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>26</bitWidth>
            </field>
            <field>
              <name>HP_ACTIVE</name>
              <description>
              read 1 indicates HPSYS is active
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LP_ACTIVE</name>
              <description>
              write 1 to indicates LPSYS is active
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>HP2LP_REQ</name>
              <description>
              indicate HPSYS request exists
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LP2HP_REQ</name>
              <description>
              write 1 to request HPSYS to stay in active mode
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TARGET</name>
          <displayName>TARGET</displayName>
          <description>BT sleep time target</description>
          <addressOffset>0x2c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>SLEEP_TARGET</name>
              <description>
              bt sleep time target in cycles of clk_lp
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>28</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ACTUAL</name>
          <displayName>ACTUAL</displayName>
          <description>BT actual sleep time</description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>SLEEP_CNT</name>
              <description>
              bt actual sleep time in cycles of clk_lp. If not woken up by software or external interrupt, sleep_cnt counts up every clk_lp cycle, until reaches sleep_target
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>28</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PRE_WKUP</name>
          <displayName>PRE_WKUP</displayName>
          <description>time before bt awake</description>
          <addressOffset>0x34</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>WKUP_TIME</name>
              <description>
              cycles of clk_lp for LPSYS ready before bt awake.
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>XTAL_TIME</name>
              <description>
              cycles of clk_lp for hxt48 ready before bt awake.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SLP_CFG</name>
          <displayName>SLP_CFG</displayName>
          <description>BT sleep configuration</description>
          <addressOffset>0x38</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>28</bitWidth>
            </field>
            <field>
              <name>XTAL_FORCE_OFF</name>
              <description>
              for debug only
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>XTAL_ALWAYS_ON</name>
              <description>
              for debug only
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SLP_CTRL</name>
          <displayName>SLP_CTRL</displayName>
          <description>BT sleep control</description>
          <addressOffset>0x3c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>25</bitWidth>
            </field>
            <field>
              <name>BT_WKUP</name>
              <description>
              bt wakeup source. 1 means bt has not enter sleep or has enter wakeup procedure
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>XTAL_REQ</name>
              <description>
              xtal request status. 1 means bt is requiring xtal. 
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SLEEP_STATUS</name>
              <description>
              bt sleep status. 1 means bt is sleeping and sleep_cnt is counting up
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>WKUP_REQ</name>
              <description>
              software request to wakeup bt. Will be cleared automatically
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SLEEP_REQ</name>
              <description>
              bt sleep request. Will be cleared automatically
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ANACR</name>
          <displayName>ANACR</displayName>
          <description>Analog Control Register</description>
          <addressOffset>0x40</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>30</bitWidth>
            </field>
            <field>
              <name>VLP_ISO</name>
              <description>
              Set 1 to force off all LPSYS related analog modules
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PB_ISO</name>
              <description>
              Set 1 to force IO(PB) into retention mode
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>GTIMR</name>
          <displayName>GTIMR</displayName>
          <description>Global Timer Register</description>
          <addressOffset>0x44</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>CNT</name>
              <description>
              Global timer value
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RESERVE0</name>
          <displayName>RESERVE0</displayName>
          <description>Reserved Register 0</description>
          <addressOffset>0x48</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              for debug only
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RESERVE1</name>
          <displayName>RESERVE1</displayName>
          <description>Reserved Register 1</description>
          <addressOffset>0x4c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              for debug only
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD1</name>
          <displayName>RSVD1</displayName>
          <description></description>
          <addressOffset>0x50</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>SPR</name>
          <displayName>SPR</displayName>
          <description>Stack Pointer Register</description>
          <addressOffset>0x100</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>SP</name>
              <description>
              LCPU stack pointer address
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PCR</name>
          <displayName>PCR</displayName>
          <description>Pointer Counter Register</description>
          <addressOffset>0x104</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>PC</name>
              <description>
              LCPU PC pointer address
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>LPTIM2</name>
      <description></description>
      <groupName>LPTIM</groupName>
      <baseAddress>0x50041000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>ISR</name>
          <displayName>ISR</displayName>
          <description>LPTIM interrupt and status register</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>21</bitWidth>
            </field>
            <field>
              <name>OCWKUP</name>
              <description>
              Indicates output compare wakeup occurred
              The OCWKUP bit is set by hardware when LPTIM_CNT register value reached the LPTIM_CMP register's value. To clear OCWKUP, first  write 0 to the OCWE bit in the LPTIM_IER register to disable, then write 1 to the WKUPCLR bit in the LPTIM_ICR register. 
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OFWKUP</name>
              <description>
              Indicates overflow wakeup occurred
              OFWKUP is set by hardware when LPTIM_CNT register's value reached the LPTIM_ARR register's value and count from zero again. To clear OFWKUP, first  write 0 to the OFWE bit in the LPTIM_IER register to disable, then write 1 to the WKUPCLR bit in the LPTIM_ICR register. 
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UEWKUP</name>
              <description>
              Indicates update event wakeup occurred
              UEWKUP is set by hardware when an update event was generated (overflow occurred while repetition counter reached zero). To clear UEWKUP, first  write 0 to the UEWE bit in the LPTIM_IER register to disable, then write 1 to the WKUPCLR bit in the LPTIM_ICR register. 
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>ET</name>
              <description>
              External trigger edge event
              ET is set by hardware to inform application that a valid edge on the selected external trigger input has occurred. If the trigger is ignored because the timer has already started, then this flag is not set. ET flag can be cleared by writing 1 to the ETCLR bit in the LPTIM_ICR register.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OC</name>
              <description>
              Output compare match
              The OC bit is set by hardware to inform application that LPTIM_CNT register value reached the LPTIM_CMP register's value. OC flag can be cleared by writing 1 to the OCCLR bit in the LPTIM_ICR register.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OF</name>
              <description>
              Overflow occurred
              OF is set by hardware to inform application that LPTIM_CNT register's value reached the LPTIM_ARR register's value and count from zero again. OF flag can be cleared by writing 1 to the OFCLR bit in the LPTIM_ICR register.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UE</name>
              <description>
              LPTIM update event occurred
              UE is set by hardware to inform application that an update event was generated when overflow occurred while repetition counter reached zero. UE flag can be cleared by writing 1 to the UECLR bit in the LPTIM_ICR register. 
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ICR</name>
          <displayName>ICR</displayName>
          <description>LPTIM interrupt and status clear register</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>WKUPCLR</name>
              <description>
              wakeup status clear flag
              Writing 1 to this bit clears all wakeup status flags in the LPTIM_ISR register.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>ETCLR</name>
              <description>
              External trigger valid edge clear flag
              Writing 1 to this bit clears the ET flag in the LPTIM_ISR register
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OCCLR</name>
              <description>
              Output compare clear flag
              Writing 1 to this bit clears the OC flag in the LPTIM_ISR register
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OFCLR</name>
              <description>
              Overflow clear flag
              Writing 1 to this bit clears the OF flag in the LPTIM_ISR register
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UECLR</name>
              <description>
              Update event clear flag
              Writing 1 to this bit clear the UE flag in the LPTIM_ISR register.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IER</name>
          <displayName>IER</displayName>
          <description>LPTIM interrupt and wakeup enable register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>21</bitWidth>
            </field>
            <field>
              <name>OCWE</name>
              <description>
              Output compare Wakeup Enable
              0: Output compare wakeup disabled
              1: Output compare wakeup enabled
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OFWE</name>
              <description>
              Overflow Wakeup Enable
              0: Overflow Wakeup disabled
              1: Overflow Wakeup enabled
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UEWE</name>
              <description>
              Update event Wakeup enable
              0: Update event Wakeup disabled
              1: Update event Wakeup enabled
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>ETIE</name>
              <description>
              External trigger valid edge Interrupt Enable
              0: External trigger interrupt disabled
              1: External trigger interrupt enabled
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OCIE</name>
              <description>
              Output compare Interrupt Enable
              0: Output compare interrupt disabled
              1: Output compare interrupt enabled
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OFIE</name>
              <description>
              Overflow Interrupt Enable
              0: Overflow interrupt disabled
              1: Overflow interrupt enabled
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UEIE</name>
              <description>
              Update event interrupt enable
              0: Update event interrupt disabled
              1: Update event interrupt enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CFGR</name>
          <displayName>CFGR</displayName>
          <description>LPTIM configuration register</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>COUNTMODE</name>
              <description>
              counter mode in internal clock source mode (CKSEL=0). If CKSEL=1, this bit has no effect.
              0: the counter is incremented following each internal clock pulse
              1: the counter is incremented following each valid pulse on the external clock
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>WAVPOL</name>
              <description>
              Waveform shape polarity
              The WAVEPOL bit controls the output polarity
              0: The LPTIM output reflects the compare results between LPTIM_ARR and LPTIM_CMP registers
              1: The LPTIM output reflects the inverse of the compare results between LPTIM_ARR and LPTIM_CMP registers
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>WAVE</name>
              <description>
              Waveform shape
              The WAVE bit controls the output shape
              0: Deactivate Set-once mode
              1: Activate the Set-once mode
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TIMOUT</name>
              <description>
              Timeout enable
              The TIMOUT bit controls the Timeout feature
              0: A trigger event arriving when the timer is already started will be ignored
              1: A trigger event arriving when the timer is already started will reset and restart the LPTIM counter and the repetition counter
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TRIGEN</name>
              <description>
              Trigger enable and polarity
              The TRIGEN bits controls whether the LPTIM counter is started by an external trigger or not. If the external trigger option is selected, three configurations are possible for the trigger active edge:
              00: software trigger (counting start is initiated by software)
              01: rising edge is the active edge
              10: falling edge is the active edge
              11: both edges are active edges
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TRIGSEL</name>
              <description>
              Trigger selector
              The TRIGSEL bits select the trigger source that will serve as a trigger event for the LPTIM among the below 8 available sources:
              000: lptim_ext0
              001: lptim_ext1
              010: lptim_ext2
              011: lptim_ext3
              100: lptim_ext4
              101: lptim_ext5
              110: lptim_ext6
              111: lptim_ext7
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PRESC</name>
              <description>
              Clock prescaler
              The PRESC bits configure the prescaler division factor. It can be one among the following division factors:
              000: /1
              001: /2
              010: /4
              011: /8
              100: /16
              101: /32
              110: /64
              111: /128
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>EXTCKSEL</name>
              <description>
              External clock source selector
              0: external clock source is from lptim_in
              1: external clock source is from LPCOMP (if LPCOMP integrated)
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TRGFLT</name>
              <description>
              Configurable digital filter for trigger
              The TRGFLT value sets the number of consecutive equal samples that should be detected when a level change occurs on an internal trigger before it is considered as a valid level transition. An internal clock source must be present to use this feature
              00: any trigger active level change is considered as a valid trigger
              01: trigger active level change must be stable for at least 2 clock periods before it is considered as valid trigger.
              10: trigger active level change must be stable for at least 4 clock periods before it is considered as valid trigger.
              11: trigger active level change must be stable for at least 8 clock periods before it is considered as valid trigger.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>INTCKSEL</name>
              <description>
              Internal clock source selector
              0: internal clock source is clk_lp
              1: internal clock source is pclk2
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CKFLT</name>
              <description>
              Configurable digital filter for external clock
              The CKFLT value sets the number of consecutive equal samples that should be detected when a level change occurs on an external clock signal before it is considered as a valid level transition. An internal clock source must be present to use this feature
              00: any external clock signal level change is considered as a valid transition
              01: external clock signal level change must be stable for at least 2 clock periods before it is considered as valid transition.
              10: external clock signal level change must be stable for at least 4 clock periods before it is considered as valid transition.
              11: external clock signal level change must be stable for at least 8 clock periods before it is considered as valid transition.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>CKPOL</name>
              <description>
              Clock Polarity
              If LPTIM is clocked by an external clock source, CKPOL bits is used to configure the active edge or edges used by the counter:
              00: the rising edge is the active edge used for counting
              01: the falling edge is the active edge used for counting
              10: both edges are active edges. When both external clock signal edges are considered active ones, the LPTIM must also be clocked by an internal clock source with a frequency equal to at least four time the external clock frequency.
              11: not allowed
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>CKSEL</name>
              <description>
              Clock selector
              The CKSEL bit selects which clock source the LPTIM will use:
              0: LPTIM is clocked by internal clock source, according to INTCKSEL
              1: LPTIM is clocked by external clock source, according to EXTCKSEL
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CR</name>
          <displayName>CR</displayName>
          <description>LPTIM control register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>28</bitWidth>
            </field>
            <field>
              <name>COUNTRST</name>
              <description>
              Counter reset
              This bit is set by software and cleared by hardware. When set to 1 this bit will trigger a synchronous reset of the CNT register. Due to the synchronous nature of this reset, it only takes place after a synchronization delay.
              COUNTRST must never be set to 1 by software before it is already cleared to 0 by hardware. Software should consequently check that COUNTRST bit is already cleared to 0 before attempting to set it to 1.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CNTSTRT</name>
              <description>
              Timer start in Continuous mode
              This bit is set by software and cleared by hardware.
              In case of software start (TRIGEN[1:0] = 00), setting this bit starts the LPTIM in Continuous mode.
              If the software start is disabled (TRIGEN[1:0] different than 00), setting this bit starts the timer in Continuous mode as soon as an external trigger is detected.
              If this bit is set when a single pulse mode counting is ongoing, then the timer will not stop at the next match between ARR and CNT registers and the LPTIM counter keeps counting in Continuous mode.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SNGSTRT</name>
              <description>
              LPTIM start in Single mode
              This bit is set by software and cleared by hardware.
              In case of software start (TRIGEN[1:0] = 00), setting this bit starts the LPTIM in single pulse mode.
              If the software start is disabled (TRIGEN[1:0] different than 00), setting this bit starts the LPTIM in single pulse mode as soon as an external trigger is detected.
              If this bit is set when the LPTIM is in continuous counting mode, then the LPTIM will stop at the following match between ARR and CNT registers.
              If this bit is set simultaneously with CNTSTRT, then LPTIM will be in continuous counting mode.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ENABLE</name>
              <description>
              LPTIM enable
              The ENABLE bit is set and cleared by software. 
              0:LPTIM is disabled
              1:LPTIM is enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CMP</name>
          <displayName>CMP</displayName>
          <description>LPTIM compare register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>CMP</name>
              <description>
              Compare value
              CMP is the compare value used by the LPTIM.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ARR</name>
          <displayName>ARR</displayName>
          <description>LPTIM autoreload register</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>ARR</name>
              <description>
              Auto reload value
              ARR is the autoreload value for the LPTIM. This value must be strictly greater than the CMP[15:0] value.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CNT</name>
          <displayName>CNT</displayName>
          <description>LPTIM counter register</description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>CNT</name>
              <description>
              Counter value
              When the LPTIM is running with an asynchronous clock, reading the CNT register may return unreliable values. So in this case it is necessary to perform two consecutive read accesses and verify that the two returned values are identical.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RCR</name>
          <displayName>RCR</displayName>
          <description>LPTIM repetition register</description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>REP</name>
              <description>
              Repetition register value
              REP is the repetition value for the LPTIM.
              Read REP will return left repetition times. It should be noted that for a reliable REP register read access, two consecutive read accesses must be performed and compared. A read access can be considered reliable when the values of the two consecutive read accesses are equal.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>LPTIM3</name>
      <description></description>
      <groupName>LPTIM</groupName>
      <baseAddress>0x50042000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>ISR</name>
          <displayName>ISR</displayName>
          <description>LPTIM interrupt and status register</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>21</bitWidth>
            </field>
            <field>
              <name>OCWKUP</name>
              <description>
              Indicates output compare wakeup occurred
              The OCWKUP bit is set by hardware when LPTIM_CNT register value reached the LPTIM_CMP register's value. To clear OCWKUP, first  write 0 to the OCWE bit in the LPTIM_IER register to disable, then write 1 to the WKUPCLR bit in the LPTIM_ICR register. 
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OFWKUP</name>
              <description>
              Indicates overflow wakeup occurred
              OFWKUP is set by hardware when LPTIM_CNT register's value reached the LPTIM_ARR register's value and count from zero again. To clear OFWKUP, first  write 0 to the OFWE bit in the LPTIM_IER register to disable, then write 1 to the WKUPCLR bit in the LPTIM_ICR register. 
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UEWKUP</name>
              <description>
              Indicates update event wakeup occurred
              UEWKUP is set by hardware when an update event was generated (overflow occurred while repetition counter reached zero). To clear UEWKUP, first  write 0 to the UEWE bit in the LPTIM_IER register to disable, then write 1 to the WKUPCLR bit in the LPTIM_ICR register. 
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>ET</name>
              <description>
              External trigger edge event
              ET is set by hardware to inform application that a valid edge on the selected external trigger input has occurred. If the trigger is ignored because the timer has already started, then this flag is not set. ET flag can be cleared by writing 1 to the ETCLR bit in the LPTIM_ICR register.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OC</name>
              <description>
              Output compare match
              The OC bit is set by hardware to inform application that LPTIM_CNT register value reached the LPTIM_CMP register's value. OC flag can be cleared by writing 1 to the OCCLR bit in the LPTIM_ICR register.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OF</name>
              <description>
              Overflow occurred
              OF is set by hardware to inform application that LPTIM_CNT register's value reached the LPTIM_ARR register's value and count from zero again. OF flag can be cleared by writing 1 to the OFCLR bit in the LPTIM_ICR register.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UE</name>
              <description>
              LPTIM update event occurred
              UE is set by hardware to inform application that an update event was generated when overflow occurred while repetition counter reached zero. UE flag can be cleared by writing 1 to the UECLR bit in the LPTIM_ICR register. 
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ICR</name>
          <displayName>ICR</displayName>
          <description>LPTIM interrupt and status clear register</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>WKUPCLR</name>
              <description>
              wakeup status clear flag
              Writing 1 to this bit clears all wakeup status flags in the LPTIM_ISR register.
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>ETCLR</name>
              <description>
              External trigger valid edge clear flag
              Writing 1 to this bit clears the ET flag in the LPTIM_ISR register
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OCCLR</name>
              <description>
              Output compare clear flag
              Writing 1 to this bit clears the OC flag in the LPTIM_ISR register
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OFCLR</name>
              <description>
              Overflow clear flag
              Writing 1 to this bit clears the OF flag in the LPTIM_ISR register
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UECLR</name>
              <description>
              Update event clear flag
              Writing 1 to this bit clear the UE flag in the LPTIM_ISR register.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IER</name>
          <displayName>IER</displayName>
          <description>LPTIM interrupt and wakeup enable register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>21</bitWidth>
            </field>
            <field>
              <name>OCWE</name>
              <description>
              Output compare Wakeup Enable
              0: Output compare wakeup disabled
              1: Output compare wakeup enabled
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OFWE</name>
              <description>
              Overflow Wakeup Enable
              0: Overflow Wakeup disabled
              1: Overflow Wakeup enabled
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UEWE</name>
              <description>
              Update event Wakeup enable
              0: Update event Wakeup disabled
              1: Update event Wakeup enabled
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>ETIE</name>
              <description>
              External trigger valid edge Interrupt Enable
              0: External trigger interrupt disabled
              1: External trigger interrupt enabled
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OCIE</name>
              <description>
              Output compare Interrupt Enable
              0: Output compare interrupt disabled
              1: Output compare interrupt enabled
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OFIE</name>
              <description>
              Overflow Interrupt Enable
              0: Overflow interrupt disabled
              1: Overflow interrupt enabled
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>UEIE</name>
              <description>
              Update event interrupt enable
              0: Update event interrupt disabled
              1: Update event interrupt enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CFGR</name>
          <displayName>CFGR</displayName>
          <description>LPTIM configuration register</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>COUNTMODE</name>
              <description>
              counter mode in internal clock source mode (CKSEL=0). If CKSEL=1, this bit has no effect.
              0: the counter is incremented following each internal clock pulse
              1: the counter is incremented following each valid pulse on the external clock
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>WAVPOL</name>
              <description>
              Waveform shape polarity
              The WAVEPOL bit controls the output polarity
              0: The LPTIM output reflects the compare results between LPTIM_ARR and LPTIM_CMP registers
              1: The LPTIM output reflects the inverse of the compare results between LPTIM_ARR and LPTIM_CMP registers
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>WAVE</name>
              <description>
              Waveform shape
              The WAVE bit controls the output shape
              0: Deactivate Set-once mode
              1: Activate the Set-once mode
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TIMOUT</name>
              <description>
              Timeout enable
              The TIMOUT bit controls the Timeout feature
              0: A trigger event arriving when the timer is already started will be ignored
              1: A trigger event arriving when the timer is already started will reset and restart the LPTIM counter and the repetition counter
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TRIGEN</name>
              <description>
              Trigger enable and polarity
              The TRIGEN bits controls whether the LPTIM counter is started by an external trigger or not. If the external trigger option is selected, three configurations are possible for the trigger active edge:
              00: software trigger (counting start is initiated by software)
              01: rising edge is the active edge
              10: falling edge is the active edge
              11: both edges are active edges
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TRIGSEL</name>
              <description>
              Trigger selector
              The TRIGSEL bits select the trigger source that will serve as a trigger event for the LPTIM among the below 8 available sources:
              000: lptim_ext0
              001: lptim_ext1
              010: lptim_ext2
              011: lptim_ext3
              100: lptim_ext4
              101: lptim_ext5
              110: lptim_ext6
              111: lptim_ext7
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PRESC</name>
              <description>
              Clock prescaler
              The PRESC bits configure the prescaler division factor. It can be one among the following division factors:
              000: /1
              001: /2
              010: /4
              011: /8
              100: /16
              101: /32
              110: /64
              111: /128
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>EXTCKSEL</name>
              <description>
              External clock source selector
              0: external clock source is from lptim_in
              1: external clock source is from LPCOMP (if LPCOMP integrated)
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TRGFLT</name>
              <description>
              Configurable digital filter for trigger
              The TRGFLT value sets the number of consecutive equal samples that should be detected when a level change occurs on an internal trigger before it is considered as a valid level transition. An internal clock source must be present to use this feature
              00: any trigger active level change is considered as a valid trigger
              01: trigger active level change must be stable for at least 2 clock periods before it is considered as valid trigger.
              10: trigger active level change must be stable for at least 4 clock periods before it is considered as valid trigger.
              11: trigger active level change must be stable for at least 8 clock periods before it is considered as valid trigger.
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>INTCKSEL</name>
              <description>
              Internal clock source selector
              0: internal clock source is clk_lp
              1: internal clock source is pclk2
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CKFLT</name>
              <description>
              Configurable digital filter for external clock
              The CKFLT value sets the number of consecutive equal samples that should be detected when a level change occurs on an external clock signal before it is considered as a valid level transition. An internal clock source must be present to use this feature
              00: any external clock signal level change is considered as a valid transition
              01: external clock signal level change must be stable for at least 2 clock periods before it is considered as valid transition.
              10: external clock signal level change must be stable for at least 4 clock periods before it is considered as valid transition.
              11: external clock signal level change must be stable for at least 8 clock periods before it is considered as valid transition.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>CKPOL</name>
              <description>
              Clock Polarity
              If LPTIM is clocked by an external clock source, CKPOL bits is used to configure the active edge or edges used by the counter:
              00: the rising edge is the active edge used for counting
              01: the falling edge is the active edge used for counting
              10: both edges are active edges. When both external clock signal edges are considered active ones, the LPTIM must also be clocked by an internal clock source with a frequency equal to at least four time the external clock frequency.
              11: not allowed
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>CKSEL</name>
              <description>
              Clock selector
              The CKSEL bit selects which clock source the LPTIM will use:
              0: LPTIM is clocked by internal clock source, according to INTCKSEL
              1: LPTIM is clocked by external clock source, according to EXTCKSEL
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CR</name>
          <displayName>CR</displayName>
          <description>LPTIM control register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>28</bitWidth>
            </field>
            <field>
              <name>COUNTRST</name>
              <description>
              Counter reset
              This bit is set by software and cleared by hardware. When set to 1 this bit will trigger a synchronous reset of the CNT register. Due to the synchronous nature of this reset, it only takes place after a synchronization delay.
              COUNTRST must never be set to 1 by software before it is already cleared to 0 by hardware. Software should consequently check that COUNTRST bit is already cleared to 0 before attempting to set it to 1.
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CNTSTRT</name>
              <description>
              Timer start in Continuous mode
              This bit is set by software and cleared by hardware.
              In case of software start (TRIGEN[1:0] = 00), setting this bit starts the LPTIM in Continuous mode.
              If the software start is disabled (TRIGEN[1:0] different than 00), setting this bit starts the timer in Continuous mode as soon as an external trigger is detected.
              If this bit is set when a single pulse mode counting is ongoing, then the timer will not stop at the next match between ARR and CNT registers and the LPTIM counter keeps counting in Continuous mode.
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SNGSTRT</name>
              <description>
              LPTIM start in Single mode
              This bit is set by software and cleared by hardware.
              In case of software start (TRIGEN[1:0] = 00), setting this bit starts the LPTIM in single pulse mode.
              If the software start is disabled (TRIGEN[1:0] different than 00), setting this bit starts the LPTIM in single pulse mode as soon as an external trigger is detected.
              If this bit is set when the LPTIM is in continuous counting mode, then the LPTIM will stop at the following match between ARR and CNT registers.
              If this bit is set simultaneously with CNTSTRT, then LPTIM will be in continuous counting mode.
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ENABLE</name>
              <description>
              LPTIM enable
              The ENABLE bit is set and cleared by software. 
              0:LPTIM is disabled
              1:LPTIM is enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CMP</name>
          <displayName>CMP</displayName>
          <description>LPTIM compare register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>CMP</name>
              <description>
              Compare value
              CMP is the compare value used by the LPTIM.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ARR</name>
          <displayName>ARR</displayName>
          <description>LPTIM autoreload register</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>ARR</name>
              <description>
              Auto reload value
              ARR is the autoreload value for the LPTIM. This value must be strictly greater than the CMP[15:0] value.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CNT</name>
          <displayName>CNT</displayName>
          <description>LPTIM counter register</description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>CNT</name>
              <description>
              Counter value
              When the LPTIM is running with an asynchronous clock, reading the CNT register may return unreliable values. So in this case it is necessary to perform two consecutive read accesses and verify that the two returned values are identical.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RCR</name>
          <displayName>RCR</displayName>
          <description>LPTIM repetition register</description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>REP</name>
              <description>
              Repetition register value
              REP is the repetition value for the LPTIM.
              Read REP will return left repetition times. It should be noted that for a reliable REP register read access, two consecutive read accesses must be performed and compared. A read access can be considered reliable when the values of the two consecutive read accesses are equal.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PMUC</name>
      <description></description>
      <groupName>PMUC</groupName>
      <baseAddress>0x5004a000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CR</name>
          <displayName>CR</displayName>
          <description>Control Register</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>14</bitWidth>
            </field>
            <field>
              <name>PIN1_SEL</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>PIN0_SEL</name>
              <description>
              select one out of 14 Pins {PBR[3:0], PA[4:0], PB[4:0]}
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>PIN1_MODE</name>
              <description>
              0 - high level, 1 - low level, 2 - pos edge, 3 - neg edge
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>PIN0_MODE</name>
              <description>
              4/6 - both edge (high-active detection), 5/7 - both edge (low-active detection)
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>REBOOT</name>
              <description>
              Write 1 to reboot; write 0 to clear after boot up
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HIBER_EN</name>
              <description>
              Write 1 to enter hibernate mode; write 0 to clear when exit from hibernate
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SEL_LPCLK</name>
              <description>
              0 - LRC10, 1 - LXT32
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>WER</name>
          <displayName>WER</displayName>
          <description>Wakeup Enable register</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>27</bitWidth>
            </field>
            <field>
              <name>PIN1</name>
              <description>
              Set 1 to enable PIN1 as wakeup source
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN0</name>
              <description>
              Set 1 to enable PIN0 as wakeup source
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>WDT2</name>
              <description>
              Set 1 to enable WDT2 as reboot cause
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>WDT1</name>
              <description>
              Set 1 to enable WDT1 as reboot cause
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RTC</name>
              <description>
              Set 1 to enable RTC as wakeup source
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>WSR</name>
          <displayName>WSR</displayName>
          <description>Wakeup Status register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>25</bitWidth>
            </field>
            <field>
              <name>PWRKEY</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IWDT</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN1</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN0</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>WDT2</name>
              <description>
              Indicates reboot by WDT2
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>WDT1</name>
              <description>
              Indicates reboot by WDT1
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RTC</name>
              <description>
              Indicates the wakeup status from RTC. Note: the status is masked by WER
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>WCR</name>
          <displayName>WCR</displayName>
          <description>Wakeup Clear register</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>AON</name>
              <description>
              Write 1 to clear the AON wakeup IRQ status
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>PWRKEY</name>
              <description>
              Write 1 to clear PWRKEY reset flag
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              Clear status in IWDT
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN1</name>
              <description>
              Write 1 to clear PIN1 wakeup flag.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PIN0</name>
              <description>
              Write 1 to clear PIN0 wakeup flag. Only valid if PIN wakeup is configured as edge trigger
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>WDT2</name>
              <description>
              Write 1 to clear WDT2 reboot flag
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>WDT1</name>
              <description>
              Write 1 to clear WDT1 reboot flag
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              Clear status in RTC
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>VRTC_CR</name>
          <displayName>VRTC_CR</displayName>
          <description>VRTC Control Register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>19</bitWidth>
            </field>
            <field>
              <name>BOR_VT_TRIM</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>BOR_EN</name>
              <description>
              Brownout Reset Enable
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>VRTC_TRIM</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>VRTC_VBIT</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>VRET_CR</name>
          <displayName>VRET_CR</displayName>
          <description>VRET Control Register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RDY</name>
              <description>
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>DLY</name>
              <description>
              VRET_LDO power up delay in number of CLK_LP cycles
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>CAL_TRIM</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>CAL_RDY</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TRIM_RSTN</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TRIM_SEL</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TRIM</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>VBIT</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>BM</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EN</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>LRC_CR</name>
          <displayName>LRC_CR</displayName>
          <description>RC10K Control Register</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>REFRES</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CHGCAP</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>CHGCRT</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>CMPBM2</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CMPBM1</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>EN</name>
              <description>
              Enabled by default
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>LXT_CR</name>
          <displayName>LXT_CR</displayName>
          <description>XTAL32K Control Register</description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RDY</name>
              <description>
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>CAP_SEL</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BMSTART</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>BMSEL</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>AMPCTRL_ENB</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>AMP_BM</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>BM</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>RSN</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EN</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BG1_CR</name>
          <displayName>BG1_CR</displayName>
          <description>BG1 Control Register</description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>BG1_VREF_L</name>
              <description>
              low voltage = 0.9V
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>BG1_VREF_M</name>
              <description>
              middle voltage = 1.05V
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>LDOBG_EN</name>
              <description>
              Force LDOBG enable
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BG1_DLY</name>
              <description>
              Bandgap power up delay in CLK_LP cycles
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>BG1_VREF12</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>BG1_VREF06</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>BG1_EN</name>
              <description>
              Force BG1 enable
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BUCK1_CR1</name>
          <displayName>BUCK1_CR1</displayName>
          <description>BUCK1 Control Register 1</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>BUCK1_FORCE_RDY</name>
              <description>
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BUCK1_H2M_EN</name>
              <description>
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BUCK1_H2L_EN</name>
              <description>
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BUCK1_M2L_EN</name>
              <description>
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BUCK1_L2M_EN</name>
              <description>
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BUCK1_RDY</name>
              <description>
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BUCK1_ZCD_AON</name>
              <description>
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BUCK1_BM_ZCD</name>
              <description>
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>BUCK1_BM_PWMCMP</name>
              <description>
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>BUCK1_BM_COTCMP</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>BUCK1_MOT</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>BUCK1_SEL_LX22</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BUCK1_CS</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>BUCK1_CCH</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>BUCK1_ILIMIT</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>BUCK1_EN</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BUCK1_CR2</name>
          <displayName>BUCK1_CR2</displayName>
          <description>BUCK1 Control Register 2</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>L2M_CNT</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>L2H_CNT</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>M2H_CNT</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>HPSYS_LDO</name>
          <displayName>HPSYS_LDO</displayName>
          <description>HPSYS LDO Control Register</description>
          <addressOffset>0x2c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>15</bitWidth>
            </field>
            <field>
              <name>RDY</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DLY</name>
              <description>
              HPSYS_LDO power up delay in CLK_LP cycles
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>VREF2</name>
              <description>
              Lower voltage for deep sleep mode
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>VREF</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>BP</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EN</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>LPSYS_LDO</name>
          <displayName>LPSYS_LDO</displayName>
          <description>LPSYS LDO Control Register</description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>15</bitWidth>
            </field>
            <field>
              <name>RDY</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DLY</name>
              <description>
              LPSYS_LDO power up delay in CLK_LP cycles
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>VREF2</name>
              <description>
              Lower voltage for deep sleep mode
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>VREF</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>BP</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EN</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>HPSYS_SWR</name>
          <displayName>HPSYS_SWR</displayName>
          <description>HPSYS Switch Register</description>
          <addressOffset>0x34</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RDY</name>
              <description>
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>NORET</name>
              <description>
              Cut off VHPRET entirely during standby. No retention
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DLY</name>
              <description>
              wait for N cycles before asserting RDY
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>PSW</name>
              <description>
              [0] - RET_LDO; [1] - HPSYS_LDO
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>LPSYS_SWR</name>
          <displayName>LPSYS_SWR</displayName>
          <description>LPSYS Switch Register</description>
          <addressOffset>0x38</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RDY</name>
              <description>
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>NORET</name>
              <description>
              Cut off VLPMEM entirely during standby. No retention
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DLY</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>PSW_RET</name>
              <description>
              PSW value during DS/SB
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>PSW</name>
              <description>
              [0] - RET_LDO; [1] - LPSYS_LDO
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PMU_TR</name>
          <displayName>PMU_TR</displayName>
          <description>PMU Test Register</description>
          <addressOffset>0x3c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>PMU_DC_MR</name>
              <description>
              macro select
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>PMU_DC_BR</name>
              <description>
              block select
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>PMU_DC_TR</name>
              <description>
              test point select
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PMU_RSVD1</name>
          <displayName>PMU_RSVD1</displayName>
          <description>PMU Reserved Register 1</description>
          <addressOffset>0x40</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RESERVE3</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>RESERVE2</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>RESERVE1</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>RESERVE0</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>HXT_CR1</name>
          <displayName>HXT_CR1</displayName>
          <description>HXT48 Control Register 1</description>
          <addressOffset>0x44</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>CBANK_SEL</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
            <field>
              <name>GM_EN</name>
              <description>
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>LDO_FLT_RSEL</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>LDO_VREF</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>BUF_RF_STR</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>BUF_AUD_STR</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>BUF_AUD_EN</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BUF_DLL_STR</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>BUF_DLL_EN</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BUF_DIG_STR</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>BUF_DIG_EN</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BUF_EN</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EN</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>HXT_CR2</name>
          <displayName>HXT_CR2</displayName>
          <description>HXT48 Control Register 2</description>
          <addressOffset>0x48</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>SLEEP_EN</name>
              <description>
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SDADC_CLKDIV2_SEL</name>
              <description>
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>SDADC_CLKDIV1_SEL</name>
              <description>
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>SDADC_CLKIN_EN</name>
              <description>
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IDAC</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
            <field>
              <name>IDAC_EN</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BUF_SEL3</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>BUF_SEL2</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>ACBUF_RSEL</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ACBUF_SEL</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>AGC_VINDC</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>AGC_VTH</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>AGC_ISTART_SEL</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>AGC_EN</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>HXT_CR3</name>
          <displayName>HXT_CR3</displayName>
          <description>HXT48 Control Register 3</description>
          <addressOffset>0x4c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DLY</name>
              <description>
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>BUF_OSLO_STR</name>
              <description>
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>BUF_DAC_STR</name>
              <description>
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>OPT_IDAC</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
            <field>
              <name>OPT_IDAC_EN</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OPT_CBANK_SEL</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>HRC_CR</name>
          <displayName>HRC_CR</displayName>
          <description>HRC48 Control Register</description>
          <addressOffset>0x50</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>DLY</name>
              <description>
              number of cycles for BG ready. 0 - one cycle of CLK_LP; 1 - two cycles of CLK_LP
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CT</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
            <field>
              <name>MODE24M_EN</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>BM</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>LDO_VREF</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>RST</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OUT_STR</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>OUT_EN</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EN</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RC1M_CR</name>
          <displayName>RC1M_CR</displayName>
          <description>RC1M Control Register</description>
          <addressOffset>0x54</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>RINGOSC_MODE</name>
              <description>
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RINGOSC_BM</name>
              <description>
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>RINGOSC_EN</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SEL_SOURCE</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DLY</name>
              <description>
              number of cycles for BG ready. 0 - one cycle of CLK_LP; 1 - two cycles of CLK_LP
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSEL</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>CSEL</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>7</bitWidth>
            </field>
            <field>
              <name>BM_COMP</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>BM_CHG</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RST</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OUT_EN</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EN</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DBL96_CR</name>
          <displayName>DBL96_CR</displayName>
          <description>DBL96 Control Register</description>
          <addressOffset>0x58</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>DLY_SEL_EXT</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
            <field>
              <name>DLY_SEL_EXT_EN</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DLY_EXT_EN</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DLY_EN</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>PH_EN</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>LOOP_RSTB</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TOOSLO_EN</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TORF_EN</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TODIG_STR</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>TODIG_EN</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OUT_EN</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EN</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DBL96_CALR</name>
          <displayName>DBL96_CALR</displayName>
          <description>DBL96 Calibration Register</description>
          <addressOffset>0x5c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>18</bitWidth>
            </field>
            <field>
              <name>CAL_LOCK</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CAL_OP</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
            <field>
              <name>CAL_CLOSE_EXT_EN</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CAL_EN</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CAU_BGR</name>
          <displayName>CAU_BGR</displayName>
          <description>CAU Bandgap Register</description>
          <addressOffset>0x60</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>21</bitWidth>
            </field>
            <field>
              <name>LPBG_VREF12</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>LPBG_VREF06</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>LPBG_EN</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HPBG_EN</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HPBG_VDDPSW_EN</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CAU_TR</name>
          <displayName>CAU_TR</displayName>
          <description>CAU Test Register</description>
          <addressOffset>0x64</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>23</bitWidth>
            </field>
            <field>
              <name>CAU_DC_MR</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>CAU_DC_BR</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>CAU_DC_TR</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CAU_RSVD</name>
          <displayName>CAU_RSVD</displayName>
          <description>CAU Reserved Register</description>
          <addressOffset>0x68</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RESERVE3</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>RESERVE2</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>RESERVE1</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>RESERVE0</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>WKUP_CNT</name>
          <displayName>WKUP_CNT</displayName>
          <description>Wakeup Count Register</description>
          <addressOffset>0x6c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>PIN1_CNT</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>PIN0_CNT</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>RTC</name>
      <description></description>
      <groupName>RTC</groupName>
      <baseAddress>0x5004b000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>TR</name>
          <displayName>TR</displayName>
          <description>Time Register</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>PM</name>
              <description>
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HT</name>
              <description>
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>HU</name>
              <description>
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>MNT</name>
              <description>
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>MNU</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>ST</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>SU</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SS</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DR</name>
          <displayName>DR</displayName>
          <description>Date Register</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>ERR</name>
              <description>
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>CB</name>
              <description>
              century bit, 0 - 2000s, 1 - 1900s/2100s
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>YT</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>YU</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>WD</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>MT</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MU</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>DT</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>DU</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CR</name>
          <displayName>CR</displayName>
          <description>Control Register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>18</bitWidth>
            </field>
            <field>
              <name>TSIE</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>WUTIE</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ALRMIE</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TSE</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>WUTE</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ALRME</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>FMT</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>TSEDGE</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>WUCKSEL</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ISR</name>
          <displayName>ISR</displayName>
          <description>Initialization and Status Register</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>21</bitWidth>
            </field>
            <field>
              <name>INIT</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>INITF</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>INITS</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSF</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SHPF</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TSOVF</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TSF</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>WUTF</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>WUTWF</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ALRMF</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>ALRMWF</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PSCLR</name>
          <displayName>PSCLR</displayName>
          <description>Prescaler Register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>DIVA_INT</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>DIVA_FRAC</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>14</bitWidth>
            </field>
            <field>
              <name>DIVB</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>WUTR</name>
          <displayName>WUTR</displayName>
          <description>Wakeup Timer Register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>14</bitWidth>
            </field>
            <field>
              <name>WUT</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>18</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ALRMTR</name>
          <displayName>ALRMTR</displayName>
          <description>Alarm Time Register</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>PM</name>
              <description>
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HT</name>
              <description>
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>HU</name>
              <description>
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>MNT</name>
              <description>
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>MNU</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>ST</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>SU</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SS</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ALRMDR</name>
          <displayName>ALRMDR</displayName>
          <description>Alarm Date Register</description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>MSKWD</name>
              <description>
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MSKM</name>
              <description>
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MSKD</name>
              <description>
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MSKH</name>
              <description>
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MSKMN</name>
              <description>
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MSKS</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MSKSS</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>WD</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>MT</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MU</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>DT</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>DU</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SHIFTR</name>
          <displayName>SHIFTR</displayName>
          <description>Shift Control Register</description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>ADD1S</name>
              <description>
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>21</bitWidth>
            </field>
            <field>
              <name>SUBFS</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TSTR</name>
          <displayName>TSTR</displayName>
          <description>Timestamp Time Register</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>PM</name>
              <description>
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HT</name>
              <description>
              </description>
              <bitOffset>29</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>HU</name>
              <description>
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>MNT</name>
              <description>
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>MNU</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>ST</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>SU</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SS</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TSDR</name>
          <displayName>TSDR</displayName>
          <description>Timestamp Date Register</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>WD</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>MT</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MU</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>DT</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>DU</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>OR</name>
          <displayName>OR</displayName>
          <description></description>
          <addressOffset>0x2c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BKP0R</name>
          <displayName>BKP0R</displayName>
          <description>Backup 0 Register</description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>BKP</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BKP1R</name>
          <displayName>BKP1R</displayName>
          <description>Backup 1 Register</description>
          <addressOffset>0x34</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>BKP</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BKP2R</name>
          <displayName>BKP2R</displayName>
          <description>Backup 2 Register</description>
          <addressOffset>0x38</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>BKP</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BKP3R</name>
          <displayName>BKP3R</displayName>
          <description>Backup 3 Register</description>
          <addressOffset>0x3c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>BKP</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BKP4R</name>
          <displayName>BKP4R</displayName>
          <description>Backup 4 Register</description>
          <addressOffset>0x40</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>BKP</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BKP5R</name>
          <displayName>BKP5R</displayName>
          <description>Backup 5 Register</description>
          <addressOffset>0x44</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>BKP</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BKP6R</name>
          <displayName>BKP6R</displayName>
          <description>Backup 6 Register</description>
          <addressOffset>0x48</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>BKP</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BKP7R</name>
          <displayName>BKP7R</displayName>
          <description>Backup 7 Register</description>
          <addressOffset>0x4c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>BKP</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BKP8R</name>
          <displayName>BKP8R</displayName>
          <description>Backup 8 Register</description>
          <addressOffset>0x50</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>BKP</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BKP9R</name>
          <displayName>BKP9R</displayName>
          <description>Backup 9 Register</description>
          <addressOffset>0x54</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>BKP</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BKP10R</name>
          <displayName>BKP10R</displayName>
          <description>Backup 10 Register</description>
          <addressOffset>0x58</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>BKP</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BKP11R</name>
          <displayName>BKP11R</displayName>
          <description>Backup 11 Register</description>
          <addressOffset>0x5c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>BKP</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BKP12R</name>
          <displayName>BKP12R</displayName>
          <description>Backup 12 Register</description>
          <addressOffset>0x60</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>BKP</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BKP13R</name>
          <displayName>BKP13R</displayName>
          <description>Backup 13 Register</description>
          <addressOffset>0x64</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>BKP</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BKP14R</name>
          <displayName>BKP14R</displayName>
          <description>Backup 14 Register</description>
          <addressOffset>0x68</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>BKP</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BKP15R</name>
          <displayName>BKP15R</displayName>
          <description>Backup 15 Register</description>
          <addressOffset>0x6c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>BKP</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BKP16R</name>
          <displayName>BKP16R</displayName>
          <description>Backup 16 Register</description>
          <addressOffset>0x70</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>BKP</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BKP17R</name>
          <displayName>BKP17R</displayName>
          <description>Backup 17 Register</description>
          <addressOffset>0x74</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>BKP</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BKP18R</name>
          <displayName>BKP18R</displayName>
          <description>Backup 18 Register</description>
          <addressOffset>0x78</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>BKP</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BKP19R</name>
          <displayName>BKP19R</displayName>
          <description>Backup 19 Register</description>
          <addressOffset>0x7c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>BKP</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BKP20R</name>
          <displayName>BKP20R</displayName>
          <description>Backup 20 Register</description>
          <addressOffset>0x80</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>BKP</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BKP21R</name>
          <displayName>BKP21R</displayName>
          <description>Backup 21 Register</description>
          <addressOffset>0x84</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>BKP</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BKP22R</name>
          <displayName>BKP22R</displayName>
          <description>Backup 22 Register</description>
          <addressOffset>0x88</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>BKP</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BKP23R</name>
          <displayName>BKP23R</displayName>
          <description>Backup 23 Register</description>
          <addressOffset>0x8c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>BKP</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BKP24R</name>
          <displayName>BKP24R</displayName>
          <description>Backup 24 Register</description>
          <addressOffset>0x90</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>BKP</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BKP25R</name>
          <displayName>BKP25R</displayName>
          <description>Backup 25 Register</description>
          <addressOffset>0x94</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>BKP</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BKP26R</name>
          <displayName>BKP26R</displayName>
          <description>Backup 26 Register</description>
          <addressOffset>0x98</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>BKP</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BKP27R</name>
          <displayName>BKP27R</displayName>
          <description>Backup 27 Register</description>
          <addressOffset>0x9c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>BKP</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BKP28R</name>
          <displayName>BKP28R</displayName>
          <description>Backup 28 Register</description>
          <addressOffset>0xa0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>BKP</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BKP29R</name>
          <displayName>BKP29R</displayName>
          <description>Backup 29 Register</description>
          <addressOffset>0xa4</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>BKP</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BKP30R</name>
          <displayName>BKP30R</displayName>
          <description>Backup 30 Register</description>
          <addressOffset>0xa8</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>BKP</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BKP31R</name>
          <displayName>BKP31R</displayName>
          <description>Backup 31 Register</description>
          <addressOffset>0xac</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>BKP</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PBRCR</name>
          <displayName>PBRCR</displayName>
          <description>PBR Control Register</description>
          <addressOffset>0xb0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>30</bitWidth>
            </field>
            <field>
              <name>SNS</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RTO</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PBR0R</name>
          <displayName>PBR0R</displayName>
          <description>PBR0 Register</description>
          <addressOffset>0xb4</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>FORCE1</name>
              <description>
              special use. Set 1 to force output 1
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>SEL</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>IN</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OE</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OUT</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PBR1R</name>
          <displayName>PBR1R</displayName>
          <description>PBR1 Register</description>
          <addressOffset>0xb8</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
            <field>
              <name>SEL</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>IN</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OE</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OUT</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PBR2R</name>
          <displayName>PBR2R</displayName>
          <description>PBR2 Register</description>
          <addressOffset>0xbc</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
            <field>
              <name>SEL</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>IN</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OE</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OUT</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PBR3R</name>
          <displayName>PBR3R</displayName>
          <description>PBR3 Register</description>
          <addressOffset>0xc0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
            <field>
              <name>SEL</name>
              <description>
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>IN</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS1</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DS0</name>
              <description>
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>IE</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OE</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OUT</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PAWKUP</name>
          <displayName>PAWKUP</displayName>
          <description>PA Wakeup Register</description>
          <addressOffset>0xc4</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>19</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PBWKUP</name>
          <displayName>PBWKUP</displayName>
          <description>PB Wakeup Register</description>
          <addressOffset>0xc8</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>19</bitWidth>
            </field>
            <field>
              <name>PS</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>PE</name>
              <description>
              Enable PB32 WKUP pull-down by default
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>IWDT</name>
      <description></description>
      <groupName>WDT</groupName>
      <baseAddress>0x5004c000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>WDT_CVR0</name>
          <displayName>WDT_CVR0</displayName>
          <description>WatchDog Counter Value 0</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>COUNT_VALUE_0</name>
              <description>
              Count Value for 1st TimeOut
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_CVR1</name>
          <displayName>WDT_CVR1</displayName>
          <description>WatchDog Counter Value 1</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>COUNT_VALUE_1</name>
              <description>
              Count Value for 2nd TimeOut
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_CR</name>
          <displayName>WDT_CR</displayName>
          <description>WatchDog Control Register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>27</bitWidth>
            </field>
            <field>
              <name>RESPONSE_MODE</name>
              <description>
              0:reset only, 1:interrupt and reset
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RESET_LENGTH</name>
              <description>
              reset pulse length in number of wdt clock cycles
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_CCR</name>
          <displayName>WDT_CCR</displayName>
          <description>WatchDog Counter Control Register</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>COUNTER_CONTROL</name>
              <description>
              SinglePulse /Write 8'h76 to restart, write8'h34 to stop, else do nothing
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_ICR</name>
          <displayName>WDT_ICR</displayName>
          <description>WatchDog Interrupt Clear Register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>31</bitWidth>
            </field>
            <field>
              <name>INT_CLR</name>
              <description>
              SinglePulse /A pulse to clear interrupt
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_SR</name>
          <displayName>WDT_SR</displayName>
          <description>WatchDog Status Register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>30</bitWidth>
            </field>
            <field>
              <name>WDT_ACTIVE</name>
              <description>
              Watchdog runs when 1, else 0
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>INT_ASSERT</name>
              <description>
              Interrupt assert when 1
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_WP</name>
          <displayName>WDT_WP</displayName>
          <description>WatchDog Write Protect Register</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>WRPT_ST</name>
              <description>
              1 indicates write protect is active
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>WRPT</name>
              <description>
              write 0x58ab99fc generate write_protect, write 0x51ff8621 to release
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>31</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_FG</name>
          <displayName>WDT_FG</displayName>
          <description>WatchDog Flag Register</description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>28</bitWidth>
            </field>
            <field>
              <name>SYNC_FG</name>
              <description>
              1 indicates one transition from system clk to wdt clk has complicated
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SYNC_FG_CLR</name>
              <description>
              SinglePulse/A pulse to clear sync flag
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RST_FG</name>
              <description>
              1 indicates wdt has already reset system
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RST_FG_CLR</name>
              <description>
              SinglePulse/A pulse to clear reset flag
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>LPSYS_GPIO</name>
      <description></description>
      <groupName>LPSYS_GPIO</groupName>
      <baseAddress>0x50080000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>DIR0</name>
          <displayName>DIR0</displayName>
          <description>Data Input Register</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>IN</name>
              <description>
              GPIO[31:0] input value
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DOR0</name>
          <displayName>DOR0</displayName>
          <description>Data Output Register</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>OUT</name>
              <description>
              GPIO[31:0] output value if output enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DOSR0</name>
          <displayName>DOSR0</displayName>
          <description>Data Output  Set Register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>DOS</name>
              <description>
              set 1 to pull up output of corresponding GPIO[31:0]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DOCR0</name>
          <displayName>DOCR0</displayName>
          <description>Data Output  Clear Register</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>DOC</name>
              <description>
              set 1 to  pull down output of corresponding GPIO[31:0]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DOER0</name>
          <displayName>DOER0</displayName>
          <description>Data Output Enable Register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>DOE</name>
              <description>
              GPIO[31:0] output enable
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DOESR0</name>
          <displayName>DOESR0</displayName>
          <description>Data Output Enable Set Register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>DOES</name>
              <description>
              set 1 to enable output of corresponding GPIO[31:0]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DOECR0</name>
          <displayName>DOECR0</displayName>
          <description>Data Output Enable Clear Register</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>DOEC</name>
              <description>
              set 1 to disable output of corresponding GPIO[31:0]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IER0</name>
          <displayName>IER0</displayName>
          <description>Interrupt Enable Register</description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>IER</name>
              <description>
              GPIO[31:0]  interrupt  enable
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IESR0</name>
          <displayName>IESR0</displayName>
          <description>Interrupt Enable Set Register</description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>IES</name>
              <description>
              set 1 to enable interrupt of corresponding GPIO[31:0]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IECR0</name>
          <displayName>IECR0</displayName>
          <description>Interrupt Enable Clear Register</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>IEC</name>
              <description>
              set 1 to disable interrupt of corresponding GPIO[31:0]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ITR0</name>
          <displayName>ITR0</displayName>
          <description>Interrupt Type Register</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>ITR</name>
              <description>
              GPIO[31:0]  interrupt  type
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ITSR0</name>
          <displayName>ITSR0</displayName>
          <description>Interrupt Type Set Register</description>
          <addressOffset>0x2c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>ITS</name>
              <description>
              set 1 for edge-sensitive interrupt mode of corresponding GPIO[31:0]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ITCR0</name>
          <displayName>ITCR0</displayName>
          <description>Interrupt Type Clear Register</description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>ITC</name>
              <description>
              set 1 for level-sensitive interrupt mode of corresponding GPIO[31:0]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IPHR0</name>
          <displayName>IPHR0</displayName>
          <description>Interrupt Polarity High Register</description>
          <addressOffset>0x34</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>IPH</name>
              <description>
              rising edge in edge mode, or high level in level mode of corresponding GPIO[31:0]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IPHSR0</name>
          <displayName>IPHSR0</displayName>
          <description>Interrupt Polarity  High Set Register</description>
          <addressOffset>0x38</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>IPHS</name>
              <description>
              set 1 for rising edge in edge mode, or high level in level mode of corresponding GPIO[31:0]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IPHCR0</name>
          <displayName>IPHCR0</displayName>
          <description>Interrupt Polarity  High Clear  Register</description>
          <addressOffset>0x3c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>IPHC</name>
              <description>
              set 1 for disable rising edge in edge mode, or high level in level mode of corresponding GPIO[31:0]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IPLR0</name>
          <displayName>IPLR0</displayName>
          <description>Interrupt Polarity Low Register</description>
          <addressOffset>0x40</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>IPL</name>
              <description>
              falling edge in edge mode, or low level in level mode of corresponding GPIO[31:0]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IPLSR0</name>
          <displayName>IPLSR0</displayName>
          <description>Interrupt Polarity Low Set Register</description>
          <addressOffset>0x44</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>IPLS</name>
              <description>
              set 1 for falling edge in edge mode, or low level in level mode of corresponding GPIO[31:0]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IPLCR0</name>
          <displayName>IPLCR0</displayName>
          <description>Interrupt Polarity Low Clear Register</description>
          <addressOffset>0x48</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>IPLC</name>
              <description>
              set 1 for disable falling edge in edge mode, or low level in level mode of corresponding GPIO[31:0]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ISR0</name>
          <displayName>ISR0</displayName>
          <description>Interrupt Status Register</description>
          <addressOffset>0x4c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>IS</name>
              <description>
              Interrupt status. Write 1 will clear interrupt status of corresponding GPIO[31:0]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IER0_EXT</name>
          <displayName>IER0_EXT</displayName>
          <description>Extra Interrupt Enable  Register</description>
          <addressOffset>0x50</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>IER</name>
              <description>
              GPIO[31:0]  extra interrupt  enable
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IESR0_EXT</name>
          <displayName>IESR0_EXT</displayName>
          <description>Extra Interrupt Enable Set Register</description>
          <addressOffset>0x54</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>IES</name>
              <description>
              set 1 to enable extra interrupt of corresponding GPIO[31:0]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IECR0_EXT</name>
          <displayName>IECR0_EXT</displayName>
          <description>Extra Interrupt Enable Clear Register</description>
          <addressOffset>0x58</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>IEC</name>
              <description>
              set 1 to disable extra interrupt of corresponding GPIO[31:0]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ISR0_EXT</name>
          <displayName>ISR0_EXT</displayName>
          <description>Extra Interrupt Status Register</description>
          <addressOffset>0x5c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>IS</name>
              <description>
              Interrupt status. Write 1 will clear extra interrupt status of corresponding GPIO[31:0]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>OEMR0</name>
          <displayName>OEMR0</displayName>
          <description>output mode Register</description>
          <addressOffset>0x60</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>OEM</name>
              <description>
              output mode of corresponding GPIO[31:0]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>OEMSR0</name>
          <displayName>OEMSR0</displayName>
          <description>output mode Set Register</description>
          <addressOffset>0x64</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>OEMS</name>
              <description>
              output mode Set of corresponding GPIO[31:0]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>OEMCR0</name>
          <displayName>OEMCR0</displayName>
          <description>output mode Clear Register</description>
          <addressOffset>0x68</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>OEMC</name>
              <description>
              output mode Clear of corresponding GPIO[31:0]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD1</name>
          <displayName>RSVD1</displayName>
          <description></description>
          <addressOffset>0x6C</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>DIR1</name>
          <displayName>DIR1</displayName>
          <description>Data Input Register</description>
          <addressOffset>0x80</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>27</bitWidth>
            </field>
            <field>
              <name>IN</name>
              <description>
              GPIO[36:32] input value
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DOR1</name>
          <displayName>DOR1</displayName>
          <description>Data Output Register</description>
          <addressOffset>0x84</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>27</bitWidth>
            </field>
            <field>
              <name>OUT</name>
              <description>
              GPIO[36:32] output value if output enabled
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DOSR1</name>
          <displayName>DOSR1</displayName>
          <description>Data Output  Set Register</description>
          <addressOffset>0x88</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>27</bitWidth>
            </field>
            <field>
              <name>DOS</name>
              <description>
              set 1 to pull up output of corresponding GPIO[36:32]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DOCR1</name>
          <displayName>DOCR1</displayName>
          <description>Data Output  Clear Register</description>
          <addressOffset>0x8c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>27</bitWidth>
            </field>
            <field>
              <name>DOC</name>
              <description>
              set 1 to  pull down output of corresponding GPIO[36:32]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DOER1</name>
          <displayName>DOER1</displayName>
          <description>Data Output Enable Register</description>
          <addressOffset>0x90</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>27</bitWidth>
            </field>
            <field>
              <name>DOE</name>
              <description>
              GPIO[36:32] output enable
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DOESR1</name>
          <displayName>DOESR1</displayName>
          <description>Data Output Enable Set Register</description>
          <addressOffset>0x94</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>27</bitWidth>
            </field>
            <field>
              <name>DOES</name>
              <description>
              set 1 to enable output of corresponding GPIO[36:32]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DOECR1</name>
          <displayName>DOECR1</displayName>
          <description>Data Output Enable Clear Register</description>
          <addressOffset>0x98</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>27</bitWidth>
            </field>
            <field>
              <name>DOEC</name>
              <description>
              set 1 to disable output of corresponding GPIO[36:32]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IER1</name>
          <displayName>IER1</displayName>
          <description>Interrupt Enable Register</description>
          <addressOffset>0x9c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>27</bitWidth>
            </field>
            <field>
              <name>IER</name>
              <description>
              GPIO[36:32] interrupt  enable
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IESR1</name>
          <displayName>IESR1</displayName>
          <description>Interrupt Enable Set Register</description>
          <addressOffset>0xa0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>27</bitWidth>
            </field>
            <field>
              <name>IES</name>
              <description>
              set 1 to enable interrupt of corresponding GPIO[36:32]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IECR1</name>
          <displayName>IECR1</displayName>
          <description>Interrupt Enable Clear Register</description>
          <addressOffset>0xa4</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>27</bitWidth>
            </field>
            <field>
              <name>IEC</name>
              <description>
              set 1 to disable interrupt of corresponding GPIO[36:32]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ITR1</name>
          <displayName>ITR1</displayName>
          <description>Interrupt Type Register</description>
          <addressOffset>0xa8</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>27</bitWidth>
            </field>
            <field>
              <name>ITR</name>
              <description>
              GPIO[36:32]  interrupt  type
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ITSR1</name>
          <displayName>ITSR1</displayName>
          <description>Interrupt Type Set Register</description>
          <addressOffset>0xac</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>27</bitWidth>
            </field>
            <field>
              <name>ITS</name>
              <description>
              set 1 for edge-sensitive interrupt mode of corresponding GPIO[36:32]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ITCR1</name>
          <displayName>ITCR1</displayName>
          <description>Interrupt Type Clear Register</description>
          <addressOffset>0xb0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>27</bitWidth>
            </field>
            <field>
              <name>ITC</name>
              <description>
              set 1 for level-sensitive interrupt mode of corresponding GPIO[36:32]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IPHR1</name>
          <displayName>IPHR1</displayName>
          <description>Interrupt Polarity High Register</description>
          <addressOffset>0xb4</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>27</bitWidth>
            </field>
            <field>
              <name>IPH</name>
              <description>
              rising edge in edge mode, or high level in level mode of corresponding GPIO[36:32]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IPHSR1</name>
          <displayName>IPHSR1</displayName>
          <description>Interrupt Polarity  High Set Register</description>
          <addressOffset>0xb8</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>27</bitWidth>
            </field>
            <field>
              <name>IPHS</name>
              <description>
              set 1 for rising edge in edge mode, or high level in level mode of corresponding GPIO[36:32]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IPHCR1</name>
          <displayName>IPHCR1</displayName>
          <description>Interrupt Polarity  High Clear  Register</description>
          <addressOffset>0xbc</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>27</bitWidth>
            </field>
            <field>
              <name>IPHC</name>
              <description>
              set 1 for disable rising edge in edge mode, or high level in level mode of corresponding GPIO[36:32]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IPLR1</name>
          <displayName>IPLR1</displayName>
          <description>Interrupt Polarity Low Register</description>
          <addressOffset>0xc0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>27</bitWidth>
            </field>
            <field>
              <name>IPL</name>
              <description>
              falling edge in edge mode, or low level in level mode of corresponding GPIO[36:32]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IPLSR1</name>
          <displayName>IPLSR1</displayName>
          <description>Interrupt Polarity Low Set Register</description>
          <addressOffset>0xc4</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>27</bitWidth>
            </field>
            <field>
              <name>IPLS</name>
              <description>
              set 1 for falling edge in edge mode, or low level in level mode of corresponding GPIO[36:32]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IPLCR1</name>
          <displayName>IPLCR1</displayName>
          <description>Interrupt Polarity Low Clear Register</description>
          <addressOffset>0xc8</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>27</bitWidth>
            </field>
            <field>
              <name>IPLC</name>
              <description>
              set 1 for disable falling edge in edge mode, or low level in level mode of corresponding GPIO[36:32]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ISR1</name>
          <displayName>ISR1</displayName>
          <description>Interrupt Status Register</description>
          <addressOffset>0xcc</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>27</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Interrupt status. Write 1 will clear interrupt status of corresponding GPIO[36:32]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IER1_EXT</name>
          <displayName>IER1_EXT</displayName>
          <description>Extra Interrupt Enable  Register</description>
          <addressOffset>0xd0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>27</bitWidth>
            </field>
            <field>
              <name>IER</name>
              <description>
              GPIO[36:32] extra interrupt  enable
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IESR1_EXT</name>
          <displayName>IESR1_EXT</displayName>
          <description>Extra Interrupt Enable Set Register</description>
          <addressOffset>0xd4</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>27</bitWidth>
            </field>
            <field>
              <name>IES</name>
              <description>
              set 1 to enable extra interrupt of corresponding GPIO[36:32]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IECR1_EXT</name>
          <displayName>IECR1_EXT</displayName>
          <description>Extra Interrupt Enable Clear Register</description>
          <addressOffset>0xd8</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>27</bitWidth>
            </field>
            <field>
              <name>IEC</name>
              <description>
              set 1 to disable extra interrupt of corresponding GPIO[36:32]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ISR1_EXT</name>
          <displayName>ISR1_EXT</displayName>
          <description>extra Interrupt Status Register</description>
          <addressOffset>0xdc</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>27</bitWidth>
            </field>
            <field>
              <name>IS</name>
              <description>
              Interrupt status. Write 1 will clear interrupt status of corresponding GPIO[36:32]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>OEMR1</name>
          <displayName>OEMR1</displayName>
          <description>output mode Register</description>
          <addressOffset>0xe0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>27</bitWidth>
            </field>
            <field>
              <name>OEM</name>
              <description>
              output mode of corresponding GPIO[36:32]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>OEMSR1</name>
          <displayName>OEMSR1</displayName>
          <description>output mode Set Register</description>
          <addressOffset>0xe4</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>27</bitWidth>
            </field>
            <field>
              <name>OEMS</name>
              <description>
              output mode Set of corresponding GPIO[36:32]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>OEMCR1</name>
          <displayName>OEMCR1</displayName>
          <description>output mode Clear Register</description>
          <addressOffset>0xe8</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>27</bitWidth>
            </field>
            <field>
              <name>OEMC</name>
              <description>
              output mode Clear of corresponding GPIO[36:32]
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>MPI5</name>
      <description></description>
      <groupName>MPI</groupName>
      <baseAddress>0x50081000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CR</name>
          <displayName>CR</displayName>
          <description>Control Register</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ABORT</name>
              <description>
              Write 1 to abort internal state machine. For debug purpose only
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>AHBDIS</name>
              <description>
              Hold hreadyout low if AHB access
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DFM</name>
              <description>
              Dual Flash ModeReserved-Do not modify
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>MX16</name>
              <description>
              Mode X16Reserved-Do not modify
              </description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>PREFE</name>
              <description>
              Prefetch enable. If enabled, MPI will prefetch at consequtive address following a read transaction. 
              Recommend to use when reading large data in a burst manner.
              0: prefetch disabled
              1: prefetch enabled
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OPIE</name>
              <description>
              OPI interface enable
              0: x8 mode disabled
              1: x8 mode enabled
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HWIFE</name>
              <description>
              Hardware interface enableReserved-Do not modify
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SMM</name>
              <description>
              Status match mode
              0: AND mode
              1: OR mode
              </description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SME2</name>
              <description>
              Status match enable. If enabled, CMD2 will be issued repeatedly until the data match the value in SMR and SMKR
              0: disabled
              1: enabled
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SME1</name>
              <description>
              Status match enable. If enabled, CMD1 will be issued repeatedly until the data match the value in SMR and SMKR
              0: disabled
              1: enabled (either SME1 or SME2 can be enabled, and SME1 has high priority)
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CMD2E</name>
              <description>
              Enable CMD2
              0: disabled
              1: CMD2 is enabled and will be issued after CMD1 with an interval of TI2
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RBXIE</name>
              <description>
              Row boundary crossing interrupt enable
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CSVIE</name>
              <description>
              CS max violation interrupt enable
              </description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SMIE</name>
              <description>
              Status match interrupt enable
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD4</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCIE</name>
              <description>
              Transfer complete interrupt enable
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTRM</name>
              <description>
              AES-CTR mode
              0: AES-128
              1: AES-256
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CTRE</name>
              <description>
              AES-CTR on-the-fly decryption enable
              0: disabled
              1: enabled, data read from memory will be decrypted on the fly by MPI controller
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMAE</name>
              <description>
              DMA enable
              0: disabled
              1: enable DMA to read or write DR register
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HOLD</name>
              <description>
              The value of HOLD when HOLDE is set
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HOLDE</name>
              <description>
              Enable HOLD function on IO3. Use this only in SPI or Dual SPI mode
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>WP</name>
              <description>
              The value of WP when WPE is set
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>WPE</name>
              <description>
              Enable WP function on IO2. Use this only in SPI or Dual SPI mode
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>EN</name>
              <description>
              Enable MPI
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DR</name>
          <displayName>DR</displayName>
          <description>Data Register</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DATA</name>
              <description>
              The entry of internal data FIFO
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DCR</name>
          <displayName>DCR</displayName>
          <description>Device Control Register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>FIXLAT</name>
              <description>
              Indicate PSRAM is fixed latency or variable latency. It must be compatible to the configuration in PSRAM registers.
              Recommend always set to 1.
              0: variable latency
              1: fixed latency
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TRCMIN</name>
              <description>
              Write/Read cycle minimum time in internal MCLK cycles. Please see MCLK frequency in PSCLR description.
              For example, if PSRAM clock is 120MHz (i.e. internal MCLK is 240MHz) and TRCMIN = n, then
              tRC time = (n+1) * 1000/240 ns which must meet minimum tRC requirement for PSRAM
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>CSHMIN</name>
              <description>
              Minimum CS high deselect time in MCLK cycles.
              For example, if PSRAM clock is 120MHz (i.e. internal MCLK is 240MHz) and CSHMIN = n, then
              CS High time = (n+1) * 1000/240 ns which must meet minimum tCPH requirement for PSRAM
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>CSLMIN</name>
              <description>
              Minimum CS low active time in MCLK cycles.
              For example, if PSRAM clock is 120MHz (i.e. internal MCLK is 240MHz) and CSLMIN = n, then
              CS Low time = (n+1) * 1000/240 ns which must meet the minimum tCEM requirement for PSRAM
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>CSLMAX</name>
              <description>
              Maximum CS low active time in MCLK cycles
              For example, if PSRAM clock is 120MHz (i.e. internal MCLK is 240MHz) and CSLMAX = n, then
              CS Low time = (n+1) * 1000/240 ns which must meet the maximum tCEM requirement for PSRAM
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
            <field>
              <name>XLEGACY</name>
              <description>
              Xccela legacy protocol. Set to 1 for AP 32Mb PSRAM only, othersize always set to 0.
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>HYPER</name>
              <description>
              HyperBus protocol. Set to 1 for HyperRAM.
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DQSE</name>
              <description>
              DQS enable. Setting to 1 indicates device provides DQS signal for Rx data latching
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RBSIZE</name>
              <description>
              Row boundary size.
              0: no row boundary
              1: 2^(1+3) = 16 bytes
              2: 2^(2+3) = 32 bytes
              
              n: 2^(n+3) bytes
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PSCLR</name>
          <displayName>PSCLR</displayName>
          <description>Prescaler Register</description>
          <addressOffset>0x0c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>DIV</name>
              <description>
              Prescaler divider.
              0: MCLK = FCLK/1
              1: MCLK = FCLK/1
              2: MCLK = FCLK/2
              n: MCLK = FCLK/n
              Note: FLASH clock = MCLK. E.g. FCLK=192M and DIV=2, then FLASH clock = MCLK = 192/2 = 96MHz
              PSRAM clock = MCLK/2. E.g. FCLK=240M and DIV=1, then PSRAM clock = MCLK/2 = 240/2 = 120MHz
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SR</name>
          <displayName>SR</displayName>
          <description>Status Register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000006</resetValue>
          <fields>
            <field>
              <name>BUSY</name>
              <description>
              For debug purpose only
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>25</bitWidth>
            </field>
            <field>
              <name>RBXF</name>
              <description>
              Row boundary crossing flag
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CSVF</name>
              <description>
              CS max violation flag
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SMF</name>
              <description>
              Status match flag in Polling Mode
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCF</name>
              <description>
              Transfer complete flag
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SCR</name>
          <displayName>SCR</displayName>
          <description>Status Clear Register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>26</bitWidth>
            </field>
            <field>
              <name>RBXFC</name>
              <description>
              Write 1 to clear RBXF
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CSVFC</name>
              <description>
              Write 1 to clear CSVF
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SMFC</name>
              <description>
              Write 1 to clear SMF
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD3</name>
              <description>
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TCFC</name>
              <description>
              Write 1 to clear TCF
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CMDR1</name>
          <displayName>CMDR1</displayName>
          <description>Command Register</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>CMD</name>
              <description>
              Command. Write to this register will trigger the sequence specified in CCR1
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>AR1</name>
          <displayName>AR1</displayName>
          <description>Address Register</description>
          <addressOffset>0x1c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ADDR</name>
              <description>
              Address
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ABR1</name>
          <displayName>ABR1</displayName>
          <description>Alternate Byte Register</description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ABYTE</name>
              <description>
              Alternate byte
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DLR1</name>
          <displayName>DLR1</displayName>
          <description>Data Length Register</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
            <field>
              <name>DLEN</name>
              <description>
              Data length
              0: one byte
              1: two bytes
              
              n: (n+1) bytes
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR1</name>
          <displayName>CCR1</displayName>
          <description>Communication Configuration Register</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
            <field>
              <name>FMODE</name>
              <description>
              Function Mode
              0: read mode
              1: write mode
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMODE</name>
              <description>
              Data Mode
              0: no data phase
              1: single line
              2: dual lines
              3: quad lines
              4/5/6: reserved
              7: quad lines DDR
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>DCYC</name>
              <description>
              Number of dummy cycles
              0: no dummy cycle
              1: one dummy cycle
              2: two dummy cycles
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>ABSIZE</name>
              <description>
              Alternate byte size
              0: one byte
              1: two bytes
              2: three bytes
              3: four bytes
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>ABMODE</name>
              <description>
              Alternate byte mode
              0: no alternate byte
              1: single line
              2: dual lines
              3: quad lines
              4/5/6: reserved
              7: quad lines DDR
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>ADSIZE</name>
              <description>
              Address size
              0: one byte
              1: two bytes
              2: three bytes
              3: four bytes
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>ADMODE</name>
              <description>
              Address mode
              0: no address phase
              1: single line
              2: dual line
              3: quad line
              4/5/6: reserved
              7: quad line DDR
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>IMODE</name>
              <description>
              Instruction mode
              0: no instruction phase
              1: single line
              2: dual lines
              3: quad lines
              4/5/6 - reserved
              7 - quad lines DDR
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CMDR2</name>
          <displayName>CMDR2</displayName>
          <description>Command Register</description>
          <addressOffset>0x2c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>CMD</name>
              <description>
              Command 2. If CMD2E is enabled, the CMD2 sequence will be issued after CMD1 as specified in CCR2
              Note: CMD2 sequence cannot be issue individually
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>AR2</name>
          <displayName>AR2</displayName>
          <description>Address Register</description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ADDR</name>
              <description>
              Address byte in CMD2 sequence
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>ABR2</name>
          <displayName>ABR2</displayName>
          <description>Alternate Byte Register</description>
          <addressOffset>0x34</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ABYTE</name>
              <description>
              Alternate byte in CMD2 sequence
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>DLR2</name>
          <displayName>DLR2</displayName>
          <description>Data Length Register</description>
          <addressOffset>0x38</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>20</bitOffset>
              <bitWidth>12</bitWidth>
            </field>
            <field>
              <name>DLEN</name>
              <description>
              Data length in CMD2 sequence
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>20</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR2</name>
          <displayName>CCR2</displayName>
          <description>Communication Configuration Register</description>
          <addressOffset>0x3c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>22</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
            <field>
              <name>FMODE</name>
              <description>
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DMODE</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>DCYC</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>ABSIZE</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>ABMODE</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>ADSIZE</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>ADMODE</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>IMODE</name>
              <description>
              This register specifies the format of CMD2 sequence. Refer to CCR1 description
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>HCMDR</name>
          <displayName>HCMDR</displayName>
          <description>AHB Command Register</description>
          <addressOffset>0x40</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>WCMD</name>
              <description>
              AHB write command. During XIP, the AHB write transaction will be translated into this Write Command on memory interface
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>RCMD</name>
              <description>
              AHB read command. During XIP, the AHB read transaction will be translated into this Read Command on memory interface
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>HRABR</name>
          <displayName>HRABR</displayName>
          <description>AHB Read Alternate Byte Register</description>
          <addressOffset>0x44</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ABYTE</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>HRCCR</name>
          <displayName>HRCCR</displayName>
          <description>AHB Read Communication Configuration Register</description>
          <addressOffset>0x48</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
            <field>
              <name>DMODE</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>DCYC</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>ABSIZE</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>ABMODE</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>ADSIZE</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>ADMODE</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>IMODE</name>
              <description>
              This register specifies the format of AHB read command sequence. Refer to CCR1 description
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>HWABR</name>
          <displayName>HWABR</displayName>
          <description>AHB Write Alternate Byte Register</description>
          <addressOffset>0x4c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ABYTE</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>HWCCR</name>
          <displayName>HWCCR</displayName>
          <description>AHB Write Communication Configuration Register</description>
          <addressOffset>0x50</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>21</bitOffset>
              <bitWidth>11</bitWidth>
            </field>
            <field>
              <name>DMODE</name>
              <description>
              </description>
              <bitOffset>18</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>DCYC</name>
              <description>
              </description>
              <bitOffset>13</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>ABSIZE</name>
              <description>
              </description>
              <bitOffset>11</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>ABMODE</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>ADSIZE</name>
              <description>
              </description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>ADMODE</name>
              <description>
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
            <field>
              <name>IMODE</name>
              <description>
              This register specifies the format of AHB write command sequence. Refer to CCR1 description
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>FIFOCR</name>
          <displayName>FIFOCR</displayName>
          <description>FIFO Control Register</description>
          <addressOffset>0x54</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>15</bitOffset>
              <bitWidth>17</bitWidth>
            </field>
            <field>
              <name>TXSLOTS</name>
              <description>
              When DMA enabled, asserts DMA reqeust if TXFIFO vacant slots is greater than or equal to TXSLOTS.
              Note: this field should be set in accordance to the burst length in DMA. For example, if DMA employs BURST8 transction, then this filed is set to 8
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>5</bitWidth>
            </field>
            <field>
              <name>TXF</name>
              <description>
              Tx FIFO full flag
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TXCLR</name>
              <description>
              write 1 to clear Tx FIFO
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD2</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>6</bitWidth>
            </field>
            <field>
              <name>RXE</name>
              <description>
              Rx FIFO empty
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RXCLR</name>
              <description>
              write 1 to clear Rx FIFO
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>MISCR</name>
          <displayName>MISCR</displayName>
          <description>Miscelaneous Register</description>
          <addressOffset>0x58</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>DBGSEL</name>
              <description>
              </description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DTRPRE</name>
              <description>
              Enable pre-sampling for DTRReserved-Do not modify
              </description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>SCKINV</name>
              <description>
              Invert output clock. This bit is used to align (coarse tune) the output clock to the center of output data.
              </description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RXCLKINV</name>
              <description>
              Invert internal Rx clock to add half-cycle delay (coarse tune) when sampling data. It is usually used for FLASH device w/ higher frequency.
              </description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DQSDLY</name>
              <description>
              Delay the input DQS signal to the appropriate sampling position.  For device w/ DQS signal only. Note: effective 7-bit
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>SCKDLY</name>
              <description>
              Add delay on output clock to fine tune the clock position. Note: effective 7-bit
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
            <field>
              <name>RXCLKDLY</name>
              <description>
              Add delay on internal Rx clock  to fine tune the sampling position. Note: effective 5-bit
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CTRSAR</name>
          <displayName>CTRSAR</displayName>
          <description>CTR Starting Address Register</description>
          <addressOffset>0x5c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>SA</name>
              <description>
              Starting address of the AES decryption area. Since the lowest 10 bits are zero, the address is always 1KB aligned.
              Together with CTREAR, the total area is [CTRSAR, CTREAR)
              For example, CTRSAR = 32'h0, CTREAR = 32'h200000, then the on-the-fly decryption area is 0x0 - 0x1FFFFF
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>22</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CTREAR</name>
          <displayName>CTREAR</displayName>
          <description>CTR Ending Address Register</description>
          <addressOffset>0x60</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>EA</name>
              <description>
              Ending address of the AES decryption area
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>22</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>NONCEA</name>
          <displayName>NONCEA</displayName>
          <description>Nonce A Register</description>
          <addressOffset>0x64</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>NONCEA</name>
              <description>
              Used for on-the-fly decryption
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>NONCEB</name>
          <displayName>NONCEB</displayName>
          <description>Nonce B Register</description>
          <addressOffset>0x68</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>NONCEB</name>
              <description>
              Used for on-the-fly decryption
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>AASAR</name>
          <displayName>AASAR</displayName>
          <description>Address Aliasing Start Address Register</description>
          <addressOffset>0x6c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>SA</name>
              <description>
              Starting address of the address aliasing area. Always 1KB aligned.Together with AAEAR, the aliasing area is [AASAR, AAEAR). 
              If the address falls into this area, an offset AAOAR is added and the aliased address will be used to access external memory
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>22</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>AAEAR</name>
          <displayName>AAEAR</displayName>
          <description>Address Aliasing Ending Address Register</description>
          <addressOffset>0x70</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>EA</name>
              <description>
              Ending address of the address aliasing area
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>22</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>AAOAR</name>
          <displayName>AAOAR</displayName>
          <description>Address Aliasing Offset Address Register</description>
          <addressOffset>0x74</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>OA</name>
              <description>
              The offset to be added to the original address
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>22</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CIR</name>
          <displayName>CIR</displayName>
          <description>Command Interval Register</description>
          <addressOffset>0x78</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>INTERVAL2</name>
              <description>
              The interval between CMD1 and CMD2 (or between CMD2 itself) if CMD2E is enabled. The unit is in MCLK cycles
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>INTERVAL1</name>
              <description>
              The interval between CMD1 itself. The unit is in MCLK cycles
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SMR</name>
          <displayName>SMR</displayName>
          <description>Status Match Register</description>
          <addressOffset>0x7c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>STATUS</name>
              <description>
              If status match is enabled, this register is compared with the data read from external memory.
              Together with SMKR, only the bits with mask=1 will be considered to compare in AND or OR mode as configured in SMM field.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SMKR</name>
          <displayName>SMKR</displayName>
          <description>Status Mask Register</description>
          <addressOffset>0x80</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>MASK</name>
              <description>
              Status mask
              0: the corresponding bit is not considered to compare
              1: the corresponding bit is considered to compare
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TIMR</name>
          <displayName>TIMR</displayName>
          <description>Timer Register</description>
          <addressOffset>0x84</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>TIMEOUT</name>
              <description>
              After the transaction is complete, CS remains low for multiple cycles of MCLK as specified by this register.
              For example if TIMEOUT=n, CS remains active for n cycles, during which if a new transaction occurs and the address is consecutive, the memory access can be resumed w/o sending the command and address again.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>WDTR</name>
          <displayName>WDTR</displayName>
          <description>WDT Register</description>
          <addressOffset>0x88</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>TOF</name>
              <description>
              Timeout flag. Self cleared when HREADYOUT becomes ready
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>17</bitOffset>
              <bitWidth>14</bitWidth>
            </field>
            <field>
              <name>EN</name>
              <description>
              WDT enable. This watchdog is on AHB side such that bus access will not hang in exceptional cases
              </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>TIMEOUT</name>
              <description>
              Set timeout value in number of clk_wdt cycles
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PRSAR</name>
          <displayName>PRSAR</displayName>
          <description>Prefetch Starting Address Register</description>
          <addressOffset>0x8c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>SA</name>
              <description>
              Starting address of the prefetch area
              If prefetch is enabled and the read address falls into [PRSAR, PREAR), controller will prefetch the following data
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>22</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PREAR</name>
          <displayName>PREAR</displayName>
          <description>Prefetch Ending Address Register</description>
          <addressOffset>0x90</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>EA</name>
              <description>
              Ending address of the prefetch area
              </description>
              <bitOffset>10</bitOffset>
              <bitWidth>22</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>10</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CALCR</name>
          <displayName>CALCR</displayName>
          <description>Calibration Clock Register</description>
          <addressOffset>0x94</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>EN</name>
              <description>
              calibration enable
              </description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>9</bitOffset>
              <bitWidth>22</bitWidth>
            </field>
            <field>
              <name>DONE</name>
              <description>
              calibration done flag
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DELAY</name>
              <description>
              calibration delay result
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>APM32CR</name>
          <displayName>APM32CR</displayName>
          <description>APM32 Control Register</description>
          <addressOffset>0x98</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>TCPHW</name>
              <description>
              For special use by AP 32Mb PSRAM.Reserved-Do not modify
              </description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>TCPHR</name>
              <description>
              For special use by AP 32Mb PSRAM.Reserved-Do not modify
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CR2</name>
          <displayName>CR2</displayName>
          <description>Control Register 2</description>
          <addressOffset>0x9c</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>LOOP</name>
              <description>
              Repeat CMD1->CMD2 sequence for n times. This filed is only valid when CMD2E=1 and SME2=0.
              For example if LOOP=0, then the sequence is CMD1 -> CMD2.
              If LOOP=2, then the sequence is (CMD1->CMD2) -> (CMD1->CMD2) -> (CMD1->CMD2)
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>CRC2</name>
      <description></description>
      <groupName>CRC</groupName>
      <baseAddress>0x50085000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>DR</name>
          <displayName>DR</displayName>
          <description>Data register</description>
          <addressOffset>0x00</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>DR</name>
              <description>
              Data register bits.
              This register is used to write new data to the CRC calculator.
              It holds the previous CRC calculation result when it is read.
              If the data size is less than 32 bits, the least significant bits are used to write/read the correct value.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>SR</name>
          <displayName>SR</displayName>
          <description>Status register</description>
          <addressOffset>0x04</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>2</bitOffset>
              <bitWidth>30</bitWidth>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>
              Overflow when new data arrive while last calculation not done yet
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>DONE</name>
              <description>
              Done flag. When DR written, done flag will be cleared automatically. The flag will assert after CRC operation of current DR finished.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CR</name>
          <displayName>CR</displayName>
          <description>Control register</description>
          <addressOffset>0x08</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>RSVD</name>
              <description>
              </description>
              <bitOffset>8</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>REV_OUT</name>
              <description>
              Reverse output data
              This bit controls the reversal of the bit order of the output data.
              0: Bit order not affected
              1: Bit-reversed output format
              </description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>REV_IN</name>
              <description>
              Reverse input data
              These bits control the reversal of the bit order of the input data
              00: Bit order not affected
              01: Bit reversal done by byte
              10: Bit reversal done by half-word
              11: Bit reversal done by word
              </description>
              <bitOffset>5</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>POLYSIZE</name>
              <description>
              Polynomial size
              These bits control the size of the polynomial.
              00: 32 bit polynomial
              01: 16 bit polynomial
              10: 8 bit polynomial
              11: 7 bit polynomial
              </description>
              <bitOffset>3</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>DATASIZE</name>
              <description>
              Valid input data size
              These bits control the valid size of the input data.
              00: lower 8-bit
              01: lower 16-bit
              10: lower 24-bit
              11: all 32-bit
              </description>
              <bitOffset>1</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>RESET</name>
              <description>
              This bit is set by software to reset the CRC calculation unit and set the data register to the value stored in the CRC_INIT register. This bit can only be set, it is automatically cleared by hardware
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RSVD1</name>
          <displayName>RSVD1</displayName>
          <description></description>
          <addressOffset>0xC</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
          </fields>
        </register>
        <register>
          <name>INIT</name>
          <displayName>INIT</displayName>
          <description>Initial CRC value</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>INIT</name>
              <description>
              Programmable initial CRC value
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>POL</name>
          <displayName>POL</displayName>
          <description>CRC polynomial</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <fields>
            <field>
              <name>POL</name>
              <description>
              Programmable polynomial 
              This register is used to write the coefficients of the polynomial to be used for CRC calculation.
              If the polynomial size is less than 32 bits, the least significant bits have to be used to program the correct value.
              </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
  </peripherals>
</device>
