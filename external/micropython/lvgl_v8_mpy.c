
/*
 * Auto-Generated file, DO NOT EDIT!
 *
 * Command line:
 * ../lib/lv_bindings/gen/gen_mpy.py -M lvgl -MP lv -MD build/lvsf/lvsf_mpy.json -E build/lvsf/lvsf.pp.c ../lib/lv_bindings/lvsf/lvsf.h
 *
 * Preprocessing command:
 * Preprocessing was disabled.
 *
 * Generating Objects: obj(None), arc(obj), btn(obj), img(obj), label(obj), line(obj), table(obj), checkbox(obj), bar(obj), slider(obj), btnmatrix(obj), dropdown(obj), roller(obj), textarea(obj), canvas(obj), switch(obj), gif(obj), qrcode(obj), animimg(obj), calendar(obj), chart(obj), keyboard(obj), list(obj), menu(obj), msgbox(obj), meter(obj), spinbox(obj), spinner(obj), tabview(obj), tileview(obj), win(obj), colorwheel(obj), led(obj), imgbtn(obj), spangroup(obj), lvsfheader(obj), lvsfpopup(obj), lvsfcomp(obj), lvsfcorner(obj), lvsfbarcode(obj), analogclk(obj), idximg(obj), lvsfcurve(obj), lvsfaezip(obj), rlottie(obj)
 */

/*
 * Mpy includes
 */

#include <stdlib.h>
#include <string.h>
#include "py/obj.h"
#include "py/objint.h"
#include "py/objstr.h"
#include "py/runtime.h"
#include "py/binary.h"
#include "py/objarray.h"

/*
 * lvgl includes
 */

#include "lvsf.h"


#define LV_OBJ_T lv_obj_t

STATIC const mp_obj_type_t mp_obj_type;

STATIC inline const mp_obj_type_t *get_BaseObj_type()
{
    return &mp_obj_type;
}
    

/*
 * Helper functions
 */

#ifndef GENMPY_UNUSED
#ifdef __GNUC__
#define GENMPY_UNUSED __attribute__ ((unused))
#else
#define GENMPY_UNUSED
#endif // __GNUC__
#endif // GENMPY_UNUSED

// Custom function mp object

typedef mp_obj_t (*mp_fun_ptr_var_t)(size_t n, const mp_obj_t *, void *ptr);

typedef struct mp_lv_obj_fun_builtin_var_t {
    mp_obj_base_t base;
    mp_uint_t n_args;
    mp_fun_ptr_var_t mp_fun;
    void *lv_fun;
} mp_lv_obj_fun_builtin_var_t;

STATIC mp_obj_t lv_fun_builtin_var_call(mp_obj_t self_in, size_t n_args, size_t n_kw, const mp_obj_t *args);
STATIC mp_int_t mp_func_get_buffer(mp_obj_t self_in, mp_buffer_info_t *bufinfo, mp_uint_t flags);

GENMPY_UNUSED STATIC const mp_obj_type_t mp_lv_type_fun_builtin_var = {
    { &mp_type_type },
    .flags = MP_TYPE_FLAG_BINDS_SELF | MP_TYPE_FLAG_BUILTIN_FUN,
    .name = MP_QSTR_function,
    .call = lv_fun_builtin_var_call,
    .unary_op = mp_generic_unary_op,
    .buffer_p = { .get_buffer = mp_func_get_buffer }
};

GENMPY_UNUSED STATIC const mp_obj_type_t mp_lv_type_fun_builtin_static_var = {
    { &mp_type_type },
    .flags = MP_TYPE_FLAG_BUILTIN_FUN,
    .name = MP_QSTR_function,
    .call = lv_fun_builtin_var_call,
    .unary_op = mp_generic_unary_op,
    .buffer_p = { .get_buffer = mp_func_get_buffer }
};

STATIC mp_obj_t lv_fun_builtin_var_call(mp_obj_t self_in, size_t n_args, size_t n_kw, const mp_obj_t *args) {
    assert(MP_OBJ_IS_TYPE(self_in, &mp_lv_type_fun_builtin_var) ||
           MP_OBJ_IS_TYPE(self_in, &mp_lv_type_fun_builtin_static_var));
    mp_lv_obj_fun_builtin_var_t *self = MP_OBJ_TO_PTR(self_in);
    mp_arg_check_num(n_args, n_kw, self->n_args, self->n_args, false);
    return self->mp_fun(n_args, args, self->lv_fun);
}

STATIC mp_int_t mp_func_get_buffer(mp_obj_t self_in, mp_buffer_info_t *bufinfo, mp_uint_t flags) {
    (void)flags;
    assert(MP_OBJ_IS_TYPE(self_in, &mp_lv_type_fun_builtin_var) ||
           MP_OBJ_IS_TYPE(self_in, &mp_lv_type_fun_builtin_static_var));
    mp_lv_obj_fun_builtin_var_t *self = MP_OBJ_TO_PTR(self_in);

    bufinfo->buf = &self->lv_fun;
    bufinfo->len = sizeof(self->lv_fun);
    bufinfo->typecode = BYTEARRAY_TYPECODE;
    return 0;
}

#define MP_DEFINE_CONST_LV_FUN_OBJ_VAR(obj_name, n_args, mp_fun, lv_fun) \
    const mp_lv_obj_fun_builtin_var_t obj_name = \
        {{&mp_lv_type_fun_builtin_var}, n_args, mp_fun, lv_fun}

#define MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(obj_name, n_args, mp_fun, lv_fun) \
    const mp_lv_obj_fun_builtin_var_t obj_name = \
        {{&mp_lv_type_fun_builtin_static_var}, n_args, mp_fun, lv_fun}

// Casting

typedef struct mp_lv_struct_t
{
    mp_obj_base_t base;
    void *data;
} mp_lv_struct_t;

STATIC const mp_lv_struct_t mp_lv_null_obj;

#ifdef LV_OBJ_T
STATIC mp_int_t mp_lv_obj_get_buffer(mp_obj_t self_in, mp_buffer_info_t *bufinfo, mp_uint_t flags);
#else
STATIC mp_int_t mp_lv_obj_get_buffer(mp_obj_t self_in, mp_buffer_info_t *bufinfo, mp_uint_t flags){ return 0; }
#endif

STATIC mp_obj_t get_native_obj(mp_obj_t *mp_obj)
{
    if (!MP_OBJ_IS_OBJ(mp_obj)) return mp_obj;
    const mp_obj_type_t *native_type = ((mp_obj_base_t*)mp_obj)->type;
    if (native_type->parent == NULL || 
        (native_type->buffer_p.get_buffer == mp_lv_obj_get_buffer)) return mp_obj;
    while (native_type->parent) native_type = native_type->parent;
    return mp_obj_cast_to_native_base(mp_obj, MP_OBJ_FROM_PTR(native_type));
}

STATIC mp_obj_t dict_to_struct(mp_obj_t dict, const mp_obj_type_t *type);

STATIC mp_obj_t make_new_lv_struct(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args);

STATIC mp_obj_t *cast(mp_obj_t *mp_obj, const mp_obj_type_t *mp_type)
{
    mp_obj_t *res = NULL;
    if (mp_obj == mp_const_none && mp_type->make_new == &make_new_lv_struct) {
        res = MP_OBJ_FROM_PTR(&mp_lv_null_obj);
    } else if (MP_OBJ_IS_OBJ(mp_obj)) {
        res = get_native_obj(mp_obj);
        if (res){
            const mp_obj_type_t *res_type = ((mp_obj_base_t*)res)->type;
            if (res_type != mp_type){
                if (res_type == &mp_type_dict &&
                    mp_type->make_new == &make_new_lv_struct)
                        res = dict_to_struct(res, mp_type);
                else res = NULL;
            }
        }
    }
    if (res == NULL) nlr_raise(
        mp_obj_new_exception_msg_varg(
            &mp_type_SyntaxError, MP_ERROR_TEXT("Can't convert %s to %s!"), mp_obj_get_type_str(mp_obj), qstr_str(mp_type->name)));
    return res;
}

// object handling
// This section is enabled only when objects are supported 

#ifdef LV_OBJ_T

typedef LV_OBJ_T* (*lv_create)(LV_OBJ_T * par, const LV_OBJ_T * copy);

typedef struct mp_lv_obj_t {
    mp_obj_base_t base;
    LV_OBJ_T *lv_obj;
    LV_OBJ_T *callbacks;
} mp_lv_obj_t;

STATIC inline LV_OBJ_T *mp_to_lv(mp_obj_t *mp_obj)
{
    if (mp_obj == NULL || mp_obj == mp_const_none) return NULL;
    mp_lv_obj_t *mp_lv_obj = MP_OBJ_TO_PTR(get_native_obj(mp_obj));
    return mp_lv_obj->lv_obj;
}

STATIC inline LV_OBJ_T *mp_get_callbacks(mp_obj_t mp_obj)
{
    if (mp_obj == NULL || mp_obj == mp_const_none) return NULL;
    mp_lv_obj_t *mp_lv_obj = MP_OBJ_TO_PTR(get_native_obj(mp_obj));
    if (!mp_lv_obj->callbacks) mp_lv_obj->callbacks = mp_obj_new_dict(0);
    return mp_lv_obj->callbacks;
}

STATIC inline const mp_obj_type_t *get_BaseObj_type();

STATIC inline mp_obj_t *lv_to_mp(LV_OBJ_T *lv_obj)
{
    if (lv_obj == NULL) return mp_const_none;
    mp_lv_obj_t *self = (mp_lv_obj_t*)lv_obj->user_data;
    if (!self) 
    {
        self = m_new_obj(mp_lv_obj_t);
        *self = (mp_lv_obj_t){
            .base = {get_BaseObj_type()},
            .lv_obj = lv_obj,
            .callbacks = NULL,
        };
        lv_obj->user_data = self;
    }
    return MP_OBJ_FROM_PTR(self);
}

STATIC mp_obj_t make_new(
    lv_create create,
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    mp_arg_check_num(n_args, n_kw, 0, 2, false);
    mp_lv_obj_t *self = m_new_obj(mp_lv_obj_t);
    LV_OBJ_T *parent = n_args > 0? mp_to_lv(args[0]): NULL;
    LV_OBJ_T *copy = n_args > 1? mp_to_lv(args[1]): NULL;
    *self = (mp_lv_obj_t){
        .base = {type}, 
        .lv_obj = create(parent, copy),
        .callbacks = NULL,
    };
    if (!self->lv_obj) return mp_const_none;
    self->lv_obj->user_data = self;
    return MP_OBJ_FROM_PTR(self);
}

STATIC void* mp_to_ptr(mp_obj_t self_in);

STATIC mp_obj_t cast_obj(mp_obj_t type_obj, mp_obj_t obj)
{
    mp_lv_obj_t *self = m_new_obj(mp_lv_obj_t);
    *self = (mp_lv_obj_t){
        .base = {(const mp_obj_type_t*)type_obj},
        .lv_obj = mp_to_ptr(obj),
        .callbacks = NULL,
    };
    if (!self->lv_obj) return mp_const_none;
    return MP_OBJ_FROM_PTR(self);
}

STATIC MP_DEFINE_CONST_FUN_OBJ_2(cast_obj_obj, cast_obj);
STATIC MP_DEFINE_CONST_CLASSMETHOD_OBJ(cast_obj_class_method, MP_ROM_PTR(&cast_obj_obj));

STATIC mp_int_t mp_lv_obj_get_buffer(mp_obj_t self_in, mp_buffer_info_t *bufinfo, mp_uint_t flags) {
    (void)flags;
    mp_lv_obj_t *self = MP_OBJ_TO_PTR(self_in);

    bufinfo->buf = &self->lv_obj;
    bufinfo->len = sizeof(self->lv_obj);
    bufinfo->typecode = BYTEARRAY_TYPECODE;
    return 0;
}

#endif

STATIC inline mp_obj_t convert_to_bool(bool b)
{
    return b? mp_const_true: mp_const_false;
}

STATIC inline mp_obj_t convert_to_str(const char *str)
{
    return str? mp_obj_new_str(str, strlen(str)): mp_const_none;
}

STATIC inline const char *convert_from_str(mp_obj_t str)
{
    if (str == NULL || str == mp_const_none)
        return NULL;

    if (MP_OBJ_IS_TYPE(str, &mp_type_bytearray) ||
        MP_OBJ_IS_TYPE(str, &mp_type_memoryview)) {
            mp_buffer_info_t buffer_info;
            if (mp_get_buffer(str, &buffer_info, MP_BUFFER_READ)) {
                return buffer_info.buf;
            }
    }

    return mp_obj_str_get_str(str);
}

// struct handling

STATIC inline mp_lv_struct_t *mp_to_lv_struct(mp_obj_t mp_obj)
{
    if (mp_obj == NULL || mp_obj == mp_const_none) return NULL;
    if (!MP_OBJ_IS_OBJ(mp_obj)) nlr_raise(
            mp_obj_new_exception_msg(
                &mp_type_SyntaxError, MP_ERROR_TEXT("Struct argument is not an object!")));
    mp_lv_struct_t *mp_lv_struct = MP_OBJ_TO_PTR(get_native_obj(mp_obj));
    return mp_lv_struct;
}

STATIC inline size_t get_lv_struct_size(const mp_obj_type_t *type)
{
    mp_obj_t size_obj = mp_obj_dict_get(type->locals_dict, MP_OBJ_NEW_QSTR(MP_QSTR_SIZE));
    return (size_t)mp_obj_get_int(size_obj);
}

STATIC mp_obj_t make_new_lv_struct(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    if ((!MP_OBJ_IS_TYPE(type, &mp_type_type)) || type->make_new != &make_new_lv_struct)
        nlr_raise(
            mp_obj_new_exception_msg(
                &mp_type_SyntaxError, MP_ERROR_TEXT("Argument is not a struct type!")));
    size_t size = get_lv_struct_size(type);
    mp_arg_check_num(n_args, n_kw, 0, 1, false);
    mp_lv_struct_t *self = m_new_obj(mp_lv_struct_t);
    *self = (mp_lv_struct_t){
        .base = {type}, 
        .data = m_malloc(size)
    };
    mp_lv_struct_t *other = n_args > 0? mp_to_lv_struct(cast(args[0], type)): NULL;
    if (other) {
        memcpy(self->data, other->data, size);
    } else {
        memset(self->data, 0, size);
    }
    return MP_OBJ_FROM_PTR(self);
}

STATIC void *copy_buffer(const void *buffer, size_t size)
{
    void *new_buffer = m_malloc(size);
    memcpy(new_buffer, buffer, size);
    return new_buffer;
}

// Reference an existing lv struct (or part of it)

STATIC mp_obj_t lv_to_mp_struct(const mp_obj_type_t *type, void *lv_struct)
{
    if (lv_struct == NULL) return mp_const_none;
    mp_lv_struct_t *self = m_new_obj(mp_lv_struct_t);
    *self = (mp_lv_struct_t){
        .base = {type},
        .data = lv_struct
    };
    return MP_OBJ_FROM_PTR(self);
}

STATIC void call_parent_methods(mp_obj_t obj, qstr attr, mp_obj_t *dest)
{
    const mp_obj_type_t *type = mp_obj_get_type(obj);
    while (type->locals_dict != NULL) {
        // generic method lookup
        // this is a lookup in the object (ie not class or type)
        assert(type->locals_dict->base.type == &mp_type_dict); // MicroPython restriction, for now
        mp_map_t *locals_map = &type->locals_dict->map;
        mp_map_elem_t *elem = mp_map_lookup(locals_map, MP_OBJ_NEW_QSTR(attr), MP_MAP_LOOKUP);
        if (elem != NULL) {
            mp_convert_member_lookup(obj, type, elem->value, dest);
            break;
        }
        if (type->parent == NULL) {
            break;
        }
        // search parents
        type = type->parent;
    }
}

// Convert dict to struct

STATIC mp_obj_t dict_to_struct(mp_obj_t dict, const mp_obj_type_t *type)
{
    mp_obj_t mp_struct = make_new_lv_struct(type, 0, 0, NULL);
    mp_obj_t *native_dict = cast(dict, &mp_type_dict);
    mp_map_t *map = mp_obj_dict_get_map(native_dict);
    if (map == NULL) return mp_const_none;
    for (uint i = 0; i < map->alloc; i++) {
        mp_obj_t key = map->table[i].key;
        mp_obj_t value = map->table[i].value;
        if (key != MP_OBJ_NULL) {
            mp_obj_t dest[] = {MP_OBJ_SENTINEL, value};
            type->attr(mp_struct, mp_obj_str_get_qstr(key), dest);
            if (dest[0]) nlr_raise(
                mp_obj_new_exception_msg_varg(
                    &mp_type_SyntaxError, MP_ERROR_TEXT("Cannot set field %s on struct %s!"), qstr_str(mp_obj_str_get_qstr(key)), qstr_str(type->name)));
        }
    }
    return mp_struct;
}

// Convert mp object to ptr

STATIC void* mp_to_ptr(mp_obj_t self_in)
{
    mp_buffer_info_t buffer_info;
    if (self_in == NULL || self_in == mp_const_none)
        return NULL;

//    if (MP_OBJ_IS_INT(self_in))
//        return (void*)mp_obj_get_int(self_in);

    if (!mp_get_buffer(self_in, &buffer_info, MP_BUFFER_READ)) {
        // No buffer protocol - this is not a Struct or a Blob, it's some other mp object.
        // We only allow setting dict directly, since it's useful to setting user_data for passing data to C.
        // On other cases throw an exception, to avoid a crash later
        if (MP_OBJ_IS_TYPE(self_in, &mp_type_dict))
            return MP_OBJ_TO_PTR(self_in);
        else nlr_raise(
                mp_obj_new_exception_msg_varg(
                    &mp_type_SyntaxError, MP_ERROR_TEXT("Cannot convert '%s' to pointer!"), mp_obj_get_type_str(self_in)));
    }

    if (MP_OBJ_IS_STR_OR_BYTES(self_in) || 
        MP_OBJ_IS_TYPE(self_in, &mp_type_bytearray) ||
        MP_OBJ_IS_TYPE(self_in, &mp_type_memoryview))
            return buffer_info.buf;
    else
    {
        void *result;
        if (buffer_info.len != sizeof(result) || buffer_info.typecode != BYTEARRAY_TYPECODE){
            nlr_raise(
                mp_obj_new_exception_msg_varg(
                    &mp_type_SyntaxError, MP_ERROR_TEXT("Cannot convert %s to pointer! (buffer does not represent a pointer)"), mp_obj_get_type_str(self_in)));
        }
        memcpy(&result, buffer_info.buf, sizeof(result));
        return result;
    }
}

// Blob is a wrapper for void* 

STATIC void mp_blob_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "Blob");
}

STATIC mp_int_t mp_blob_get_buffer(mp_obj_t self_in, mp_buffer_info_t *bufinfo, mp_uint_t flags) {
    (void)flags;
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);

    bufinfo->buf = &self->data;
    bufinfo->len = sizeof(self->data);
    bufinfo->typecode = BYTEARRAY_TYPECODE;
    return 0;
}

STATIC const mp_obj_fun_builtin_var_t mp_lv_dereference_obj;

// Sometimes (but not always!) Blob represents a Micropython object.
// In such cases it's safe to cast the Blob back to the Micropython object
// cast argument is the underlying object type, and it's optional.

STATIC mp_obj_t mp_blob_cast(size_t argc, const mp_obj_t *argv)
{
    mp_obj_t self = argv[0];
    void *ptr = mp_to_ptr(self);
    if (argc == 1) return MP_OBJ_FROM_PTR(ptr);
    mp_obj_t type = argv[1];
    if (!MP_OBJ_IS_TYPE(type, &mp_type_type))
        nlr_raise(
            mp_obj_new_exception_msg(
                &mp_type_SyntaxError, MP_ERROR_TEXT("Cast argument must be a type!")));
    return cast(MP_OBJ_FROM_PTR(ptr), type);
}

STATIC MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(mp_blob_cast_obj, 1, 2, mp_blob_cast);

STATIC const mp_rom_map_elem_t mp_blob_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_blob_cast_obj) },
};

STATIC MP_DEFINE_CONST_DICT(mp_blob_locals_dict, mp_blob_locals_dict_table);

STATIC const mp_obj_type_t mp_blob_type = {
    { &mp_type_type },
    .name = MP_QSTR_Blob,
    .print = mp_blob_print,
    //.make_new = make_new_blob,
    .locals_dict = (mp_obj_dict_t*)&mp_blob_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC const mp_lv_struct_t mp_lv_null_obj = { {&mp_blob_type}, NULL };

STATIC inline mp_obj_t ptr_to_mp(void *data)
{
    return lv_to_mp_struct(&mp_blob_type, data);
}

// Cast pointer to struct

STATIC mp_obj_t mp_lv_cast(mp_obj_t type_obj, mp_obj_t ptr_obj)
{
    mp_lv_struct_t *self = m_new_obj(mp_lv_struct_t);
    *self = (mp_lv_struct_t){
        .base = {(const mp_obj_type_t*)type_obj}, 
        .data = mp_to_ptr(ptr_obj)
    };
    return MP_OBJ_FROM_PTR(self);
}

// Cast instance. Can be used in ISR when memory allocation is prohibited

STATIC inline mp_obj_t mp_lv_cast_instance(mp_obj_t self_in, mp_obj_t ptr_obj)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    self->data = mp_to_ptr(ptr_obj);
    return self_in;
}

STATIC MP_DEFINE_CONST_FUN_OBJ_2(mp_lv_cast_obj, mp_lv_cast);
STATIC MP_DEFINE_CONST_CLASSMETHOD_OBJ(mp_lv_cast_class_method, MP_ROM_PTR(&mp_lv_cast_obj));

STATIC MP_DEFINE_CONST_FUN_OBJ_2(mp_lv_cast_instance_obj, mp_lv_cast_instance);

// Dereference a struct/blob. This allows access to the raw data the struct holds

STATIC mp_obj_t mp_lv_dereference(size_t argc, const mp_obj_t *argv)
{
    mp_obj_t self_in = argv[0];
    mp_obj_t size_in = argc > 1? argv[1]: mp_const_none;
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    size_t size = 0;
    if (size_in == mp_const_none){
        const mp_obj_type_t *type = self->base.type;
        size = get_lv_struct_size(type);
    } else {
        size = (size_t)mp_obj_get_int(size_in);
    }
    mp_obj_array_t *view = MP_OBJ_TO_PTR(mp_obj_new_memoryview(BYTEARRAY_TYPECODE,
        size, self->data));
    view->typecode |= 0x80; // used to indicate writable buffer
    return MP_OBJ_FROM_PTR(view);
}

STATIC MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(mp_lv_dereference_obj, 1, 2, mp_lv_dereference);

// Callback function handling
// Callback is either a callable object or a pointer. If it's a callable object, set user_data to the callback.
// Multiple callbacks are kept per object/struct using a dict that associate callback name with callback object
// In case of an lv_obj_t, user_data is mp_lv_obj_t which contains a member "callbacks" for that dict.
// In case of a struct, user_data is a pointer to that dict directly

STATIC mp_obj_t get_callback_dict_from_user_data(void *user_data)
{
    if (user_data){
        mp_obj_t obj = MP_OBJ_FROM_PTR(user_data);
#ifdef LV_OBJ_T
        return 
            MP_OBJ_IS_TYPE(obj, &mp_type_dict)? obj: // Handle the case of dict for a struct
            mp_get_callbacks(obj); // Handle the case of mp_lv_obj_t for an lv_obj_t
#else
        return obj;
#endif
    }
    return NULL;
}

STATIC void *mp_lv_callback(mp_obj_t mp_callback, void *lv_callback, qstr callback_name, void **user_data_ptr)
{
    if (lv_callback && mp_obj_is_callable(mp_callback)){
        if (user_data_ptr){
            // user_data is either a dict of callbacks in case of struct, or a pointer to mp_lv_obj_t in case of lv_obj_t
            if (! (*user_data_ptr) ) *user_data_ptr = MP_OBJ_TO_PTR(mp_obj_new_dict(0)); // if it's NULL - it's a dict for a struct
            mp_obj_t callbacks = get_callback_dict_from_user_data(*user_data_ptr);
            mp_obj_dict_store(callbacks, MP_OBJ_NEW_QSTR(callback_name), mp_callback);
        }
        return lv_callback;
    } else {
        return mp_to_ptr(mp_callback);
    }
}

// Function pointers wrapper

STATIC mp_obj_t mp_lv_funcptr(const mp_lv_obj_fun_builtin_var_t *mp_fun, void *lv_fun, void *lv_callback, qstr func_name, void *user_data)
{
    if (lv_fun == NULL)
        return mp_const_none;
    if (lv_fun == lv_callback) {
        mp_obj_t callbacks = get_callback_dict_from_user_data(user_data);
        if (callbacks)
            return mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(func_name));
    }
    mp_lv_obj_fun_builtin_var_t *funcptr = m_new_obj(mp_lv_obj_fun_builtin_var_t);
    *funcptr = *mp_fun;
    funcptr->lv_fun = lv_fun;
    return MP_OBJ_FROM_PTR(funcptr);
}

// Missing implementation for 64bit integer conversion

STATIC unsigned long long mp_obj_get_ull(mp_obj_t obj)
{
    if (mp_obj_is_small_int(obj))
        return MP_OBJ_SMALL_INT_VALUE(obj);

    unsigned long long val = 0;
    bool big_endian = false;
    mp_obj_int_to_bytes_impl(obj, big_endian, sizeof(val), (byte*)&val);
    return val;
}



/*
 * LVGL string constants
 */

MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_BULLET, LV_SYMBOL_BULLET);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_AUDIO, LV_SYMBOL_AUDIO);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_VIDEO, LV_SYMBOL_VIDEO);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_LIST, LV_SYMBOL_LIST);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_OK, LV_SYMBOL_OK);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_CLOSE, LV_SYMBOL_CLOSE);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_POWER, LV_SYMBOL_POWER);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_SETTINGS, LV_SYMBOL_SETTINGS);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_HOME, LV_SYMBOL_HOME);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_DOWNLOAD, LV_SYMBOL_DOWNLOAD);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_DRIVE, LV_SYMBOL_DRIVE);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_REFRESH, LV_SYMBOL_REFRESH);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_MUTE, LV_SYMBOL_MUTE);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_VOLUME_MID, LV_SYMBOL_VOLUME_MID);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_VOLUME_MAX, LV_SYMBOL_VOLUME_MAX);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_IMAGE, LV_SYMBOL_IMAGE);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_TINT, LV_SYMBOL_TINT);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_PREV, LV_SYMBOL_PREV);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_PLAY, LV_SYMBOL_PLAY);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_PAUSE, LV_SYMBOL_PAUSE);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_STOP, LV_SYMBOL_STOP);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_NEXT, LV_SYMBOL_NEXT);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_EJECT, LV_SYMBOL_EJECT);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_LEFT, LV_SYMBOL_LEFT);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_RIGHT, LV_SYMBOL_RIGHT);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_PLUS, LV_SYMBOL_PLUS);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_MINUS, LV_SYMBOL_MINUS);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_EYE_OPEN, LV_SYMBOL_EYE_OPEN);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_EYE_CLOSE, LV_SYMBOL_EYE_CLOSE);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_WARNING, LV_SYMBOL_WARNING);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_SHUFFLE, LV_SYMBOL_SHUFFLE);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_UP, LV_SYMBOL_UP);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_DOWN, LV_SYMBOL_DOWN);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_LOOP, LV_SYMBOL_LOOP);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_DIRECTORY, LV_SYMBOL_DIRECTORY);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_UPLOAD, LV_SYMBOL_UPLOAD);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_CALL, LV_SYMBOL_CALL);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_CUT, LV_SYMBOL_CUT);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_COPY, LV_SYMBOL_COPY);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_SAVE, LV_SYMBOL_SAVE);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_BARS, LV_SYMBOL_BARS);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_ENVELOPE, LV_SYMBOL_ENVELOPE);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_CHARGE, LV_SYMBOL_CHARGE);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_PASTE, LV_SYMBOL_PASTE);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_BELL, LV_SYMBOL_BELL);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_KEYBOARD, LV_SYMBOL_KEYBOARD);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_GPS, LV_SYMBOL_GPS);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_FILE, LV_SYMBOL_FILE);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_WIFI, LV_SYMBOL_WIFI);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_BATTERY_FULL, LV_SYMBOL_BATTERY_FULL);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_BATTERY_3, LV_SYMBOL_BATTERY_3);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_BATTERY_2, LV_SYMBOL_BATTERY_2);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_BATTERY_1, LV_SYMBOL_BATTERY_1);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_BATTERY_EMPTY, LV_SYMBOL_BATTERY_EMPTY);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_USB, LV_SYMBOL_USB);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_BLUETOOTH, LV_SYMBOL_BLUETOOTH);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_TRASH, LV_SYMBOL_TRASH);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_EDIT, LV_SYMBOL_EDIT);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_BACKSPACE, LV_SYMBOL_BACKSPACE);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_SD_CARD, LV_SYMBOL_SD_CARD);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_NEW_LINE, LV_SYMBOL_NEW_LINE);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_DUMMY, LV_SYMBOL_DUMMY);

/*
 * Helper Structs
 */
        

typedef union {
    void*           ptr_val;
    const char*     str_val;
    int             int_val;
    unsigned int    uint_val;
    short           short_val[sizeof(void*) / sizeof(short)];
    unsigned short  ushort_val[sizeof(void*) / sizeof(unsigned short)];
    char            char_val[sizeof(void*) / sizeof(char)];
    unsigned char   uchar_val[sizeof(void*) / sizeof(unsigned char)];
} C_Pointer;


/*
 * Array convertors for short [(sizeof(void *)) / (sizeof(short))]
 */

STATIC short *mp_arr_to_short_____sizeof__void_ptr______div____sizeof__short______(mp_obj_t mp_arr)
{
    mp_obj_t mp_len = mp_obj_len_maybe(mp_arr);
    if (mp_len == MP_OBJ_NULL) return mp_to_ptr(mp_arr);
    mp_int_t len = mp_obj_get_int(mp_len);
    //TODO check dim!
    short *lv_arr = (short*)m_malloc(len * sizeof(short));
    mp_obj_t iter = mp_getiter(mp_arr, NULL);
    mp_obj_t item;
    size_t i = 0;
    while ((item = mp_iternext(iter)) != MP_OBJ_STOP_ITERATION) {
        lv_arr[i++] = (short)mp_obj_get_int(item);
    }
    return (short *)lv_arr;
}
    
STATIC mp_obj_t mp_arr_from_short_____sizeof__void_ptr______div____sizeof__short______(short *arr)
{
    mp_obj_t obj_arr[(sizeof(void *)) / (sizeof(short))];
    for (size_t i=0; i<(sizeof(void *)) / (sizeof(short)); i++){
        obj_arr[i] = mp_obj_new_int(arr[i]);
    }
    return mp_obj_new_list((sizeof(void *)) / (sizeof(short)), obj_arr); // TODO: return custom iterable object!
}
    

/*
 * Array convertors for unsigned short [(sizeof(void *)) / (sizeof(unsigned short))]
 */

STATIC unsigned short *mp_arr_to_unsigned_short_____sizeof__void_ptr______div____sizeof__unsigned_short______(mp_obj_t mp_arr)
{
    mp_obj_t mp_len = mp_obj_len_maybe(mp_arr);
    if (mp_len == MP_OBJ_NULL) return mp_to_ptr(mp_arr);
    mp_int_t len = mp_obj_get_int(mp_len);
    //TODO check dim!
    unsigned short *lv_arr = (unsigned short*)m_malloc(len * sizeof(unsigned short));
    mp_obj_t iter = mp_getiter(mp_arr, NULL);
    mp_obj_t item;
    size_t i = 0;
    while ((item = mp_iternext(iter)) != MP_OBJ_STOP_ITERATION) {
        lv_arr[i++] = (unsigned short)mp_obj_get_int(item);
    }
    return (unsigned short *)lv_arr;
}
    
STATIC mp_obj_t mp_arr_from_unsigned_short_____sizeof__void_ptr______div____sizeof__unsigned_short______(unsigned short *arr)
{
    mp_obj_t obj_arr[(sizeof(void *)) / (sizeof(unsigned short))];
    for (size_t i=0; i<(sizeof(void *)) / (sizeof(unsigned short)); i++){
        obj_arr[i] = mp_obj_new_int_from_uint(arr[i]);
    }
    return mp_obj_new_list((sizeof(void *)) / (sizeof(unsigned short)), obj_arr); // TODO: return custom iterable object!
}
    

/*
 * Array convertors for char [(sizeof(void *)) / (sizeof(char))]
 */

STATIC char *mp_arr_to_char_____sizeof__void_ptr______div____sizeof__char______(mp_obj_t mp_arr)
{
    mp_obj_t mp_len = mp_obj_len_maybe(mp_arr);
    if (mp_len == MP_OBJ_NULL) return mp_to_ptr(mp_arr);
    mp_int_t len = mp_obj_get_int(mp_len);
    //TODO check dim!
    char *lv_arr = (char*)m_malloc(len * sizeof(char));
    mp_obj_t iter = mp_getiter(mp_arr, NULL);
    mp_obj_t item;
    size_t i = 0;
    while ((item = mp_iternext(iter)) != MP_OBJ_STOP_ITERATION) {
        lv_arr[i++] = (char)mp_obj_get_int(item);
    }
    return (char *)lv_arr;
}
    
STATIC mp_obj_t mp_arr_from_char_____sizeof__void_ptr______div____sizeof__char______(char *arr)
{
    mp_obj_t obj_arr[(sizeof(void *)) / (sizeof(char))];
    for (size_t i=0; i<(sizeof(void *)) / (sizeof(char)); i++){
        obj_arr[i] = mp_obj_new_int(arr[i]);
    }
    return mp_obj_new_list((sizeof(void *)) / (sizeof(char)), obj_arr); // TODO: return custom iterable object!
}
    

/*
 * Array convertors for unsigned char [(sizeof(void *)) / (sizeof(unsigned char))]
 */

STATIC unsigned char *mp_arr_to_unsigned_char_____sizeof__void_ptr______div____sizeof__unsigned_char______(mp_obj_t mp_arr)
{
    mp_obj_t mp_len = mp_obj_len_maybe(mp_arr);
    if (mp_len == MP_OBJ_NULL) return mp_to_ptr(mp_arr);
    mp_int_t len = mp_obj_get_int(mp_len);
    //TODO check dim!
    unsigned char *lv_arr = (unsigned char*)m_malloc(len * sizeof(unsigned char));
    mp_obj_t iter = mp_getiter(mp_arr, NULL);
    mp_obj_t item;
    size_t i = 0;
    while ((item = mp_iternext(iter)) != MP_OBJ_STOP_ITERATION) {
        lv_arr[i++] = (unsigned char)mp_obj_get_int(item);
    }
    return (unsigned char *)lv_arr;
}
    
STATIC mp_obj_t mp_arr_from_unsigned_char_____sizeof__void_ptr______div____sizeof__unsigned_char______(unsigned char *arr)
{
    mp_obj_t obj_arr[(sizeof(void *)) / (sizeof(unsigned char))];
    for (size_t i=0; i<(sizeof(void *)) / (sizeof(unsigned char)); i++){
        obj_arr[i] = mp_obj_new_int_from_uint(arr[i]);
    }
    return mp_obj_new_list((sizeof(void *)) / (sizeof(unsigned char)), obj_arr); // TODO: return custom iterable object!
}
    

/*
 * Struct C_Pointer
 */

STATIC inline const mp_obj_type_t *get_mp_C_Pointer_type();

STATIC inline C_Pointer* mp_write_ptr_C_Pointer(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_C_Pointer_type()));
    return (C_Pointer*)self->data;
}

#define mp_write_C_Pointer(struct_obj) *mp_write_ptr_C_Pointer(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_C_Pointer(C_Pointer *field)
{
    return lv_to_mp_struct(get_mp_C_Pointer_type(), (void*)field);
}

#define mp_read_C_Pointer(field) mp_read_ptr_C_Pointer(copy_buffer(&field, sizeof(C_Pointer)))
#define mp_read_byref_C_Pointer(field) mp_read_ptr_C_Pointer(&field)

STATIC void mp_C_Pointer_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    C_Pointer *data = (C_Pointer*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_ptr_val: dest[0] = ptr_to_mp((void*)data->ptr_val); break; // converting from void *;
            case MP_QSTR_str_val: dest[0] = convert_to_str((void*)data->str_val); break; // converting from char *;
            case MP_QSTR_int_val: dest[0] = mp_obj_new_int(data->int_val); break; // converting from int;
            case MP_QSTR_uint_val: dest[0] = mp_obj_new_int_from_uint(data->uint_val); break; // converting from unsigned int;
            case MP_QSTR_short_val: dest[0] = mp_arr_from_short_____sizeof__void_ptr______div____sizeof__short______(data->short_val); break; // converting from short [(sizeof(void *)) / (sizeof(short))];
            case MP_QSTR_ushort_val: dest[0] = mp_arr_from_unsigned_short_____sizeof__void_ptr______div____sizeof__unsigned_short______(data->ushort_val); break; // converting from unsigned short [(sizeof(void *)) / (sizeof(unsigned short))];
            case MP_QSTR_char_val: dest[0] = mp_arr_from_char_____sizeof__void_ptr______div____sizeof__char______(data->char_val); break; // converting from char [(sizeof(void *)) / (sizeof(char))];
            case MP_QSTR_uchar_val: dest[0] = mp_arr_from_unsigned_char_____sizeof__void_ptr______div____sizeof__unsigned_char______(data->uchar_val); break; // converting from unsigned char [(sizeof(void *)) / (sizeof(unsigned char))];
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_ptr_val: data->ptr_val = (void*)mp_to_ptr(dest[1]); break; // converting to void *;
                case MP_QSTR_str_val: data->str_val = (void*)(char*)convert_from_str(dest[1]); break; // converting to char *;
                case MP_QSTR_int_val: data->int_val = (int)mp_obj_get_int(dest[1]); break; // converting to int;
                case MP_QSTR_uint_val: data->uint_val = (unsigned int)mp_obj_get_int(dest[1]); break; // converting to unsigned int;
                case MP_QSTR_short_val: memcpy((void*)&data->short_val, mp_arr_to_short_____sizeof__void_ptr______div____sizeof__short______(dest[1]), sizeof(short)*(sizeof(void *)) / (sizeof(short))); break; // converting to short [(sizeof(void *)) / (sizeof(short))];
                case MP_QSTR_ushort_val: memcpy((void*)&data->ushort_val, mp_arr_to_unsigned_short_____sizeof__void_ptr______div____sizeof__unsigned_short______(dest[1]), sizeof(unsigned short)*(sizeof(void *)) / (sizeof(unsigned short))); break; // converting to unsigned short [(sizeof(void *)) / (sizeof(unsigned short))];
                case MP_QSTR_char_val: memcpy((void*)&data->char_val, mp_arr_to_char_____sizeof__void_ptr______div____sizeof__char______(dest[1]), sizeof(char)*(sizeof(void *)) / (sizeof(char))); break; // converting to char [(sizeof(void *)) / (sizeof(char))];
                case MP_QSTR_uchar_val: memcpy((void*)&data->uchar_val, mp_arr_to_unsigned_char_____sizeof__void_ptr______div____sizeof__unsigned_char______(dest[1]), sizeof(unsigned char)*(sizeof(void *)) / (sizeof(unsigned char))); break; // converting to unsigned char [(sizeof(void *)) / (sizeof(unsigned char))];
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_C_Pointer_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct C_Pointer");
}

STATIC const mp_obj_dict_t mp_C_Pointer_locals_dict;

STATIC const mp_obj_type_t mp_C_Pointer_type = {
    { &mp_type_type },
    .name = MP_QSTR_C_Pointer,
    .print = mp_C_Pointer_print,
    .make_new = make_new_lv_struct,
    .attr = mp_C_Pointer_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_C_Pointer_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_C_Pointer_type()
{
    return &mp_C_Pointer_type;
}
    

/*
 * lvgl LV_RES object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_RES_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_INV), MP_ROM_PTR(MP_ROM_INT(LV_RES_INV)) },
    { MP_ROM_QSTR(MP_QSTR_OK), MP_ROM_PTR(MP_ROM_INT(LV_RES_OK)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_RES_locals_dict, LV_RES_locals_dict_table);

STATIC void LV_RES_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_RES");
}



STATIC const mp_obj_type_t mp_LV_RES_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_RES,
    .print = LV_RES_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_RES_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_ALIGN object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_ALIGN_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_DEFAULT), MP_ROM_PTR(MP_ROM_INT(LV_ALIGN_DEFAULT)) },
    { MP_ROM_QSTR(MP_QSTR_TOP_LEFT), MP_ROM_PTR(MP_ROM_INT(LV_ALIGN_TOP_LEFT)) },
    { MP_ROM_QSTR(MP_QSTR_TOP_MID), MP_ROM_PTR(MP_ROM_INT(LV_ALIGN_TOP_MID)) },
    { MP_ROM_QSTR(MP_QSTR_TOP_RIGHT), MP_ROM_PTR(MP_ROM_INT(LV_ALIGN_TOP_RIGHT)) },
    { MP_ROM_QSTR(MP_QSTR_BOTTOM_LEFT), MP_ROM_PTR(MP_ROM_INT(LV_ALIGN_BOTTOM_LEFT)) },
    { MP_ROM_QSTR(MP_QSTR_BOTTOM_MID), MP_ROM_PTR(MP_ROM_INT(LV_ALIGN_BOTTOM_MID)) },
    { MP_ROM_QSTR(MP_QSTR_BOTTOM_RIGHT), MP_ROM_PTR(MP_ROM_INT(LV_ALIGN_BOTTOM_RIGHT)) },
    { MP_ROM_QSTR(MP_QSTR_LEFT_MID), MP_ROM_PTR(MP_ROM_INT(LV_ALIGN_LEFT_MID)) },
    { MP_ROM_QSTR(MP_QSTR_RIGHT_MID), MP_ROM_PTR(MP_ROM_INT(LV_ALIGN_RIGHT_MID)) },
    { MP_ROM_QSTR(MP_QSTR_CENTER), MP_ROM_PTR(MP_ROM_INT(LV_ALIGN_CENTER)) },
    { MP_ROM_QSTR(MP_QSTR_OUT_TOP_LEFT), MP_ROM_PTR(MP_ROM_INT(LV_ALIGN_OUT_TOP_LEFT)) },
    { MP_ROM_QSTR(MP_QSTR_OUT_TOP_MID), MP_ROM_PTR(MP_ROM_INT(LV_ALIGN_OUT_TOP_MID)) },
    { MP_ROM_QSTR(MP_QSTR_OUT_TOP_RIGHT), MP_ROM_PTR(MP_ROM_INT(LV_ALIGN_OUT_TOP_RIGHT)) },
    { MP_ROM_QSTR(MP_QSTR_OUT_BOTTOM_LEFT), MP_ROM_PTR(MP_ROM_INT(LV_ALIGN_OUT_BOTTOM_LEFT)) },
    { MP_ROM_QSTR(MP_QSTR_OUT_BOTTOM_MID), MP_ROM_PTR(MP_ROM_INT(LV_ALIGN_OUT_BOTTOM_MID)) },
    { MP_ROM_QSTR(MP_QSTR_OUT_BOTTOM_RIGHT), MP_ROM_PTR(MP_ROM_INT(LV_ALIGN_OUT_BOTTOM_RIGHT)) },
    { MP_ROM_QSTR(MP_QSTR_OUT_LEFT_TOP), MP_ROM_PTR(MP_ROM_INT(LV_ALIGN_OUT_LEFT_TOP)) },
    { MP_ROM_QSTR(MP_QSTR_OUT_LEFT_MID), MP_ROM_PTR(MP_ROM_INT(LV_ALIGN_OUT_LEFT_MID)) },
    { MP_ROM_QSTR(MP_QSTR_OUT_LEFT_BOTTOM), MP_ROM_PTR(MP_ROM_INT(LV_ALIGN_OUT_LEFT_BOTTOM)) },
    { MP_ROM_QSTR(MP_QSTR_OUT_RIGHT_TOP), MP_ROM_PTR(MP_ROM_INT(LV_ALIGN_OUT_RIGHT_TOP)) },
    { MP_ROM_QSTR(MP_QSTR_OUT_RIGHT_MID), MP_ROM_PTR(MP_ROM_INT(LV_ALIGN_OUT_RIGHT_MID)) },
    { MP_ROM_QSTR(MP_QSTR_OUT_RIGHT_BOTTOM), MP_ROM_PTR(MP_ROM_INT(LV_ALIGN_OUT_RIGHT_BOTTOM)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_ALIGN_locals_dict, LV_ALIGN_locals_dict_table);

STATIC void LV_ALIGN_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_ALIGN");
}



STATIC const mp_obj_type_t mp_LV_ALIGN_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_ALIGN,
    .print = LV_ALIGN_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_ALIGN_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_DIR object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_DIR_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_NONE), MP_ROM_PTR(MP_ROM_INT(LV_DIR_NONE)) },
    { MP_ROM_QSTR(MP_QSTR_LEFT), MP_ROM_PTR(MP_ROM_INT(LV_DIR_LEFT)) },
    { MP_ROM_QSTR(MP_QSTR_RIGHT), MP_ROM_PTR(MP_ROM_INT(LV_DIR_RIGHT)) },
    { MP_ROM_QSTR(MP_QSTR_TOP), MP_ROM_PTR(MP_ROM_INT(LV_DIR_TOP)) },
    { MP_ROM_QSTR(MP_QSTR_BOTTOM), MP_ROM_PTR(MP_ROM_INT(LV_DIR_BOTTOM)) },
    { MP_ROM_QSTR(MP_QSTR_HOR), MP_ROM_PTR(MP_ROM_INT(LV_DIR_HOR)) },
    { MP_ROM_QSTR(MP_QSTR_VER), MP_ROM_PTR(MP_ROM_INT(LV_DIR_VER)) },
    { MP_ROM_QSTR(MP_QSTR_ALL), MP_ROM_PTR(MP_ROM_INT(LV_DIR_ALL)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_DIR_locals_dict, LV_DIR_locals_dict_table);

STATIC void LV_DIR_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_DIR");
}



STATIC const mp_obj_type_t mp_LV_DIR_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_DIR,
    .print = LV_DIR_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_DIR_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_FONT_SUBPX object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_FONT_SUBPX_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_NONE), MP_ROM_PTR(MP_ROM_INT(LV_FONT_SUBPX_NONE)) },
    { MP_ROM_QSTR(MP_QSTR_HOR), MP_ROM_PTR(MP_ROM_INT(LV_FONT_SUBPX_HOR)) },
    { MP_ROM_QSTR(MP_QSTR_VER), MP_ROM_PTR(MP_ROM_INT(LV_FONT_SUBPX_VER)) },
    { MP_ROM_QSTR(MP_QSTR_BOTH), MP_ROM_PTR(MP_ROM_INT(LV_FONT_SUBPX_BOTH)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_FONT_SUBPX_locals_dict, LV_FONT_SUBPX_locals_dict_table);

STATIC void LV_FONT_SUBPX_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_FONT_SUBPX");
}



STATIC const mp_obj_type_t mp_LV_FONT_SUBPX_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_FONT_SUBPX,
    .print = LV_FONT_SUBPX_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_FONT_SUBPX_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_OPA object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_OPA_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_TRANSP), MP_ROM_PTR(MP_ROM_INT(LV_OPA_TRANSP)) },
    { MP_ROM_QSTR(MP_QSTR__0), MP_ROM_PTR(MP_ROM_INT(LV_OPA_0)) },
    { MP_ROM_QSTR(MP_QSTR__10), MP_ROM_PTR(MP_ROM_INT(LV_OPA_10)) },
    { MP_ROM_QSTR(MP_QSTR__20), MP_ROM_PTR(MP_ROM_INT(LV_OPA_20)) },
    { MP_ROM_QSTR(MP_QSTR__30), MP_ROM_PTR(MP_ROM_INT(LV_OPA_30)) },
    { MP_ROM_QSTR(MP_QSTR__40), MP_ROM_PTR(MP_ROM_INT(LV_OPA_40)) },
    { MP_ROM_QSTR(MP_QSTR__50), MP_ROM_PTR(MP_ROM_INT(LV_OPA_50)) },
    { MP_ROM_QSTR(MP_QSTR__60), MP_ROM_PTR(MP_ROM_INT(LV_OPA_60)) },
    { MP_ROM_QSTR(MP_QSTR__70), MP_ROM_PTR(MP_ROM_INT(LV_OPA_70)) },
    { MP_ROM_QSTR(MP_QSTR__80), MP_ROM_PTR(MP_ROM_INT(LV_OPA_80)) },
    { MP_ROM_QSTR(MP_QSTR__90), MP_ROM_PTR(MP_ROM_INT(LV_OPA_90)) },
    { MP_ROM_QSTR(MP_QSTR__100), MP_ROM_PTR(MP_ROM_INT(LV_OPA_100)) },
    { MP_ROM_QSTR(MP_QSTR_COVER), MP_ROM_PTR(MP_ROM_INT(LV_OPA_COVER)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_OPA_locals_dict, LV_OPA_locals_dict_table);

STATIC void LV_OPA_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_OPA");
}



STATIC const mp_obj_type_t mp_LV_OPA_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_OPA,
    .print = LV_OPA_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_OPA_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_TEXT_FLAG object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_TEXT_FLAG_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_NONE), MP_ROM_PTR(MP_ROM_INT(LV_TEXT_FLAG_NONE)) },
    { MP_ROM_QSTR(MP_QSTR_RECOLOR), MP_ROM_PTR(MP_ROM_INT(LV_TEXT_FLAG_RECOLOR)) },
    { MP_ROM_QSTR(MP_QSTR_EXPAND), MP_ROM_PTR(MP_ROM_INT(LV_TEXT_FLAG_EXPAND)) },
    { MP_ROM_QSTR(MP_QSTR_FIT), MP_ROM_PTR(MP_ROM_INT(LV_TEXT_FLAG_FIT)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_TEXT_FLAG_locals_dict, LV_TEXT_FLAG_locals_dict_table);

STATIC void LV_TEXT_FLAG_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_TEXT_FLAG");
}



STATIC const mp_obj_type_t mp_LV_TEXT_FLAG_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_TEXT_FLAG,
    .print = LV_TEXT_FLAG_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_TEXT_FLAG_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_TEXT_CMD_STATE object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_TEXT_CMD_STATE_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_WAIT), MP_ROM_PTR(MP_ROM_INT(LV_TEXT_CMD_STATE_WAIT)) },
    { MP_ROM_QSTR(MP_QSTR_PAR), MP_ROM_PTR(MP_ROM_INT(LV_TEXT_CMD_STATE_PAR)) },
    { MP_ROM_QSTR(MP_QSTR_IN), MP_ROM_PTR(MP_ROM_INT(LV_TEXT_CMD_STATE_IN)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_TEXT_CMD_STATE_locals_dict, LV_TEXT_CMD_STATE_locals_dict_table);

STATIC void LV_TEXT_CMD_STATE_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_TEXT_CMD_STATE");
}



STATIC const mp_obj_type_t mp_LV_TEXT_CMD_STATE_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_TEXT_CMD_STATE,
    .print = LV_TEXT_CMD_STATE_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_TEXT_CMD_STATE_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_TEXT_ALIGN object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_TEXT_ALIGN_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_AUTO), MP_ROM_PTR(MP_ROM_INT(LV_TEXT_ALIGN_AUTO)) },
    { MP_ROM_QSTR(MP_QSTR_LEFT), MP_ROM_PTR(MP_ROM_INT(LV_TEXT_ALIGN_LEFT)) },
    { MP_ROM_QSTR(MP_QSTR_CENTER), MP_ROM_PTR(MP_ROM_INT(LV_TEXT_ALIGN_CENTER)) },
    { MP_ROM_QSTR(MP_QSTR_RIGHT), MP_ROM_PTR(MP_ROM_INT(LV_TEXT_ALIGN_RIGHT)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_TEXT_ALIGN_locals_dict, LV_TEXT_ALIGN_locals_dict_table);

STATIC void LV_TEXT_ALIGN_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_TEXT_ALIGN");
}



STATIC const mp_obj_type_t mp_LV_TEXT_ALIGN_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_TEXT_ALIGN,
    .print = LV_TEXT_ALIGN_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_TEXT_ALIGN_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_BASE_DIR object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_BASE_DIR_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_LTR), MP_ROM_PTR(MP_ROM_INT(LV_BASE_DIR_LTR)) },
    { MP_ROM_QSTR(MP_QSTR_RTL), MP_ROM_PTR(MP_ROM_INT(LV_BASE_DIR_RTL)) },
    { MP_ROM_QSTR(MP_QSTR_AUTO), MP_ROM_PTR(MP_ROM_INT(LV_BASE_DIR_AUTO)) },
    { MP_ROM_QSTR(MP_QSTR_NEUTRAL), MP_ROM_PTR(MP_ROM_INT(LV_BASE_DIR_NEUTRAL)) },
    { MP_ROM_QSTR(MP_QSTR_WEAK), MP_ROM_PTR(MP_ROM_INT(LV_BASE_DIR_WEAK)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_BASE_DIR_locals_dict, LV_BASE_DIR_locals_dict_table);

STATIC void LV_BASE_DIR_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_BASE_DIR");
}



STATIC const mp_obj_type_t mp_LV_BASE_DIR_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_BASE_DIR,
    .print = LV_BASE_DIR_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_BASE_DIR_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_BLEND_MODE object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_BLEND_MODE_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_NORMAL), MP_ROM_PTR(MP_ROM_INT(LV_BLEND_MODE_NORMAL)) },
    { MP_ROM_QSTR(MP_QSTR_ADDITIVE), MP_ROM_PTR(MP_ROM_INT(LV_BLEND_MODE_ADDITIVE)) },
    { MP_ROM_QSTR(MP_QSTR_SUBTRACTIVE), MP_ROM_PTR(MP_ROM_INT(LV_BLEND_MODE_SUBTRACTIVE)) },
    { MP_ROM_QSTR(MP_QSTR_MULTIPLY), MP_ROM_PTR(MP_ROM_INT(LV_BLEND_MODE_MULTIPLY)) },
    { MP_ROM_QSTR(MP_QSTR_REPLACE), MP_ROM_PTR(MP_ROM_INT(LV_BLEND_MODE_REPLACE)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_BLEND_MODE_locals_dict, LV_BLEND_MODE_locals_dict_table);

STATIC void LV_BLEND_MODE_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_BLEND_MODE");
}



STATIC const mp_obj_type_t mp_LV_BLEND_MODE_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_BLEND_MODE,
    .print = LV_BLEND_MODE_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_BLEND_MODE_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_TEXT_DECOR object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_TEXT_DECOR_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_NONE), MP_ROM_PTR(MP_ROM_INT(LV_TEXT_DECOR_NONE)) },
    { MP_ROM_QSTR(MP_QSTR_UNDERLINE), MP_ROM_PTR(MP_ROM_INT(LV_TEXT_DECOR_UNDERLINE)) },
    { MP_ROM_QSTR(MP_QSTR_STRIKETHROUGH), MP_ROM_PTR(MP_ROM_INT(LV_TEXT_DECOR_STRIKETHROUGH)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_TEXT_DECOR_locals_dict, LV_TEXT_DECOR_locals_dict_table);

STATIC void LV_TEXT_DECOR_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_TEXT_DECOR");
}



STATIC const mp_obj_type_t mp_LV_TEXT_DECOR_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_TEXT_DECOR,
    .print = LV_TEXT_DECOR_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_TEXT_DECOR_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_BORDER_SIDE object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_BORDER_SIDE_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_NONE), MP_ROM_PTR(MP_ROM_INT(LV_BORDER_SIDE_NONE)) },
    { MP_ROM_QSTR(MP_QSTR_BOTTOM), MP_ROM_PTR(MP_ROM_INT(LV_BORDER_SIDE_BOTTOM)) },
    { MP_ROM_QSTR(MP_QSTR_TOP), MP_ROM_PTR(MP_ROM_INT(LV_BORDER_SIDE_TOP)) },
    { MP_ROM_QSTR(MP_QSTR_LEFT), MP_ROM_PTR(MP_ROM_INT(LV_BORDER_SIDE_LEFT)) },
    { MP_ROM_QSTR(MP_QSTR_RIGHT), MP_ROM_PTR(MP_ROM_INT(LV_BORDER_SIDE_RIGHT)) },
    { MP_ROM_QSTR(MP_QSTR_FULL), MP_ROM_PTR(MP_ROM_INT(LV_BORDER_SIDE_FULL)) },
    { MP_ROM_QSTR(MP_QSTR_INTERNAL), MP_ROM_PTR(MP_ROM_INT(LV_BORDER_SIDE_INTERNAL)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_BORDER_SIDE_locals_dict, LV_BORDER_SIDE_locals_dict_table);

STATIC void LV_BORDER_SIDE_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_BORDER_SIDE");
}



STATIC const mp_obj_type_t mp_LV_BORDER_SIDE_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_BORDER_SIDE,
    .print = LV_BORDER_SIDE_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_BORDER_SIDE_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_GRAD_DIR object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_GRAD_DIR_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_NONE), MP_ROM_PTR(MP_ROM_INT(LV_GRAD_DIR_NONE)) },
    { MP_ROM_QSTR(MP_QSTR_VER), MP_ROM_PTR(MP_ROM_INT(LV_GRAD_DIR_VER)) },
    { MP_ROM_QSTR(MP_QSTR_HOR), MP_ROM_PTR(MP_ROM_INT(LV_GRAD_DIR_HOR)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_GRAD_DIR_locals_dict, LV_GRAD_DIR_locals_dict_table);

STATIC void LV_GRAD_DIR_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_GRAD_DIR");
}



STATIC const mp_obj_type_t mp_LV_GRAD_DIR_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_GRAD_DIR,
    .print = LV_GRAD_DIR_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_GRAD_DIR_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_DITHER object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_DITHER_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_NONE), MP_ROM_PTR(MP_ROM_INT(LV_DITHER_NONE)) },
    { MP_ROM_QSTR(MP_QSTR_ORDERED), MP_ROM_PTR(MP_ROM_INT(LV_DITHER_ORDERED)) },
    { MP_ROM_QSTR(MP_QSTR_ERR_DIFF), MP_ROM_PTR(MP_ROM_INT(LV_DITHER_ERR_DIFF)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_DITHER_locals_dict, LV_DITHER_locals_dict_table);

STATIC void LV_DITHER_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_DITHER");
}



STATIC const mp_obj_type_t mp_LV_DITHER_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_DITHER,
    .print = LV_DITHER_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_DITHER_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_STYLE_RES object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_STYLE_RES_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_NOT_FOUND), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_RES_NOT_FOUND)) },
    { MP_ROM_QSTR(MP_QSTR_FOUND), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_RES_FOUND)) },
    { MP_ROM_QSTR(MP_QSTR_INHERIT), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_RES_INHERIT)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_STYLE_RES_locals_dict, LV_STYLE_RES_locals_dict_table);

STATIC void LV_STYLE_RES_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_STYLE_RES");
}



STATIC const mp_obj_type_t mp_LV_STYLE_RES_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_STYLE_RES,
    .print = LV_STYLE_RES_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_STYLE_RES_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_IMG_CF object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_IMG_CF_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_UNKNOWN), MP_ROM_PTR(MP_ROM_INT(LV_IMG_CF_UNKNOWN)) },
    { MP_ROM_QSTR(MP_QSTR_RAW), MP_ROM_PTR(MP_ROM_INT(LV_IMG_CF_RAW)) },
    { MP_ROM_QSTR(MP_QSTR_RAW_ALPHA), MP_ROM_PTR(MP_ROM_INT(LV_IMG_CF_RAW_ALPHA)) },
    { MP_ROM_QSTR(MP_QSTR_RAW_CHROMA_KEYED), MP_ROM_PTR(MP_ROM_INT(LV_IMG_CF_RAW_CHROMA_KEYED)) },
    { MP_ROM_QSTR(MP_QSTR_TRUE_COLOR), MP_ROM_PTR(MP_ROM_INT(LV_IMG_CF_TRUE_COLOR)) },
    { MP_ROM_QSTR(MP_QSTR_TRUE_COLOR_ALPHA), MP_ROM_PTR(MP_ROM_INT(LV_IMG_CF_TRUE_COLOR_ALPHA)) },
    { MP_ROM_QSTR(MP_QSTR_TRUE_COLOR_CHROMA_KEYED), MP_ROM_PTR(MP_ROM_INT(LV_IMG_CF_TRUE_COLOR_CHROMA_KEYED)) },
    { MP_ROM_QSTR(MP_QSTR_INDEXED_1BIT), MP_ROM_PTR(MP_ROM_INT(LV_IMG_CF_INDEXED_1BIT)) },
    { MP_ROM_QSTR(MP_QSTR_INDEXED_2BIT), MP_ROM_PTR(MP_ROM_INT(LV_IMG_CF_INDEXED_2BIT)) },
    { MP_ROM_QSTR(MP_QSTR_INDEXED_4BIT), MP_ROM_PTR(MP_ROM_INT(LV_IMG_CF_INDEXED_4BIT)) },
    { MP_ROM_QSTR(MP_QSTR_INDEXED_8BIT), MP_ROM_PTR(MP_ROM_INT(LV_IMG_CF_INDEXED_8BIT)) },
    { MP_ROM_QSTR(MP_QSTR_ALPHA_1BIT), MP_ROM_PTR(MP_ROM_INT(LV_IMG_CF_ALPHA_1BIT)) },
    { MP_ROM_QSTR(MP_QSTR_ALPHA_2BIT), MP_ROM_PTR(MP_ROM_INT(LV_IMG_CF_ALPHA_2BIT)) },
    { MP_ROM_QSTR(MP_QSTR_ALPHA_4BIT), MP_ROM_PTR(MP_ROM_INT(LV_IMG_CF_ALPHA_4BIT)) },
    { MP_ROM_QSTR(MP_QSTR_ALPHA_8BIT), MP_ROM_PTR(MP_ROM_INT(LV_IMG_CF_ALPHA_8BIT)) },
    { MP_ROM_QSTR(MP_QSTR_RGB888), MP_ROM_PTR(MP_ROM_INT(LV_IMG_CF_RGB888)) },
    { MP_ROM_QSTR(MP_QSTR_RGBA8888), MP_ROM_PTR(MP_ROM_INT(LV_IMG_CF_RGBA8888)) },
    { MP_ROM_QSTR(MP_QSTR_RGBX8888), MP_ROM_PTR(MP_ROM_INT(LV_IMG_CF_RGBX8888)) },
    { MP_ROM_QSTR(MP_QSTR_RGB565), MP_ROM_PTR(MP_ROM_INT(LV_IMG_CF_RGB565)) },
    { MP_ROM_QSTR(MP_QSTR_RGBA5658), MP_ROM_PTR(MP_ROM_INT(LV_IMG_CF_RGBA5658)) },
    { MP_ROM_QSTR(MP_QSTR_RGB565A8), MP_ROM_PTR(MP_ROM_INT(LV_IMG_CF_RGB565A8)) },
    { MP_ROM_QSTR(MP_QSTR_RESERVED_15), MP_ROM_PTR(MP_ROM_INT(LV_IMG_CF_RESERVED_15)) },
    { MP_ROM_QSTR(MP_QSTR_RESERVED_16), MP_ROM_PTR(MP_ROM_INT(LV_IMG_CF_RESERVED_16)) },
    { MP_ROM_QSTR(MP_QSTR_RESERVED_17), MP_ROM_PTR(MP_ROM_INT(LV_IMG_CF_RESERVED_17)) },
    { MP_ROM_QSTR(MP_QSTR_RESERVED_18), MP_ROM_PTR(MP_ROM_INT(LV_IMG_CF_RESERVED_18)) },
    { MP_ROM_QSTR(MP_QSTR_RESERVED_19), MP_ROM_PTR(MP_ROM_INT(LV_IMG_CF_RESERVED_19)) },
    { MP_ROM_QSTR(MP_QSTR_RESERVED_20), MP_ROM_PTR(MP_ROM_INT(LV_IMG_CF_RESERVED_20)) },
    { MP_ROM_QSTR(MP_QSTR_RESERVED_21), MP_ROM_PTR(MP_ROM_INT(LV_IMG_CF_RESERVED_21)) },
    { MP_ROM_QSTR(MP_QSTR_RESERVED_22), MP_ROM_PTR(MP_ROM_INT(LV_IMG_CF_RESERVED_22)) },
    { MP_ROM_QSTR(MP_QSTR_RESERVED_23), MP_ROM_PTR(MP_ROM_INT(LV_IMG_CF_RESERVED_23)) },
    { MP_ROM_QSTR(MP_QSTR_USER_ENCODED_0), MP_ROM_PTR(MP_ROM_INT(LV_IMG_CF_USER_ENCODED_0)) },
    { MP_ROM_QSTR(MP_QSTR_USER_ENCODED_1), MP_ROM_PTR(MP_ROM_INT(LV_IMG_CF_USER_ENCODED_1)) },
    { MP_ROM_QSTR(MP_QSTR_USER_ENCODED_2), MP_ROM_PTR(MP_ROM_INT(LV_IMG_CF_USER_ENCODED_2)) },
    { MP_ROM_QSTR(MP_QSTR_USER_ENCODED_3), MP_ROM_PTR(MP_ROM_INT(LV_IMG_CF_USER_ENCODED_3)) },
    { MP_ROM_QSTR(MP_QSTR_USER_ENCODED_4), MP_ROM_PTR(MP_ROM_INT(LV_IMG_CF_USER_ENCODED_4)) },
    { MP_ROM_QSTR(MP_QSTR_USER_ENCODED_5), MP_ROM_PTR(MP_ROM_INT(LV_IMG_CF_USER_ENCODED_5)) },
    { MP_ROM_QSTR(MP_QSTR_USER_ENCODED_6), MP_ROM_PTR(MP_ROM_INT(LV_IMG_CF_USER_ENCODED_6)) },
    { MP_ROM_QSTR(MP_QSTR_USER_ENCODED_7), MP_ROM_PTR(MP_ROM_INT(LV_IMG_CF_USER_ENCODED_7)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_IMG_CF_locals_dict, LV_IMG_CF_locals_dict_table);

STATIC void LV_IMG_CF_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_IMG_CF");
}



STATIC const mp_obj_type_t mp_LV_IMG_CF_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_IMG_CF,
    .print = LV_IMG_CF_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_IMG_CF_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_FS_RES object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_FS_RES_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_OK), MP_ROM_PTR(MP_ROM_INT(LV_FS_RES_OK)) },
    { MP_ROM_QSTR(MP_QSTR_HW_ERR), MP_ROM_PTR(MP_ROM_INT(LV_FS_RES_HW_ERR)) },
    { MP_ROM_QSTR(MP_QSTR_FS_ERR), MP_ROM_PTR(MP_ROM_INT(LV_FS_RES_FS_ERR)) },
    { MP_ROM_QSTR(MP_QSTR_NOT_EX), MP_ROM_PTR(MP_ROM_INT(LV_FS_RES_NOT_EX)) },
    { MP_ROM_QSTR(MP_QSTR_FULL), MP_ROM_PTR(MP_ROM_INT(LV_FS_RES_FULL)) },
    { MP_ROM_QSTR(MP_QSTR_LOCKED), MP_ROM_PTR(MP_ROM_INT(LV_FS_RES_LOCKED)) },
    { MP_ROM_QSTR(MP_QSTR_DENIED), MP_ROM_PTR(MP_ROM_INT(LV_FS_RES_DENIED)) },
    { MP_ROM_QSTR(MP_QSTR_BUSY), MP_ROM_PTR(MP_ROM_INT(LV_FS_RES_BUSY)) },
    { MP_ROM_QSTR(MP_QSTR_TOUT), MP_ROM_PTR(MP_ROM_INT(LV_FS_RES_TOUT)) },
    { MP_ROM_QSTR(MP_QSTR_NOT_IMP), MP_ROM_PTR(MP_ROM_INT(LV_FS_RES_NOT_IMP)) },
    { MP_ROM_QSTR(MP_QSTR_OUT_OF_MEM), MP_ROM_PTR(MP_ROM_INT(LV_FS_RES_OUT_OF_MEM)) },
    { MP_ROM_QSTR(MP_QSTR_INV_PARAM), MP_ROM_PTR(MP_ROM_INT(LV_FS_RES_INV_PARAM)) },
    { MP_ROM_QSTR(MP_QSTR_UNKNOWN), MP_ROM_PTR(MP_ROM_INT(LV_FS_RES_UNKNOWN)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_FS_RES_locals_dict, LV_FS_RES_locals_dict_table);

STATIC void LV_FS_RES_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_FS_RES");
}



STATIC const mp_obj_type_t mp_LV_FS_RES_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_FS_RES,
    .print = LV_FS_RES_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_FS_RES_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_FS_MODE object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_FS_MODE_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_WR), MP_ROM_PTR(MP_ROM_INT(LV_FS_MODE_WR)) },
    { MP_ROM_QSTR(MP_QSTR_RD), MP_ROM_PTR(MP_ROM_INT(LV_FS_MODE_RD)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_FS_MODE_locals_dict, LV_FS_MODE_locals_dict_table);

STATIC void LV_FS_MODE_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_FS_MODE");
}



STATIC const mp_obj_type_t mp_LV_FS_MODE_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_FS_MODE,
    .print = LV_FS_MODE_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_FS_MODE_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_IMG_SRC object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_IMG_SRC_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_VARIABLE), MP_ROM_PTR(MP_ROM_INT(LV_IMG_SRC_VARIABLE)) },
    { MP_ROM_QSTR(MP_QSTR_FILE), MP_ROM_PTR(MP_ROM_INT(LV_IMG_SRC_FILE)) },
    { MP_ROM_QSTR(MP_QSTR_SYMBOL), MP_ROM_PTR(MP_ROM_INT(LV_IMG_SRC_SYMBOL)) },
    { MP_ROM_QSTR(MP_QSTR_UNKNOWN), MP_ROM_PTR(MP_ROM_INT(LV_IMG_SRC_UNKNOWN)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_IMG_SRC_locals_dict, LV_IMG_SRC_locals_dict_table);

STATIC void LV_IMG_SRC_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_IMG_SRC");
}



STATIC const mp_obj_type_t mp_LV_IMG_SRC_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_IMG_SRC,
    .print = LV_IMG_SRC_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_IMG_SRC_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_DRAW_MASK_RES object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_DRAW_MASK_RES_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_TRANSP), MP_ROM_PTR(MP_ROM_INT(LV_DRAW_MASK_RES_TRANSP)) },
    { MP_ROM_QSTR(MP_QSTR_FULL_COVER), MP_ROM_PTR(MP_ROM_INT(LV_DRAW_MASK_RES_FULL_COVER)) },
    { MP_ROM_QSTR(MP_QSTR_CHANGED), MP_ROM_PTR(MP_ROM_INT(LV_DRAW_MASK_RES_CHANGED)) },
    { MP_ROM_QSTR(MP_QSTR_UNKNOWN), MP_ROM_PTR(MP_ROM_INT(LV_DRAW_MASK_RES_UNKNOWN)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_DRAW_MASK_RES_locals_dict, LV_DRAW_MASK_RES_locals_dict_table);

STATIC void LV_DRAW_MASK_RES_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_DRAW_MASK_RES");
}



STATIC const mp_obj_type_t mp_LV_DRAW_MASK_RES_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_DRAW_MASK_RES,
    .print = LV_DRAW_MASK_RES_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_DRAW_MASK_RES_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_DRAW_MASK_TYPE object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_DRAW_MASK_TYPE_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_LINE), MP_ROM_PTR(MP_ROM_INT(LV_DRAW_MASK_TYPE_LINE)) },
    { MP_ROM_QSTR(MP_QSTR_ANGLE), MP_ROM_PTR(MP_ROM_INT(LV_DRAW_MASK_TYPE_ANGLE)) },
    { MP_ROM_QSTR(MP_QSTR_RADIUS), MP_ROM_PTR(MP_ROM_INT(LV_DRAW_MASK_TYPE_RADIUS)) },
    { MP_ROM_QSTR(MP_QSTR_FADE), MP_ROM_PTR(MP_ROM_INT(LV_DRAW_MASK_TYPE_FADE)) },
    { MP_ROM_QSTR(MP_QSTR_MAP), MP_ROM_PTR(MP_ROM_INT(LV_DRAW_MASK_TYPE_MAP)) },
    { MP_ROM_QSTR(MP_QSTR_POLYGON), MP_ROM_PTR(MP_ROM_INT(LV_DRAW_MASK_TYPE_POLYGON)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_DRAW_MASK_TYPE_locals_dict, LV_DRAW_MASK_TYPE_locals_dict_table);

STATIC void LV_DRAW_MASK_TYPE_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_DRAW_MASK_TYPE");
}



STATIC const mp_obj_type_t mp_LV_DRAW_MASK_TYPE_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_DRAW_MASK_TYPE,
    .print = LV_DRAW_MASK_TYPE_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_DRAW_MASK_TYPE_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_DRAW_MASK_LINE_SIDE object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_DRAW_MASK_LINE_SIDE_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_LEFT), MP_ROM_PTR(MP_ROM_INT(LV_DRAW_MASK_LINE_SIDE_LEFT)) },
    { MP_ROM_QSTR(MP_QSTR_RIGHT), MP_ROM_PTR(MP_ROM_INT(LV_DRAW_MASK_LINE_SIDE_RIGHT)) },
    { MP_ROM_QSTR(MP_QSTR_TOP), MP_ROM_PTR(MP_ROM_INT(LV_DRAW_MASK_LINE_SIDE_TOP)) },
    { MP_ROM_QSTR(MP_QSTR_BOTTOM), MP_ROM_PTR(MP_ROM_INT(LV_DRAW_MASK_LINE_SIDE_BOTTOM)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_DRAW_MASK_LINE_SIDE_locals_dict, LV_DRAW_MASK_LINE_SIDE_locals_dict_table);

STATIC void LV_DRAW_MASK_LINE_SIDE_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_DRAW_MASK_LINE_SIDE");
}



STATIC const mp_obj_type_t mp_LV_DRAW_MASK_LINE_SIDE_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_DRAW_MASK_LINE_SIDE,
    .print = LV_DRAW_MASK_LINE_SIDE_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_DRAW_MASK_LINE_SIDE_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_STATE object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_STATE_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_DEFAULT), MP_ROM_PTR(MP_ROM_INT(LV_STATE_DEFAULT)) },
    { MP_ROM_QSTR(MP_QSTR_CHECKED), MP_ROM_PTR(MP_ROM_INT(LV_STATE_CHECKED)) },
    { MP_ROM_QSTR(MP_QSTR_FOCUSED), MP_ROM_PTR(MP_ROM_INT(LV_STATE_FOCUSED)) },
    { MP_ROM_QSTR(MP_QSTR_FOCUS_KEY), MP_ROM_PTR(MP_ROM_INT(LV_STATE_FOCUS_KEY)) },
    { MP_ROM_QSTR(MP_QSTR_EDITED), MP_ROM_PTR(MP_ROM_INT(LV_STATE_EDITED)) },
    { MP_ROM_QSTR(MP_QSTR_HOVERED), MP_ROM_PTR(MP_ROM_INT(LV_STATE_HOVERED)) },
    { MP_ROM_QSTR(MP_QSTR_PRESSED), MP_ROM_PTR(MP_ROM_INT(LV_STATE_PRESSED)) },
    { MP_ROM_QSTR(MP_QSTR_SCROLLED), MP_ROM_PTR(MP_ROM_INT(LV_STATE_SCROLLED)) },
    { MP_ROM_QSTR(MP_QSTR_DISABLED), MP_ROM_PTR(MP_ROM_INT(LV_STATE_DISABLED)) },
    { MP_ROM_QSTR(MP_QSTR_USER_1), MP_ROM_PTR(MP_ROM_INT(LV_STATE_USER_1)) },
    { MP_ROM_QSTR(MP_QSTR_USER_2), MP_ROM_PTR(MP_ROM_INT(LV_STATE_USER_2)) },
    { MP_ROM_QSTR(MP_QSTR_USER_3), MP_ROM_PTR(MP_ROM_INT(LV_STATE_USER_3)) },
    { MP_ROM_QSTR(MP_QSTR_USER_4), MP_ROM_PTR(MP_ROM_INT(LV_STATE_USER_4)) },
    { MP_ROM_QSTR(MP_QSTR_ANY), MP_ROM_PTR(MP_ROM_INT(LV_STATE_ANY)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_STATE_locals_dict, LV_STATE_locals_dict_table);

STATIC void LV_STATE_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_STATE");
}



STATIC const mp_obj_type_t mp_LV_STATE_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_STATE,
    .print = LV_STATE_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_STATE_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_PART object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_PART_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_MAIN), MP_ROM_PTR(MP_ROM_INT(LV_PART_MAIN)) },
    { MP_ROM_QSTR(MP_QSTR_SCROLLBAR), MP_ROM_PTR(MP_ROM_INT(LV_PART_SCROLLBAR)) },
    { MP_ROM_QSTR(MP_QSTR_INDICATOR), MP_ROM_PTR(MP_ROM_INT(LV_PART_INDICATOR)) },
    { MP_ROM_QSTR(MP_QSTR_KNOB), MP_ROM_PTR(MP_ROM_INT(LV_PART_KNOB)) },
    { MP_ROM_QSTR(MP_QSTR_SELECTED), MP_ROM_PTR(MP_ROM_INT(LV_PART_SELECTED)) },
    { MP_ROM_QSTR(MP_QSTR_ITEMS), MP_ROM_PTR(MP_ROM_INT(LV_PART_ITEMS)) },
    { MP_ROM_QSTR(MP_QSTR_TICKS), MP_ROM_PTR(MP_ROM_INT(LV_PART_TICKS)) },
    { MP_ROM_QSTR(MP_QSTR_CURSOR), MP_ROM_PTR(MP_ROM_INT(LV_PART_CURSOR)) },
    { MP_ROM_QSTR(MP_QSTR_CUSTOM_FIRST), MP_ROM_PTR(MP_ROM_INT(LV_PART_CUSTOM_FIRST)) },
    { MP_ROM_QSTR(MP_QSTR_ANY), MP_ROM_PTR(MP_ROM_INT(LV_PART_ANY)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_PART_locals_dict, LV_PART_locals_dict_table);

STATIC void LV_PART_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_PART");
}



STATIC const mp_obj_type_t mp_LV_PART_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_PART,
    .print = LV_PART_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_PART_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_OBJ_FLAG object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_OBJ_FLAG_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_HIDDEN), MP_ROM_PTR(MP_ROM_INT(LV_OBJ_FLAG_HIDDEN)) },
    { MP_ROM_QSTR(MP_QSTR_CLICKABLE), MP_ROM_PTR(MP_ROM_INT(LV_OBJ_FLAG_CLICKABLE)) },
    { MP_ROM_QSTR(MP_QSTR_CLICK_FOCUSABLE), MP_ROM_PTR(MP_ROM_INT(LV_OBJ_FLAG_CLICK_FOCUSABLE)) },
    { MP_ROM_QSTR(MP_QSTR_CHECKABLE), MP_ROM_PTR(MP_ROM_INT(LV_OBJ_FLAG_CHECKABLE)) },
    { MP_ROM_QSTR(MP_QSTR_SCROLLABLE), MP_ROM_PTR(MP_ROM_INT(LV_OBJ_FLAG_SCROLLABLE)) },
    { MP_ROM_QSTR(MP_QSTR_SCROLL_ELASTIC), MP_ROM_PTR(MP_ROM_INT(LV_OBJ_FLAG_SCROLL_ELASTIC)) },
    { MP_ROM_QSTR(MP_QSTR_SCROLL_MOMENTUM), MP_ROM_PTR(MP_ROM_INT(LV_OBJ_FLAG_SCROLL_MOMENTUM)) },
    { MP_ROM_QSTR(MP_QSTR_SCROLL_ONE), MP_ROM_PTR(MP_ROM_INT(LV_OBJ_FLAG_SCROLL_ONE)) },
    { MP_ROM_QSTR(MP_QSTR_SCROLL_CHAIN_HOR), MP_ROM_PTR(MP_ROM_INT(LV_OBJ_FLAG_SCROLL_CHAIN_HOR)) },
    { MP_ROM_QSTR(MP_QSTR_SCROLL_CHAIN_VER), MP_ROM_PTR(MP_ROM_INT(LV_OBJ_FLAG_SCROLL_CHAIN_VER)) },
    { MP_ROM_QSTR(MP_QSTR_SCROLL_CHAIN), MP_ROM_PTR(MP_ROM_INT(LV_OBJ_FLAG_SCROLL_CHAIN)) },
    { MP_ROM_QSTR(MP_QSTR_SCROLL_ON_FOCUS), MP_ROM_PTR(MP_ROM_INT(LV_OBJ_FLAG_SCROLL_ON_FOCUS)) },
    { MP_ROM_QSTR(MP_QSTR_SCROLL_WITH_ARROW), MP_ROM_PTR(MP_ROM_INT(LV_OBJ_FLAG_SCROLL_WITH_ARROW)) },
    { MP_ROM_QSTR(MP_QSTR_SNAPPABLE), MP_ROM_PTR(MP_ROM_INT(LV_OBJ_FLAG_SNAPPABLE)) },
    { MP_ROM_QSTR(MP_QSTR_PRESS_LOCK), MP_ROM_PTR(MP_ROM_INT(LV_OBJ_FLAG_PRESS_LOCK)) },
    { MP_ROM_QSTR(MP_QSTR_EVENT_BUBBLE), MP_ROM_PTR(MP_ROM_INT(LV_OBJ_FLAG_EVENT_BUBBLE)) },
    { MP_ROM_QSTR(MP_QSTR_GESTURE_BUBBLE), MP_ROM_PTR(MP_ROM_INT(LV_OBJ_FLAG_GESTURE_BUBBLE)) },
    { MP_ROM_QSTR(MP_QSTR_ADV_HITTEST), MP_ROM_PTR(MP_ROM_INT(LV_OBJ_FLAG_ADV_HITTEST)) },
    { MP_ROM_QSTR(MP_QSTR_IGNORE_LAYOUT), MP_ROM_PTR(MP_ROM_INT(LV_OBJ_FLAG_IGNORE_LAYOUT)) },
    { MP_ROM_QSTR(MP_QSTR_FLOATING), MP_ROM_PTR(MP_ROM_INT(LV_OBJ_FLAG_FLOATING)) },
    { MP_ROM_QSTR(MP_QSTR_OVERFLOW_VISIBLE), MP_ROM_PTR(MP_ROM_INT(LV_OBJ_FLAG_OVERFLOW_VISIBLE)) },
    { MP_ROM_QSTR(MP_QSTR_LAYOUT_1), MP_ROM_PTR(MP_ROM_INT(LV_OBJ_FLAG_LAYOUT_1)) },
    { MP_ROM_QSTR(MP_QSTR_LAYOUT_2), MP_ROM_PTR(MP_ROM_INT(LV_OBJ_FLAG_LAYOUT_2)) },
    { MP_ROM_QSTR(MP_QSTR_WIDGET_1), MP_ROM_PTR(MP_ROM_INT(LV_OBJ_FLAG_WIDGET_1)) },
    { MP_ROM_QSTR(MP_QSTR_WIDGET_2), MP_ROM_PTR(MP_ROM_INT(LV_OBJ_FLAG_WIDGET_2)) },
    { MP_ROM_QSTR(MP_QSTR_USER_1), MP_ROM_PTR(MP_ROM_INT(LV_OBJ_FLAG_USER_1)) },
    { MP_ROM_QSTR(MP_QSTR_USER_2), MP_ROM_PTR(MP_ROM_INT(LV_OBJ_FLAG_USER_2)) },
    { MP_ROM_QSTR(MP_QSTR_USER_3), MP_ROM_PTR(MP_ROM_INT(LV_OBJ_FLAG_USER_3)) },
    { MP_ROM_QSTR(MP_QSTR_USER_4), MP_ROM_PTR(MP_ROM_INT(LV_OBJ_FLAG_USER_4)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_OBJ_FLAG_locals_dict, LV_OBJ_FLAG_locals_dict_table);

STATIC void LV_OBJ_FLAG_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_OBJ_FLAG");
}



STATIC const mp_obj_type_t mp_LV_OBJ_FLAG_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_OBJ_FLAG,
    .print = LV_OBJ_FLAG_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_OBJ_FLAG_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_SCROLLBAR_MODE object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_SCROLLBAR_MODE_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_OFF), MP_ROM_PTR(MP_ROM_INT(LV_SCROLLBAR_MODE_OFF)) },
    { MP_ROM_QSTR(MP_QSTR_ON), MP_ROM_PTR(MP_ROM_INT(LV_SCROLLBAR_MODE_ON)) },
    { MP_ROM_QSTR(MP_QSTR_ACTIVE), MP_ROM_PTR(MP_ROM_INT(LV_SCROLLBAR_MODE_ACTIVE)) },
    { MP_ROM_QSTR(MP_QSTR_AUTO), MP_ROM_PTR(MP_ROM_INT(LV_SCROLLBAR_MODE_AUTO)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_SCROLLBAR_MODE_locals_dict, LV_SCROLLBAR_MODE_locals_dict_table);

STATIC void LV_SCROLLBAR_MODE_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_SCROLLBAR_MODE");
}



STATIC const mp_obj_type_t mp_LV_SCROLLBAR_MODE_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_SCROLLBAR_MODE,
    .print = LV_SCROLLBAR_MODE_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_SCROLLBAR_MODE_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_SCROLL_SNAP object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_SCROLL_SNAP_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_NONE), MP_ROM_PTR(MP_ROM_INT(LV_SCROLL_SNAP_NONE)) },
    { MP_ROM_QSTR(MP_QSTR_START), MP_ROM_PTR(MP_ROM_INT(LV_SCROLL_SNAP_START)) },
    { MP_ROM_QSTR(MP_QSTR_END), MP_ROM_PTR(MP_ROM_INT(LV_SCROLL_SNAP_END)) },
    { MP_ROM_QSTR(MP_QSTR_CENTER), MP_ROM_PTR(MP_ROM_INT(LV_SCROLL_SNAP_CENTER)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_SCROLL_SNAP_locals_dict, LV_SCROLL_SNAP_locals_dict_table);

STATIC void LV_SCROLL_SNAP_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_SCROLL_SNAP");
}



STATIC const mp_obj_type_t mp_LV_SCROLL_SNAP_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_SCROLL_SNAP,
    .print = LV_SCROLL_SNAP_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_SCROLL_SNAP_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_KEY object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_KEY_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_UP), MP_ROM_PTR(MP_ROM_INT(LV_KEY_UP)) },
    { MP_ROM_QSTR(MP_QSTR_DOWN), MP_ROM_PTR(MP_ROM_INT(LV_KEY_DOWN)) },
    { MP_ROM_QSTR(MP_QSTR_RIGHT), MP_ROM_PTR(MP_ROM_INT(LV_KEY_RIGHT)) },
    { MP_ROM_QSTR(MP_QSTR_LEFT), MP_ROM_PTR(MP_ROM_INT(LV_KEY_LEFT)) },
    { MP_ROM_QSTR(MP_QSTR_ESC), MP_ROM_PTR(MP_ROM_INT(LV_KEY_ESC)) },
    { MP_ROM_QSTR(MP_QSTR_DEL), MP_ROM_PTR(MP_ROM_INT(LV_KEY_DEL)) },
    { MP_ROM_QSTR(MP_QSTR_BACKSPACE), MP_ROM_PTR(MP_ROM_INT(LV_KEY_BACKSPACE)) },
    { MP_ROM_QSTR(MP_QSTR_ENTER), MP_ROM_PTR(MP_ROM_INT(LV_KEY_ENTER)) },
    { MP_ROM_QSTR(MP_QSTR_NEXT), MP_ROM_PTR(MP_ROM_INT(LV_KEY_NEXT)) },
    { MP_ROM_QSTR(MP_QSTR_PREV), MP_ROM_PTR(MP_ROM_INT(LV_KEY_PREV)) },
    { MP_ROM_QSTR(MP_QSTR_HOME), MP_ROM_PTR(MP_ROM_INT(LV_KEY_HOME)) },
    { MP_ROM_QSTR(MP_QSTR_END), MP_ROM_PTR(MP_ROM_INT(LV_KEY_END)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_KEY_locals_dict, LV_KEY_locals_dict_table);

STATIC void LV_KEY_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_KEY");
}



STATIC const mp_obj_type_t mp_LV_KEY_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_KEY,
    .print = LV_KEY_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_KEY_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_FONT_FMT_TXT_CMAP object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_FONT_FMT_TXT_CMAP_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_FORMAT0_FULL), MP_ROM_PTR(MP_ROM_INT(LV_FONT_FMT_TXT_CMAP_FORMAT0_FULL)) },
    { MP_ROM_QSTR(MP_QSTR_SPARSE_FULL), MP_ROM_PTR(MP_ROM_INT(LV_FONT_FMT_TXT_CMAP_SPARSE_FULL)) },
    { MP_ROM_QSTR(MP_QSTR_FORMAT0_TINY), MP_ROM_PTR(MP_ROM_INT(LV_FONT_FMT_TXT_CMAP_FORMAT0_TINY)) },
    { MP_ROM_QSTR(MP_QSTR_SPARSE_TINY), MP_ROM_PTR(MP_ROM_INT(LV_FONT_FMT_TXT_CMAP_SPARSE_TINY)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_FONT_FMT_TXT_CMAP_locals_dict, LV_FONT_FMT_TXT_CMAP_locals_dict_table);

STATIC void LV_FONT_FMT_TXT_CMAP_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_FONT_FMT_TXT_CMAP");
}



STATIC const mp_obj_type_t mp_LV_FONT_FMT_TXT_CMAP_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_FONT_FMT_TXT_CMAP,
    .print = LV_FONT_FMT_TXT_CMAP_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_FONT_FMT_TXT_CMAP_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_ARC_MODE object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_ARC_MODE_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_NORMAL), MP_ROM_PTR(MP_ROM_INT(LV_ARC_MODE_NORMAL)) },
    { MP_ROM_QSTR(MP_QSTR_SYMMETRICAL), MP_ROM_PTR(MP_ROM_INT(LV_ARC_MODE_SYMMETRICAL)) },
    { MP_ROM_QSTR(MP_QSTR_REVERSE), MP_ROM_PTR(MP_ROM_INT(LV_ARC_MODE_REVERSE)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_ARC_MODE_locals_dict, LV_ARC_MODE_locals_dict_table);

STATIC void LV_ARC_MODE_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_ARC_MODE");
}



STATIC const mp_obj_type_t mp_LV_ARC_MODE_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_ARC_MODE,
    .print = LV_ARC_MODE_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_ARC_MODE_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_IMG_SIZE_MODE object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_IMG_SIZE_MODE_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_VIRTUAL), MP_ROM_PTR(MP_ROM_INT(LV_IMG_SIZE_MODE_VIRTUAL)) },
    { MP_ROM_QSTR(MP_QSTR_REAL), MP_ROM_PTR(MP_ROM_INT(LV_IMG_SIZE_MODE_REAL)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_IMG_SIZE_MODE_locals_dict, LV_IMG_SIZE_MODE_locals_dict_table);

STATIC void LV_IMG_SIZE_MODE_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_IMG_SIZE_MODE");
}



STATIC const mp_obj_type_t mp_LV_IMG_SIZE_MODE_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_IMG_SIZE_MODE,
    .print = LV_IMG_SIZE_MODE_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_IMG_SIZE_MODE_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_LABEL_LONG object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_LABEL_LONG_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_WRAP), MP_ROM_PTR(MP_ROM_INT(LV_LABEL_LONG_WRAP)) },
    { MP_ROM_QSTR(MP_QSTR_DOT), MP_ROM_PTR(MP_ROM_INT(LV_LABEL_LONG_DOT)) },
    { MP_ROM_QSTR(MP_QSTR_SCROLL), MP_ROM_PTR(MP_ROM_INT(LV_LABEL_LONG_SCROLL)) },
    { MP_ROM_QSTR(MP_QSTR_SCROLL_CIRCULAR), MP_ROM_PTR(MP_ROM_INT(LV_LABEL_LONG_SCROLL_CIRCULAR)) },
    { MP_ROM_QSTR(MP_QSTR_CLIP), MP_ROM_PTR(MP_ROM_INT(LV_LABEL_LONG_CLIP)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_LABEL_LONG_locals_dict, LV_LABEL_LONG_locals_dict_table);

STATIC void LV_LABEL_LONG_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_LABEL_LONG");
}



STATIC const mp_obj_type_t mp_LV_LABEL_LONG_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_LABEL_LONG,
    .print = LV_LABEL_LONG_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_LABEL_LONG_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_TABLE_CELL_CTRL object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_TABLE_CELL_CTRL_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_MERGE_RIGHT), MP_ROM_PTR(MP_ROM_INT(LV_TABLE_CELL_CTRL_MERGE_RIGHT)) },
    { MP_ROM_QSTR(MP_QSTR_TEXT_CROP), MP_ROM_PTR(MP_ROM_INT(LV_TABLE_CELL_CTRL_TEXT_CROP)) },
    { MP_ROM_QSTR(MP_QSTR_CUSTOM_1), MP_ROM_PTR(MP_ROM_INT(LV_TABLE_CELL_CTRL_CUSTOM_1)) },
    { MP_ROM_QSTR(MP_QSTR_CUSTOM_2), MP_ROM_PTR(MP_ROM_INT(LV_TABLE_CELL_CTRL_CUSTOM_2)) },
    { MP_ROM_QSTR(MP_QSTR_CUSTOM_3), MP_ROM_PTR(MP_ROM_INT(LV_TABLE_CELL_CTRL_CUSTOM_3)) },
    { MP_ROM_QSTR(MP_QSTR_CUSTOM_4), MP_ROM_PTR(MP_ROM_INT(LV_TABLE_CELL_CTRL_CUSTOM_4)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_TABLE_CELL_CTRL_locals_dict, LV_TABLE_CELL_CTRL_locals_dict_table);

STATIC void LV_TABLE_CELL_CTRL_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_TABLE_CELL_CTRL");
}



STATIC const mp_obj_type_t mp_LV_TABLE_CELL_CTRL_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_TABLE_CELL_CTRL,
    .print = LV_TABLE_CELL_CTRL_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_TABLE_CELL_CTRL_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_BAR_MODE object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_BAR_MODE_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_NORMAL), MP_ROM_PTR(MP_ROM_INT(LV_BAR_MODE_NORMAL)) },
    { MP_ROM_QSTR(MP_QSTR_SYMMETRICAL), MP_ROM_PTR(MP_ROM_INT(LV_BAR_MODE_SYMMETRICAL)) },
    { MP_ROM_QSTR(MP_QSTR_RANGE), MP_ROM_PTR(MP_ROM_INT(LV_BAR_MODE_RANGE)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_BAR_MODE_locals_dict, LV_BAR_MODE_locals_dict_table);

STATIC void LV_BAR_MODE_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_BAR_MODE");
}



STATIC const mp_obj_type_t mp_LV_BAR_MODE_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_BAR_MODE,
    .print = LV_BAR_MODE_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_BAR_MODE_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_SLIDER_MODE object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_SLIDER_MODE_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_NORMAL), MP_ROM_PTR(MP_ROM_INT(LV_SLIDER_MODE_NORMAL)) },
    { MP_ROM_QSTR(MP_QSTR_SYMMETRICAL), MP_ROM_PTR(MP_ROM_INT(LV_SLIDER_MODE_SYMMETRICAL)) },
    { MP_ROM_QSTR(MP_QSTR_RANGE), MP_ROM_PTR(MP_ROM_INT(LV_SLIDER_MODE_RANGE)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_SLIDER_MODE_locals_dict, LV_SLIDER_MODE_locals_dict_table);

STATIC void LV_SLIDER_MODE_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_SLIDER_MODE");
}



STATIC const mp_obj_type_t mp_LV_SLIDER_MODE_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_SLIDER_MODE,
    .print = LV_SLIDER_MODE_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_SLIDER_MODE_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_BTNMATRIX_CTRL object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_BTNMATRIX_CTRL_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_HIDDEN), MP_ROM_PTR(MP_ROM_INT(LV_BTNMATRIX_CTRL_HIDDEN)) },
    { MP_ROM_QSTR(MP_QSTR_NO_REPEAT), MP_ROM_PTR(MP_ROM_INT(LV_BTNMATRIX_CTRL_NO_REPEAT)) },
    { MP_ROM_QSTR(MP_QSTR_DISABLED), MP_ROM_PTR(MP_ROM_INT(LV_BTNMATRIX_CTRL_DISABLED)) },
    { MP_ROM_QSTR(MP_QSTR_CHECKABLE), MP_ROM_PTR(MP_ROM_INT(LV_BTNMATRIX_CTRL_CHECKABLE)) },
    { MP_ROM_QSTR(MP_QSTR_CHECKED), MP_ROM_PTR(MP_ROM_INT(LV_BTNMATRIX_CTRL_CHECKED)) },
    { MP_ROM_QSTR(MP_QSTR_CLICK_TRIG), MP_ROM_PTR(MP_ROM_INT(LV_BTNMATRIX_CTRL_CLICK_TRIG)) },
    { MP_ROM_QSTR(MP_QSTR_POPOVER), MP_ROM_PTR(MP_ROM_INT(LV_BTNMATRIX_CTRL_POPOVER)) },
    { MP_ROM_QSTR(MP_QSTR_RECOLOR), MP_ROM_PTR(MP_ROM_INT(LV_BTNMATRIX_CTRL_RECOLOR)) },
    { MP_ROM_QSTR(MP_QSTR_CUSTOM_1), MP_ROM_PTR(MP_ROM_INT(LV_BTNMATRIX_CTRL_CUSTOM_1)) },
    { MP_ROM_QSTR(MP_QSTR_CUSTOM_2), MP_ROM_PTR(MP_ROM_INT(LV_BTNMATRIX_CTRL_CUSTOM_2)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_BTNMATRIX_CTRL_locals_dict, LV_BTNMATRIX_CTRL_locals_dict_table);

STATIC void LV_BTNMATRIX_CTRL_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_BTNMATRIX_CTRL");
}



STATIC const mp_obj_type_t mp_LV_BTNMATRIX_CTRL_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_BTNMATRIX_CTRL,
    .print = LV_BTNMATRIX_CTRL_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_BTNMATRIX_CTRL_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_ROLLER_MODE object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_ROLLER_MODE_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_NORMAL), MP_ROM_PTR(MP_ROM_INT(LV_ROLLER_MODE_NORMAL)) },
    { MP_ROM_QSTR(MP_QSTR_INFINITE), MP_ROM_PTR(MP_ROM_INT(LV_ROLLER_MODE_INFINITE)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_ROLLER_MODE_locals_dict, LV_ROLLER_MODE_locals_dict_table);

STATIC void LV_ROLLER_MODE_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_ROLLER_MODE");
}



STATIC const mp_obj_type_t mp_LV_ROLLER_MODE_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_ROLLER_MODE,
    .print = LV_ROLLER_MODE_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_ROLLER_MODE_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_PART_TEXTAREA object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_PART_TEXTAREA_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_PLACEHOLDER), MP_ROM_PTR(MP_ROM_INT(LV_PART_TEXTAREA_PLACEHOLDER)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_PART_TEXTAREA_locals_dict, LV_PART_TEXTAREA_locals_dict_table);

STATIC void LV_PART_TEXTAREA_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_PART_TEXTAREA");
}



STATIC const mp_obj_type_t mp_LV_PART_TEXTAREA_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_PART_TEXTAREA,
    .print = LV_PART_TEXTAREA_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_PART_TEXTAREA_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_ANIM_IMG_PART object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_ANIM_IMG_PART_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_MAIN), MP_ROM_PTR(MP_ROM_INT(LV_ANIM_IMG_PART_MAIN)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_ANIM_IMG_PART_locals_dict, LV_ANIM_IMG_PART_locals_dict_table);

STATIC void LV_ANIM_IMG_PART_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_ANIM_IMG_PART");
}



STATIC const mp_obj_type_t mp_LV_ANIM_IMG_PART_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_ANIM_IMG_PART,
    .print = LV_ANIM_IMG_PART_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_ANIM_IMG_PART_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_CHART_TYPE object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_CHART_TYPE_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_NONE), MP_ROM_PTR(MP_ROM_INT(LV_CHART_TYPE_NONE)) },
    { MP_ROM_QSTR(MP_QSTR_LINE), MP_ROM_PTR(MP_ROM_INT(LV_CHART_TYPE_LINE)) },
    { MP_ROM_QSTR(MP_QSTR_BAR), MP_ROM_PTR(MP_ROM_INT(LV_CHART_TYPE_BAR)) },
    { MP_ROM_QSTR(MP_QSTR_SCATTER), MP_ROM_PTR(MP_ROM_INT(LV_CHART_TYPE_SCATTER)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_CHART_TYPE_locals_dict, LV_CHART_TYPE_locals_dict_table);

STATIC void LV_CHART_TYPE_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_CHART_TYPE");
}



STATIC const mp_obj_type_t mp_LV_CHART_TYPE_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_CHART_TYPE,
    .print = LV_CHART_TYPE_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_CHART_TYPE_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_CHART_UPDATE_MODE object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_CHART_UPDATE_MODE_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SHIFT), MP_ROM_PTR(MP_ROM_INT(LV_CHART_UPDATE_MODE_SHIFT)) },
    { MP_ROM_QSTR(MP_QSTR_CIRCULAR), MP_ROM_PTR(MP_ROM_INT(LV_CHART_UPDATE_MODE_CIRCULAR)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_CHART_UPDATE_MODE_locals_dict, LV_CHART_UPDATE_MODE_locals_dict_table);

STATIC void LV_CHART_UPDATE_MODE_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_CHART_UPDATE_MODE");
}



STATIC const mp_obj_type_t mp_LV_CHART_UPDATE_MODE_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_CHART_UPDATE_MODE,
    .print = LV_CHART_UPDATE_MODE_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_CHART_UPDATE_MODE_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_CHART_AXIS object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_CHART_AXIS_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_PRIMARY_Y), MP_ROM_PTR(MP_ROM_INT(LV_CHART_AXIS_PRIMARY_Y)) },
    { MP_ROM_QSTR(MP_QSTR_SECONDARY_Y), MP_ROM_PTR(MP_ROM_INT(LV_CHART_AXIS_SECONDARY_Y)) },
    { MP_ROM_QSTR(MP_QSTR_PRIMARY_X), MP_ROM_PTR(MP_ROM_INT(LV_CHART_AXIS_PRIMARY_X)) },
    { MP_ROM_QSTR(MP_QSTR_SECONDARY_X), MP_ROM_PTR(MP_ROM_INT(LV_CHART_AXIS_SECONDARY_X)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_CHART_AXIS_locals_dict, LV_CHART_AXIS_locals_dict_table);

STATIC void LV_CHART_AXIS_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_CHART_AXIS");
}



STATIC const mp_obj_type_t mp_LV_CHART_AXIS_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_CHART_AXIS,
    .print = LV_CHART_AXIS_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_CHART_AXIS_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_KEYBOARD_MODE object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_KEYBOARD_MODE_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_TEXT_LOWER), MP_ROM_PTR(MP_ROM_INT(LV_KEYBOARD_MODE_TEXT_LOWER)) },
    { MP_ROM_QSTR(MP_QSTR_TEXT_UPPER), MP_ROM_PTR(MP_ROM_INT(LV_KEYBOARD_MODE_TEXT_UPPER)) },
    { MP_ROM_QSTR(MP_QSTR_SPECIAL), MP_ROM_PTR(MP_ROM_INT(LV_KEYBOARD_MODE_SPECIAL)) },
    { MP_ROM_QSTR(MP_QSTR_NUMBER), MP_ROM_PTR(MP_ROM_INT(LV_KEYBOARD_MODE_NUMBER)) },
    { MP_ROM_QSTR(MP_QSTR_USER_1), MP_ROM_PTR(MP_ROM_INT(LV_KEYBOARD_MODE_USER_1)) },
    { MP_ROM_QSTR(MP_QSTR_USER_2), MP_ROM_PTR(MP_ROM_INT(LV_KEYBOARD_MODE_USER_2)) },
    { MP_ROM_QSTR(MP_QSTR_USER_3), MP_ROM_PTR(MP_ROM_INT(LV_KEYBOARD_MODE_USER_3)) },
    { MP_ROM_QSTR(MP_QSTR_USER_4), MP_ROM_PTR(MP_ROM_INT(LV_KEYBOARD_MODE_USER_4)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_KEYBOARD_MODE_locals_dict, LV_KEYBOARD_MODE_locals_dict_table);

STATIC void LV_KEYBOARD_MODE_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_KEYBOARD_MODE");
}



STATIC const mp_obj_type_t mp_LV_KEYBOARD_MODE_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_KEYBOARD_MODE,
    .print = LV_KEYBOARD_MODE_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_KEYBOARD_MODE_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_MENU_HEADER object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_MENU_HEADER_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_TOP_FIXED), MP_ROM_PTR(MP_ROM_INT(LV_MENU_HEADER_TOP_FIXED)) },
    { MP_ROM_QSTR(MP_QSTR_TOP_UNFIXED), MP_ROM_PTR(MP_ROM_INT(LV_MENU_HEADER_TOP_UNFIXED)) },
    { MP_ROM_QSTR(MP_QSTR_BOTTOM_FIXED), MP_ROM_PTR(MP_ROM_INT(LV_MENU_HEADER_BOTTOM_FIXED)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_MENU_HEADER_locals_dict, LV_MENU_HEADER_locals_dict_table);

STATIC void LV_MENU_HEADER_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_MENU_HEADER");
}



STATIC const mp_obj_type_t mp_LV_MENU_HEADER_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_MENU_HEADER,
    .print = LV_MENU_HEADER_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_MENU_HEADER_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_MENU_ROOT_BACK_BTN object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_MENU_ROOT_BACK_BTN_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_DISABLED), MP_ROM_PTR(MP_ROM_INT(LV_MENU_ROOT_BACK_BTN_DISABLED)) },
    { MP_ROM_QSTR(MP_QSTR_ENABLED), MP_ROM_PTR(MP_ROM_INT(LV_MENU_ROOT_BACK_BTN_ENABLED)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_MENU_ROOT_BACK_BTN_locals_dict, LV_MENU_ROOT_BACK_BTN_locals_dict_table);

STATIC void LV_MENU_ROOT_BACK_BTN_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_MENU_ROOT_BACK_BTN");
}



STATIC const mp_obj_type_t mp_LV_MENU_ROOT_BACK_BTN_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_MENU_ROOT_BACK_BTN,
    .print = LV_MENU_ROOT_BACK_BTN_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_MENU_ROOT_BACK_BTN_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_METER_INDICATOR_TYPE object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_METER_INDICATOR_TYPE_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_NEEDLE_IMG), MP_ROM_PTR(MP_ROM_INT(LV_METER_INDICATOR_TYPE_NEEDLE_IMG)) },
    { MP_ROM_QSTR(MP_QSTR_NEEDLE_LINE), MP_ROM_PTR(MP_ROM_INT(LV_METER_INDICATOR_TYPE_NEEDLE_LINE)) },
    { MP_ROM_QSTR(MP_QSTR_SCALE_LINES), MP_ROM_PTR(MP_ROM_INT(LV_METER_INDICATOR_TYPE_SCALE_LINES)) },
    { MP_ROM_QSTR(MP_QSTR_ARC), MP_ROM_PTR(MP_ROM_INT(LV_METER_INDICATOR_TYPE_ARC)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_METER_INDICATOR_TYPE_locals_dict, LV_METER_INDICATOR_TYPE_locals_dict_table);

STATIC void LV_METER_INDICATOR_TYPE_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_METER_INDICATOR_TYPE");
}



STATIC const mp_obj_type_t mp_LV_METER_INDICATOR_TYPE_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_METER_INDICATOR_TYPE,
    .print = LV_METER_INDICATOR_TYPE_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_METER_INDICATOR_TYPE_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_COLORWHEEL_MODE object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_COLORWHEEL_MODE_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_HUE), MP_ROM_PTR(MP_ROM_INT(LV_COLORWHEEL_MODE_HUE)) },
    { MP_ROM_QSTR(MP_QSTR_SATURATION), MP_ROM_PTR(MP_ROM_INT(LV_COLORWHEEL_MODE_SATURATION)) },
    { MP_ROM_QSTR(MP_QSTR_VALUE), MP_ROM_PTR(MP_ROM_INT(LV_COLORWHEEL_MODE_VALUE)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_COLORWHEEL_MODE_locals_dict, LV_COLORWHEEL_MODE_locals_dict_table);

STATIC void LV_COLORWHEEL_MODE_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_COLORWHEEL_MODE");
}



STATIC const mp_obj_type_t mp_LV_COLORWHEEL_MODE_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_COLORWHEEL_MODE,
    .print = LV_COLORWHEEL_MODE_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_COLORWHEEL_MODE_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_SPAN_OVERFLOW object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_SPAN_OVERFLOW_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_CLIP), MP_ROM_PTR(MP_ROM_INT(LV_SPAN_OVERFLOW_CLIP)) },
    { MP_ROM_QSTR(MP_QSTR_ELLIPSIS), MP_ROM_PTR(MP_ROM_INT(LV_SPAN_OVERFLOW_ELLIPSIS)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_SPAN_OVERFLOW_locals_dict, LV_SPAN_OVERFLOW_locals_dict_table);

STATIC void LV_SPAN_OVERFLOW_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_SPAN_OVERFLOW");
}



STATIC const mp_obj_type_t mp_LV_SPAN_OVERFLOW_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_SPAN_OVERFLOW,
    .print = LV_SPAN_OVERFLOW_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_SPAN_OVERFLOW_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_SPAN_MODE object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_SPAN_MODE_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_FIXED), MP_ROM_PTR(MP_ROM_INT(LV_SPAN_MODE_FIXED)) },
    { MP_ROM_QSTR(MP_QSTR_EXPAND), MP_ROM_PTR(MP_ROM_INT(LV_SPAN_MODE_EXPAND)) },
    { MP_ROM_QSTR(MP_QSTR_BREAK), MP_ROM_PTR(MP_ROM_INT(LV_SPAN_MODE_BREAK)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_SPAN_MODE_locals_dict, LV_SPAN_MODE_locals_dict_table);

STATIC void LV_SPAN_MODE_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_SPAN_MODE");
}



STATIC const mp_obj_type_t mp_LV_SPAN_MODE_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_SPAN_MODE,
    .print = LV_SPAN_MODE_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_SPAN_MODE_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LVSF_HEADER object definitions
 */
    

STATIC const mp_rom_map_elem_t LVSF_HEADER_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_BACK_BTN), MP_ROM_PTR(MP_ROM_INT(LVSF_HEADER_BACK_BTN)) },
    { MP_ROM_QSTR(MP_QSTR_TITLE), MP_ROM_PTR(MP_ROM_INT(LVSF_HEADER_TITLE)) },
    { MP_ROM_QSTR(MP_QSTR_ICONS), MP_ROM_PTR(MP_ROM_INT(LVSF_HEADER_ICONS)) },
    { MP_ROM_QSTR(MP_QSTR_TIME), MP_ROM_PTR(MP_ROM_INT(LVSF_HEADER_TIME)) },
    { MP_ROM_QSTR(MP_QSTR_ROOT), MP_ROM_PTR(MP_ROM_INT(LVSF_HEADER_ROOT)) },
    { MP_ROM_QSTR(MP_QSTR_BRANCH), MP_ROM_PTR(MP_ROM_INT(LVSF_HEADER_BRANCH)) },
    { MP_ROM_QSTR(MP_QSTR_DEFAULT), MP_ROM_PTR(MP_ROM_INT(LVSF_HEADER_DEFAULT)) }
};

STATIC MP_DEFINE_CONST_DICT(LVSF_HEADER_locals_dict, LVSF_HEADER_locals_dict_table);

STATIC void LVSF_HEADER_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LVSF_HEADER");
}



STATIC const mp_obj_type_t mp_LVSF_HEADER_type = {
    { &mp_type_type },
    .name = MP_QSTR_LVSF_HEADER,
    .print = LVSF_HEADER_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LVSF_HEADER_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_ANIM object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_ANIM_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_OFF), MP_ROM_PTR(MP_ROM_INT(LV_ANIM_OFF)) },
    { MP_ROM_QSTR(MP_QSTR_ON), MP_ROM_PTR(MP_ROM_INT(LV_ANIM_ON)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_ANIM_locals_dict, LV_ANIM_locals_dict_table);

STATIC void LV_ANIM_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_ANIM");
}



STATIC const mp_obj_type_t mp_LV_ANIM_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_ANIM,
    .print = LV_ANIM_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_ANIM_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_PALETTE object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_PALETTE_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_RED), MP_ROM_PTR(MP_ROM_INT(LV_PALETTE_RED)) },
    { MP_ROM_QSTR(MP_QSTR_PINK), MP_ROM_PTR(MP_ROM_INT(LV_PALETTE_PINK)) },
    { MP_ROM_QSTR(MP_QSTR_PURPLE), MP_ROM_PTR(MP_ROM_INT(LV_PALETTE_PURPLE)) },
    { MP_ROM_QSTR(MP_QSTR_DEEP_PURPLE), MP_ROM_PTR(MP_ROM_INT(LV_PALETTE_DEEP_PURPLE)) },
    { MP_ROM_QSTR(MP_QSTR_INDIGO), MP_ROM_PTR(MP_ROM_INT(LV_PALETTE_INDIGO)) },
    { MP_ROM_QSTR(MP_QSTR_BLUE), MP_ROM_PTR(MP_ROM_INT(LV_PALETTE_BLUE)) },
    { MP_ROM_QSTR(MP_QSTR_LIGHT_BLUE), MP_ROM_PTR(MP_ROM_INT(LV_PALETTE_LIGHT_BLUE)) },
    { MP_ROM_QSTR(MP_QSTR_CYAN), MP_ROM_PTR(MP_ROM_INT(LV_PALETTE_CYAN)) },
    { MP_ROM_QSTR(MP_QSTR_TEAL), MP_ROM_PTR(MP_ROM_INT(LV_PALETTE_TEAL)) },
    { MP_ROM_QSTR(MP_QSTR_GREEN), MP_ROM_PTR(MP_ROM_INT(LV_PALETTE_GREEN)) },
    { MP_ROM_QSTR(MP_QSTR_LIGHT_GREEN), MP_ROM_PTR(MP_ROM_INT(LV_PALETTE_LIGHT_GREEN)) },
    { MP_ROM_QSTR(MP_QSTR_LIME), MP_ROM_PTR(MP_ROM_INT(LV_PALETTE_LIME)) },
    { MP_ROM_QSTR(MP_QSTR_YELLOW), MP_ROM_PTR(MP_ROM_INT(LV_PALETTE_YELLOW)) },
    { MP_ROM_QSTR(MP_QSTR_AMBER), MP_ROM_PTR(MP_ROM_INT(LV_PALETTE_AMBER)) },
    { MP_ROM_QSTR(MP_QSTR_ORANGE), MP_ROM_PTR(MP_ROM_INT(LV_PALETTE_ORANGE)) },
    { MP_ROM_QSTR(MP_QSTR_DEEP_ORANGE), MP_ROM_PTR(MP_ROM_INT(LV_PALETTE_DEEP_ORANGE)) },
    { MP_ROM_QSTR(MP_QSTR_BROWN), MP_ROM_PTR(MP_ROM_INT(LV_PALETTE_BROWN)) },
    { MP_ROM_QSTR(MP_QSTR_BLUE_GREY), MP_ROM_PTR(MP_ROM_INT(LV_PALETTE_BLUE_GREY)) },
    { MP_ROM_QSTR(MP_QSTR_GREY), MP_ROM_PTR(MP_ROM_INT(LV_PALETTE_GREY)) },
    { MP_ROM_QSTR(MP_QSTR_NONE), MP_ROM_PTR(MP_ROM_INT(LV_PALETTE_NONE)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_PALETTE_locals_dict, LV_PALETTE_locals_dict_table);

STATIC void LV_PALETTE_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_PALETTE");
}



STATIC const mp_obj_type_t mp_LV_PALETTE_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_PALETTE,
    .print = LV_PALETTE_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_PALETTE_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_STYLE object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_STYLE_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_PROP_INV), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_PROP_INV)) },
    { MP_ROM_QSTR(MP_QSTR_WIDTH), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_WIDTH)) },
    { MP_ROM_QSTR(MP_QSTR_MIN_WIDTH), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_MIN_WIDTH)) },
    { MP_ROM_QSTR(MP_QSTR_MAX_WIDTH), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_MAX_WIDTH)) },
    { MP_ROM_QSTR(MP_QSTR_HEIGHT), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_HEIGHT)) },
    { MP_ROM_QSTR(MP_QSTR_MIN_HEIGHT), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_MIN_HEIGHT)) },
    { MP_ROM_QSTR(MP_QSTR_MAX_HEIGHT), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_MAX_HEIGHT)) },
    { MP_ROM_QSTR(MP_QSTR_X), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_X)) },
    { MP_ROM_QSTR(MP_QSTR_Y), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_Y)) },
    { MP_ROM_QSTR(MP_QSTR_ALIGN), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_ALIGN)) },
    { MP_ROM_QSTR(MP_QSTR_LAYOUT), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_LAYOUT)) },
    { MP_ROM_QSTR(MP_QSTR_RADIUS), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_RADIUS)) },
    { MP_ROM_QSTR(MP_QSTR_PAD_TOP), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_PAD_TOP)) },
    { MP_ROM_QSTR(MP_QSTR_PAD_BOTTOM), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_PAD_BOTTOM)) },
    { MP_ROM_QSTR(MP_QSTR_PAD_LEFT), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_PAD_LEFT)) },
    { MP_ROM_QSTR(MP_QSTR_PAD_RIGHT), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_PAD_RIGHT)) },
    { MP_ROM_QSTR(MP_QSTR_PAD_ROW), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_PAD_ROW)) },
    { MP_ROM_QSTR(MP_QSTR_PAD_COLUMN), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_PAD_COLUMN)) },
    { MP_ROM_QSTR(MP_QSTR_BASE_DIR), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_BASE_DIR)) },
    { MP_ROM_QSTR(MP_QSTR_CLIP_CORNER), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_CLIP_CORNER)) },
    { MP_ROM_QSTR(MP_QSTR_BG_COLOR), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_BG_COLOR)) },
    { MP_ROM_QSTR(MP_QSTR_BG_OPA), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_BG_OPA)) },
    { MP_ROM_QSTR(MP_QSTR_BG_GRAD_COLOR), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_BG_GRAD_COLOR)) },
    { MP_ROM_QSTR(MP_QSTR_BG_GRAD_DIR), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_BG_GRAD_DIR)) },
    { MP_ROM_QSTR(MP_QSTR_BG_MAIN_STOP), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_BG_MAIN_STOP)) },
    { MP_ROM_QSTR(MP_QSTR_BG_GRAD_STOP), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_BG_GRAD_STOP)) },
    { MP_ROM_QSTR(MP_QSTR_BG_GRAD), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_BG_GRAD)) },
    { MP_ROM_QSTR(MP_QSTR_BG_DITHER_MODE), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_BG_DITHER_MODE)) },
    { MP_ROM_QSTR(MP_QSTR_BG_IMG_SRC), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_BG_IMG_SRC)) },
    { MP_ROM_QSTR(MP_QSTR_BG_IMG_OPA), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_BG_IMG_OPA)) },
    { MP_ROM_QSTR(MP_QSTR_BG_IMG_RECOLOR), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_BG_IMG_RECOLOR)) },
    { MP_ROM_QSTR(MP_QSTR_BG_IMG_RECOLOR_OPA), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_BG_IMG_RECOLOR_OPA)) },
    { MP_ROM_QSTR(MP_QSTR_BG_IMG_TILED), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_BG_IMG_TILED)) },
    { MP_ROM_QSTR(MP_QSTR_BORDER_COLOR), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_BORDER_COLOR)) },
    { MP_ROM_QSTR(MP_QSTR_BORDER_OPA), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_BORDER_OPA)) },
    { MP_ROM_QSTR(MP_QSTR_BORDER_WIDTH), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_BORDER_WIDTH)) },
    { MP_ROM_QSTR(MP_QSTR_BORDER_SIDE), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_BORDER_SIDE)) },
    { MP_ROM_QSTR(MP_QSTR_BORDER_POST), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_BORDER_POST)) },
    { MP_ROM_QSTR(MP_QSTR_OUTLINE_WIDTH), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_OUTLINE_WIDTH)) },
    { MP_ROM_QSTR(MP_QSTR_OUTLINE_COLOR), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_OUTLINE_COLOR)) },
    { MP_ROM_QSTR(MP_QSTR_OUTLINE_OPA), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_OUTLINE_OPA)) },
    { MP_ROM_QSTR(MP_QSTR_OUTLINE_PAD), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_OUTLINE_PAD)) },
    { MP_ROM_QSTR(MP_QSTR_SHADOW_WIDTH), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_SHADOW_WIDTH)) },
    { MP_ROM_QSTR(MP_QSTR_SHADOW_OFS_X), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_SHADOW_OFS_X)) },
    { MP_ROM_QSTR(MP_QSTR_SHADOW_OFS_Y), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_SHADOW_OFS_Y)) },
    { MP_ROM_QSTR(MP_QSTR_SHADOW_SPREAD), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_SHADOW_SPREAD)) },
    { MP_ROM_QSTR(MP_QSTR_SHADOW_COLOR), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_SHADOW_COLOR)) },
    { MP_ROM_QSTR(MP_QSTR_SHADOW_OPA), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_SHADOW_OPA)) },
    { MP_ROM_QSTR(MP_QSTR_IMG_OPA), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_IMG_OPA)) },
    { MP_ROM_QSTR(MP_QSTR_IMG_RECOLOR), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_IMG_RECOLOR)) },
    { MP_ROM_QSTR(MP_QSTR_IMG_RECOLOR_OPA), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_IMG_RECOLOR_OPA)) },
    { MP_ROM_QSTR(MP_QSTR_LINE_WIDTH), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_LINE_WIDTH)) },
    { MP_ROM_QSTR(MP_QSTR_LINE_DASH_WIDTH), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_LINE_DASH_WIDTH)) },
    { MP_ROM_QSTR(MP_QSTR_LINE_DASH_GAP), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_LINE_DASH_GAP)) },
    { MP_ROM_QSTR(MP_QSTR_LINE_ROUNDED), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_LINE_ROUNDED)) },
    { MP_ROM_QSTR(MP_QSTR_LINE_COLOR), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_LINE_COLOR)) },
    { MP_ROM_QSTR(MP_QSTR_LINE_OPA), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_LINE_OPA)) },
    { MP_ROM_QSTR(MP_QSTR_ARC_WIDTH), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_ARC_WIDTH)) },
    { MP_ROM_QSTR(MP_QSTR_ARC_ROUNDED), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_ARC_ROUNDED)) },
    { MP_ROM_QSTR(MP_QSTR_ARC_COLOR), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_ARC_COLOR)) },
    { MP_ROM_QSTR(MP_QSTR_ARC_OPA), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_ARC_OPA)) },
    { MP_ROM_QSTR(MP_QSTR_ARC_IMG_SRC), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_ARC_IMG_SRC)) },
    { MP_ROM_QSTR(MP_QSTR_TEXT_COLOR), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_TEXT_COLOR)) },
    { MP_ROM_QSTR(MP_QSTR_TEXT_OPA), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_TEXT_OPA)) },
    { MP_ROM_QSTR(MP_QSTR_TEXT_FONT), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_TEXT_FONT)) },
    { MP_ROM_QSTR(MP_QSTR_TEXT_LETTER_SPACE), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_TEXT_LETTER_SPACE)) },
    { MP_ROM_QSTR(MP_QSTR_TEXT_LINE_SPACE), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_TEXT_LINE_SPACE)) },
    { MP_ROM_QSTR(MP_QSTR_TEXT_DECOR), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_TEXT_DECOR)) },
    { MP_ROM_QSTR(MP_QSTR_TEXT_ALIGN), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_TEXT_ALIGN)) },
    { MP_ROM_QSTR(MP_QSTR_OPA), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_OPA)) },
    { MP_ROM_QSTR(MP_QSTR_COLOR_FILTER_DSC), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_COLOR_FILTER_DSC)) },
    { MP_ROM_QSTR(MP_QSTR_COLOR_FILTER_OPA), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_COLOR_FILTER_OPA)) },
    { MP_ROM_QSTR(MP_QSTR_ANIM), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_ANIM)) },
    { MP_ROM_QSTR(MP_QSTR_ANIM_TIME), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_ANIM_TIME)) },
    { MP_ROM_QSTR(MP_QSTR_ANIM_SPEED), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_ANIM_SPEED)) },
    { MP_ROM_QSTR(MP_QSTR_TRANSITION), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_TRANSITION)) },
    { MP_ROM_QSTR(MP_QSTR_BLEND_MODE), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_BLEND_MODE)) },
    { MP_ROM_QSTR(MP_QSTR_TRANSFORM_WIDTH), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_TRANSFORM_WIDTH)) },
    { MP_ROM_QSTR(MP_QSTR_TRANSFORM_HEIGHT), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_TRANSFORM_HEIGHT)) },
    { MP_ROM_QSTR(MP_QSTR_TRANSLATE_X), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_TRANSLATE_X)) },
    { MP_ROM_QSTR(MP_QSTR_TRANSLATE_Y), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_TRANSLATE_Y)) },
    { MP_ROM_QSTR(MP_QSTR_TRANSFORM_ZOOM), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_TRANSFORM_ZOOM)) },
    { MP_ROM_QSTR(MP_QSTR_TRANSFORM_ANGLE), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_TRANSFORM_ANGLE)) },
    { MP_ROM_QSTR(MP_QSTR_TRANSFORM_PIVOT_X), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_TRANSFORM_PIVOT_X)) },
    { MP_ROM_QSTR(MP_QSTR_TRANSFORM_PIVOT_Y), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_TRANSFORM_PIVOT_Y)) },
    { MP_ROM_QSTR(MP_QSTR_PROP_ANY), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_PROP_ANY)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_STYLE_locals_dict, LV_STYLE_locals_dict_table);

STATIC void LV_STYLE_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_STYLE");
}



STATIC const mp_obj_type_t mp_LV_STYLE_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_STYLE,
    .print = LV_STYLE_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_STYLE_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_FS_SEEK object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_FS_SEEK_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SET), MP_ROM_PTR(MP_ROM_INT(LV_FS_SEEK_SET)) },
    { MP_ROM_QSTR(MP_QSTR_CUR), MP_ROM_PTR(MP_ROM_INT(LV_FS_SEEK_CUR)) },
    { MP_ROM_QSTR(MP_QSTR_END), MP_ROM_PTR(MP_ROM_INT(LV_FS_SEEK_END)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_FS_SEEK_locals_dict, LV_FS_SEEK_locals_dict_table);

STATIC void LV_FS_SEEK_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_FS_SEEK");
}



STATIC const mp_obj_type_t mp_LV_FS_SEEK_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_FS_SEEK,
    .print = LV_FS_SEEK_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_FS_SEEK_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_DRAW_LAYER_FLAG object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_DRAW_LAYER_FLAG_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_NONE), MP_ROM_PTR(MP_ROM_INT(LV_DRAW_LAYER_FLAG_NONE)) },
    { MP_ROM_QSTR(MP_QSTR_HAS_ALPHA), MP_ROM_PTR(MP_ROM_INT(LV_DRAW_LAYER_FLAG_HAS_ALPHA)) },
    { MP_ROM_QSTR(MP_QSTR_CAN_SUBDIVIDE), MP_ROM_PTR(MP_ROM_INT(LV_DRAW_LAYER_FLAG_CAN_SUBDIVIDE)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_DRAW_LAYER_FLAG_locals_dict, LV_DRAW_LAYER_FLAG_locals_dict_table);

STATIC void LV_DRAW_LAYER_FLAG_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_DRAW_LAYER_FLAG");
}



STATIC const mp_obj_type_t mp_LV_DRAW_LAYER_FLAG_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_DRAW_LAYER_FLAG,
    .print = LV_DRAW_LAYER_FLAG_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_DRAW_LAYER_FLAG_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_DISP_ROT object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_DISP_ROT_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_NONE), MP_ROM_PTR(MP_ROM_INT(LV_DISP_ROT_NONE)) },
    { MP_ROM_QSTR(MP_QSTR__90), MP_ROM_PTR(MP_ROM_INT(LV_DISP_ROT_90)) },
    { MP_ROM_QSTR(MP_QSTR__180), MP_ROM_PTR(MP_ROM_INT(LV_DISP_ROT_180)) },
    { MP_ROM_QSTR(MP_QSTR__270), MP_ROM_PTR(MP_ROM_INT(LV_DISP_ROT_270)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_DISP_ROT_locals_dict, LV_DISP_ROT_locals_dict_table);

STATIC void LV_DISP_ROT_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_DISP_ROT");
}



STATIC const mp_obj_type_t mp_LV_DISP_ROT_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_DISP_ROT,
    .print = LV_DISP_ROT_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_DISP_ROT_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_INDEV_TYPE object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_INDEV_TYPE_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_NONE), MP_ROM_PTR(MP_ROM_INT(LV_INDEV_TYPE_NONE)) },
    { MP_ROM_QSTR(MP_QSTR_POINTER), MP_ROM_PTR(MP_ROM_INT(LV_INDEV_TYPE_POINTER)) },
    { MP_ROM_QSTR(MP_QSTR_KEYPAD), MP_ROM_PTR(MP_ROM_INT(LV_INDEV_TYPE_KEYPAD)) },
    { MP_ROM_QSTR(MP_QSTR_BUTTON), MP_ROM_PTR(MP_ROM_INT(LV_INDEV_TYPE_BUTTON)) },
    { MP_ROM_QSTR(MP_QSTR_ENCODER), MP_ROM_PTR(MP_ROM_INT(LV_INDEV_TYPE_ENCODER)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_INDEV_TYPE_locals_dict, LV_INDEV_TYPE_locals_dict_table);

STATIC void LV_INDEV_TYPE_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_INDEV_TYPE");
}



STATIC const mp_obj_type_t mp_LV_INDEV_TYPE_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_INDEV_TYPE,
    .print = LV_INDEV_TYPE_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_INDEV_TYPE_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_INDEV_STATE object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_INDEV_STATE_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_RELEASED), MP_ROM_PTR(MP_ROM_INT(LV_INDEV_STATE_RELEASED)) },
    { MP_ROM_QSTR(MP_QSTR_PRESSED), MP_ROM_PTR(MP_ROM_INT(LV_INDEV_STATE_PRESSED)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_INDEV_STATE_locals_dict, LV_INDEV_STATE_locals_dict_table);

STATIC void LV_INDEV_STATE_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_INDEV_STATE");
}



STATIC const mp_obj_type_t mp_LV_INDEV_STATE_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_INDEV_STATE,
    .print = LV_INDEV_STATE_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_INDEV_STATE_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_OBJ_DRAW_PART object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_OBJ_DRAW_PART_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_RECTANGLE), MP_ROM_PTR(MP_ROM_INT(LV_OBJ_DRAW_PART_RECTANGLE)) },
    { MP_ROM_QSTR(MP_QSTR_BORDER_POST), MP_ROM_PTR(MP_ROM_INT(LV_OBJ_DRAW_PART_BORDER_POST)) },
    { MP_ROM_QSTR(MP_QSTR_SCROLLBAR), MP_ROM_PTR(MP_ROM_INT(LV_OBJ_DRAW_PART_SCROLLBAR)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_OBJ_DRAW_PART_locals_dict, LV_OBJ_DRAW_PART_locals_dict_table);

STATIC void LV_OBJ_DRAW_PART_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_OBJ_DRAW_PART");
}



STATIC const mp_obj_type_t mp_LV_OBJ_DRAW_PART_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_OBJ_DRAW_PART,
    .print = LV_OBJ_DRAW_PART_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_OBJ_DRAW_PART_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_OBJ_TREE_WALK object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_OBJ_TREE_WALK_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_NEXT), MP_ROM_PTR(MP_ROM_INT(LV_OBJ_TREE_WALK_NEXT)) },
    { MP_ROM_QSTR(MP_QSTR_SKIP_CHILDREN), MP_ROM_PTR(MP_ROM_INT(LV_OBJ_TREE_WALK_SKIP_CHILDREN)) },
    { MP_ROM_QSTR(MP_QSTR_END), MP_ROM_PTR(MP_ROM_INT(LV_OBJ_TREE_WALK_END)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_OBJ_TREE_WALK_locals_dict, LV_OBJ_TREE_WALK_locals_dict_table);

STATIC void LV_OBJ_TREE_WALK_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_OBJ_TREE_WALK");
}



STATIC const mp_obj_type_t mp_LV_OBJ_TREE_WALK_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_OBJ_TREE_WALK,
    .print = LV_OBJ_TREE_WALK_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_OBJ_TREE_WALK_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_COVER_RES object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_COVER_RES_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_COVER), MP_ROM_PTR(MP_ROM_INT(LV_COVER_RES_COVER)) },
    { MP_ROM_QSTR(MP_QSTR_NOT_COVER), MP_ROM_PTR(MP_ROM_INT(LV_COVER_RES_NOT_COVER)) },
    { MP_ROM_QSTR(MP_QSTR_MASKED), MP_ROM_PTR(MP_ROM_INT(LV_COVER_RES_MASKED)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_COVER_RES_locals_dict, LV_COVER_RES_locals_dict_table);

STATIC void LV_COVER_RES_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_COVER_RES");
}



STATIC const mp_obj_type_t mp_LV_COVER_RES_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_COVER_RES,
    .print = LV_COVER_RES_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_COVER_RES_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_LAYER_TYPE object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_LAYER_TYPE_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_NONE), MP_ROM_PTR(MP_ROM_INT(LV_LAYER_TYPE_NONE)) },
    { MP_ROM_QSTR(MP_QSTR_SIMPLE), MP_ROM_PTR(MP_ROM_INT(LV_LAYER_TYPE_SIMPLE)) },
    { MP_ROM_QSTR(MP_QSTR_TRANSFORM), MP_ROM_PTR(MP_ROM_INT(LV_LAYER_TYPE_TRANSFORM)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_LAYER_TYPE_locals_dict, LV_LAYER_TYPE_locals_dict_table);

STATIC void LV_LAYER_TYPE_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_LAYER_TYPE");
}



STATIC const mp_obj_type_t mp_LV_LAYER_TYPE_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_LAYER_TYPE,
    .print = LV_LAYER_TYPE_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_LAYER_TYPE_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_OBJ_CLASS_EDITABLE object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_OBJ_CLASS_EDITABLE_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_INHERIT), MP_ROM_PTR(MP_ROM_INT(LV_OBJ_CLASS_EDITABLE_INHERIT)) },
    { MP_ROM_QSTR(MP_QSTR_TRUE), MP_ROM_PTR(MP_ROM_INT(LV_OBJ_CLASS_EDITABLE_TRUE)) },
    { MP_ROM_QSTR(MP_QSTR_FALSE), MP_ROM_PTR(MP_ROM_INT(LV_OBJ_CLASS_EDITABLE_FALSE)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_OBJ_CLASS_EDITABLE_locals_dict, LV_OBJ_CLASS_EDITABLE_locals_dict_table);

STATIC void LV_OBJ_CLASS_EDITABLE_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_OBJ_CLASS_EDITABLE");
}



STATIC const mp_obj_type_t mp_LV_OBJ_CLASS_EDITABLE_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_OBJ_CLASS_EDITABLE,
    .print = LV_OBJ_CLASS_EDITABLE_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_OBJ_CLASS_EDITABLE_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_OBJ_CLASS_GROUP_DEF object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_OBJ_CLASS_GROUP_DEF_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_INHERIT), MP_ROM_PTR(MP_ROM_INT(LV_OBJ_CLASS_GROUP_DEF_INHERIT)) },
    { MP_ROM_QSTR(MP_QSTR_TRUE), MP_ROM_PTR(MP_ROM_INT(LV_OBJ_CLASS_GROUP_DEF_TRUE)) },
    { MP_ROM_QSTR(MP_QSTR_FALSE), MP_ROM_PTR(MP_ROM_INT(LV_OBJ_CLASS_GROUP_DEF_FALSE)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_OBJ_CLASS_GROUP_DEF_locals_dict, LV_OBJ_CLASS_GROUP_DEF_locals_dict_table);

STATIC void LV_OBJ_CLASS_GROUP_DEF_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_OBJ_CLASS_GROUP_DEF");
}



STATIC const mp_obj_type_t mp_LV_OBJ_CLASS_GROUP_DEF_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_OBJ_CLASS_GROUP_DEF,
    .print = LV_OBJ_CLASS_GROUP_DEF_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_OBJ_CLASS_GROUP_DEF_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_EVENT object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_EVENT_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_ALL), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_ALL)) },
    { MP_ROM_QSTR(MP_QSTR_PRESSED), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_PRESSED)) },
    { MP_ROM_QSTR(MP_QSTR_PRESSING), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_PRESSING)) },
    { MP_ROM_QSTR(MP_QSTR_PRESS_LOST), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_PRESS_LOST)) },
    { MP_ROM_QSTR(MP_QSTR_SHORT_CLICKED), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_SHORT_CLICKED)) },
    { MP_ROM_QSTR(MP_QSTR_LONG_PRESSED), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_LONG_PRESSED)) },
    { MP_ROM_QSTR(MP_QSTR_LONG_PRESSED_REPEAT), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_LONG_PRESSED_REPEAT)) },
    { MP_ROM_QSTR(MP_QSTR_CLICKED), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_CLICKED)) },
    { MP_ROM_QSTR(MP_QSTR_RELEASED), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_RELEASED)) },
    { MP_ROM_QSTR(MP_QSTR_SCROLL_BEGIN), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_SCROLL_BEGIN)) },
    { MP_ROM_QSTR(MP_QSTR_SCROLL_END), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_SCROLL_END)) },
    { MP_ROM_QSTR(MP_QSTR_SCROLL), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_SCROLL)) },
    { MP_ROM_QSTR(MP_QSTR_GESTURE), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_GESTURE)) },
    { MP_ROM_QSTR(MP_QSTR_KEY), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_KEY)) },
    { MP_ROM_QSTR(MP_QSTR_FOCUSED), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_FOCUSED)) },
    { MP_ROM_QSTR(MP_QSTR_DEFOCUSED), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_DEFOCUSED)) },
    { MP_ROM_QSTR(MP_QSTR_LEAVE), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_LEAVE)) },
    { MP_ROM_QSTR(MP_QSTR_HIT_TEST), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_HIT_TEST)) },
    { MP_ROM_QSTR(MP_QSTR_COVER_CHECK), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_COVER_CHECK)) },
    { MP_ROM_QSTR(MP_QSTR_REFR_EXT_DRAW_SIZE), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_REFR_EXT_DRAW_SIZE)) },
    { MP_ROM_QSTR(MP_QSTR_DRAW_MAIN_BEGIN), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_DRAW_MAIN_BEGIN)) },
    { MP_ROM_QSTR(MP_QSTR_DRAW_MAIN), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_DRAW_MAIN)) },
    { MP_ROM_QSTR(MP_QSTR_DRAW_MAIN_END), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_DRAW_MAIN_END)) },
    { MP_ROM_QSTR(MP_QSTR_DRAW_POST_BEGIN), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_DRAW_POST_BEGIN)) },
    { MP_ROM_QSTR(MP_QSTR_DRAW_POST), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_DRAW_POST)) },
    { MP_ROM_QSTR(MP_QSTR_DRAW_POST_END), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_DRAW_POST_END)) },
    { MP_ROM_QSTR(MP_QSTR_DRAW_PART_BEGIN), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_DRAW_PART_BEGIN)) },
    { MP_ROM_QSTR(MP_QSTR_DRAW_PART_END), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_DRAW_PART_END)) },
    { MP_ROM_QSTR(MP_QSTR_VALUE_CHANGED), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_VALUE_CHANGED)) },
    { MP_ROM_QSTR(MP_QSTR_INSERT), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_INSERT)) },
    { MP_ROM_QSTR(MP_QSTR_REFRESH), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_REFRESH)) },
    { MP_ROM_QSTR(MP_QSTR_READY), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_READY)) },
    { MP_ROM_QSTR(MP_QSTR_CANCEL), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_CANCEL)) },
    { MP_ROM_QSTR(MP_QSTR_DELETE), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_DELETE)) },
    { MP_ROM_QSTR(MP_QSTR_CHILD_CHANGED), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_CHILD_CHANGED)) },
    { MP_ROM_QSTR(MP_QSTR_CHILD_CREATED), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_CHILD_CREATED)) },
    { MP_ROM_QSTR(MP_QSTR_CHILD_DELETED), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_CHILD_DELETED)) },
    { MP_ROM_QSTR(MP_QSTR_SCREEN_UNLOAD_START), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_SCREEN_UNLOAD_START)) },
    { MP_ROM_QSTR(MP_QSTR_SCREEN_LOAD_START), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_SCREEN_LOAD_START)) },
    { MP_ROM_QSTR(MP_QSTR_SCREEN_LOADED), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_SCREEN_LOADED)) },
    { MP_ROM_QSTR(MP_QSTR_SCREEN_UNLOADED), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_SCREEN_UNLOADED)) },
    { MP_ROM_QSTR(MP_QSTR_SIZE_CHANGED), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_SIZE_CHANGED)) },
    { MP_ROM_QSTR(MP_QSTR_STYLE_CHANGED), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_STYLE_CHANGED)) },
    { MP_ROM_QSTR(MP_QSTR_LAYOUT_CHANGED), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_LAYOUT_CHANGED)) },
    { MP_ROM_QSTR(MP_QSTR_GET_SELF_SIZE), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_GET_SELF_SIZE)) },
    { MP_ROM_QSTR(MP_QSTR_PREPROCESS), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_PREPROCESS)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_EVENT_locals_dict, LV_EVENT_locals_dict_table);

STATIC void LV_EVENT_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_EVENT");
}



STATIC const mp_obj_type_t mp_LV_EVENT_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_EVENT,
    .print = LV_EVENT_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_EVENT_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_GROUP_REFOCUS_POLICY object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_GROUP_REFOCUS_POLICY_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_NEXT), MP_ROM_PTR(MP_ROM_INT(LV_GROUP_REFOCUS_POLICY_NEXT)) },
    { MP_ROM_QSTR(MP_QSTR_PREV), MP_ROM_PTR(MP_ROM_INT(LV_GROUP_REFOCUS_POLICY_PREV)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_GROUP_REFOCUS_POLICY_locals_dict, LV_GROUP_REFOCUS_POLICY_locals_dict_table);

STATIC void LV_GROUP_REFOCUS_POLICY_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_GROUP_REFOCUS_POLICY");
}



STATIC const mp_obj_type_t mp_LV_GROUP_REFOCUS_POLICY_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_GROUP_REFOCUS_POLICY,
    .print = LV_GROUP_REFOCUS_POLICY_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_GROUP_REFOCUS_POLICY_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_SCR_LOAD_ANIM object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_SCR_LOAD_ANIM_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_NONE), MP_ROM_PTR(MP_ROM_INT(LV_SCR_LOAD_ANIM_NONE)) },
    { MP_ROM_QSTR(MP_QSTR_OVER_LEFT), MP_ROM_PTR(MP_ROM_INT(LV_SCR_LOAD_ANIM_OVER_LEFT)) },
    { MP_ROM_QSTR(MP_QSTR_OVER_RIGHT), MP_ROM_PTR(MP_ROM_INT(LV_SCR_LOAD_ANIM_OVER_RIGHT)) },
    { MP_ROM_QSTR(MP_QSTR_OVER_TOP), MP_ROM_PTR(MP_ROM_INT(LV_SCR_LOAD_ANIM_OVER_TOP)) },
    { MP_ROM_QSTR(MP_QSTR_OVER_BOTTOM), MP_ROM_PTR(MP_ROM_INT(LV_SCR_LOAD_ANIM_OVER_BOTTOM)) },
    { MP_ROM_QSTR(MP_QSTR_MOVE_LEFT), MP_ROM_PTR(MP_ROM_INT(LV_SCR_LOAD_ANIM_MOVE_LEFT)) },
    { MP_ROM_QSTR(MP_QSTR_MOVE_RIGHT), MP_ROM_PTR(MP_ROM_INT(LV_SCR_LOAD_ANIM_MOVE_RIGHT)) },
    { MP_ROM_QSTR(MP_QSTR_MOVE_TOP), MP_ROM_PTR(MP_ROM_INT(LV_SCR_LOAD_ANIM_MOVE_TOP)) },
    { MP_ROM_QSTR(MP_QSTR_MOVE_BOTTOM), MP_ROM_PTR(MP_ROM_INT(LV_SCR_LOAD_ANIM_MOVE_BOTTOM)) },
    { MP_ROM_QSTR(MP_QSTR_FADE_IN), MP_ROM_PTR(MP_ROM_INT(LV_SCR_LOAD_ANIM_FADE_IN)) },
    { MP_ROM_QSTR(MP_QSTR_FADE_ON), MP_ROM_PTR(MP_ROM_INT(LV_SCR_LOAD_ANIM_FADE_ON)) },
    { MP_ROM_QSTR(MP_QSTR_FADE_OUT), MP_ROM_PTR(MP_ROM_INT(LV_SCR_LOAD_ANIM_FADE_OUT)) },
    { MP_ROM_QSTR(MP_QSTR_OUT_LEFT), MP_ROM_PTR(MP_ROM_INT(LV_SCR_LOAD_ANIM_OUT_LEFT)) },
    { MP_ROM_QSTR(MP_QSTR_OUT_RIGHT), MP_ROM_PTR(MP_ROM_INT(LV_SCR_LOAD_ANIM_OUT_RIGHT)) },
    { MP_ROM_QSTR(MP_QSTR_OUT_TOP), MP_ROM_PTR(MP_ROM_INT(LV_SCR_LOAD_ANIM_OUT_TOP)) },
    { MP_ROM_QSTR(MP_QSTR_OUT_BOTTOM), MP_ROM_PTR(MP_ROM_INT(LV_SCR_LOAD_ANIM_OUT_BOTTOM)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_SCR_LOAD_ANIM_locals_dict, LV_SCR_LOAD_ANIM_locals_dict_table);

STATIC void LV_SCR_LOAD_ANIM_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_SCR_LOAD_ANIM");
}



STATIC const mp_obj_type_t mp_LV_SCR_LOAD_ANIM_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_SCR_LOAD_ANIM,
    .print = LV_SCR_LOAD_ANIM_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_SCR_LOAD_ANIM_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_FONT_FMT_TXT object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_FONT_FMT_TXT_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_PLAIN), MP_ROM_PTR(MP_ROM_INT(LV_FONT_FMT_TXT_PLAIN)) },
    { MP_ROM_QSTR(MP_QSTR_COMPRESSED), MP_ROM_PTR(MP_ROM_INT(LV_FONT_FMT_TXT_COMPRESSED)) },
    { MP_ROM_QSTR(MP_QSTR_COMPRESSED_NO_PREFILTER), MP_ROM_PTR(MP_ROM_INT(LV_FONT_FMT_TXT_COMPRESSED_NO_PREFILTER)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_FONT_FMT_TXT_locals_dict, LV_FONT_FMT_TXT_locals_dict_table);

STATIC void LV_FONT_FMT_TXT_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_FONT_FMT_TXT");
}



STATIC const mp_obj_type_t mp_LV_FONT_FMT_TXT_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_FONT_FMT_TXT,
    .print = LV_FONT_FMT_TXT_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_FONT_FMT_TXT_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_ARC_DRAW_PART object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_ARC_DRAW_PART_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_BACKGROUND), MP_ROM_PTR(MP_ROM_INT(LV_ARC_DRAW_PART_BACKGROUND)) },
    { MP_ROM_QSTR(MP_QSTR_FOREGROUND), MP_ROM_PTR(MP_ROM_INT(LV_ARC_DRAW_PART_FOREGROUND)) },
    { MP_ROM_QSTR(MP_QSTR_KNOB), MP_ROM_PTR(MP_ROM_INT(LV_ARC_DRAW_PART_KNOB)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_ARC_DRAW_PART_locals_dict, LV_ARC_DRAW_PART_locals_dict_table);

STATIC void LV_ARC_DRAW_PART_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_ARC_DRAW_PART");
}



STATIC const mp_obj_type_t mp_LV_ARC_DRAW_PART_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_ARC_DRAW_PART,
    .print = LV_ARC_DRAW_PART_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_ARC_DRAW_PART_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_TABLE_DRAW_PART object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_TABLE_DRAW_PART_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_CELL), MP_ROM_PTR(MP_ROM_INT(LV_TABLE_DRAW_PART_CELL)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_TABLE_DRAW_PART_locals_dict, LV_TABLE_DRAW_PART_locals_dict_table);

STATIC void LV_TABLE_DRAW_PART_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_TABLE_DRAW_PART");
}



STATIC const mp_obj_type_t mp_LV_TABLE_DRAW_PART_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_TABLE_DRAW_PART,
    .print = LV_TABLE_DRAW_PART_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_TABLE_DRAW_PART_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_CHECKBOX_DRAW_PART object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_CHECKBOX_DRAW_PART_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_BOX), MP_ROM_PTR(MP_ROM_INT(LV_CHECKBOX_DRAW_PART_BOX)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_CHECKBOX_DRAW_PART_locals_dict, LV_CHECKBOX_DRAW_PART_locals_dict_table);

STATIC void LV_CHECKBOX_DRAW_PART_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_CHECKBOX_DRAW_PART");
}



STATIC const mp_obj_type_t mp_LV_CHECKBOX_DRAW_PART_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_CHECKBOX_DRAW_PART,
    .print = LV_CHECKBOX_DRAW_PART_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_CHECKBOX_DRAW_PART_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_BAR_DRAW_PART object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_BAR_DRAW_PART_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_INDICATOR), MP_ROM_PTR(MP_ROM_INT(LV_BAR_DRAW_PART_INDICATOR)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_BAR_DRAW_PART_locals_dict, LV_BAR_DRAW_PART_locals_dict_table);

STATIC void LV_BAR_DRAW_PART_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_BAR_DRAW_PART");
}



STATIC const mp_obj_type_t mp_LV_BAR_DRAW_PART_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_BAR_DRAW_PART,
    .print = LV_BAR_DRAW_PART_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_BAR_DRAW_PART_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_SLIDER_DRAW_PART object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_SLIDER_DRAW_PART_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_KNOB), MP_ROM_PTR(MP_ROM_INT(LV_SLIDER_DRAW_PART_KNOB)) },
    { MP_ROM_QSTR(MP_QSTR_KNOB_LEFT), MP_ROM_PTR(MP_ROM_INT(LV_SLIDER_DRAW_PART_KNOB_LEFT)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_SLIDER_DRAW_PART_locals_dict, LV_SLIDER_DRAW_PART_locals_dict_table);

STATIC void LV_SLIDER_DRAW_PART_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_SLIDER_DRAW_PART");
}



STATIC const mp_obj_type_t mp_LV_SLIDER_DRAW_PART_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_SLIDER_DRAW_PART,
    .print = LV_SLIDER_DRAW_PART_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_SLIDER_DRAW_PART_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_BTNMATRIX_DRAW_PART object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_BTNMATRIX_DRAW_PART_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_BTN), MP_ROM_PTR(MP_ROM_INT(LV_BTNMATRIX_DRAW_PART_BTN)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_BTNMATRIX_DRAW_PART_locals_dict, LV_BTNMATRIX_DRAW_PART_locals_dict_table);

STATIC void LV_BTNMATRIX_DRAW_PART_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_BTNMATRIX_DRAW_PART");
}



STATIC const mp_obj_type_t mp_LV_BTNMATRIX_DRAW_PART_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_BTNMATRIX_DRAW_PART,
    .print = LV_BTNMATRIX_DRAW_PART_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_BTNMATRIX_DRAW_PART_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_FLEX_ALIGN object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_FLEX_ALIGN_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_START), MP_ROM_PTR(MP_ROM_INT(LV_FLEX_ALIGN_START)) },
    { MP_ROM_QSTR(MP_QSTR_END), MP_ROM_PTR(MP_ROM_INT(LV_FLEX_ALIGN_END)) },
    { MP_ROM_QSTR(MP_QSTR_CENTER), MP_ROM_PTR(MP_ROM_INT(LV_FLEX_ALIGN_CENTER)) },
    { MP_ROM_QSTR(MP_QSTR_SPACE_EVENLY), MP_ROM_PTR(MP_ROM_INT(LV_FLEX_ALIGN_SPACE_EVENLY)) },
    { MP_ROM_QSTR(MP_QSTR_SPACE_AROUND), MP_ROM_PTR(MP_ROM_INT(LV_FLEX_ALIGN_SPACE_AROUND)) },
    { MP_ROM_QSTR(MP_QSTR_SPACE_BETWEEN), MP_ROM_PTR(MP_ROM_INT(LV_FLEX_ALIGN_SPACE_BETWEEN)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_FLEX_ALIGN_locals_dict, LV_FLEX_ALIGN_locals_dict_table);

STATIC void LV_FLEX_ALIGN_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_FLEX_ALIGN");
}



STATIC const mp_obj_type_t mp_LV_FLEX_ALIGN_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_FLEX_ALIGN,
    .print = LV_FLEX_ALIGN_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_FLEX_ALIGN_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_FLEX_FLOW object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_FLEX_FLOW_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_ROW), MP_ROM_PTR(MP_ROM_INT(LV_FLEX_FLOW_ROW)) },
    { MP_ROM_QSTR(MP_QSTR_COLUMN), MP_ROM_PTR(MP_ROM_INT(LV_FLEX_FLOW_COLUMN)) },
    { MP_ROM_QSTR(MP_QSTR_ROW_WRAP), MP_ROM_PTR(MP_ROM_INT(LV_FLEX_FLOW_ROW_WRAP)) },
    { MP_ROM_QSTR(MP_QSTR_ROW_REVERSE), MP_ROM_PTR(MP_ROM_INT(LV_FLEX_FLOW_ROW_REVERSE)) },
    { MP_ROM_QSTR(MP_QSTR_ROW_WRAP_REVERSE), MP_ROM_PTR(MP_ROM_INT(LV_FLEX_FLOW_ROW_WRAP_REVERSE)) },
    { MP_ROM_QSTR(MP_QSTR_COLUMN_WRAP), MP_ROM_PTR(MP_ROM_INT(LV_FLEX_FLOW_COLUMN_WRAP)) },
    { MP_ROM_QSTR(MP_QSTR_COLUMN_REVERSE), MP_ROM_PTR(MP_ROM_INT(LV_FLEX_FLOW_COLUMN_REVERSE)) },
    { MP_ROM_QSTR(MP_QSTR_COLUMN_WRAP_REVERSE), MP_ROM_PTR(MP_ROM_INT(LV_FLEX_FLOW_COLUMN_WRAP_REVERSE)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_FLEX_FLOW_locals_dict, LV_FLEX_FLOW_locals_dict_table);

STATIC void LV_FLEX_FLOW_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_FLEX_FLOW");
}



STATIC const mp_obj_type_t mp_LV_FLEX_FLOW_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_FLEX_FLOW,
    .print = LV_FLEX_FLOW_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_FLEX_FLOW_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_GRID_ALIGN object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_GRID_ALIGN_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_START), MP_ROM_PTR(MP_ROM_INT(LV_GRID_ALIGN_START)) },
    { MP_ROM_QSTR(MP_QSTR_CENTER), MP_ROM_PTR(MP_ROM_INT(LV_GRID_ALIGN_CENTER)) },
    { MP_ROM_QSTR(MP_QSTR_END), MP_ROM_PTR(MP_ROM_INT(LV_GRID_ALIGN_END)) },
    { MP_ROM_QSTR(MP_QSTR_STRETCH), MP_ROM_PTR(MP_ROM_INT(LV_GRID_ALIGN_STRETCH)) },
    { MP_ROM_QSTR(MP_QSTR_SPACE_EVENLY), MP_ROM_PTR(MP_ROM_INT(LV_GRID_ALIGN_SPACE_EVENLY)) },
    { MP_ROM_QSTR(MP_QSTR_SPACE_AROUND), MP_ROM_PTR(MP_ROM_INT(LV_GRID_ALIGN_SPACE_AROUND)) },
    { MP_ROM_QSTR(MP_QSTR_SPACE_BETWEEN), MP_ROM_PTR(MP_ROM_INT(LV_GRID_ALIGN_SPACE_BETWEEN)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_GRID_ALIGN_locals_dict, LV_GRID_ALIGN_locals_dict_table);

STATIC void LV_GRID_ALIGN_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_GRID_ALIGN");
}



STATIC const mp_obj_type_t mp_LV_GRID_ALIGN_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_GRID_ALIGN,
    .print = LV_GRID_ALIGN_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_GRID_ALIGN_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_CHART_DRAW_PART object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_CHART_DRAW_PART_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_DIV_LINE_INIT), MP_ROM_PTR(MP_ROM_INT(LV_CHART_DRAW_PART_DIV_LINE_INIT)) },
    { MP_ROM_QSTR(MP_QSTR_DIV_LINE_HOR), MP_ROM_PTR(MP_ROM_INT(LV_CHART_DRAW_PART_DIV_LINE_HOR)) },
    { MP_ROM_QSTR(MP_QSTR_DIV_LINE_VER), MP_ROM_PTR(MP_ROM_INT(LV_CHART_DRAW_PART_DIV_LINE_VER)) },
    { MP_ROM_QSTR(MP_QSTR_LINE_AND_POINT), MP_ROM_PTR(MP_ROM_INT(LV_CHART_DRAW_PART_LINE_AND_POINT)) },
    { MP_ROM_QSTR(MP_QSTR_BAR), MP_ROM_PTR(MP_ROM_INT(LV_CHART_DRAW_PART_BAR)) },
    { MP_ROM_QSTR(MP_QSTR_CURSOR), MP_ROM_PTR(MP_ROM_INT(LV_CHART_DRAW_PART_CURSOR)) },
    { MP_ROM_QSTR(MP_QSTR_TICK_LABEL), MP_ROM_PTR(MP_ROM_INT(LV_CHART_DRAW_PART_TICK_LABEL)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_CHART_DRAW_PART_locals_dict, LV_CHART_DRAW_PART_locals_dict_table);

STATIC void LV_CHART_DRAW_PART_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_CHART_DRAW_PART");
}



STATIC const mp_obj_type_t mp_LV_CHART_DRAW_PART_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_CHART_DRAW_PART,
    .print = LV_CHART_DRAW_PART_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_CHART_DRAW_PART_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_METER_DRAW_PART object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_METER_DRAW_PART_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_ARC), MP_ROM_PTR(MP_ROM_INT(LV_METER_DRAW_PART_ARC)) },
    { MP_ROM_QSTR(MP_QSTR_NEEDLE_LINE), MP_ROM_PTR(MP_ROM_INT(LV_METER_DRAW_PART_NEEDLE_LINE)) },
    { MP_ROM_QSTR(MP_QSTR_NEEDLE_IMG), MP_ROM_PTR(MP_ROM_INT(LV_METER_DRAW_PART_NEEDLE_IMG)) },
    { MP_ROM_QSTR(MP_QSTR_TICK), MP_ROM_PTR(MP_ROM_INT(LV_METER_DRAW_PART_TICK)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_METER_DRAW_PART_locals_dict, LV_METER_DRAW_PART_locals_dict_table);

STATIC void LV_METER_DRAW_PART_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_METER_DRAW_PART");
}



STATIC const mp_obj_type_t mp_LV_METER_DRAW_PART_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_METER_DRAW_PART,
    .print = LV_METER_DRAW_PART_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_METER_DRAW_PART_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_LED_DRAW_PART object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_LED_DRAW_PART_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_RECTANGLE), MP_ROM_PTR(MP_ROM_INT(LV_LED_DRAW_PART_RECTANGLE)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_LED_DRAW_PART_locals_dict, LV_LED_DRAW_PART_locals_dict_table);

STATIC void LV_LED_DRAW_PART_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_LED_DRAW_PART");
}



STATIC const mp_obj_type_t mp_LV_LED_DRAW_PART_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_LED_DRAW_PART,
    .print = LV_LED_DRAW_PART_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_LED_DRAW_PART_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_IMGBTN_STATE object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_IMGBTN_STATE_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_RELEASED), MP_ROM_PTR(MP_ROM_INT(LV_IMGBTN_STATE_RELEASED)) },
    { MP_ROM_QSTR(MP_QSTR_PRESSED), MP_ROM_PTR(MP_ROM_INT(LV_IMGBTN_STATE_PRESSED)) },
    { MP_ROM_QSTR(MP_QSTR_DISABLED), MP_ROM_PTR(MP_ROM_INT(LV_IMGBTN_STATE_DISABLED)) },
    { MP_ROM_QSTR(MP_QSTR_CHECKED_RELEASED), MP_ROM_PTR(MP_ROM_INT(LV_IMGBTN_STATE_CHECKED_RELEASED)) },
    { MP_ROM_QSTR(MP_QSTR_CHECKED_PRESSED), MP_ROM_PTR(MP_ROM_INT(LV_IMGBTN_STATE_CHECKED_PRESSED)) },
    { MP_ROM_QSTR(MP_QSTR_CHECKED_DISABLED), MP_ROM_PTR(MP_ROM_INT(LV_IMGBTN_STATE_CHECKED_DISABLED)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_IMGBTN_STATE_locals_dict, LV_IMGBTN_STATE_locals_dict_table);

STATIC void LV_IMGBTN_STATE_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_IMGBTN_STATE");
}



STATIC const mp_obj_type_t mp_LV_IMGBTN_STATE_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_IMGBTN_STATE,
    .print = LV_IMGBTN_STATE_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_IMGBTN_STATE_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_EX_DATA object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_EX_DATA_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_STRING), MP_ROM_PTR(MP_ROM_INT(LV_EX_DATA_STRING)) },
    { MP_ROM_QSTR(MP_QSTR_INT32), MP_ROM_PTR(MP_ROM_INT(LV_EX_DATA_INT32)) },
    { MP_ROM_QSTR(MP_QSTR_UINT32), MP_ROM_PTR(MP_ROM_INT(LV_EX_DATA_UINT32)) },
    { MP_ROM_QSTR(MP_QSTR_FLOAT), MP_ROM_PTR(MP_ROM_INT(LV_EX_DATA_FLOAT)) },
    { MP_ROM_QSTR(MP_QSTR_TIME), MP_ROM_PTR(MP_ROM_INT(LV_EX_DATA_TIME)) },
    { MP_ROM_QSTR(MP_QSTR_POINTER), MP_ROM_PTR(MP_ROM_INT(LV_EX_DATA_POINTER)) },
    { MP_ROM_QSTR(MP_QSTR_LIST), MP_ROM_PTR(MP_ROM_INT(LV_EX_DATA_LIST)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_EX_DATA_locals_dict, LV_EX_DATA_locals_dict_table);

STATIC void LV_EX_DATA_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_EX_DATA");
}



STATIC const mp_obj_type_t mp_LV_EX_DATA_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_EX_DATA,
    .print = LV_EX_DATA_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_EX_DATA_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LVSF_COMP object definitions
 */
    

STATIC const mp_rom_map_elem_t LVSF_COMP_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_CIRCLE), MP_ROM_PTR(MP_ROM_INT(LVSF_COMP_CIRCLE)) },
    { MP_ROM_QSTR(MP_QSTR_MOD_SMALL), MP_ROM_PTR(MP_ROM_INT(LVSF_COMP_MOD_SMALL)) },
    { MP_ROM_QSTR(MP_QSTR_MOD_LARGE), MP_ROM_PTR(MP_ROM_INT(LVSF_COMP_MOD_LARGE)) },
    { MP_ROM_QSTR(MP_QSTR_EXTRA_LARGE), MP_ROM_PTR(MP_ROM_INT(LVSF_COMP_EXTRA_LARGE)) },
    { MP_ROM_QSTR(MP_QSTR_UTILITY_SMALL), MP_ROM_PTR(MP_ROM_INT(LVSF_COMP_UTILITY_SMALL)) },
    { MP_ROM_QSTR(MP_QSTR_CIRCULAR), MP_ROM_PTR(MP_ROM_INT(LVSF_COMP_CIRCULAR)) },
    { MP_ROM_QSTR(MP_QSTR_CORNER), MP_ROM_PTR(MP_ROM_INT(LVSF_COMP_CORNER)) },
    { MP_ROM_QSTR(MP_QSTR_MAX), MP_ROM_PTR(MP_ROM_INT(LVSF_COMP_MAX)) }
};

STATIC MP_DEFINE_CONST_DICT(LVSF_COMP_locals_dict, LVSF_COMP_locals_dict_table);

STATIC void LVSF_COMP_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LVSF_COMP");
}



STATIC const mp_obj_type_t mp_LVSF_COMP_type = {
    { &mp_type_type },
    .name = MP_QSTR_LVSF_COMP,
    .print = LVSF_COMP_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LVSF_COMP_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl GUI_APP_MSG object definitions
 */
    

STATIC const mp_rom_map_elem_t GUI_APP_MSG_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_ONSTART), MP_ROM_PTR(MP_ROM_INT(GUI_APP_MSG_ONSTART)) },
    { MP_ROM_QSTR(MP_QSTR_ONRESUME), MP_ROM_PTR(MP_ROM_INT(GUI_APP_MSG_ONRESUME)) },
    { MP_ROM_QSTR(MP_QSTR_ONPAUSE), MP_ROM_PTR(MP_ROM_INT(GUI_APP_MSG_ONPAUSE)) },
    { MP_ROM_QSTR(MP_QSTR_ONSTOP), MP_ROM_PTR(MP_ROM_INT(GUI_APP_MSG_ONSTOP)) },
    { MP_ROM_QSTR(MP_QSTR_USER_END), MP_ROM_PTR(MP_ROM_INT(GUI_APP_MSG_USER_END)) }
};

STATIC MP_DEFINE_CONST_DICT(GUI_APP_MSG_locals_dict, GUI_APP_MSG_locals_dict_table);

STATIC void GUI_APP_MSG_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl GUI_APP_MSG");
}



STATIC const mp_obj_type_t mp_GUI_APP_MSG_type = {
    { &mp_type_type },
    .name = MP_QSTR_GUI_APP_MSG,
    .print = GUI_APP_MSG_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&GUI_APP_MSG_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_SYMBOL object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_SYMBOL_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_BULLET), MP_ROM_PTR(&mp_LV_SYMBOL_BULLET) },
    { MP_ROM_QSTR(MP_QSTR_AUDIO), MP_ROM_PTR(&mp_LV_SYMBOL_AUDIO) },
    { MP_ROM_QSTR(MP_QSTR_VIDEO), MP_ROM_PTR(&mp_LV_SYMBOL_VIDEO) },
    { MP_ROM_QSTR(MP_QSTR_LIST), MP_ROM_PTR(&mp_LV_SYMBOL_LIST) },
    { MP_ROM_QSTR(MP_QSTR_OK), MP_ROM_PTR(&mp_LV_SYMBOL_OK) },
    { MP_ROM_QSTR(MP_QSTR_CLOSE), MP_ROM_PTR(&mp_LV_SYMBOL_CLOSE) },
    { MP_ROM_QSTR(MP_QSTR_POWER), MP_ROM_PTR(&mp_LV_SYMBOL_POWER) },
    { MP_ROM_QSTR(MP_QSTR_SETTINGS), MP_ROM_PTR(&mp_LV_SYMBOL_SETTINGS) },
    { MP_ROM_QSTR(MP_QSTR_HOME), MP_ROM_PTR(&mp_LV_SYMBOL_HOME) },
    { MP_ROM_QSTR(MP_QSTR_DOWNLOAD), MP_ROM_PTR(&mp_LV_SYMBOL_DOWNLOAD) },
    { MP_ROM_QSTR(MP_QSTR_DRIVE), MP_ROM_PTR(&mp_LV_SYMBOL_DRIVE) },
    { MP_ROM_QSTR(MP_QSTR_REFRESH), MP_ROM_PTR(&mp_LV_SYMBOL_REFRESH) },
    { MP_ROM_QSTR(MP_QSTR_MUTE), MP_ROM_PTR(&mp_LV_SYMBOL_MUTE) },
    { MP_ROM_QSTR(MP_QSTR_VOLUME_MID), MP_ROM_PTR(&mp_LV_SYMBOL_VOLUME_MID) },
    { MP_ROM_QSTR(MP_QSTR_VOLUME_MAX), MP_ROM_PTR(&mp_LV_SYMBOL_VOLUME_MAX) },
    { MP_ROM_QSTR(MP_QSTR_IMAGE), MP_ROM_PTR(&mp_LV_SYMBOL_IMAGE) },
    { MP_ROM_QSTR(MP_QSTR_TINT), MP_ROM_PTR(&mp_LV_SYMBOL_TINT) },
    { MP_ROM_QSTR(MP_QSTR_PREV), MP_ROM_PTR(&mp_LV_SYMBOL_PREV) },
    { MP_ROM_QSTR(MP_QSTR_PLAY), MP_ROM_PTR(&mp_LV_SYMBOL_PLAY) },
    { MP_ROM_QSTR(MP_QSTR_PAUSE), MP_ROM_PTR(&mp_LV_SYMBOL_PAUSE) },
    { MP_ROM_QSTR(MP_QSTR_STOP), MP_ROM_PTR(&mp_LV_SYMBOL_STOP) },
    { MP_ROM_QSTR(MP_QSTR_NEXT), MP_ROM_PTR(&mp_LV_SYMBOL_NEXT) },
    { MP_ROM_QSTR(MP_QSTR_EJECT), MP_ROM_PTR(&mp_LV_SYMBOL_EJECT) },
    { MP_ROM_QSTR(MP_QSTR_LEFT), MP_ROM_PTR(&mp_LV_SYMBOL_LEFT) },
    { MP_ROM_QSTR(MP_QSTR_RIGHT), MP_ROM_PTR(&mp_LV_SYMBOL_RIGHT) },
    { MP_ROM_QSTR(MP_QSTR_PLUS), MP_ROM_PTR(&mp_LV_SYMBOL_PLUS) },
    { MP_ROM_QSTR(MP_QSTR_MINUS), MP_ROM_PTR(&mp_LV_SYMBOL_MINUS) },
    { MP_ROM_QSTR(MP_QSTR_EYE_OPEN), MP_ROM_PTR(&mp_LV_SYMBOL_EYE_OPEN) },
    { MP_ROM_QSTR(MP_QSTR_EYE_CLOSE), MP_ROM_PTR(&mp_LV_SYMBOL_EYE_CLOSE) },
    { MP_ROM_QSTR(MP_QSTR_WARNING), MP_ROM_PTR(&mp_LV_SYMBOL_WARNING) },
    { MP_ROM_QSTR(MP_QSTR_SHUFFLE), MP_ROM_PTR(&mp_LV_SYMBOL_SHUFFLE) },
    { MP_ROM_QSTR(MP_QSTR_UP), MP_ROM_PTR(&mp_LV_SYMBOL_UP) },
    { MP_ROM_QSTR(MP_QSTR_DOWN), MP_ROM_PTR(&mp_LV_SYMBOL_DOWN) },
    { MP_ROM_QSTR(MP_QSTR_LOOP), MP_ROM_PTR(&mp_LV_SYMBOL_LOOP) },
    { MP_ROM_QSTR(MP_QSTR_DIRECTORY), MP_ROM_PTR(&mp_LV_SYMBOL_DIRECTORY) },
    { MP_ROM_QSTR(MP_QSTR_UPLOAD), MP_ROM_PTR(&mp_LV_SYMBOL_UPLOAD) },
    { MP_ROM_QSTR(MP_QSTR_CALL), MP_ROM_PTR(&mp_LV_SYMBOL_CALL) },
    { MP_ROM_QSTR(MP_QSTR_CUT), MP_ROM_PTR(&mp_LV_SYMBOL_CUT) },
    { MP_ROM_QSTR(MP_QSTR_COPY), MP_ROM_PTR(&mp_LV_SYMBOL_COPY) },
    { MP_ROM_QSTR(MP_QSTR_SAVE), MP_ROM_PTR(&mp_LV_SYMBOL_SAVE) },
    { MP_ROM_QSTR(MP_QSTR_BARS), MP_ROM_PTR(&mp_LV_SYMBOL_BARS) },
    { MP_ROM_QSTR(MP_QSTR_ENVELOPE), MP_ROM_PTR(&mp_LV_SYMBOL_ENVELOPE) },
    { MP_ROM_QSTR(MP_QSTR_CHARGE), MP_ROM_PTR(&mp_LV_SYMBOL_CHARGE) },
    { MP_ROM_QSTR(MP_QSTR_PASTE), MP_ROM_PTR(&mp_LV_SYMBOL_PASTE) },
    { MP_ROM_QSTR(MP_QSTR_BELL), MP_ROM_PTR(&mp_LV_SYMBOL_BELL) },
    { MP_ROM_QSTR(MP_QSTR_KEYBOARD), MP_ROM_PTR(&mp_LV_SYMBOL_KEYBOARD) },
    { MP_ROM_QSTR(MP_QSTR_GPS), MP_ROM_PTR(&mp_LV_SYMBOL_GPS) },
    { MP_ROM_QSTR(MP_QSTR_FILE), MP_ROM_PTR(&mp_LV_SYMBOL_FILE) },
    { MP_ROM_QSTR(MP_QSTR_WIFI), MP_ROM_PTR(&mp_LV_SYMBOL_WIFI) },
    { MP_ROM_QSTR(MP_QSTR_BATTERY_FULL), MP_ROM_PTR(&mp_LV_SYMBOL_BATTERY_FULL) },
    { MP_ROM_QSTR(MP_QSTR_BATTERY_3), MP_ROM_PTR(&mp_LV_SYMBOL_BATTERY_3) },
    { MP_ROM_QSTR(MP_QSTR_BATTERY_2), MP_ROM_PTR(&mp_LV_SYMBOL_BATTERY_2) },
    { MP_ROM_QSTR(MP_QSTR_BATTERY_1), MP_ROM_PTR(&mp_LV_SYMBOL_BATTERY_1) },
    { MP_ROM_QSTR(MP_QSTR_BATTERY_EMPTY), MP_ROM_PTR(&mp_LV_SYMBOL_BATTERY_EMPTY) },
    { MP_ROM_QSTR(MP_QSTR_USB), MP_ROM_PTR(&mp_LV_SYMBOL_USB) },
    { MP_ROM_QSTR(MP_QSTR_BLUETOOTH), MP_ROM_PTR(&mp_LV_SYMBOL_BLUETOOTH) },
    { MP_ROM_QSTR(MP_QSTR_TRASH), MP_ROM_PTR(&mp_LV_SYMBOL_TRASH) },
    { MP_ROM_QSTR(MP_QSTR_EDIT), MP_ROM_PTR(&mp_LV_SYMBOL_EDIT) },
    { MP_ROM_QSTR(MP_QSTR_BACKSPACE), MP_ROM_PTR(&mp_LV_SYMBOL_BACKSPACE) },
    { MP_ROM_QSTR(MP_QSTR_SD_CARD), MP_ROM_PTR(&mp_LV_SYMBOL_SD_CARD) },
    { MP_ROM_QSTR(MP_QSTR_NEW_LINE), MP_ROM_PTR(&mp_LV_SYMBOL_NEW_LINE) },
    { MP_ROM_QSTR(MP_QSTR_DUMMY), MP_ROM_PTR(&mp_LV_SYMBOL_DUMMY) }
};

STATIC MP_DEFINE_CONST_DICT(LV_SYMBOL_locals_dict, LV_SYMBOL_locals_dict_table);

STATIC void LV_SYMBOL_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_SYMBOL");
}



STATIC const mp_obj_type_t mp_LV_SYMBOL_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_SYMBOL,
    .print = LV_SYMBOL_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_SYMBOL_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl extension definition for:
 * inline static void lv_obj_center(struct _lv_obj_t *obj)
 */
 
STATIC mp_obj_t mp_lv_obj_center(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_obj_t *obj = mp_to_lv(mp_args[0]);
    ((void (*)(struct _lv_obj_t *))lv_func_ptr)(obj);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_center_obj, 1, mp_lv_obj_center, lv_obj_center);
    
/* Reusing lv_obj_center for lv_obj_remove_style_all */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_remove_style_all_obj, 1, mp_lv_obj_center, lv_obj_remove_style_all);
    

/*
 * lvgl extension definition for:
 * inline static lv_coord_t lv_obj_get_style_width(const struct _lv_obj_t *obj, uint32_t part)
 */
 
STATIC mp_obj_t mp_lv_obj_get_style_width(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const struct _lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint32_t part = (uint32_t)mp_obj_get_int(mp_args[1]);
    lv_coord_t _res = ((lv_coord_t (*)(const struct _lv_obj_t *, uint32_t))lv_func_ptr)(obj, part);
    return mp_obj_new_int(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_width_obj, 2, mp_lv_obj_get_style_width, lv_obj_get_style_width);
    
/* Reusing lv_obj_get_style_width for lv_obj_get_style_min_width */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_min_width_obj, 2, mp_lv_obj_get_style_width, lv_obj_get_style_min_width);
    
/* Reusing lv_obj_get_style_width for lv_obj_get_style_max_width */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_max_width_obj, 2, mp_lv_obj_get_style_width, lv_obj_get_style_max_width);
    
/* Reusing lv_obj_get_style_width for lv_obj_get_style_height */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_height_obj, 2, mp_lv_obj_get_style_width, lv_obj_get_style_height);
    
/* Reusing lv_obj_get_style_width for lv_obj_get_style_min_height */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_min_height_obj, 2, mp_lv_obj_get_style_width, lv_obj_get_style_min_height);
    
/* Reusing lv_obj_get_style_width for lv_obj_get_style_max_height */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_max_height_obj, 2, mp_lv_obj_get_style_width, lv_obj_get_style_max_height);
    
/* Reusing lv_obj_get_style_width for lv_obj_get_style_x */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_x_obj, 2, mp_lv_obj_get_style_width, lv_obj_get_style_x);
    
/* Reusing lv_obj_get_style_width for lv_obj_get_style_y */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_y_obj, 2, mp_lv_obj_get_style_width, lv_obj_get_style_y);
    

/*
 * lvgl extension definition for:
 * inline static lv_align_t lv_obj_get_style_align(const struct _lv_obj_t *obj, uint32_t part)
 */
 
STATIC mp_obj_t mp_lv_obj_get_style_align(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const struct _lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint32_t part = (uint32_t)mp_obj_get_int(mp_args[1]);
    lv_align_t _res = ((lv_align_t (*)(const struct _lv_obj_t *, uint32_t))lv_func_ptr)(obj, part);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_align_obj, 2, mp_lv_obj_get_style_align, lv_obj_get_style_align);
    
/* Reusing lv_obj_get_style_width for lv_obj_get_style_transform_width */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_transform_width_obj, 2, mp_lv_obj_get_style_width, lv_obj_get_style_transform_width);
    
/* Reusing lv_obj_get_style_width for lv_obj_get_style_transform_height */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_transform_height_obj, 2, mp_lv_obj_get_style_width, lv_obj_get_style_transform_height);
    
/* Reusing lv_obj_get_style_width for lv_obj_get_style_translate_x */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_translate_x_obj, 2, mp_lv_obj_get_style_width, lv_obj_get_style_translate_x);
    
/* Reusing lv_obj_get_style_width for lv_obj_get_style_translate_y */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_translate_y_obj, 2, mp_lv_obj_get_style_width, lv_obj_get_style_translate_y);
    
/* Reusing lv_obj_get_style_width for lv_obj_get_style_transform_zoom */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_transform_zoom_obj, 2, mp_lv_obj_get_style_width, lv_obj_get_style_transform_zoom);
    
/* Reusing lv_obj_get_style_width for lv_obj_get_style_transform_angle */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_transform_angle_obj, 2, mp_lv_obj_get_style_width, lv_obj_get_style_transform_angle);
    
/* Reusing lv_obj_get_style_width for lv_obj_get_style_transform_pivot_x */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_transform_pivot_x_obj, 2, mp_lv_obj_get_style_width, lv_obj_get_style_transform_pivot_x);
    
/* Reusing lv_obj_get_style_width for lv_obj_get_style_transform_pivot_y */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_transform_pivot_y_obj, 2, mp_lv_obj_get_style_width, lv_obj_get_style_transform_pivot_y);
    
/* Reusing lv_obj_get_style_width for lv_obj_get_style_pad_top */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_pad_top_obj, 2, mp_lv_obj_get_style_width, lv_obj_get_style_pad_top);
    
/* Reusing lv_obj_get_style_width for lv_obj_get_style_pad_bottom */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_pad_bottom_obj, 2, mp_lv_obj_get_style_width, lv_obj_get_style_pad_bottom);
    
/* Reusing lv_obj_get_style_width for lv_obj_get_style_pad_left */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_pad_left_obj, 2, mp_lv_obj_get_style_width, lv_obj_get_style_pad_left);
    
/* Reusing lv_obj_get_style_width for lv_obj_get_style_pad_right */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_pad_right_obj, 2, mp_lv_obj_get_style_width, lv_obj_get_style_pad_right);
    
/* Reusing lv_obj_get_style_width for lv_obj_get_style_pad_row */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_pad_row_obj, 2, mp_lv_obj_get_style_width, lv_obj_get_style_pad_row);
    
/* Reusing lv_obj_get_style_width for lv_obj_get_style_pad_column */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_pad_column_obj, 2, mp_lv_obj_get_style_width, lv_obj_get_style_pad_column);
    
typedef __typeof__( ((lv_color16_t*)(0))->ch ) lv_color16_ch_t;

/*
 * Struct lv_color16_ch_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_color16_ch_t_type();

STATIC inline lv_color16_ch_t* mp_write_ptr_lv_color16_ch_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_color16_ch_t_type()));
    return (lv_color16_ch_t*)self->data;
}

#define mp_write_lv_color16_ch_t(struct_obj) *mp_write_ptr_lv_color16_ch_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_color16_ch_t(lv_color16_ch_t *field)
{
    return lv_to_mp_struct(get_mp_lv_color16_ch_t_type(), (void*)field);
}

#define mp_read_lv_color16_ch_t(field) mp_read_ptr_lv_color16_ch_t(copy_buffer(&field, sizeof(lv_color16_ch_t)))
#define mp_read_byref_lv_color16_ch_t(field) mp_read_ptr_lv_color16_ch_t(&field)

STATIC void mp_lv_color16_ch_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_color16_ch_t *data = (lv_color16_ch_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_blue: dest[0] = mp_obj_new_int_from_uint(data->blue); break; // converting from uint16_t;
            case MP_QSTR_green: dest[0] = mp_obj_new_int_from_uint(data->green); break; // converting from uint16_t;
            case MP_QSTR_red: dest[0] = mp_obj_new_int_from_uint(data->red); break; // converting from uint16_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_blue: data->blue = (uint16_t)mp_obj_get_int(dest[1]); break; // converting to uint16_t;
                case MP_QSTR_green: data->green = (uint16_t)mp_obj_get_int(dest[1]); break; // converting to uint16_t;
                case MP_QSTR_red: data->red = (uint16_t)mp_obj_get_int(dest[1]); break; // converting to uint16_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_color16_ch_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_color16_ch_t");
}

STATIC const mp_obj_dict_t mp_lv_color16_ch_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_color16_ch_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_color16_ch_t,
    .print = mp_lv_color16_ch_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_color16_ch_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_color16_ch_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_color16_ch_t_type()
{
    return &mp_lv_color16_ch_t_type;
}
    

/*
 * Struct lv_color16_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_color16_t_type();

STATIC inline lv_color16_t* mp_write_ptr_lv_color16_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_color16_t_type()));
    return (lv_color16_t*)self->data;
}

#define mp_write_lv_color16_t(struct_obj) *mp_write_ptr_lv_color16_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_color16_t(lv_color16_t *field)
{
    return lv_to_mp_struct(get_mp_lv_color16_t_type(), (void*)field);
}

#define mp_read_lv_color16_t(field) mp_read_ptr_lv_color16_t(copy_buffer(&field, sizeof(lv_color16_t)))
#define mp_read_byref_lv_color16_t(field) mp_read_ptr_lv_color16_t(&field)

STATIC void mp_lv_color16_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_color16_t *data = (lv_color16_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_ch: dest[0] = mp_read_byref_lv_color16_ch_t(data->ch); break; // converting from lv_color16_ch_t;
            case MP_QSTR_full: dest[0] = mp_obj_new_int_from_uint(data->full); break; // converting from uint16_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_ch: data->ch = mp_write_lv_color16_ch_t(dest[1]); break; // converting to lv_color16_ch_t;
                case MP_QSTR_full: data->full = (uint16_t)mp_obj_get_int(dest[1]); break; // converting to uint16_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_color16_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_color16_t");
}

STATIC const mp_obj_dict_t mp_lv_color16_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_color16_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_color16_t,
    .print = mp_lv_color16_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_color16_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_color16_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_color16_t_type()
{
    return &mp_lv_color16_t_type;
}
    

/*
 * lvgl extension definition for:
 * inline static lv_color_t lv_obj_get_style_bg_color(const struct _lv_obj_t *obj, uint32_t part)
 */
 
STATIC mp_obj_t mp_lv_obj_get_style_bg_color(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const struct _lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint32_t part = (uint32_t)mp_obj_get_int(mp_args[1]);
    lv_color_t _res = ((lv_color_t (*)(const struct _lv_obj_t *, uint32_t))lv_func_ptr)(obj, part);
    return mp_read_lv_color16_t(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_bg_color_obj, 2, mp_lv_obj_get_style_bg_color, lv_obj_get_style_bg_color);
    
/* Reusing lv_obj_get_style_bg_color for lv_obj_get_style_bg_color_filtered */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_bg_color_filtered_obj, 2, mp_lv_obj_get_style_bg_color, lv_obj_get_style_bg_color_filtered);
    

/*
 * lvgl extension definition for:
 * inline static lv_opa_t lv_obj_get_style_bg_opa(const struct _lv_obj_t *obj, uint32_t part)
 */
 
STATIC mp_obj_t mp_lv_obj_get_style_bg_opa(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const struct _lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint32_t part = (uint32_t)mp_obj_get_int(mp_args[1]);
    lv_opa_t _res = ((lv_opa_t (*)(const struct _lv_obj_t *, uint32_t))lv_func_ptr)(obj, part);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_bg_opa_obj, 2, mp_lv_obj_get_style_bg_opa, lv_obj_get_style_bg_opa);
    
/* Reusing lv_obj_get_style_bg_color for lv_obj_get_style_bg_grad_color */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_bg_grad_color_obj, 2, mp_lv_obj_get_style_bg_color, lv_obj_get_style_bg_grad_color);
    
/* Reusing lv_obj_get_style_bg_color for lv_obj_get_style_bg_grad_color_filtered */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_bg_grad_color_filtered_obj, 2, mp_lv_obj_get_style_bg_color, lv_obj_get_style_bg_grad_color_filtered);
    

/*
 * lvgl extension definition for:
 * inline static lv_grad_dir_t lv_obj_get_style_bg_grad_dir(const struct _lv_obj_t *obj, uint32_t part)
 */
 
STATIC mp_obj_t mp_lv_obj_get_style_bg_grad_dir(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const struct _lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint32_t part = (uint32_t)mp_obj_get_int(mp_args[1]);
    lv_grad_dir_t _res = ((lv_grad_dir_t (*)(const struct _lv_obj_t *, uint32_t))lv_func_ptr)(obj, part);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_bg_grad_dir_obj, 2, mp_lv_obj_get_style_bg_grad_dir, lv_obj_get_style_bg_grad_dir);
    
/* Reusing lv_obj_get_style_width for lv_obj_get_style_bg_main_stop */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_bg_main_stop_obj, 2, mp_lv_obj_get_style_width, lv_obj_get_style_bg_main_stop);
    
/* Reusing lv_obj_get_style_width for lv_obj_get_style_bg_grad_stop */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_bg_grad_stop_obj, 2, mp_lv_obj_get_style_width, lv_obj_get_style_bg_grad_stop);
    

/*
 * Struct lv_gradient_stop_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_gradient_stop_t_type();

STATIC inline lv_gradient_stop_t* mp_write_ptr_lv_gradient_stop_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_gradient_stop_t_type()));
    return (lv_gradient_stop_t*)self->data;
}

#define mp_write_lv_gradient_stop_t(struct_obj) *mp_write_ptr_lv_gradient_stop_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_gradient_stop_t(lv_gradient_stop_t *field)
{
    return lv_to_mp_struct(get_mp_lv_gradient_stop_t_type(), (void*)field);
}

#define mp_read_lv_gradient_stop_t(field) mp_read_ptr_lv_gradient_stop_t(copy_buffer(&field, sizeof(lv_gradient_stop_t)))
#define mp_read_byref_lv_gradient_stop_t(field) mp_read_ptr_lv_gradient_stop_t(&field)

STATIC void mp_lv_gradient_stop_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_gradient_stop_t *data = (lv_gradient_stop_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_color: dest[0] = mp_read_byref_lv_color16_t(data->color); break; // converting from lv_color_t;
            case MP_QSTR_frac: dest[0] = mp_obj_new_int_from_uint(data->frac); break; // converting from uint8_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_color: data->color = mp_write_lv_color16_t(dest[1]); break; // converting to lv_color_t;
                case MP_QSTR_frac: data->frac = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_gradient_stop_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_gradient_stop_t");
}

STATIC const mp_obj_dict_t mp_lv_gradient_stop_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_gradient_stop_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_gradient_stop_t,
    .print = mp_lv_gradient_stop_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_gradient_stop_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_gradient_stop_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_gradient_stop_t_type()
{
    return &mp_lv_gradient_stop_t_type;
}
    

/*
 * Array convertors for lv_gradient_stop_t [2]
 */

STATIC lv_gradient_stop_t *mp_arr_to_lv_gradient_stop_t___2__(mp_obj_t mp_arr)
{
    mp_obj_t mp_len = mp_obj_len_maybe(mp_arr);
    if (mp_len == MP_OBJ_NULL) return mp_to_ptr(mp_arr);
    mp_int_t len = mp_obj_get_int(mp_len);
    //TODO check dim!
    lv_gradient_stop_t *lv_arr = (lv_gradient_stop_t*)m_malloc(len * sizeof(lv_gradient_stop_t));
    mp_obj_t iter = mp_getiter(mp_arr, NULL);
    mp_obj_t item;
    size_t i = 0;
    while ((item = mp_iternext(iter)) != MP_OBJ_STOP_ITERATION) {
        lv_arr[i++] = mp_write_lv_gradient_stop_t(item);
    }
    return (lv_gradient_stop_t *)lv_arr;
}
    
STATIC mp_obj_t mp_arr_from_lv_gradient_stop_t___2__(lv_gradient_stop_t *arr)
{
    mp_obj_t obj_arr[2];
    for (size_t i=0; i<2; i++){
        obj_arr[i] = mp_read_lv_gradient_stop_t(arr[i]);
    }
    return mp_obj_new_list(2, obj_arr); // TODO: return custom iterable object!
}
    

/*
 * Struct lv_grad_dsc_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_grad_dsc_t_type();

STATIC inline lv_grad_dsc_t* mp_write_ptr_lv_grad_dsc_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_grad_dsc_t_type()));
    return (lv_grad_dsc_t*)self->data;
}

#define mp_write_lv_grad_dsc_t(struct_obj) *mp_write_ptr_lv_grad_dsc_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_grad_dsc_t(lv_grad_dsc_t *field)
{
    return lv_to_mp_struct(get_mp_lv_grad_dsc_t_type(), (void*)field);
}

#define mp_read_lv_grad_dsc_t(field) mp_read_ptr_lv_grad_dsc_t(copy_buffer(&field, sizeof(lv_grad_dsc_t)))
#define mp_read_byref_lv_grad_dsc_t(field) mp_read_ptr_lv_grad_dsc_t(&field)

STATIC void mp_lv_grad_dsc_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_grad_dsc_t *data = (lv_grad_dsc_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_stops: dest[0] = mp_arr_from_lv_gradient_stop_t___2__(data->stops); break; // converting from lv_gradient_stop_t [2];
            case MP_QSTR_stops_count: dest[0] = mp_obj_new_int_from_uint(data->stops_count); break; // converting from uint8_t;
            case MP_QSTR_dir: dest[0] = mp_obj_new_int_from_uint(data->dir); break; // converting from lv_grad_dir_t;
            case MP_QSTR_dither: dest[0] = mp_obj_new_int_from_uint(data->dither); break; // converting from lv_dither_mode_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_stops: memcpy((void*)&data->stops, mp_arr_to_lv_gradient_stop_t___2__(dest[1]), sizeof(lv_gradient_stop_t)*2); break; // converting to lv_gradient_stop_t [2];
                case MP_QSTR_stops_count: data->stops_count = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                case MP_QSTR_dir: data->dir = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to lv_grad_dir_t;
                case MP_QSTR_dither: data->dither = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to lv_dither_mode_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_grad_dsc_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_grad_dsc_t");
}

STATIC const mp_obj_dict_t mp_lv_grad_dsc_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_grad_dsc_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_grad_dsc_t,
    .print = mp_lv_grad_dsc_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_grad_dsc_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_grad_dsc_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_grad_dsc_t_type()
{
    return &mp_lv_grad_dsc_t_type;
}
    

/*
 * lvgl extension definition for:
 * inline static const lv_grad_dsc_t *lv_obj_get_style_bg_grad(const struct _lv_obj_t *obj, uint32_t part)
 */
 
STATIC mp_obj_t mp_lv_obj_get_style_bg_grad(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const struct _lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint32_t part = (uint32_t)mp_obj_get_int(mp_args[1]);
    const lv_grad_dsc_t * _res = ((const lv_grad_dsc_t *(*)(const struct _lv_obj_t *, uint32_t))lv_func_ptr)(obj, part);
    return mp_read_ptr_lv_grad_dsc_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_bg_grad_obj, 2, mp_lv_obj_get_style_bg_grad, lv_obj_get_style_bg_grad);
    

/*
 * lvgl extension definition for:
 * inline static lv_dither_mode_t lv_obj_get_style_bg_dither_mode(const struct _lv_obj_t *obj, uint32_t part)
 */
 
STATIC mp_obj_t mp_lv_obj_get_style_bg_dither_mode(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const struct _lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint32_t part = (uint32_t)mp_obj_get_int(mp_args[1]);
    lv_dither_mode_t _res = ((lv_dither_mode_t (*)(const struct _lv_obj_t *, uint32_t))lv_func_ptr)(obj, part);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_bg_dither_mode_obj, 2, mp_lv_obj_get_style_bg_dither_mode, lv_obj_get_style_bg_dither_mode);
    

/*
 * lvgl extension definition for:
 * inline static const void *lv_obj_get_style_bg_img_src(const struct _lv_obj_t *obj, uint32_t part)
 */
 
STATIC mp_obj_t mp_lv_obj_get_style_bg_img_src(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const struct _lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint32_t part = (uint32_t)mp_obj_get_int(mp_args[1]);
    const void * _res = ((const void *(*)(const struct _lv_obj_t *, uint32_t))lv_func_ptr)(obj, part);
    return ptr_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_bg_img_src_obj, 2, mp_lv_obj_get_style_bg_img_src, lv_obj_get_style_bg_img_src);
    
/* Reusing lv_obj_get_style_bg_opa for lv_obj_get_style_bg_img_opa */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_bg_img_opa_obj, 2, mp_lv_obj_get_style_bg_opa, lv_obj_get_style_bg_img_opa);
    
/* Reusing lv_obj_get_style_bg_color for lv_obj_get_style_bg_img_recolor */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_bg_img_recolor_obj, 2, mp_lv_obj_get_style_bg_color, lv_obj_get_style_bg_img_recolor);
    
/* Reusing lv_obj_get_style_bg_color for lv_obj_get_style_bg_img_recolor_filtered */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_bg_img_recolor_filtered_obj, 2, mp_lv_obj_get_style_bg_color, lv_obj_get_style_bg_img_recolor_filtered);
    
/* Reusing lv_obj_get_style_bg_opa for lv_obj_get_style_bg_img_recolor_opa */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_bg_img_recolor_opa_obj, 2, mp_lv_obj_get_style_bg_opa, lv_obj_get_style_bg_img_recolor_opa);
    

/*
 * lvgl extension definition for:
 * inline static bool lv_obj_get_style_bg_img_tiled(const struct _lv_obj_t *obj, uint32_t part)
 */
 
STATIC mp_obj_t mp_lv_obj_get_style_bg_img_tiled(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const struct _lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint32_t part = (uint32_t)mp_obj_get_int(mp_args[1]);
    bool _res = ((bool (*)(const struct _lv_obj_t *, uint32_t))lv_func_ptr)(obj, part);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_bg_img_tiled_obj, 2, mp_lv_obj_get_style_bg_img_tiled, lv_obj_get_style_bg_img_tiled);
    
/* Reusing lv_obj_get_style_bg_color for lv_obj_get_style_border_color */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_border_color_obj, 2, mp_lv_obj_get_style_bg_color, lv_obj_get_style_border_color);
    
/* Reusing lv_obj_get_style_bg_color for lv_obj_get_style_border_color_filtered */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_border_color_filtered_obj, 2, mp_lv_obj_get_style_bg_color, lv_obj_get_style_border_color_filtered);
    
/* Reusing lv_obj_get_style_bg_opa for lv_obj_get_style_border_opa */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_border_opa_obj, 2, mp_lv_obj_get_style_bg_opa, lv_obj_get_style_border_opa);
    
/* Reusing lv_obj_get_style_width for lv_obj_get_style_border_width */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_border_width_obj, 2, mp_lv_obj_get_style_width, lv_obj_get_style_border_width);
    

/*
 * lvgl extension definition for:
 * inline static lv_border_side_t lv_obj_get_style_border_side(const struct _lv_obj_t *obj, uint32_t part)
 */
 
STATIC mp_obj_t mp_lv_obj_get_style_border_side(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const struct _lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint32_t part = (uint32_t)mp_obj_get_int(mp_args[1]);
    lv_border_side_t _res = ((lv_border_side_t (*)(const struct _lv_obj_t *, uint32_t))lv_func_ptr)(obj, part);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_border_side_obj, 2, mp_lv_obj_get_style_border_side, lv_obj_get_style_border_side);
    
/* Reusing lv_obj_get_style_bg_img_tiled for lv_obj_get_style_border_post */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_border_post_obj, 2, mp_lv_obj_get_style_bg_img_tiled, lv_obj_get_style_border_post);
    
/* Reusing lv_obj_get_style_width for lv_obj_get_style_outline_width */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_outline_width_obj, 2, mp_lv_obj_get_style_width, lv_obj_get_style_outline_width);
    
/* Reusing lv_obj_get_style_bg_color for lv_obj_get_style_outline_color */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_outline_color_obj, 2, mp_lv_obj_get_style_bg_color, lv_obj_get_style_outline_color);
    
/* Reusing lv_obj_get_style_bg_color for lv_obj_get_style_outline_color_filtered */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_outline_color_filtered_obj, 2, mp_lv_obj_get_style_bg_color, lv_obj_get_style_outline_color_filtered);
    
/* Reusing lv_obj_get_style_bg_opa for lv_obj_get_style_outline_opa */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_outline_opa_obj, 2, mp_lv_obj_get_style_bg_opa, lv_obj_get_style_outline_opa);
    
/* Reusing lv_obj_get_style_width for lv_obj_get_style_outline_pad */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_outline_pad_obj, 2, mp_lv_obj_get_style_width, lv_obj_get_style_outline_pad);
    
/* Reusing lv_obj_get_style_width for lv_obj_get_style_shadow_width */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_shadow_width_obj, 2, mp_lv_obj_get_style_width, lv_obj_get_style_shadow_width);
    
/* Reusing lv_obj_get_style_width for lv_obj_get_style_shadow_ofs_x */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_shadow_ofs_x_obj, 2, mp_lv_obj_get_style_width, lv_obj_get_style_shadow_ofs_x);
    
/* Reusing lv_obj_get_style_width for lv_obj_get_style_shadow_ofs_y */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_shadow_ofs_y_obj, 2, mp_lv_obj_get_style_width, lv_obj_get_style_shadow_ofs_y);
    
/* Reusing lv_obj_get_style_width for lv_obj_get_style_shadow_spread */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_shadow_spread_obj, 2, mp_lv_obj_get_style_width, lv_obj_get_style_shadow_spread);
    
/* Reusing lv_obj_get_style_bg_color for lv_obj_get_style_shadow_color */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_shadow_color_obj, 2, mp_lv_obj_get_style_bg_color, lv_obj_get_style_shadow_color);
    
/* Reusing lv_obj_get_style_bg_color for lv_obj_get_style_shadow_color_filtered */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_shadow_color_filtered_obj, 2, mp_lv_obj_get_style_bg_color, lv_obj_get_style_shadow_color_filtered);
    
/* Reusing lv_obj_get_style_bg_opa for lv_obj_get_style_shadow_opa */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_shadow_opa_obj, 2, mp_lv_obj_get_style_bg_opa, lv_obj_get_style_shadow_opa);
    
/* Reusing lv_obj_get_style_bg_opa for lv_obj_get_style_img_opa */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_img_opa_obj, 2, mp_lv_obj_get_style_bg_opa, lv_obj_get_style_img_opa);
    
/* Reusing lv_obj_get_style_bg_color for lv_obj_get_style_img_recolor */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_img_recolor_obj, 2, mp_lv_obj_get_style_bg_color, lv_obj_get_style_img_recolor);
    
/* Reusing lv_obj_get_style_bg_color for lv_obj_get_style_img_recolor_filtered */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_img_recolor_filtered_obj, 2, mp_lv_obj_get_style_bg_color, lv_obj_get_style_img_recolor_filtered);
    
/* Reusing lv_obj_get_style_bg_opa for lv_obj_get_style_img_recolor_opa */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_img_recolor_opa_obj, 2, mp_lv_obj_get_style_bg_opa, lv_obj_get_style_img_recolor_opa);
    
/* Reusing lv_obj_get_style_width for lv_obj_get_style_line_width */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_line_width_obj, 2, mp_lv_obj_get_style_width, lv_obj_get_style_line_width);
    
/* Reusing lv_obj_get_style_width for lv_obj_get_style_line_dash_width */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_line_dash_width_obj, 2, mp_lv_obj_get_style_width, lv_obj_get_style_line_dash_width);
    
/* Reusing lv_obj_get_style_width for lv_obj_get_style_line_dash_gap */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_line_dash_gap_obj, 2, mp_lv_obj_get_style_width, lv_obj_get_style_line_dash_gap);
    
/* Reusing lv_obj_get_style_bg_img_tiled for lv_obj_get_style_line_rounded */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_line_rounded_obj, 2, mp_lv_obj_get_style_bg_img_tiled, lv_obj_get_style_line_rounded);
    
/* Reusing lv_obj_get_style_bg_color for lv_obj_get_style_line_color */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_line_color_obj, 2, mp_lv_obj_get_style_bg_color, lv_obj_get_style_line_color);
    
/* Reusing lv_obj_get_style_bg_color for lv_obj_get_style_line_color_filtered */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_line_color_filtered_obj, 2, mp_lv_obj_get_style_bg_color, lv_obj_get_style_line_color_filtered);
    
/* Reusing lv_obj_get_style_bg_opa for lv_obj_get_style_line_opa */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_line_opa_obj, 2, mp_lv_obj_get_style_bg_opa, lv_obj_get_style_line_opa);
    
/* Reusing lv_obj_get_style_width for lv_obj_get_style_arc_width */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_arc_width_obj, 2, mp_lv_obj_get_style_width, lv_obj_get_style_arc_width);
    
/* Reusing lv_obj_get_style_bg_img_tiled for lv_obj_get_style_arc_rounded */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_arc_rounded_obj, 2, mp_lv_obj_get_style_bg_img_tiled, lv_obj_get_style_arc_rounded);
    
/* Reusing lv_obj_get_style_bg_color for lv_obj_get_style_arc_color */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_arc_color_obj, 2, mp_lv_obj_get_style_bg_color, lv_obj_get_style_arc_color);
    
/* Reusing lv_obj_get_style_bg_color for lv_obj_get_style_arc_color_filtered */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_arc_color_filtered_obj, 2, mp_lv_obj_get_style_bg_color, lv_obj_get_style_arc_color_filtered);
    
/* Reusing lv_obj_get_style_bg_opa for lv_obj_get_style_arc_opa */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_arc_opa_obj, 2, mp_lv_obj_get_style_bg_opa, lv_obj_get_style_arc_opa);
    
/* Reusing lv_obj_get_style_bg_img_src for lv_obj_get_style_arc_img_src */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_arc_img_src_obj, 2, mp_lv_obj_get_style_bg_img_src, lv_obj_get_style_arc_img_src);
    
/* Reusing lv_obj_get_style_bg_color for lv_obj_get_style_text_color */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_text_color_obj, 2, mp_lv_obj_get_style_bg_color, lv_obj_get_style_text_color);
    
/* Reusing lv_obj_get_style_bg_color for lv_obj_get_style_text_color_filtered */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_text_color_filtered_obj, 2, mp_lv_obj_get_style_bg_color, lv_obj_get_style_text_color_filtered);
    
/* Reusing lv_obj_get_style_bg_opa for lv_obj_get_style_text_opa */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_text_opa_obj, 2, mp_lv_obj_get_style_bg_opa, lv_obj_get_style_text_opa);
    
#define funcptr_get_glyph_dsc NULL


/*
 * Struct lv_font_glyph_dsc_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_font_glyph_dsc_t_type();

STATIC inline lv_font_glyph_dsc_t* mp_write_ptr_lv_font_glyph_dsc_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_font_glyph_dsc_t_type()));
    return (lv_font_glyph_dsc_t*)self->data;
}

#define mp_write_lv_font_glyph_dsc_t(struct_obj) *mp_write_ptr_lv_font_glyph_dsc_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_font_glyph_dsc_t(lv_font_glyph_dsc_t *field)
{
    return lv_to_mp_struct(get_mp_lv_font_glyph_dsc_t_type(), (void*)field);
}

#define mp_read_lv_font_glyph_dsc_t(field) mp_read_ptr_lv_font_glyph_dsc_t(copy_buffer(&field, sizeof(lv_font_glyph_dsc_t)))
#define mp_read_byref_lv_font_glyph_dsc_t(field) mp_read_ptr_lv_font_glyph_dsc_t(&field)

STATIC void mp_lv_font_glyph_dsc_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_font_glyph_dsc_t *data = (lv_font_glyph_dsc_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_resolved_font: dest[0] = ptr_to_mp((void*)data->resolved_font); break; // converting from lv_font_t *;
            case MP_QSTR_adv_w: dest[0] = mp_obj_new_int_from_uint(data->adv_w); break; // converting from uint16_t;
            case MP_QSTR_box_w: dest[0] = mp_obj_new_int_from_uint(data->box_w); break; // converting from uint16_t;
            case MP_QSTR_box_h: dest[0] = mp_obj_new_int_from_uint(data->box_h); break; // converting from uint16_t;
            case MP_QSTR_ofs_x: dest[0] = mp_obj_new_int(data->ofs_x); break; // converting from int16_t;
            case MP_QSTR_ofs_y: dest[0] = mp_obj_new_int(data->ofs_y); break; // converting from int16_t;
            case MP_QSTR_bpp: dest[0] = mp_obj_new_int_from_uint(data->bpp); break; // converting from uint8_t;
            case MP_QSTR_is_placeholder: dest[0] = mp_obj_new_int_from_uint(data->is_placeholder); break; // converting from uint8_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_resolved_font: data->resolved_font = (void*)mp_to_ptr(dest[1]); break; // converting to lv_font_t *;
                case MP_QSTR_adv_w: data->adv_w = (uint16_t)mp_obj_get_int(dest[1]); break; // converting to uint16_t;
                case MP_QSTR_box_w: data->box_w = (uint16_t)mp_obj_get_int(dest[1]); break; // converting to uint16_t;
                case MP_QSTR_box_h: data->box_h = (uint16_t)mp_obj_get_int(dest[1]); break; // converting to uint16_t;
                case MP_QSTR_ofs_x: data->ofs_x = (int16_t)mp_obj_get_int(dest[1]); break; // converting to int16_t;
                case MP_QSTR_ofs_y: data->ofs_y = (int16_t)mp_obj_get_int(dest[1]); break; // converting to int16_t;
                case MP_QSTR_bpp: data->bpp = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                case MP_QSTR_is_placeholder: data->is_placeholder = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_font_glyph_dsc_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_font_glyph_dsc_t");
}

STATIC const mp_obj_dict_t mp_lv_font_glyph_dsc_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_font_glyph_dsc_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_font_glyph_dsc_t,
    .print = mp_lv_font_glyph_dsc_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_font_glyph_dsc_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_font_glyph_dsc_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_font_glyph_dsc_t_type()
{
    return &mp_lv_font_glyph_dsc_t_type;
}
    

/*
 * lvgl extension definition for:
 * bool get_glyph_dsc(const struct _lv_font_t *, lv_font_glyph_dsc_t *, uint32_t letter, uint32_t letter_next)
 */
 
STATIC mp_obj_t mp_funcptr_get_glyph_dsc(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const struct _lv_font_t *arg0 = mp_to_ptr(mp_args[0]);
    lv_font_glyph_dsc_t *arg1 = mp_write_ptr_lv_font_glyph_dsc_t(mp_args[1]);
    uint32_t letter = (uint32_t)mp_obj_get_int(mp_args[2]);
    uint32_t letter_next = (uint32_t)mp_obj_get_int(mp_args[3]);
    bool _res = ((bool (*)(const struct _lv_font_t *, lv_font_glyph_dsc_t *, uint32_t, uint32_t))lv_func_ptr)(arg0, arg1, letter, letter_next);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_get_glyph_dsc_obj, 4, mp_funcptr_get_glyph_dsc, funcptr_get_glyph_dsc);
    
STATIC inline mp_obj_t mp_lv_funcptr_get_glyph_dsc(void *func){ return mp_lv_funcptr(&mp_funcptr_get_glyph_dsc_obj, func, NULL, MP_QSTR_, NULL); }

STATIC bool lv_font_t_get_glyph_dsc_callback(const struct _lv_font_t *, lv_font_glyph_dsc_t *, uint32_t letter, uint32_t letter_next);
#define funcptr_get_glyph_bitmap NULL


/*
 * lvgl extension definition for:
 * const uint8_t *get_glyph_bitmap(const struct _lv_font_t *, uint32_t)
 */
 
STATIC mp_obj_t mp_funcptr_get_glyph_bitmap(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const struct _lv_font_t *arg0 = mp_to_ptr(mp_args[0]);
    uint32_t arg1 = (uint32_t)mp_obj_get_int(mp_args[1]);
    const uint8_t * _res = ((const uint8_t *(*)(const struct _lv_font_t *, uint32_t))lv_func_ptr)(arg0, arg1);
    return ptr_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_get_glyph_bitmap_obj, 2, mp_funcptr_get_glyph_bitmap, funcptr_get_glyph_bitmap);
    
STATIC inline mp_obj_t mp_lv_funcptr_get_glyph_bitmap(void *func){ return mp_lv_funcptr(&mp_funcptr_get_glyph_bitmap_obj, func, NULL, MP_QSTR_, NULL); }

STATIC const uint8_t * lv_font_t_get_glyph_bitmap_callback(const struct _lv_font_t *, uint32_t);

/*
 * Struct lv_font_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_font_t_type();

STATIC inline lv_font_t* mp_write_ptr_lv_font_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_font_t_type()));
    return (lv_font_t*)self->data;
}

#define mp_write_lv_font_t(struct_obj) *mp_write_ptr_lv_font_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_font_t(lv_font_t *field)
{
    return lv_to_mp_struct(get_mp_lv_font_t_type(), (void*)field);
}

#define mp_read_lv_font_t(field) mp_read_ptr_lv_font_t(copy_buffer(&field, sizeof(lv_font_t)))
#define mp_read_byref_lv_font_t(field) mp_read_ptr_lv_font_t(&field)

STATIC void mp_lv_font_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_font_t *data = (lv_font_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_get_glyph_dsc: dest[0] = mp_lv_funcptr(&mp_funcptr_get_glyph_dsc_obj, (void*)data->get_glyph_dsc, lv_font_t_get_glyph_dsc_callback ,MP_QSTR_lv_font_t_get_glyph_dsc, data->user_data); break; // converting from callback bool (*)(lv_font_t *, lv_font_glyph_dsc_t *, uint32_t letter, uint32_t letter_next);
            case MP_QSTR_get_glyph_bitmap: dest[0] = mp_lv_funcptr(&mp_funcptr_get_glyph_bitmap_obj, (void*)data->get_glyph_bitmap, lv_font_t_get_glyph_bitmap_callback ,MP_QSTR_lv_font_t_get_glyph_bitmap, data->user_data); break; // converting from callback uint8_t *(*)(lv_font_t *, uint32_t);
            case MP_QSTR_line_height: dest[0] = mp_obj_new_int(data->line_height); break; // converting from lv_coord_t;
            case MP_QSTR_base_line: dest[0] = mp_obj_new_int(data->base_line); break; // converting from lv_coord_t;
            case MP_QSTR_subpx: dest[0] = mp_obj_new_int_from_uint(data->subpx); break; // converting from uint8_t;
            case MP_QSTR_underline_position: dest[0] = mp_obj_new_int(data->underline_position); break; // converting from int8_t;
            case MP_QSTR_underline_thickness: dest[0] = mp_obj_new_int(data->underline_thickness); break; // converting from int8_t;
            case MP_QSTR_dsc: dest[0] = ptr_to_mp((void*)data->dsc); break; // converting from void *;
            case MP_QSTR_fallback: dest[0] = ptr_to_mp((void*)data->fallback); break; // converting from lv_font_t *;
            case MP_QSTR_user_data: dest[0] = ptr_to_mp((void*)data->user_data); break; // converting from void *;
            case MP_QSTR_font_lib_size: dest[0] = mp_obj_new_int_from_uint(data->font_lib_size); break; // converting from uint32_t;
            case MP_QSTR_font_lib_data: dest[0] = convert_to_str((void*)data->font_lib_data); break; // converting from char *;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_get_glyph_dsc: data->get_glyph_dsc = (void*)mp_lv_callback(dest[1], lv_font_t_get_glyph_dsc_callback ,MP_QSTR_lv_font_t_get_glyph_dsc, &data->user_data); break; // converting to callback bool (*)(lv_font_t *, lv_font_glyph_dsc_t *, uint32_t letter, uint32_t letter_next);
                case MP_QSTR_get_glyph_bitmap: data->get_glyph_bitmap = (void*)mp_lv_callback(dest[1], lv_font_t_get_glyph_bitmap_callback ,MP_QSTR_lv_font_t_get_glyph_bitmap, &data->user_data); break; // converting to callback uint8_t *(*)(lv_font_t *, uint32_t);
                case MP_QSTR_line_height: data->line_height = (int16_t)mp_obj_get_int(dest[1]); break; // converting to lv_coord_t;
                case MP_QSTR_base_line: data->base_line = (int16_t)mp_obj_get_int(dest[1]); break; // converting to lv_coord_t;
                case MP_QSTR_subpx: data->subpx = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                case MP_QSTR_underline_position: data->underline_position = (int8_t)mp_obj_get_int(dest[1]); break; // converting to int8_t;
                case MP_QSTR_underline_thickness: data->underline_thickness = (int8_t)mp_obj_get_int(dest[1]); break; // converting to int8_t;
                case MP_QSTR_dsc: data->dsc = (void*)mp_to_ptr(dest[1]); break; // converting to void *;
                case MP_QSTR_fallback: data->fallback = (void*)mp_to_ptr(dest[1]); break; // converting to lv_font_t *;
                case MP_QSTR_user_data: data->user_data = (void*)mp_to_ptr(dest[1]); break; // converting to void *;
                case MP_QSTR_font_lib_size: data->font_lib_size = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_font_lib_data: data->font_lib_data = (void*)(char*)convert_from_str(dest[1]); break; // converting to char *;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_font_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_font_t");
}

STATIC const mp_obj_dict_t mp_lv_font_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_font_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_font_t,
    .print = mp_lv_font_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_font_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_font_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_font_t_type()
{
    return &mp_lv_font_t_type;
}
    

/*
 * lvgl extension definition for:
 * inline static const lv_font_t *lv_obj_get_style_text_font(const struct _lv_obj_t *obj, uint32_t part)
 */
 
STATIC mp_obj_t mp_lv_obj_get_style_text_font(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const struct _lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint32_t part = (uint32_t)mp_obj_get_int(mp_args[1]);
    const lv_font_t * _res = ((const lv_font_t *(*)(const struct _lv_obj_t *, uint32_t))lv_func_ptr)(obj, part);
    return mp_read_ptr_lv_font_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_text_font_obj, 2, mp_lv_obj_get_style_text_font, lv_obj_get_style_text_font);
    
/* Reusing lv_obj_get_style_width for lv_obj_get_style_text_letter_space */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_text_letter_space_obj, 2, mp_lv_obj_get_style_width, lv_obj_get_style_text_letter_space);
    
/* Reusing lv_obj_get_style_width for lv_obj_get_style_text_line_space */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_text_line_space_obj, 2, mp_lv_obj_get_style_width, lv_obj_get_style_text_line_space);
    

/*
 * lvgl extension definition for:
 * inline static lv_text_decor_t lv_obj_get_style_text_decor(const struct _lv_obj_t *obj, uint32_t part)
 */
 
STATIC mp_obj_t mp_lv_obj_get_style_text_decor(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const struct _lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint32_t part = (uint32_t)mp_obj_get_int(mp_args[1]);
    lv_text_decor_t _res = ((lv_text_decor_t (*)(const struct _lv_obj_t *, uint32_t))lv_func_ptr)(obj, part);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_text_decor_obj, 2, mp_lv_obj_get_style_text_decor, lv_obj_get_style_text_decor);
    

/*
 * lvgl extension definition for:
 * inline static lv_text_align_t lv_obj_get_style_text_align(const struct _lv_obj_t *obj, uint32_t part)
 */
 
STATIC mp_obj_t mp_lv_obj_get_style_text_align(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const struct _lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint32_t part = (uint32_t)mp_obj_get_int(mp_args[1]);
    lv_text_align_t _res = ((lv_text_align_t (*)(const struct _lv_obj_t *, uint32_t))lv_func_ptr)(obj, part);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_text_align_obj, 2, mp_lv_obj_get_style_text_align, lv_obj_get_style_text_align);
    
/* Reusing lv_obj_get_style_width for lv_obj_get_style_radius */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_radius_obj, 2, mp_lv_obj_get_style_width, lv_obj_get_style_radius);
    
/* Reusing lv_obj_get_style_bg_img_tiled for lv_obj_get_style_clip_corner */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_clip_corner_obj, 2, mp_lv_obj_get_style_bg_img_tiled, lv_obj_get_style_clip_corner);
    
/* Reusing lv_obj_get_style_bg_opa for lv_obj_get_style_opa */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_opa_obj, 2, mp_lv_obj_get_style_bg_opa, lv_obj_get_style_opa);
    
#define funcptr_lv_color_filter_cb_t NULL


/*
 * lvgl extension definition for:
 * lv_color_t lv_color_filter_cb_t(const struct _lv_color_filter_dsc_t *, lv_color_t, lv_opa_t)
 */
 
STATIC mp_obj_t mp_funcptr_lv_color_filter_cb_t(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const struct _lv_color_filter_dsc_t *arg0 = mp_to_ptr(mp_args[0]);
    lv_color_t arg1 = mp_write_lv_color16_t(mp_args[1]);
    lv_opa_t arg2 = (uint8_t)mp_obj_get_int(mp_args[2]);
    lv_color_t _res = ((lv_color_t (*)(const struct _lv_color_filter_dsc_t *, lv_color_t, lv_opa_t))lv_func_ptr)(arg0, arg1, arg2);
    return mp_read_lv_color16_t(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_lv_color_filter_cb_t_obj, 3, mp_funcptr_lv_color_filter_cb_t, funcptr_lv_color_filter_cb_t);
    
STATIC inline mp_obj_t mp_lv_funcptr_lv_color_filter_cb_t(void *func){ return mp_lv_funcptr(&mp_funcptr_lv_color_filter_cb_t_obj, func, NULL, MP_QSTR_, NULL); }

STATIC lv_color_t lv_color_filter_dsc_t_filter_cb_callback(const struct _lv_color_filter_dsc_t *, lv_color_t, lv_opa_t);

/*
 * Struct lv_color_filter_dsc_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_color_filter_dsc_t_type();

STATIC inline lv_color_filter_dsc_t* mp_write_ptr_lv_color_filter_dsc_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_color_filter_dsc_t_type()));
    return (lv_color_filter_dsc_t*)self->data;
}

#define mp_write_lv_color_filter_dsc_t(struct_obj) *mp_write_ptr_lv_color_filter_dsc_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_color_filter_dsc_t(lv_color_filter_dsc_t *field)
{
    return lv_to_mp_struct(get_mp_lv_color_filter_dsc_t_type(), (void*)field);
}

#define mp_read_lv_color_filter_dsc_t(field) mp_read_ptr_lv_color_filter_dsc_t(copy_buffer(&field, sizeof(lv_color_filter_dsc_t)))
#define mp_read_byref_lv_color_filter_dsc_t(field) mp_read_ptr_lv_color_filter_dsc_t(&field)

STATIC void mp_lv_color_filter_dsc_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_color_filter_dsc_t *data = (lv_color_filter_dsc_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_filter_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_lv_color_filter_cb_t_obj, data->filter_cb, lv_color_filter_dsc_t_filter_cb_callback ,MP_QSTR_lv_color_filter_dsc_t_filter_cb, data->user_data); break; // converting from callback lv_color_filter_cb_t;
            case MP_QSTR_user_data: dest[0] = ptr_to_mp((void*)data->user_data); break; // converting from void *;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_filter_cb: data->filter_cb = mp_lv_callback(dest[1], lv_color_filter_dsc_t_filter_cb_callback ,MP_QSTR_lv_color_filter_dsc_t_filter_cb, &data->user_data); break; // converting to callback lv_color_filter_cb_t;
                case MP_QSTR_user_data: data->user_data = (void*)mp_to_ptr(dest[1]); break; // converting to void *;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_color_filter_dsc_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_color_filter_dsc_t");
}

STATIC const mp_obj_dict_t mp_lv_color_filter_dsc_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_color_filter_dsc_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_color_filter_dsc_t,
    .print = mp_lv_color_filter_dsc_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_color_filter_dsc_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_color_filter_dsc_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_color_filter_dsc_t_type()
{
    return &mp_lv_color_filter_dsc_t_type;
}
    

/*
 * lvgl extension definition for:
 * inline static const lv_color_filter_dsc_t *lv_obj_get_style_color_filter_dsc(const struct _lv_obj_t *obj, uint32_t part)
 */
 
STATIC mp_obj_t mp_lv_obj_get_style_color_filter_dsc(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const struct _lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint32_t part = (uint32_t)mp_obj_get_int(mp_args[1]);
    const lv_color_filter_dsc_t * _res = ((const lv_color_filter_dsc_t *(*)(const struct _lv_obj_t *, uint32_t))lv_func_ptr)(obj, part);
    return mp_read_ptr_lv_color_filter_dsc_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_color_filter_dsc_obj, 2, mp_lv_obj_get_style_color_filter_dsc, lv_obj_get_style_color_filter_dsc);
    
/* Reusing lv_obj_get_style_bg_opa for lv_obj_get_style_color_filter_opa */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_color_filter_opa_obj, 2, mp_lv_obj_get_style_bg_opa, lv_obj_get_style_color_filter_opa);
    
#define funcptr_lv_anim_exec_xcb_t NULL


/*
 * lvgl extension definition for:
 * void lv_anim_exec_xcb_t(void *, int32_t)
 */
 
STATIC mp_obj_t mp_funcptr_lv_anim_exec_xcb_t(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    void *arg0 = mp_to_ptr(mp_args[0]);
    int32_t arg1 = (int32_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(void *, int32_t))lv_func_ptr)(arg0, arg1);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_lv_anim_exec_xcb_t_obj, 2, mp_funcptr_lv_anim_exec_xcb_t, funcptr_lv_anim_exec_xcb_t);
    
STATIC inline mp_obj_t mp_lv_funcptr_lv_anim_exec_xcb_t(void *func){ return mp_lv_funcptr(&mp_funcptr_lv_anim_exec_xcb_t_obj, func, NULL, MP_QSTR_, NULL); }


/*
 * Function NOT generated:
 * Missing 'user_data' as a field of the first parameter of the callback function 'lv_anim_t_exec_cb_callback'
 * lv_anim_exec_xcb_t exec_cb
 */
    
#define funcptr_lv_anim_start_cb_t NULL


/*
 * lvgl extension definition for:
 * void lv_anim_start_cb_t(struct _lv_anim_t *)
 */
 
STATIC mp_obj_t mp_funcptr_lv_anim_start_cb_t(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_anim_t *arg0 = mp_to_ptr(mp_args[0]);
    ((void (*)(struct _lv_anim_t *))lv_func_ptr)(arg0);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_lv_anim_start_cb_t_obj, 1, mp_funcptr_lv_anim_start_cb_t, funcptr_lv_anim_start_cb_t);
    
STATIC inline mp_obj_t mp_lv_funcptr_lv_anim_start_cb_t(void *func){ return mp_lv_funcptr(&mp_funcptr_lv_anim_start_cb_t_obj, func, NULL, MP_QSTR_, NULL); }

STATIC void lv_anim_t_start_cb_callback(struct _lv_anim_t *);
STATIC void lv_anim_t_ready_cb_callback(struct _lv_anim_t *);
STATIC void lv_anim_t_deleted_cb_callback(struct _lv_anim_t *);
#define funcptr_lv_anim_get_value_cb_t NULL


/*
 * lvgl extension definition for:
 * int32_t lv_anim_get_value_cb_t(struct _lv_anim_t *)
 */
 
STATIC mp_obj_t mp_funcptr_lv_anim_get_value_cb_t(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_anim_t *arg0 = mp_to_ptr(mp_args[0]);
    int32_t _res = ((int32_t (*)(struct _lv_anim_t *))lv_func_ptr)(arg0);
    return mp_obj_new_int(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_lv_anim_get_value_cb_t_obj, 1, mp_funcptr_lv_anim_get_value_cb_t, funcptr_lv_anim_get_value_cb_t);
    
STATIC inline mp_obj_t mp_lv_funcptr_lv_anim_get_value_cb_t(void *func){ return mp_lv_funcptr(&mp_funcptr_lv_anim_get_value_cb_t_obj, func, NULL, MP_QSTR_, NULL); }

STATIC int32_t lv_anim_t_get_value_cb_callback(struct _lv_anim_t *);
STATIC int32_t lv_anim_t_path_cb_callback(const struct _lv_anim_t *);

/*
 * Struct lv_anim_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_anim_t_type();

STATIC inline lv_anim_t* mp_write_ptr_lv_anim_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_anim_t_type()));
    return (lv_anim_t*)self->data;
}

#define mp_write_lv_anim_t(struct_obj) *mp_write_ptr_lv_anim_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_anim_t(lv_anim_t *field)
{
    return lv_to_mp_struct(get_mp_lv_anim_t_type(), (void*)field);
}

#define mp_read_lv_anim_t(field) mp_read_ptr_lv_anim_t(copy_buffer(&field, sizeof(lv_anim_t)))
#define mp_read_byref_lv_anim_t(field) mp_read_ptr_lv_anim_t(&field)

STATIC void mp_lv_anim_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_anim_t *data = (lv_anim_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_var: dest[0] = ptr_to_mp((void*)data->var); break; // converting from void *;
            case MP_QSTR_exec_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_lv_anim_exec_xcb_t_obj, data->exec_cb, NULL ,MP_QSTR_lv_anim_t_exec_cb, NULL); break; // converting from callback lv_anim_exec_xcb_t;
            case MP_QSTR_start_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_lv_anim_start_cb_t_obj, data->start_cb, lv_anim_t_start_cb_callback ,MP_QSTR_lv_anim_t_start_cb, data->user_data); break; // converting from callback lv_anim_start_cb_t;
            case MP_QSTR_ready_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_lv_anim_start_cb_t_obj, data->ready_cb, lv_anim_t_ready_cb_callback ,MP_QSTR_lv_anim_t_ready_cb, data->user_data); break; // converting from callback lv_anim_ready_cb_t;
            case MP_QSTR_deleted_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_lv_anim_start_cb_t_obj, data->deleted_cb, lv_anim_t_deleted_cb_callback ,MP_QSTR_lv_anim_t_deleted_cb, data->user_data); break; // converting from callback lv_anim_deleted_cb_t;
            case MP_QSTR_get_value_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_lv_anim_get_value_cb_t_obj, data->get_value_cb, lv_anim_t_get_value_cb_callback ,MP_QSTR_lv_anim_t_get_value_cb, data->user_data); break; // converting from callback lv_anim_get_value_cb_t;
            case MP_QSTR_user_data: dest[0] = ptr_to_mp((void*)data->user_data); break; // converting from void *;
            case MP_QSTR_path_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_lv_anim_get_value_cb_t_obj, data->path_cb, lv_anim_t_path_cb_callback ,MP_QSTR_lv_anim_t_path_cb, data->user_data); break; // converting from callback lv_anim_path_cb_t;
            case MP_QSTR_start_value: dest[0] = mp_obj_new_int(data->start_value); break; // converting from int32_t;
            case MP_QSTR_current_value: dest[0] = mp_obj_new_int(data->current_value); break; // converting from int32_t;
            case MP_QSTR_end_value: dest[0] = mp_obj_new_int(data->end_value); break; // converting from int32_t;
            case MP_QSTR_time: dest[0] = mp_obj_new_int(data->time); break; // converting from int32_t;
            case MP_QSTR_act_time: dest[0] = mp_obj_new_int(data->act_time); break; // converting from int32_t;
            case MP_QSTR_playback_delay: dest[0] = mp_obj_new_int_from_uint(data->playback_delay); break; // converting from uint32_t;
            case MP_QSTR_playback_time: dest[0] = mp_obj_new_int_from_uint(data->playback_time); break; // converting from uint32_t;
            case MP_QSTR_repeat_delay: dest[0] = mp_obj_new_int_from_uint(data->repeat_delay); break; // converting from uint32_t;
            case MP_QSTR_repeat_cnt: dest[0] = mp_obj_new_int_from_uint(data->repeat_cnt); break; // converting from uint16_t;
            case MP_QSTR_early_apply: dest[0] = mp_obj_new_int_from_uint(data->early_apply); break; // converting from uint8_t;
            case MP_QSTR_playback_now: dest[0] = mp_obj_new_int_from_uint(data->playback_now); break; // converting from uint8_t;
            case MP_QSTR_run_round: dest[0] = mp_obj_new_int_from_uint(data->run_round); break; // converting from uint8_t;
            case MP_QSTR_start_cb_called: dest[0] = mp_obj_new_int_from_uint(data->start_cb_called); break; // converting from uint8_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_var: data->var = (void*)mp_to_ptr(dest[1]); break; // converting to void *;
                case MP_QSTR_exec_cb: data->exec_cb = mp_lv_callback(dest[1], NULL ,MP_QSTR_lv_anim_t_exec_cb, NULL); break; // converting to callback lv_anim_exec_xcb_t;
                case MP_QSTR_start_cb: data->start_cb = mp_lv_callback(dest[1], lv_anim_t_start_cb_callback ,MP_QSTR_lv_anim_t_start_cb, &data->user_data); break; // converting to callback lv_anim_start_cb_t;
                case MP_QSTR_ready_cb: data->ready_cb = mp_lv_callback(dest[1], lv_anim_t_ready_cb_callback ,MP_QSTR_lv_anim_t_ready_cb, &data->user_data); break; // converting to callback lv_anim_ready_cb_t;
                case MP_QSTR_deleted_cb: data->deleted_cb = mp_lv_callback(dest[1], lv_anim_t_deleted_cb_callback ,MP_QSTR_lv_anim_t_deleted_cb, &data->user_data); break; // converting to callback lv_anim_deleted_cb_t;
                case MP_QSTR_get_value_cb: data->get_value_cb = mp_lv_callback(dest[1], lv_anim_t_get_value_cb_callback ,MP_QSTR_lv_anim_t_get_value_cb, &data->user_data); break; // converting to callback lv_anim_get_value_cb_t;
                case MP_QSTR_user_data: data->user_data = (void*)mp_to_ptr(dest[1]); break; // converting to void *;
                case MP_QSTR_path_cb: data->path_cb = mp_lv_callback(dest[1], lv_anim_t_path_cb_callback ,MP_QSTR_lv_anim_t_path_cb, &data->user_data); break; // converting to callback lv_anim_path_cb_t;
                case MP_QSTR_start_value: data->start_value = (int32_t)mp_obj_get_int(dest[1]); break; // converting to int32_t;
                case MP_QSTR_current_value: data->current_value = (int32_t)mp_obj_get_int(dest[1]); break; // converting to int32_t;
                case MP_QSTR_end_value: data->end_value = (int32_t)mp_obj_get_int(dest[1]); break; // converting to int32_t;
                case MP_QSTR_time: data->time = (int32_t)mp_obj_get_int(dest[1]); break; // converting to int32_t;
                case MP_QSTR_act_time: data->act_time = (int32_t)mp_obj_get_int(dest[1]); break; // converting to int32_t;
                case MP_QSTR_playback_delay: data->playback_delay = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_playback_time: data->playback_time = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_repeat_delay: data->repeat_delay = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_repeat_cnt: data->repeat_cnt = (uint16_t)mp_obj_get_int(dest[1]); break; // converting to uint16_t;
                case MP_QSTR_early_apply: data->early_apply = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                case MP_QSTR_playback_now: data->playback_now = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                case MP_QSTR_run_round: data->run_round = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                case MP_QSTR_start_cb_called: data->start_cb_called = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_anim_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_anim_t");
}

STATIC const mp_obj_dict_t mp_lv_anim_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_anim_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_anim_t,
    .print = mp_lv_anim_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_anim_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_anim_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_anim_t_type()
{
    return &mp_lv_anim_t_type;
}
    

/*
 * lvgl extension definition for:
 * inline static const lv_anim_t *lv_obj_get_style_anim(const struct _lv_obj_t *obj, uint32_t part)
 */
 
STATIC mp_obj_t mp_lv_obj_get_style_anim(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const struct _lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint32_t part = (uint32_t)mp_obj_get_int(mp_args[1]);
    const lv_anim_t * _res = ((const lv_anim_t *(*)(const struct _lv_obj_t *, uint32_t))lv_func_ptr)(obj, part);
    return mp_read_ptr_lv_anim_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_anim_obj, 2, mp_lv_obj_get_style_anim, lv_obj_get_style_anim);
    

/*
 * lvgl extension definition for:
 * inline static uint32_t lv_obj_get_style_anim_time(const struct _lv_obj_t *obj, uint32_t part)
 */
 
STATIC mp_obj_t mp_lv_obj_get_style_anim_time(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const struct _lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint32_t part = (uint32_t)mp_obj_get_int(mp_args[1]);
    uint32_t _res = ((uint32_t (*)(const struct _lv_obj_t *, uint32_t))lv_func_ptr)(obj, part);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_anim_time_obj, 2, mp_lv_obj_get_style_anim_time, lv_obj_get_style_anim_time);
    
/* Reusing lv_obj_get_style_anim_time for lv_obj_get_style_anim_speed */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_anim_speed_obj, 2, mp_lv_obj_get_style_anim_time, lv_obj_get_style_anim_speed);
    

/*
 * Function NOT generated:
 * Missing 'user_data' as a field of the first parameter of the callback function 'lv_style_transition_dsc_t_path_xcb_callback'
 * lv_anim_path_cb_t path_xcb
 */
    

/*
 * Struct lv_style_transition_dsc_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_style_transition_dsc_t_type();

STATIC inline lv_style_transition_dsc_t* mp_write_ptr_lv_style_transition_dsc_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_style_transition_dsc_t_type()));
    return (lv_style_transition_dsc_t*)self->data;
}

#define mp_write_lv_style_transition_dsc_t(struct_obj) *mp_write_ptr_lv_style_transition_dsc_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_style_transition_dsc_t(lv_style_transition_dsc_t *field)
{
    return lv_to_mp_struct(get_mp_lv_style_transition_dsc_t_type(), (void*)field);
}

#define mp_read_lv_style_transition_dsc_t(field) mp_read_ptr_lv_style_transition_dsc_t(copy_buffer(&field, sizeof(lv_style_transition_dsc_t)))
#define mp_read_byref_lv_style_transition_dsc_t(field) mp_read_ptr_lv_style_transition_dsc_t(&field)

STATIC void mp_lv_style_transition_dsc_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_style_transition_dsc_t *data = (lv_style_transition_dsc_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_props: dest[0] = ptr_to_mp((void*)data->props); break; // converting from lv_style_prop_t *;
            case MP_QSTR_user_data: dest[0] = ptr_to_mp((void*)data->user_data); break; // converting from void *;
            case MP_QSTR_path_xcb: dest[0] = mp_lv_funcptr(&mp_funcptr_lv_anim_get_value_cb_t_obj, data->path_xcb, NULL ,MP_QSTR_lv_style_transition_dsc_t_path_xcb, NULL); break; // converting from callback lv_anim_path_cb_t;
            case MP_QSTR_time: dest[0] = mp_obj_new_int_from_uint(data->time); break; // converting from uint32_t;
            case MP_QSTR_delay: dest[0] = mp_obj_new_int_from_uint(data->delay); break; // converting from uint32_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_props: data->props = (void*)mp_to_ptr(dest[1]); break; // converting to lv_style_prop_t *;
                case MP_QSTR_user_data: data->user_data = (void*)mp_to_ptr(dest[1]); break; // converting to void *;
                case MP_QSTR_path_xcb: data->path_xcb = mp_lv_callback(dest[1], NULL ,MP_QSTR_lv_style_transition_dsc_t_path_xcb, NULL); break; // converting to callback lv_anim_path_cb_t;
                case MP_QSTR_time: data->time = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_delay: data->delay = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_style_transition_dsc_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_style_transition_dsc_t");
}

STATIC const mp_obj_dict_t mp_lv_style_transition_dsc_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_style_transition_dsc_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_style_transition_dsc_t,
    .print = mp_lv_style_transition_dsc_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_style_transition_dsc_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_style_transition_dsc_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_style_transition_dsc_t_type()
{
    return &mp_lv_style_transition_dsc_t_type;
}
    

/*
 * lvgl extension definition for:
 * inline static const lv_style_transition_dsc_t *lv_obj_get_style_transition(const struct _lv_obj_t *obj, uint32_t part)
 */
 
STATIC mp_obj_t mp_lv_obj_get_style_transition(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const struct _lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint32_t part = (uint32_t)mp_obj_get_int(mp_args[1]);
    const lv_style_transition_dsc_t * _res = ((const lv_style_transition_dsc_t *(*)(const struct _lv_obj_t *, uint32_t))lv_func_ptr)(obj, part);
    return mp_read_ptr_lv_style_transition_dsc_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_transition_obj, 2, mp_lv_obj_get_style_transition, lv_obj_get_style_transition);
    

/*
 * lvgl extension definition for:
 * inline static lv_blend_mode_t lv_obj_get_style_blend_mode(const struct _lv_obj_t *obj, uint32_t part)
 */
 
STATIC mp_obj_t mp_lv_obj_get_style_blend_mode(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const struct _lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint32_t part = (uint32_t)mp_obj_get_int(mp_args[1]);
    lv_blend_mode_t _res = ((lv_blend_mode_t (*)(const struct _lv_obj_t *, uint32_t))lv_func_ptr)(obj, part);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_blend_mode_obj, 2, mp_lv_obj_get_style_blend_mode, lv_obj_get_style_blend_mode);
    

/*
 * lvgl extension definition for:
 * inline static uint16_t lv_obj_get_style_layout(const struct _lv_obj_t *obj, uint32_t part)
 */
 
STATIC mp_obj_t mp_lv_obj_get_style_layout(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const struct _lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint32_t part = (uint32_t)mp_obj_get_int(mp_args[1]);
    uint16_t _res = ((uint16_t (*)(const struct _lv_obj_t *, uint32_t))lv_func_ptr)(obj, part);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_layout_obj, 2, mp_lv_obj_get_style_layout, lv_obj_get_style_layout);
    

/*
 * lvgl extension definition for:
 * inline static lv_base_dir_t lv_obj_get_style_base_dir(const struct _lv_obj_t *obj, uint32_t part)
 */
 
STATIC mp_obj_t mp_lv_obj_get_style_base_dir(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const struct _lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint32_t part = (uint32_t)mp_obj_get_int(mp_args[1]);
    lv_base_dir_t _res = ((lv_base_dir_t (*)(const struct _lv_obj_t *, uint32_t))lv_func_ptr)(obj, part);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_base_dir_obj, 2, mp_lv_obj_get_style_base_dir, lv_obj_get_style_base_dir);
    

/*
 * lvgl extension definition for:
 * inline static void lv_obj_set_style_pad_all(struct _lv_obj_t *obj, lv_coord_t value, lv_style_selector_t selector)
 */
 
STATIC mp_obj_t mp_lv_obj_set_style_pad_all(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_coord_t value = (int16_t)mp_obj_get_int(mp_args[1]);
    lv_style_selector_t selector = (uint32_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(struct _lv_obj_t *, lv_coord_t, lv_style_selector_t))lv_func_ptr)(obj, value, selector);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_pad_all_obj, 3, mp_lv_obj_set_style_pad_all, lv_obj_set_style_pad_all);
    
/* Reusing lv_obj_set_style_pad_all for lv_obj_set_style_pad_hor */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_pad_hor_obj, 3, mp_lv_obj_set_style_pad_all, lv_obj_set_style_pad_hor);
    
/* Reusing lv_obj_set_style_pad_all for lv_obj_set_style_pad_ver */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_pad_ver_obj, 3, mp_lv_obj_set_style_pad_all, lv_obj_set_style_pad_ver);
    
/* Reusing lv_obj_set_style_pad_all for lv_obj_set_style_pad_gap */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_pad_gap_obj, 3, mp_lv_obj_set_style_pad_all, lv_obj_set_style_pad_gap);
    
/* Reusing lv_obj_set_style_pad_all for lv_obj_set_style_size */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_size_obj, 3, mp_lv_obj_set_style_pad_all, lv_obj_set_style_size);
    

/*
 * lvgl extension definition for:
 * inline static void lv_obj_set_user_data(lv_obj_t *obj, void *user_data)
 */
 
STATIC mp_obj_t mp_lv_obj_set_user_data(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    void *user_data = mp_to_ptr(mp_args[1]);
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    ((void (*)(lv_obj_t *, void *))lv_func_ptr)(obj, user_data);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_user_data_obj, 2, mp_lv_obj_set_user_data, lv_obj_set_user_data);
    

/*
 * lvgl extension definition for:
 * inline static void *lv_obj_get_user_data(lv_obj_t *obj)
 */
 
STATIC mp_obj_t mp_lv_obj_get_user_data(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    void * _res = ((void *(*)(lv_obj_t *))lv_func_ptr)(obj);
    return ptr_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_user_data_obj, 1, mp_lv_obj_get_user_data, lv_obj_get_user_data);
    

/*
 * lvgl extension definition for:
 * inline static lv_coord_t lv_obj_dpx(const lv_obj_t *obj, lv_coord_t n)
 */
 
STATIC mp_obj_t mp_lv_obj_dpx(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_coord_t n = (int16_t)mp_obj_get_int(mp_args[1]);
    lv_coord_t _res = ((lv_coord_t (*)(const lv_obj_t *, lv_coord_t))lv_func_ptr)(obj, n);
    return mp_obj_new_int(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_dpx_obj, 2, mp_lv_obj_dpx, lv_obj_dpx);
    

/*
 * lvgl extension definition for:
 * inline static void lv_obj_move_foreground(lv_obj_t *obj)
 */
 
STATIC mp_obj_t mp_lv_obj_move_foreground(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    ((void (*)(lv_obj_t *))lv_func_ptr)(obj);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_move_foreground_obj, 1, mp_lv_obj_move_foreground, lv_obj_move_foreground);
    
/* Reusing lv_obj_move_foreground for lv_obj_move_background */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_move_background_obj, 1, mp_lv_obj_move_foreground, lv_obj_move_background);
    

/*
 * lvgl extension definition for:
 * inline static uint32_t lv_obj_get_child_id(const struct _lv_obj_t *obj)
 */
 
STATIC mp_obj_t mp_lv_obj_get_child_id(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const struct _lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint32_t _res = ((uint32_t (*)(const struct _lv_obj_t *))lv_func_ptr)(obj);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_child_id_obj, 1, mp_lv_obj_get_child_id, lv_obj_get_child_id);
    

/*
 * lvgl extension definition for:
 * inline static lv_flex_flow_t lv_obj_get_style_flex_flow(const lv_obj_t *obj, uint32_t part)
 */
 
STATIC mp_obj_t mp_lv_obj_get_style_flex_flow(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint32_t part = (uint32_t)mp_obj_get_int(mp_args[1]);
    lv_flex_flow_t _res = ((lv_flex_flow_t (*)(const lv_obj_t *, uint32_t))lv_func_ptr)(obj, part);
    return mp_obj_new_int(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_flex_flow_obj, 2, mp_lv_obj_get_style_flex_flow, lv_obj_get_style_flex_flow);
    

/*
 * lvgl extension definition for:
 * inline static lv_flex_align_t lv_obj_get_style_flex_main_place(const lv_obj_t *obj, uint32_t part)
 */
 
STATIC mp_obj_t mp_lv_obj_get_style_flex_main_place(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint32_t part = (uint32_t)mp_obj_get_int(mp_args[1]);
    lv_flex_align_t _res = ((lv_flex_align_t (*)(const lv_obj_t *, uint32_t))lv_func_ptr)(obj, part);
    return mp_obj_new_int(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_flex_main_place_obj, 2, mp_lv_obj_get_style_flex_main_place, lv_obj_get_style_flex_main_place);
    
/* Reusing lv_obj_get_style_flex_main_place for lv_obj_get_style_flex_cross_place */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_flex_cross_place_obj, 2, mp_lv_obj_get_style_flex_main_place, lv_obj_get_style_flex_cross_place);
    
/* Reusing lv_obj_get_style_flex_main_place for lv_obj_get_style_flex_track_place */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_flex_track_place_obj, 2, mp_lv_obj_get_style_flex_main_place, lv_obj_get_style_flex_track_place);
    

/*
 * lvgl extension definition for:
 * inline static uint8_t lv_obj_get_style_flex_grow(const lv_obj_t *obj, uint32_t part)
 */
 
STATIC mp_obj_t mp_lv_obj_get_style_flex_grow(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint32_t part = (uint32_t)mp_obj_get_int(mp_args[1]);
    uint8_t _res = ((uint8_t (*)(const lv_obj_t *, uint32_t))lv_func_ptr)(obj, part);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_flex_grow_obj, 2, mp_lv_obj_get_style_flex_grow, lv_obj_get_style_flex_grow);
    

/*
 * Array convertors for lv_coord_t *
 */

STATIC const lv_coord_t *mp_arr_to_lv_coord_t_ptr(mp_obj_t mp_arr)
{
    mp_obj_t mp_len = mp_obj_len_maybe(mp_arr);
    if (mp_len == MP_OBJ_NULL) return mp_to_ptr(mp_arr);
    mp_int_t len = mp_obj_get_int(mp_len);
    
    lv_coord_t *lv_arr = (lv_coord_t*)m_malloc(len * sizeof(lv_coord_t));
    mp_obj_t iter = mp_getiter(mp_arr, NULL);
    mp_obj_t item;
    size_t i = 0;
    while ((item = mp_iternext(iter)) != MP_OBJ_STOP_ITERATION) {
        lv_arr[i++] = (int16_t)mp_obj_get_int(item);
    }
    return (const lv_coord_t *)lv_arr;
}
    
STATIC mp_obj_t mp_arr_from_lv_coord_t_ptr(const lv_coord_t *arr)
{
    mp_obj_t obj_arr[1];
    for (size_t i=0; i<1; i++){
        obj_arr[i] = mp_obj_new_int(arr[i]);
    }
    return mp_obj_new_list(1, obj_arr); // TODO: return custom iterable object!
}
    

/*
 * lvgl extension definition for:
 * inline static const lv_coord_t *lv_obj_get_style_grid_row_dsc_array(const lv_obj_t *obj, uint32_t part)
 */
 
STATIC mp_obj_t mp_lv_obj_get_style_grid_row_dsc_array(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint32_t part = (uint32_t)mp_obj_get_int(mp_args[1]);
    const lv_coord_t * _res = ((const lv_coord_t *(*)(const lv_obj_t *, uint32_t))lv_func_ptr)(obj, part);
    return mp_arr_from_lv_coord_t_ptr((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_grid_row_dsc_array_obj, 2, mp_lv_obj_get_style_grid_row_dsc_array, lv_obj_get_style_grid_row_dsc_array);
    
/* Reusing lv_obj_get_style_grid_row_dsc_array for lv_obj_get_style_grid_column_dsc_array */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_grid_column_dsc_array_obj, 2, mp_lv_obj_get_style_grid_row_dsc_array, lv_obj_get_style_grid_column_dsc_array);
    

/*
 * lvgl extension definition for:
 * inline static lv_grid_align_t lv_obj_get_style_grid_row_align(const lv_obj_t *obj, uint32_t part)
 */
 
STATIC mp_obj_t mp_lv_obj_get_style_grid_row_align(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint32_t part = (uint32_t)mp_obj_get_int(mp_args[1]);
    lv_grid_align_t _res = ((lv_grid_align_t (*)(const lv_obj_t *, uint32_t))lv_func_ptr)(obj, part);
    return mp_obj_new_int(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_grid_row_align_obj, 2, mp_lv_obj_get_style_grid_row_align, lv_obj_get_style_grid_row_align);
    
/* Reusing lv_obj_get_style_grid_row_align for lv_obj_get_style_grid_column_align */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_grid_column_align_obj, 2, mp_lv_obj_get_style_grid_row_align, lv_obj_get_style_grid_column_align);
    

/*
 * lvgl extension definition for:
 * inline static lv_coord_t lv_obj_get_style_grid_cell_column_pos(const lv_obj_t *obj, uint32_t part)
 */
 
STATIC mp_obj_t mp_lv_obj_get_style_grid_cell_column_pos(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint32_t part = (uint32_t)mp_obj_get_int(mp_args[1]);
    lv_coord_t _res = ((lv_coord_t (*)(const lv_obj_t *, uint32_t))lv_func_ptr)(obj, part);
    return mp_obj_new_int(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_grid_cell_column_pos_obj, 2, mp_lv_obj_get_style_grid_cell_column_pos, lv_obj_get_style_grid_cell_column_pos);
    
/* Reusing lv_obj_get_style_grid_cell_column_pos for lv_obj_get_style_grid_cell_column_span */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_grid_cell_column_span_obj, 2, mp_lv_obj_get_style_grid_cell_column_pos, lv_obj_get_style_grid_cell_column_span);
    
/* Reusing lv_obj_get_style_grid_cell_column_pos for lv_obj_get_style_grid_cell_row_pos */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_grid_cell_row_pos_obj, 2, mp_lv_obj_get_style_grid_cell_column_pos, lv_obj_get_style_grid_cell_row_pos);
    
/* Reusing lv_obj_get_style_grid_cell_column_pos for lv_obj_get_style_grid_cell_row_span */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_grid_cell_row_span_obj, 2, mp_lv_obj_get_style_grid_cell_column_pos, lv_obj_get_style_grid_cell_row_span);
    
/* Reusing lv_obj_get_style_grid_cell_column_pos for lv_obj_get_style_grid_cell_x_align */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_grid_cell_x_align_obj, 2, mp_lv_obj_get_style_grid_cell_column_pos, lv_obj_get_style_grid_cell_x_align);
    
/* Reusing lv_obj_get_style_grid_cell_column_pos for lv_obj_get_style_grid_cell_y_align */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_grid_cell_y_align_obj, 2, mp_lv_obj_get_style_grid_cell_column_pos, lv_obj_get_style_grid_cell_y_align);
    

/*
 * lvgl extension definition for:
 * void lv_obj_set_pos(struct _lv_obj_t *obj, lv_coord_t x, lv_coord_t y)
 */
 
STATIC mp_obj_t mp_lv_obj_set_pos(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_coord_t x = (int16_t)mp_obj_get_int(mp_args[1]);
    lv_coord_t y = (int16_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(struct _lv_obj_t *, lv_coord_t, lv_coord_t))lv_func_ptr)(obj, x, y);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_pos_obj, 3, mp_lv_obj_set_pos, lv_obj_set_pos);
    

/*
 * lvgl extension definition for:
 * void lv_obj_set_x(struct _lv_obj_t *obj, lv_coord_t x)
 */
 
STATIC mp_obj_t mp_lv_obj_set_x(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_coord_t x = (int16_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(struct _lv_obj_t *, lv_coord_t))lv_func_ptr)(obj, x);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_x_obj, 2, mp_lv_obj_set_x, lv_obj_set_x);
    
/* Reusing lv_obj_set_x for lv_obj_set_y */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_y_obj, 2, mp_lv_obj_set_x, lv_obj_set_y);
    
/* Reusing lv_obj_set_pos for lv_obj_set_size */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_size_obj, 3, mp_lv_obj_set_pos, lv_obj_set_size);
    

/*
 * lvgl extension definition for:
 * bool lv_obj_refr_size(struct _lv_obj_t *obj)
 */
 
STATIC mp_obj_t mp_lv_obj_refr_size(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_obj_t *obj = mp_to_lv(mp_args[0]);
    bool _res = ((bool (*)(struct _lv_obj_t *))lv_func_ptr)(obj);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_refr_size_obj, 1, mp_lv_obj_refr_size, lv_obj_refr_size);
    
/* Reusing lv_obj_set_x for lv_obj_set_width */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_width_obj, 2, mp_lv_obj_set_x, lv_obj_set_width);
    
/* Reusing lv_obj_set_x for lv_obj_set_height */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_height_obj, 2, mp_lv_obj_set_x, lv_obj_set_height);
    
/* Reusing lv_obj_set_x for lv_obj_set_content_width */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_content_width_obj, 2, mp_lv_obj_set_x, lv_obj_set_content_width);
    
/* Reusing lv_obj_set_x for lv_obj_set_content_height */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_content_height_obj, 2, mp_lv_obj_set_x, lv_obj_set_content_height);
    

/*
 * lvgl extension definition for:
 * void lv_obj_set_layout(struct _lv_obj_t *obj, uint32_t layout)
 */
 
STATIC mp_obj_t mp_lv_obj_set_layout(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint32_t layout = (uint32_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(struct _lv_obj_t *, uint32_t))lv_func_ptr)(obj, layout);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_layout_obj, 2, mp_lv_obj_set_layout, lv_obj_set_layout);
    

/*
 * lvgl extension definition for:
 * bool lv_obj_is_layout_positioned(const struct _lv_obj_t *obj)
 */
 
STATIC mp_obj_t mp_lv_obj_is_layout_positioned(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const struct _lv_obj_t *obj = mp_to_lv(mp_args[0]);
    bool _res = ((bool (*)(const struct _lv_obj_t *))lv_func_ptr)(obj);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_is_layout_positioned_obj, 1, mp_lv_obj_is_layout_positioned, lv_obj_is_layout_positioned);
    
/* Reusing lv_obj_center for lv_obj_mark_layout_as_dirty */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_mark_layout_as_dirty_obj, 1, mp_lv_obj_center, lv_obj_mark_layout_as_dirty);
    

/*
 * lvgl extension definition for:
 * void lv_obj_update_layout(const struct _lv_obj_t *obj)
 */
 
STATIC mp_obj_t mp_lv_obj_update_layout(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const struct _lv_obj_t *obj = mp_to_lv(mp_args[0]);
    ((void (*)(const struct _lv_obj_t *))lv_func_ptr)(obj);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_update_layout_obj, 1, mp_lv_obj_update_layout, lv_obj_update_layout);
    

/*
 * lvgl extension definition for:
 * void lv_obj_set_align(struct _lv_obj_t *obj, lv_align_t align)
 */
 
STATIC mp_obj_t mp_lv_obj_set_align(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_align_t align = (uint8_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(struct _lv_obj_t *, lv_align_t))lv_func_ptr)(obj, align);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_align_obj, 2, mp_lv_obj_set_align, lv_obj_set_align);
    

/*
 * lvgl extension definition for:
 * void lv_obj_align(struct _lv_obj_t *obj, lv_align_t align, lv_coord_t x_ofs, lv_coord_t y_ofs)
 */
 
STATIC mp_obj_t mp_lv_obj_align(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_align_t align = (uint8_t)mp_obj_get_int(mp_args[1]);
    lv_coord_t x_ofs = (int16_t)mp_obj_get_int(mp_args[2]);
    lv_coord_t y_ofs = (int16_t)mp_obj_get_int(mp_args[3]);
    ((void (*)(struct _lv_obj_t *, lv_align_t, lv_coord_t, lv_coord_t))lv_func_ptr)(obj, align, x_ofs, y_ofs);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_align_obj, 4, mp_lv_obj_align, lv_obj_align);
    

/*
 * lvgl extension definition for:
 * void lv_obj_align_to(struct _lv_obj_t *obj, const struct _lv_obj_t *base, lv_align_t align, lv_coord_t x_ofs, lv_coord_t y_ofs)
 */
 
STATIC mp_obj_t mp_lv_obj_align_to(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_obj_t *obj = mp_to_lv(mp_args[0]);
    const struct _lv_obj_t *base = mp_to_lv(mp_args[1]);
    lv_align_t align = (uint8_t)mp_obj_get_int(mp_args[2]);
    lv_coord_t x_ofs = (int16_t)mp_obj_get_int(mp_args[3]);
    lv_coord_t y_ofs = (int16_t)mp_obj_get_int(mp_args[4]);
    ((void (*)(struct _lv_obj_t *, const struct _lv_obj_t *, lv_align_t, lv_coord_t, lv_coord_t))lv_func_ptr)(obj, base, align, x_ofs, y_ofs);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_align_to_obj, 5, mp_lv_obj_align_to, lv_obj_align_to);
    

/*
 * Struct lv_area_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_area_t_type();

STATIC inline lv_area_t* mp_write_ptr_lv_area_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_area_t_type()));
    return (lv_area_t*)self->data;
}

#define mp_write_lv_area_t(struct_obj) *mp_write_ptr_lv_area_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_area_t(lv_area_t *field)
{
    return lv_to_mp_struct(get_mp_lv_area_t_type(), (void*)field);
}

#define mp_read_lv_area_t(field) mp_read_ptr_lv_area_t(copy_buffer(&field, sizeof(lv_area_t)))
#define mp_read_byref_lv_area_t(field) mp_read_ptr_lv_area_t(&field)

STATIC void mp_lv_area_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_area_t *data = (lv_area_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_x1: dest[0] = mp_obj_new_int(data->x1); break; // converting from lv_coord_t;
            case MP_QSTR_y1: dest[0] = mp_obj_new_int(data->y1); break; // converting from lv_coord_t;
            case MP_QSTR_x2: dest[0] = mp_obj_new_int(data->x2); break; // converting from lv_coord_t;
            case MP_QSTR_y2: dest[0] = mp_obj_new_int(data->y2); break; // converting from lv_coord_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_x1: data->x1 = (int16_t)mp_obj_get_int(dest[1]); break; // converting to lv_coord_t;
                case MP_QSTR_y1: data->y1 = (int16_t)mp_obj_get_int(dest[1]); break; // converting to lv_coord_t;
                case MP_QSTR_x2: data->x2 = (int16_t)mp_obj_get_int(dest[1]); break; // converting to lv_coord_t;
                case MP_QSTR_y2: data->y2 = (int16_t)mp_obj_get_int(dest[1]); break; // converting to lv_coord_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_area_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_area_t");
}

STATIC const mp_obj_dict_t mp_lv_area_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_area_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_area_t,
    .print = mp_lv_area_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_area_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_area_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_area_t_type()
{
    return &mp_lv_area_t_type;
}
    

/*
 * lvgl extension definition for:
 * void lv_obj_get_coords(const struct _lv_obj_t *obj, lv_area_t *coords)
 */
 
STATIC mp_obj_t mp_lv_obj_get_coords(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const struct _lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_area_t *coords = mp_write_ptr_lv_area_t(mp_args[1]);
    ((void (*)(const struct _lv_obj_t *, lv_area_t *))lv_func_ptr)(obj, coords);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_coords_obj, 2, mp_lv_obj_get_coords, lv_obj_get_coords);
    

/*
 * lvgl extension definition for:
 * lv_coord_t lv_obj_get_x(const struct _lv_obj_t *obj)
 */
 
STATIC mp_obj_t mp_lv_obj_get_x(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const struct _lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_coord_t _res = ((lv_coord_t (*)(const struct _lv_obj_t *))lv_func_ptr)(obj);
    return mp_obj_new_int(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_x_obj, 1, mp_lv_obj_get_x, lv_obj_get_x);
    
/* Reusing lv_obj_get_x for lv_obj_get_x2 */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_x2_obj, 1, mp_lv_obj_get_x, lv_obj_get_x2);
    
/* Reusing lv_obj_get_x for lv_obj_get_y */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_y_obj, 1, mp_lv_obj_get_x, lv_obj_get_y);
    
/* Reusing lv_obj_get_x for lv_obj_get_y2 */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_y2_obj, 1, mp_lv_obj_get_x, lv_obj_get_y2);
    
/* Reusing lv_obj_get_x for lv_obj_get_x_aligned */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_x_aligned_obj, 1, mp_lv_obj_get_x, lv_obj_get_x_aligned);
    
/* Reusing lv_obj_get_x for lv_obj_get_y_aligned */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_y_aligned_obj, 1, mp_lv_obj_get_x, lv_obj_get_y_aligned);
    
/* Reusing lv_obj_get_x for lv_obj_get_width */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_width_obj, 1, mp_lv_obj_get_x, lv_obj_get_width);
    
/* Reusing lv_obj_get_x for lv_obj_get_height */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_height_obj, 1, mp_lv_obj_get_x, lv_obj_get_height);
    
/* Reusing lv_obj_get_x for lv_obj_get_content_width */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_content_width_obj, 1, mp_lv_obj_get_x, lv_obj_get_content_width);
    
/* Reusing lv_obj_get_x for lv_obj_get_content_height */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_content_height_obj, 1, mp_lv_obj_get_x, lv_obj_get_content_height);
    
/* Reusing lv_obj_get_coords for lv_obj_get_content_coords */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_content_coords_obj, 2, mp_lv_obj_get_coords, lv_obj_get_content_coords);
    
/* Reusing lv_obj_get_x for lv_obj_get_self_width */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_self_width_obj, 1, mp_lv_obj_get_x, lv_obj_get_self_width);
    
/* Reusing lv_obj_get_x for lv_obj_get_self_height */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_self_height_obj, 1, mp_lv_obj_get_x, lv_obj_get_self_height);
    
/* Reusing lv_obj_refr_size for lv_obj_refresh_self_size */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_refresh_self_size_obj, 1, mp_lv_obj_refr_size, lv_obj_refresh_self_size);
    
/* Reusing lv_obj_center for lv_obj_refr_pos */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_refr_pos_obj, 1, mp_lv_obj_center, lv_obj_refr_pos);
    
/* Reusing lv_obj_set_pos for lv_obj_move_to */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_move_to_obj, 3, mp_lv_obj_set_pos, lv_obj_move_to);
    

/*
 * lvgl extension definition for:
 * void lv_obj_move_children_by(struct _lv_obj_t *obj, lv_coord_t x_diff, lv_coord_t y_diff, bool ignore_floating)
 */
 
STATIC mp_obj_t mp_lv_obj_move_children_by(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_coord_t x_diff = (int16_t)mp_obj_get_int(mp_args[1]);
    lv_coord_t y_diff = (int16_t)mp_obj_get_int(mp_args[2]);
    bool ignore_floating = mp_obj_is_true(mp_args[3]);
    ((void (*)(struct _lv_obj_t *, lv_coord_t, lv_coord_t, bool))lv_func_ptr)(obj, x_diff, y_diff, ignore_floating);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_move_children_by_obj, 4, mp_lv_obj_move_children_by, lv_obj_move_children_by);
    

/*
 * Struct lv_point_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_point_t_type();

STATIC inline lv_point_t* mp_write_ptr_lv_point_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_point_t_type()));
    return (lv_point_t*)self->data;
}

#define mp_write_lv_point_t(struct_obj) *mp_write_ptr_lv_point_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_point_t(lv_point_t *field)
{
    return lv_to_mp_struct(get_mp_lv_point_t_type(), (void*)field);
}

#define mp_read_lv_point_t(field) mp_read_ptr_lv_point_t(copy_buffer(&field, sizeof(lv_point_t)))
#define mp_read_byref_lv_point_t(field) mp_read_ptr_lv_point_t(&field)

STATIC void mp_lv_point_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_point_t *data = (lv_point_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_x: dest[0] = mp_obj_new_int(data->x); break; // converting from lv_coord_t;
            case MP_QSTR_y: dest[0] = mp_obj_new_int(data->y); break; // converting from lv_coord_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_x: data->x = (int16_t)mp_obj_get_int(dest[1]); break; // converting to lv_coord_t;
                case MP_QSTR_y: data->y = (int16_t)mp_obj_get_int(dest[1]); break; // converting to lv_coord_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_point_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_point_t");
}

STATIC const mp_obj_dict_t mp_lv_point_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_point_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_point_t,
    .print = mp_lv_point_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_point_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_point_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_point_t_type()
{
    return &mp_lv_point_t_type;
}
    

/*
 * lvgl extension definition for:
 * void lv_obj_transform_point(const struct _lv_obj_t *obj, lv_point_t *p, bool recursive, bool inv)
 */
 
STATIC mp_obj_t mp_lv_obj_transform_point(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const struct _lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_point_t *p = mp_write_ptr_lv_point_t(mp_args[1]);
    bool recursive = mp_obj_is_true(mp_args[2]);
    bool inv = mp_obj_is_true(mp_args[3]);
    ((void (*)(const struct _lv_obj_t *, lv_point_t *, bool, bool))lv_func_ptr)(obj, p, recursive, inv);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_transform_point_obj, 4, mp_lv_obj_transform_point, lv_obj_transform_point);
    

/*
 * lvgl extension definition for:
 * void lv_obj_get_transformed_area(const struct _lv_obj_t *obj, lv_area_t *area, bool recursive, bool inv)
 */
 
STATIC mp_obj_t mp_lv_obj_get_transformed_area(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const struct _lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_area_t *area = mp_write_ptr_lv_area_t(mp_args[1]);
    bool recursive = mp_obj_is_true(mp_args[2]);
    bool inv = mp_obj_is_true(mp_args[3]);
    ((void (*)(const struct _lv_obj_t *, lv_area_t *, bool, bool))lv_func_ptr)(obj, area, recursive, inv);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_transformed_area_obj, 4, mp_lv_obj_get_transformed_area, lv_obj_get_transformed_area);
    

/*
 * lvgl extension definition for:
 * void lv_obj_invalidate_area(const struct _lv_obj_t *obj, const lv_area_t *area)
 */
 
STATIC mp_obj_t mp_lv_obj_invalidate_area(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const struct _lv_obj_t *obj = mp_to_lv(mp_args[0]);
    const lv_area_t *area = mp_write_ptr_lv_area_t(mp_args[1]);
    ((void (*)(const struct _lv_obj_t *, const lv_area_t *))lv_func_ptr)(obj, area);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_invalidate_area_obj, 2, mp_lv_obj_invalidate_area, lv_obj_invalidate_area);
    
/* Reusing lv_obj_update_layout for lv_obj_invalidate */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_invalidate_obj, 1, mp_lv_obj_update_layout, lv_obj_invalidate);
    

/*
 * lvgl extension definition for:
 * bool lv_obj_area_is_visible(const struct _lv_obj_t *obj, lv_area_t *area)
 */
 
STATIC mp_obj_t mp_lv_obj_area_is_visible(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const struct _lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_area_t *area = mp_write_ptr_lv_area_t(mp_args[1]);
    bool _res = ((bool (*)(const struct _lv_obj_t *, lv_area_t *))lv_func_ptr)(obj, area);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_area_is_visible_obj, 2, mp_lv_obj_area_is_visible, lv_obj_area_is_visible);
    
/* Reusing lv_obj_is_layout_positioned for lv_obj_is_visible */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_is_visible_obj, 1, mp_lv_obj_is_layout_positioned, lv_obj_is_visible);
    
/* Reusing lv_obj_set_x for lv_obj_set_ext_click_area */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_ext_click_area_obj, 2, mp_lv_obj_set_x, lv_obj_set_ext_click_area);
    
/* Reusing lv_obj_get_coords for lv_obj_get_click_area */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_click_area_obj, 2, mp_lv_obj_get_coords, lv_obj_get_click_area);
    

/*
 * lvgl extension definition for:
 * bool lv_obj_hit_test(struct _lv_obj_t *obj, const lv_point_t *point)
 */
 
STATIC mp_obj_t mp_lv_obj_hit_test(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_obj_t *obj = mp_to_lv(mp_args[0]);
    const lv_point_t *point = mp_write_ptr_lv_point_t(mp_args[1]);
    bool _res = ((bool (*)(struct _lv_obj_t *, const lv_point_t *))lv_func_ptr)(obj, point);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_hit_test_obj, 2, mp_lv_obj_hit_test, lv_obj_hit_test);
    
/* Reusing lv_obj_center for lv_obj_del */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_del_obj, 1, mp_lv_obj_center, lv_obj_del);
    
/* Reusing lv_obj_center for lv_obj_clean */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_clean_obj, 1, mp_lv_obj_center, lv_obj_clean);
    
/* Reusing lv_obj_set_layout for lv_obj_del_delayed */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_del_delayed_obj, 2, mp_lv_obj_set_layout, lv_obj_del_delayed);
    

/*
 * lvgl extension definition for:
 * void lv_obj_del_anim_ready_cb(lv_anim_t *a)
 */
 
STATIC mp_obj_t mp_lv_obj_del_anim_ready_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_anim_t *a = mp_write_ptr_lv_anim_t(mp_args[0]);
    ((void (*)(lv_anim_t *))lv_func_ptr)(a);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_obj_del_anim_ready_cb_obj, 1, mp_lv_obj_del_anim_ready_cb, lv_obj_del_anim_ready_cb);
    
/* Reusing lv_obj_center for lv_obj_del_async */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_del_async_obj, 1, mp_lv_obj_center, lv_obj_del_async);
    

/*
 * lvgl extension definition for:
 * void lv_obj_set_parent(struct _lv_obj_t *obj, struct _lv_obj_t *parent)
 */
 
STATIC mp_obj_t mp_lv_obj_set_parent(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_obj_t *obj = mp_to_lv(mp_args[0]);
    struct _lv_obj_t *parent = mp_to_lv(mp_args[1]);
    ((void (*)(struct _lv_obj_t *, struct _lv_obj_t *))lv_func_ptr)(obj, parent);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_parent_obj, 2, mp_lv_obj_set_parent, lv_obj_set_parent);
    
/* Reusing lv_obj_set_parent for lv_obj_swap */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_swap_obj, 2, mp_lv_obj_set_parent, lv_obj_swap);
    

/*
 * lvgl extension definition for:
 * void lv_obj_move_to_index(struct _lv_obj_t *obj, int32_t index)
 */
 
STATIC mp_obj_t mp_lv_obj_move_to_index(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_obj_t *obj = mp_to_lv(mp_args[0]);
    int32_t index = (int32_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(struct _lv_obj_t *, int32_t))lv_func_ptr)(obj, index);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_move_to_index_obj, 2, mp_lv_obj_move_to_index, lv_obj_move_to_index);
    

/*
 * lvgl extension definition for:
 * struct _lv_obj_t *lv_obj_get_screen(const struct _lv_obj_t *obj)
 */
 
STATIC mp_obj_t mp_lv_obj_get_screen(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const struct _lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_obj_t * _res = ((struct _lv_obj_t *(*)(const struct _lv_obj_t *))lv_func_ptr)(obj);
    return lv_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_screen_obj, 1, mp_lv_obj_get_screen, lv_obj_get_screen);
    

/*
 * Struct lv_disp_draw_buf_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_disp_draw_buf_t_type();

STATIC inline lv_disp_draw_buf_t* mp_write_ptr_lv_disp_draw_buf_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_disp_draw_buf_t_type()));
    return (lv_disp_draw_buf_t*)self->data;
}

#define mp_write_lv_disp_draw_buf_t(struct_obj) *mp_write_ptr_lv_disp_draw_buf_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_disp_draw_buf_t(lv_disp_draw_buf_t *field)
{
    return lv_to_mp_struct(get_mp_lv_disp_draw_buf_t_type(), (void*)field);
}

#define mp_read_lv_disp_draw_buf_t(field) mp_read_ptr_lv_disp_draw_buf_t(copy_buffer(&field, sizeof(lv_disp_draw_buf_t)))
#define mp_read_byref_lv_disp_draw_buf_t(field) mp_read_ptr_lv_disp_draw_buf_t(&field)

STATIC void mp_lv_disp_draw_buf_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_disp_draw_buf_t *data = (lv_disp_draw_buf_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_buf1: dest[0] = ptr_to_mp((void*)data->buf1); break; // converting from void *;
            case MP_QSTR_buf2: dest[0] = ptr_to_mp((void*)data->buf2); break; // converting from void *;
            case MP_QSTR_buf_act: dest[0] = ptr_to_mp((void*)data->buf_act); break; // converting from void *;
            case MP_QSTR_size: dest[0] = mp_obj_new_int_from_uint(data->size); break; // converting from uint32_t;
            case MP_QSTR_flushing: dest[0] = mp_obj_new_int(data->flushing); break; // converting from int;
            case MP_QSTR_flushing_last: dest[0] = mp_obj_new_int(data->flushing_last); break; // converting from int;
            case MP_QSTR_last_area: dest[0] = mp_obj_new_int_from_uint(data->last_area); break; // converting from uint32_t;
            case MP_QSTR_last_part: dest[0] = mp_obj_new_int_from_uint(data->last_part); break; // converting from uint32_t;
            case MP_QSTR_cf: dest[0] = mp_obj_new_int_from_uint(data->cf); break; // converting from uint8_t;
            case MP_QSTR_width: dest[0] = mp_obj_new_int(data->width); break; // converting from lv_coord_t;
            case MP_QSTR_height: dest[0] = mp_obj_new_int(data->height); break; // converting from lv_coord_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_buf1: data->buf1 = (void*)mp_to_ptr(dest[1]); break; // converting to void *;
                case MP_QSTR_buf2: data->buf2 = (void*)mp_to_ptr(dest[1]); break; // converting to void *;
                case MP_QSTR_buf_act: data->buf_act = (void*)mp_to_ptr(dest[1]); break; // converting to void *;
                case MP_QSTR_size: data->size = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_flushing: data->flushing = (int)mp_obj_get_int(dest[1]); break; // converting to int;
                case MP_QSTR_flushing_last: data->flushing_last = (int)mp_obj_get_int(dest[1]); break; // converting to int;
                case MP_QSTR_last_area: data->last_area = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_last_part: data->last_part = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_cf: data->cf = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                case MP_QSTR_width: data->width = (int16_t)mp_obj_get_int(dest[1]); break; // converting to lv_coord_t;
                case MP_QSTR_height: data->height = (int16_t)mp_obj_get_int(dest[1]); break; // converting to lv_coord_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_disp_draw_buf_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_disp_draw_buf_t");
}

STATIC const mp_obj_dict_t mp_lv_disp_draw_buf_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_disp_draw_buf_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_disp_draw_buf_t,
    .print = mp_lv_disp_draw_buf_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_disp_draw_buf_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_disp_draw_buf_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_disp_draw_buf_t_type()
{
    return &mp_lv_disp_draw_buf_t_type;
}
    
#define funcptr_flush_cb NULL


/*
 * lvgl extension definition for:
 * void flush_cb(struct _lv_disp_drv_t *disp_drv, const lv_area_t *area, lv_color_t *color_p)
 */
 
STATIC mp_obj_t mp_funcptr_flush_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_disp_drv_t *disp_drv = mp_to_ptr(mp_args[0]);
    const lv_area_t *area = mp_write_ptr_lv_area_t(mp_args[1]);
    lv_color_t *color_p = mp_write_ptr_lv_color16_t(mp_args[2]);
    ((void (*)(struct _lv_disp_drv_t *, const lv_area_t *, lv_color_t *))lv_func_ptr)(disp_drv, area, color_p);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_flush_cb_obj, 3, mp_funcptr_flush_cb, funcptr_flush_cb);
    
STATIC inline mp_obj_t mp_lv_funcptr_flush_cb(void *func){ return mp_lv_funcptr(&mp_funcptr_flush_cb_obj, func, NULL, MP_QSTR_, NULL); }

STATIC void lv_disp_drv_t_flush_cb_callback(struct _lv_disp_drv_t *disp_drv, const lv_area_t *area, lv_color_t *color_p);
#define funcptr_rounder_cb NULL


/*
 * lvgl extension definition for:
 * void rounder_cb(struct _lv_disp_drv_t *disp_drv, lv_area_t *area)
 */
 
STATIC mp_obj_t mp_funcptr_rounder_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_disp_drv_t *disp_drv = mp_to_ptr(mp_args[0]);
    lv_area_t *area = mp_write_ptr_lv_area_t(mp_args[1]);
    ((void (*)(struct _lv_disp_drv_t *, lv_area_t *))lv_func_ptr)(disp_drv, area);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_rounder_cb_obj, 2, mp_funcptr_rounder_cb, funcptr_rounder_cb);
    
STATIC inline mp_obj_t mp_lv_funcptr_rounder_cb(void *func){ return mp_lv_funcptr(&mp_funcptr_rounder_cb_obj, func, NULL, MP_QSTR_, NULL); }

STATIC void lv_disp_drv_t_rounder_cb_callback(struct _lv_disp_drv_t *disp_drv, lv_area_t *area);
#define funcptr_set_px_cb NULL


/*
 * lvgl extension definition for:
 * void set_px_cb(struct _lv_disp_drv_t *disp_drv, uint8_t *buf, lv_coord_t buf_w, lv_coord_t x, lv_coord_t y, lv_color_t color, lv_opa_t opa)
 */
 
STATIC mp_obj_t mp_funcptr_set_px_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_disp_drv_t *disp_drv = mp_to_ptr(mp_args[0]);
    uint8_t *buf = mp_to_ptr(mp_args[1]);
    lv_coord_t buf_w = (int16_t)mp_obj_get_int(mp_args[2]);
    lv_coord_t x = (int16_t)mp_obj_get_int(mp_args[3]);
    lv_coord_t y = (int16_t)mp_obj_get_int(mp_args[4]);
    lv_color_t color = mp_write_lv_color16_t(mp_args[5]);
    lv_opa_t opa = (uint8_t)mp_obj_get_int(mp_args[6]);
    ((void (*)(struct _lv_disp_drv_t *, uint8_t *, lv_coord_t, lv_coord_t, lv_coord_t, lv_color_t, lv_opa_t))lv_func_ptr)(disp_drv, buf, buf_w, x, y, color, opa);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_set_px_cb_obj, 7, mp_funcptr_set_px_cb, funcptr_set_px_cb);
    
STATIC inline mp_obj_t mp_lv_funcptr_set_px_cb(void *func){ return mp_lv_funcptr(&mp_funcptr_set_px_cb_obj, func, NULL, MP_QSTR_, NULL); }

STATIC void lv_disp_drv_t_set_px_cb_callback(struct _lv_disp_drv_t *disp_drv, uint8_t *buf, lv_coord_t buf_w, lv_coord_t x, lv_coord_t y, lv_color_t color, lv_opa_t opa);
#define funcptr_clear_cb NULL


/*
 * lvgl extension definition for:
 * void clear_cb(struct _lv_disp_drv_t *disp_drv, uint8_t *buf, uint32_t size)
 */
 
STATIC mp_obj_t mp_funcptr_clear_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_disp_drv_t *disp_drv = mp_to_ptr(mp_args[0]);
    uint8_t *buf = mp_to_ptr(mp_args[1]);
    uint32_t size = (uint32_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(struct _lv_disp_drv_t *, uint8_t *, uint32_t))lv_func_ptr)(disp_drv, buf, size);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_clear_cb_obj, 3, mp_funcptr_clear_cb, funcptr_clear_cb);
    
STATIC inline mp_obj_t mp_lv_funcptr_clear_cb(void *func){ return mp_lv_funcptr(&mp_funcptr_clear_cb_obj, func, NULL, MP_QSTR_, NULL); }

STATIC void lv_disp_drv_t_clear_cb_callback(struct _lv_disp_drv_t *disp_drv, uint8_t *buf, uint32_t size);
#define funcptr_monitor_cb NULL


/*
 * lvgl extension definition for:
 * void monitor_cb(struct _lv_disp_drv_t *disp_drv, uint32_t time, uint32_t px)
 */
 
STATIC mp_obj_t mp_funcptr_monitor_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_disp_drv_t *disp_drv = mp_to_ptr(mp_args[0]);
    uint32_t time = (uint32_t)mp_obj_get_int(mp_args[1]);
    uint32_t px = (uint32_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(struct _lv_disp_drv_t *, uint32_t, uint32_t))lv_func_ptr)(disp_drv, time, px);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_monitor_cb_obj, 3, mp_funcptr_monitor_cb, funcptr_monitor_cb);
    
STATIC inline mp_obj_t mp_lv_funcptr_monitor_cb(void *func){ return mp_lv_funcptr(&mp_funcptr_monitor_cb_obj, func, NULL, MP_QSTR_, NULL); }

STATIC void lv_disp_drv_t_monitor_cb_callback(struct _lv_disp_drv_t *disp_drv, uint32_t time, uint32_t px);
#define funcptr_wait_cb NULL


/*
 * lvgl extension definition for:
 * void wait_cb(struct _lv_disp_drv_t *disp_drv)
 */
 
STATIC mp_obj_t mp_funcptr_wait_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_disp_drv_t *disp_drv = mp_to_ptr(mp_args[0]);
    ((void (*)(struct _lv_disp_drv_t *))lv_func_ptr)(disp_drv);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_wait_cb_obj, 1, mp_funcptr_wait_cb, funcptr_wait_cb);
    
STATIC inline mp_obj_t mp_lv_funcptr_wait_cb(void *func){ return mp_lv_funcptr(&mp_funcptr_wait_cb_obj, func, NULL, MP_QSTR_, NULL); }

STATIC void lv_disp_drv_t_wait_cb_callback(struct _lv_disp_drv_t *disp_drv);
STATIC void lv_disp_drv_t_clean_dcache_cb_callback(struct _lv_disp_drv_t *disp_drv);
STATIC void lv_disp_drv_t_drv_update_cb_callback(struct _lv_disp_drv_t *disp_drv);
STATIC void lv_disp_drv_t_render_start_cb_callback(struct _lv_disp_drv_t *disp_drv);
#define funcptr_draw_rect NULL


/*
 * Struct lv_draw_rect_dsc_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_draw_rect_dsc_t_type();

STATIC inline lv_draw_rect_dsc_t* mp_write_ptr_lv_draw_rect_dsc_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_draw_rect_dsc_t_type()));
    return (lv_draw_rect_dsc_t*)self->data;
}

#define mp_write_lv_draw_rect_dsc_t(struct_obj) *mp_write_ptr_lv_draw_rect_dsc_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_draw_rect_dsc_t(lv_draw_rect_dsc_t *field)
{
    return lv_to_mp_struct(get_mp_lv_draw_rect_dsc_t_type(), (void*)field);
}

#define mp_read_lv_draw_rect_dsc_t(field) mp_read_ptr_lv_draw_rect_dsc_t(copy_buffer(&field, sizeof(lv_draw_rect_dsc_t)))
#define mp_read_byref_lv_draw_rect_dsc_t(field) mp_read_ptr_lv_draw_rect_dsc_t(&field)

STATIC void mp_lv_draw_rect_dsc_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_draw_rect_dsc_t *data = (lv_draw_rect_dsc_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_radius: dest[0] = mp_obj_new_int(data->radius); break; // converting from lv_coord_t;
            case MP_QSTR_blend_mode: dest[0] = mp_obj_new_int_from_uint(data->blend_mode); break; // converting from lv_blend_mode_t;
            case MP_QSTR_bg_opa: dest[0] = mp_obj_new_int_from_uint(data->bg_opa); break; // converting from lv_opa_t;
            case MP_QSTR_bg_color: dest[0] = mp_read_byref_lv_color16_t(data->bg_color); break; // converting from lv_color_t;
            case MP_QSTR_bg_grad: dest[0] = mp_read_byref_lv_grad_dsc_t(data->bg_grad); break; // converting from lv_grad_dsc_t;
            case MP_QSTR_bg_img_src: dest[0] = ptr_to_mp((void*)data->bg_img_src); break; // converting from void *;
            case MP_QSTR_bg_img_symbol_font: dest[0] = ptr_to_mp((void*)data->bg_img_symbol_font); break; // converting from void *;
            case MP_QSTR_bg_img_recolor: dest[0] = mp_read_byref_lv_color16_t(data->bg_img_recolor); break; // converting from lv_color_t;
            case MP_QSTR_bg_img_opa: dest[0] = mp_obj_new_int_from_uint(data->bg_img_opa); break; // converting from lv_opa_t;
            case MP_QSTR_bg_img_recolor_opa: dest[0] = mp_obj_new_int_from_uint(data->bg_img_recolor_opa); break; // converting from lv_opa_t;
            case MP_QSTR_bg_img_tiled: dest[0] = mp_obj_new_int_from_uint(data->bg_img_tiled); break; // converting from uint8_t;
            case MP_QSTR_border_color: dest[0] = mp_read_byref_lv_color16_t(data->border_color); break; // converting from lv_color_t;
            case MP_QSTR_border_width: dest[0] = mp_obj_new_int(data->border_width); break; // converting from lv_coord_t;
            case MP_QSTR_border_opa: dest[0] = mp_obj_new_int_from_uint(data->border_opa); break; // converting from lv_opa_t;
            case MP_QSTR_border_post: dest[0] = mp_obj_new_int_from_uint(data->border_post); break; // converting from uint8_t;
            case MP_QSTR_border_side: dest[0] = mp_obj_new_int_from_uint(data->border_side); break; // converting from lv_border_side_t;
            case MP_QSTR_outline_color: dest[0] = mp_read_byref_lv_color16_t(data->outline_color); break; // converting from lv_color_t;
            case MP_QSTR_outline_width: dest[0] = mp_obj_new_int(data->outline_width); break; // converting from lv_coord_t;
            case MP_QSTR_outline_pad: dest[0] = mp_obj_new_int(data->outline_pad); break; // converting from lv_coord_t;
            case MP_QSTR_outline_opa: dest[0] = mp_obj_new_int_from_uint(data->outline_opa); break; // converting from lv_opa_t;
            case MP_QSTR_shadow_color: dest[0] = mp_read_byref_lv_color16_t(data->shadow_color); break; // converting from lv_color_t;
            case MP_QSTR_shadow_width: dest[0] = mp_obj_new_int(data->shadow_width); break; // converting from lv_coord_t;
            case MP_QSTR_shadow_ofs_x: dest[0] = mp_obj_new_int(data->shadow_ofs_x); break; // converting from lv_coord_t;
            case MP_QSTR_shadow_ofs_y: dest[0] = mp_obj_new_int(data->shadow_ofs_y); break; // converting from lv_coord_t;
            case MP_QSTR_shadow_spread: dest[0] = mp_obj_new_int(data->shadow_spread); break; // converting from lv_coord_t;
            case MP_QSTR_shadow_opa: dest[0] = mp_obj_new_int_from_uint(data->shadow_opa); break; // converting from lv_opa_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_radius: data->radius = (int16_t)mp_obj_get_int(dest[1]); break; // converting to lv_coord_t;
                case MP_QSTR_blend_mode: data->blend_mode = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to lv_blend_mode_t;
                case MP_QSTR_bg_opa: data->bg_opa = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to lv_opa_t;
                case MP_QSTR_bg_color: data->bg_color = mp_write_lv_color16_t(dest[1]); break; // converting to lv_color_t;
                case MP_QSTR_bg_grad: data->bg_grad = mp_write_lv_grad_dsc_t(dest[1]); break; // converting to lv_grad_dsc_t;
                case MP_QSTR_bg_img_src: data->bg_img_src = (void*)mp_to_ptr(dest[1]); break; // converting to void *;
                case MP_QSTR_bg_img_symbol_font: data->bg_img_symbol_font = (void*)mp_to_ptr(dest[1]); break; // converting to void *;
                case MP_QSTR_bg_img_recolor: data->bg_img_recolor = mp_write_lv_color16_t(dest[1]); break; // converting to lv_color_t;
                case MP_QSTR_bg_img_opa: data->bg_img_opa = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to lv_opa_t;
                case MP_QSTR_bg_img_recolor_opa: data->bg_img_recolor_opa = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to lv_opa_t;
                case MP_QSTR_bg_img_tiled: data->bg_img_tiled = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                case MP_QSTR_border_color: data->border_color = mp_write_lv_color16_t(dest[1]); break; // converting to lv_color_t;
                case MP_QSTR_border_width: data->border_width = (int16_t)mp_obj_get_int(dest[1]); break; // converting to lv_coord_t;
                case MP_QSTR_border_opa: data->border_opa = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to lv_opa_t;
                case MP_QSTR_border_post: data->border_post = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                case MP_QSTR_border_side: data->border_side = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to lv_border_side_t;
                case MP_QSTR_outline_color: data->outline_color = mp_write_lv_color16_t(dest[1]); break; // converting to lv_color_t;
                case MP_QSTR_outline_width: data->outline_width = (int16_t)mp_obj_get_int(dest[1]); break; // converting to lv_coord_t;
                case MP_QSTR_outline_pad: data->outline_pad = (int16_t)mp_obj_get_int(dest[1]); break; // converting to lv_coord_t;
                case MP_QSTR_outline_opa: data->outline_opa = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to lv_opa_t;
                case MP_QSTR_shadow_color: data->shadow_color = mp_write_lv_color16_t(dest[1]); break; // converting to lv_color_t;
                case MP_QSTR_shadow_width: data->shadow_width = (int16_t)mp_obj_get_int(dest[1]); break; // converting to lv_coord_t;
                case MP_QSTR_shadow_ofs_x: data->shadow_ofs_x = (int16_t)mp_obj_get_int(dest[1]); break; // converting to lv_coord_t;
                case MP_QSTR_shadow_ofs_y: data->shadow_ofs_y = (int16_t)mp_obj_get_int(dest[1]); break; // converting to lv_coord_t;
                case MP_QSTR_shadow_spread: data->shadow_spread = (int16_t)mp_obj_get_int(dest[1]); break; // converting to lv_coord_t;
                case MP_QSTR_shadow_opa: data->shadow_opa = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to lv_opa_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_draw_rect_dsc_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_draw_rect_dsc_t");
}

STATIC const mp_obj_dict_t mp_lv_draw_rect_dsc_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_draw_rect_dsc_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_draw_rect_dsc_t,
    .print = mp_lv_draw_rect_dsc_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_draw_rect_dsc_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_draw_rect_dsc_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_draw_rect_dsc_t_type()
{
    return &mp_lv_draw_rect_dsc_t_type;
}
    

/*
 * lvgl extension definition for:
 * void draw_rect(struct _lv_draw_ctx_t *draw_ctx, const lv_draw_rect_dsc_t *dsc, const lv_area_t *coords)
 */
 
STATIC mp_obj_t mp_funcptr_draw_rect(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_draw_ctx_t *draw_ctx = mp_to_ptr(mp_args[0]);
    const lv_draw_rect_dsc_t *dsc = mp_write_ptr_lv_draw_rect_dsc_t(mp_args[1]);
    const lv_area_t *coords = mp_write_ptr_lv_area_t(mp_args[2]);
    ((void (*)(struct _lv_draw_ctx_t *, const lv_draw_rect_dsc_t *, const lv_area_t *))lv_func_ptr)(draw_ctx, dsc, coords);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_draw_rect_obj, 3, mp_funcptr_draw_rect, funcptr_draw_rect);
    
STATIC inline mp_obj_t mp_lv_funcptr_draw_rect(void *func){ return mp_lv_funcptr(&mp_funcptr_draw_rect_obj, func, NULL, MP_QSTR_, NULL); }

STATIC void lv_draw_ctx_t_draw_rect_callback(struct _lv_draw_ctx_t *draw_ctx, const lv_draw_rect_dsc_t *dsc, const lv_area_t *coords);
#define funcptr_draw_arc NULL


/*
 * Struct lv_draw_arc_dsc_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_draw_arc_dsc_t_type();

STATIC inline lv_draw_arc_dsc_t* mp_write_ptr_lv_draw_arc_dsc_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_draw_arc_dsc_t_type()));
    return (lv_draw_arc_dsc_t*)self->data;
}

#define mp_write_lv_draw_arc_dsc_t(struct_obj) *mp_write_ptr_lv_draw_arc_dsc_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_draw_arc_dsc_t(lv_draw_arc_dsc_t *field)
{
    return lv_to_mp_struct(get_mp_lv_draw_arc_dsc_t_type(), (void*)field);
}

#define mp_read_lv_draw_arc_dsc_t(field) mp_read_ptr_lv_draw_arc_dsc_t(copy_buffer(&field, sizeof(lv_draw_arc_dsc_t)))
#define mp_read_byref_lv_draw_arc_dsc_t(field) mp_read_ptr_lv_draw_arc_dsc_t(&field)

STATIC void mp_lv_draw_arc_dsc_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_draw_arc_dsc_t *data = (lv_draw_arc_dsc_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_color: dest[0] = mp_read_byref_lv_color16_t(data->color); break; // converting from lv_color_t;
            case MP_QSTR_width: dest[0] = mp_obj_new_int(data->width); break; // converting from lv_coord_t;
            case MP_QSTR_start_angle: dest[0] = mp_obj_new_int_from_uint(data->start_angle); break; // converting from uint16_t;
            case MP_QSTR_end_angle: dest[0] = mp_obj_new_int_from_uint(data->end_angle); break; // converting from uint16_t;
            case MP_QSTR_img_src: dest[0] = ptr_to_mp((void*)data->img_src); break; // converting from void *;
            case MP_QSTR_opa: dest[0] = mp_obj_new_int_from_uint(data->opa); break; // converting from lv_opa_t;
            case MP_QSTR_blend_mode: dest[0] = mp_obj_new_int_from_uint(data->blend_mode); break; // converting from lv_blend_mode_t;
            case MP_QSTR_rounded: dest[0] = mp_obj_new_int_from_uint(data->rounded); break; // converting from uint8_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_color: data->color = mp_write_lv_color16_t(dest[1]); break; // converting to lv_color_t;
                case MP_QSTR_width: data->width = (int16_t)mp_obj_get_int(dest[1]); break; // converting to lv_coord_t;
                case MP_QSTR_start_angle: data->start_angle = (uint16_t)mp_obj_get_int(dest[1]); break; // converting to uint16_t;
                case MP_QSTR_end_angle: data->end_angle = (uint16_t)mp_obj_get_int(dest[1]); break; // converting to uint16_t;
                case MP_QSTR_img_src: data->img_src = (void*)mp_to_ptr(dest[1]); break; // converting to void *;
                case MP_QSTR_opa: data->opa = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to lv_opa_t;
                case MP_QSTR_blend_mode: data->blend_mode = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to lv_blend_mode_t;
                case MP_QSTR_rounded: data->rounded = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_draw_arc_dsc_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_draw_arc_dsc_t");
}

STATIC const mp_obj_dict_t mp_lv_draw_arc_dsc_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_draw_arc_dsc_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_draw_arc_dsc_t,
    .print = mp_lv_draw_arc_dsc_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_draw_arc_dsc_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_draw_arc_dsc_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_draw_arc_dsc_t_type()
{
    return &mp_lv_draw_arc_dsc_t_type;
}
    

/*
 * lvgl extension definition for:
 * void draw_arc(struct _lv_draw_ctx_t *draw_ctx, const lv_draw_arc_dsc_t *dsc, const lv_point_t *center, uint16_t radius, uint16_t start_angle, uint16_t end_angle)
 */
 
STATIC mp_obj_t mp_funcptr_draw_arc(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_draw_ctx_t *draw_ctx = mp_to_ptr(mp_args[0]);
    const lv_draw_arc_dsc_t *dsc = mp_write_ptr_lv_draw_arc_dsc_t(mp_args[1]);
    const lv_point_t *center = mp_write_ptr_lv_point_t(mp_args[2]);
    uint16_t radius = (uint16_t)mp_obj_get_int(mp_args[3]);
    uint16_t start_angle = (uint16_t)mp_obj_get_int(mp_args[4]);
    uint16_t end_angle = (uint16_t)mp_obj_get_int(mp_args[5]);
    ((void (*)(struct _lv_draw_ctx_t *, const lv_draw_arc_dsc_t *, const lv_point_t *, uint16_t, uint16_t, uint16_t))lv_func_ptr)(draw_ctx, dsc, center, radius, start_angle, end_angle);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_draw_arc_obj, 6, mp_funcptr_draw_arc, funcptr_draw_arc);
    
STATIC inline mp_obj_t mp_lv_funcptr_draw_arc(void *func){ return mp_lv_funcptr(&mp_funcptr_draw_arc_obj, func, NULL, MP_QSTR_, NULL); }

STATIC void lv_draw_ctx_t_draw_arc_callback(struct _lv_draw_ctx_t *draw_ctx, const lv_draw_arc_dsc_t *dsc, const lv_point_t *center, uint16_t radius, uint16_t start_angle, uint16_t end_angle);
#define funcptr_draw_img_decoded NULL


/*
 * Struct lv_draw_img_dsc_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_draw_img_dsc_t_type();

STATIC inline lv_draw_img_dsc_t* mp_write_ptr_lv_draw_img_dsc_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_draw_img_dsc_t_type()));
    return (lv_draw_img_dsc_t*)self->data;
}

#define mp_write_lv_draw_img_dsc_t(struct_obj) *mp_write_ptr_lv_draw_img_dsc_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_draw_img_dsc_t(lv_draw_img_dsc_t *field)
{
    return lv_to_mp_struct(get_mp_lv_draw_img_dsc_t_type(), (void*)field);
}

#define mp_read_lv_draw_img_dsc_t(field) mp_read_ptr_lv_draw_img_dsc_t(copy_buffer(&field, sizeof(lv_draw_img_dsc_t)))
#define mp_read_byref_lv_draw_img_dsc_t(field) mp_read_ptr_lv_draw_img_dsc_t(&field)

STATIC void mp_lv_draw_img_dsc_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_draw_img_dsc_t *data = (lv_draw_img_dsc_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_angle: dest[0] = mp_obj_new_int(data->angle); break; // converting from int16_t;
            case MP_QSTR_zoom: dest[0] = mp_obj_new_int_from_uint(data->zoom); break; // converting from uint16_t;
            case MP_QSTR_pivot: dest[0] = mp_read_byref_lv_point_t(data->pivot); break; // converting from lv_point_t;
            case MP_QSTR_recolor: dest[0] = mp_read_byref_lv_color16_t(data->recolor); break; // converting from lv_color_t;
            case MP_QSTR_recolor_opa: dest[0] = mp_obj_new_int_from_uint(data->recolor_opa); break; // converting from lv_opa_t;
            case MP_QSTR_opa: dest[0] = mp_obj_new_int_from_uint(data->opa); break; // converting from lv_opa_t;
            case MP_QSTR_blend_mode: dest[0] = mp_obj_new_int_from_uint(data->blend_mode); break; // converting from lv_blend_mode_t;
            case MP_QSTR_frame_id: dest[0] = mp_obj_new_int(data->frame_id); break; // converting from int32_t;
            case MP_QSTR_antialias: dest[0] = mp_obj_new_int_from_uint(data->antialias); break; // converting from uint8_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_angle: data->angle = (int16_t)mp_obj_get_int(dest[1]); break; // converting to int16_t;
                case MP_QSTR_zoom: data->zoom = (uint16_t)mp_obj_get_int(dest[1]); break; // converting to uint16_t;
                case MP_QSTR_pivot: data->pivot = mp_write_lv_point_t(dest[1]); break; // converting to lv_point_t;
                case MP_QSTR_recolor: data->recolor = mp_write_lv_color16_t(dest[1]); break; // converting to lv_color_t;
                case MP_QSTR_recolor_opa: data->recolor_opa = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to lv_opa_t;
                case MP_QSTR_opa: data->opa = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to lv_opa_t;
                case MP_QSTR_blend_mode: data->blend_mode = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to lv_blend_mode_t;
                case MP_QSTR_frame_id: data->frame_id = (int32_t)mp_obj_get_int(dest[1]); break; // converting to int32_t;
                case MP_QSTR_antialias: data->antialias = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_draw_img_dsc_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_draw_img_dsc_t");
}

STATIC const mp_obj_dict_t mp_lv_draw_img_dsc_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_draw_img_dsc_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_draw_img_dsc_t,
    .print = mp_lv_draw_img_dsc_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_draw_img_dsc_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_draw_img_dsc_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_draw_img_dsc_t_type()
{
    return &mp_lv_draw_img_dsc_t_type;
}
    

/*
 * lvgl extension definition for:
 * void draw_img_decoded(struct _lv_draw_ctx_t *draw_ctx, const lv_draw_img_dsc_t *dsc, const lv_area_t *coords, const uint8_t *map_p, lv_img_cf_t color_format)
 */
 
STATIC mp_obj_t mp_funcptr_draw_img_decoded(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_draw_ctx_t *draw_ctx = mp_to_ptr(mp_args[0]);
    const lv_draw_img_dsc_t *dsc = mp_write_ptr_lv_draw_img_dsc_t(mp_args[1]);
    const lv_area_t *coords = mp_write_ptr_lv_area_t(mp_args[2]);
    const uint8_t *map_p = mp_to_ptr(mp_args[3]);
    lv_img_cf_t color_format = (uint8_t)mp_obj_get_int(mp_args[4]);
    ((void (*)(struct _lv_draw_ctx_t *, const lv_draw_img_dsc_t *, const lv_area_t *, const uint8_t *, lv_img_cf_t))lv_func_ptr)(draw_ctx, dsc, coords, map_p, color_format);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_draw_img_decoded_obj, 5, mp_funcptr_draw_img_decoded, funcptr_draw_img_decoded);
    
STATIC inline mp_obj_t mp_lv_funcptr_draw_img_decoded(void *func){ return mp_lv_funcptr(&mp_funcptr_draw_img_decoded_obj, func, NULL, MP_QSTR_, NULL); }

STATIC void lv_draw_ctx_t_draw_img_decoded_callback(struct _lv_draw_ctx_t *draw_ctx, const lv_draw_img_dsc_t *dsc, const lv_area_t *coords, const uint8_t *map_p, lv_img_cf_t color_format);
#define funcptr_draw_img NULL


/*
 * lvgl extension definition for:
 * lv_res_t draw_img(struct _lv_draw_ctx_t *draw_ctx, const lv_draw_img_dsc_t *draw_dsc, const lv_area_t *coords, const void *src)
 */
 
STATIC mp_obj_t mp_funcptr_draw_img(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_draw_ctx_t *draw_ctx = mp_to_ptr(mp_args[0]);
    const lv_draw_img_dsc_t *draw_dsc = mp_write_ptr_lv_draw_img_dsc_t(mp_args[1]);
    const lv_area_t *coords = mp_write_ptr_lv_area_t(mp_args[2]);
    const void *src = mp_to_ptr(mp_args[3]);
    lv_res_t _res = ((lv_res_t (*)(struct _lv_draw_ctx_t *, const lv_draw_img_dsc_t *, const lv_area_t *, const void *))lv_func_ptr)(draw_ctx, draw_dsc, coords, src);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_draw_img_obj, 4, mp_funcptr_draw_img, funcptr_draw_img);
    
STATIC inline mp_obj_t mp_lv_funcptr_draw_img(void *func){ return mp_lv_funcptr(&mp_funcptr_draw_img_obj, func, NULL, MP_QSTR_, NULL); }

STATIC lv_res_t lv_draw_ctx_t_draw_img_callback(struct _lv_draw_ctx_t *draw_ctx, const lv_draw_img_dsc_t *draw_dsc, const lv_area_t *coords, const void *src);
#define funcptr_draw_letter NULL


/*
 * Struct lv_draw_label_dsc_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_draw_label_dsc_t_type();

STATIC inline lv_draw_label_dsc_t* mp_write_ptr_lv_draw_label_dsc_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_draw_label_dsc_t_type()));
    return (lv_draw_label_dsc_t*)self->data;
}

#define mp_write_lv_draw_label_dsc_t(struct_obj) *mp_write_ptr_lv_draw_label_dsc_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_draw_label_dsc_t(lv_draw_label_dsc_t *field)
{
    return lv_to_mp_struct(get_mp_lv_draw_label_dsc_t_type(), (void*)field);
}

#define mp_read_lv_draw_label_dsc_t(field) mp_read_ptr_lv_draw_label_dsc_t(copy_buffer(&field, sizeof(lv_draw_label_dsc_t)))
#define mp_read_byref_lv_draw_label_dsc_t(field) mp_read_ptr_lv_draw_label_dsc_t(&field)

STATIC void mp_lv_draw_label_dsc_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_draw_label_dsc_t *data = (lv_draw_label_dsc_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_font: dest[0] = mp_read_ptr_lv_font_t((void*)data->font); break; // converting from lv_font_t *;
            case MP_QSTR_sel_start: dest[0] = mp_obj_new_int_from_uint(data->sel_start); break; // converting from uint32_t;
            case MP_QSTR_sel_end: dest[0] = mp_obj_new_int_from_uint(data->sel_end); break; // converting from uint32_t;
            case MP_QSTR_color: dest[0] = mp_read_byref_lv_color16_t(data->color); break; // converting from lv_color_t;
            case MP_QSTR_sel_color: dest[0] = mp_read_byref_lv_color16_t(data->sel_color); break; // converting from lv_color_t;
            case MP_QSTR_sel_bg_color: dest[0] = mp_read_byref_lv_color16_t(data->sel_bg_color); break; // converting from lv_color_t;
            case MP_QSTR_line_space: dest[0] = mp_obj_new_int(data->line_space); break; // converting from lv_coord_t;
            case MP_QSTR_letter_space: dest[0] = mp_obj_new_int(data->letter_space); break; // converting from lv_coord_t;
            case MP_QSTR_ofs_x: dest[0] = mp_obj_new_int(data->ofs_x); break; // converting from lv_coord_t;
            case MP_QSTR_ofs_y: dest[0] = mp_obj_new_int(data->ofs_y); break; // converting from lv_coord_t;
            case MP_QSTR_opa: dest[0] = mp_obj_new_int_from_uint(data->opa); break; // converting from lv_opa_t;
            case MP_QSTR_bidi_dir: dest[0] = mp_obj_new_int_from_uint(data->bidi_dir); break; // converting from lv_base_dir_t;
            case MP_QSTR_align: dest[0] = mp_obj_new_int_from_uint(data->align); break; // converting from lv_text_align_t;
            case MP_QSTR_flag: dest[0] = mp_obj_new_int_from_uint(data->flag); break; // converting from lv_text_flag_t;
            case MP_QSTR_decor: dest[0] = mp_obj_new_int_from_uint(data->decor); break; // converting from lv_text_decor_t;
            case MP_QSTR_blend_mode: dest[0] = mp_obj_new_int_from_uint(data->blend_mode); break; // converting from lv_blend_mode_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_font: data->font = (void*)mp_write_ptr_lv_font_t(dest[1]); break; // converting to lv_font_t *;
                case MP_QSTR_sel_start: data->sel_start = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_sel_end: data->sel_end = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_color: data->color = mp_write_lv_color16_t(dest[1]); break; // converting to lv_color_t;
                case MP_QSTR_sel_color: data->sel_color = mp_write_lv_color16_t(dest[1]); break; // converting to lv_color_t;
                case MP_QSTR_sel_bg_color: data->sel_bg_color = mp_write_lv_color16_t(dest[1]); break; // converting to lv_color_t;
                case MP_QSTR_line_space: data->line_space = (int16_t)mp_obj_get_int(dest[1]); break; // converting to lv_coord_t;
                case MP_QSTR_letter_space: data->letter_space = (int16_t)mp_obj_get_int(dest[1]); break; // converting to lv_coord_t;
                case MP_QSTR_ofs_x: data->ofs_x = (int16_t)mp_obj_get_int(dest[1]); break; // converting to lv_coord_t;
                case MP_QSTR_ofs_y: data->ofs_y = (int16_t)mp_obj_get_int(dest[1]); break; // converting to lv_coord_t;
                case MP_QSTR_opa: data->opa = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to lv_opa_t;
                case MP_QSTR_bidi_dir: data->bidi_dir = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to lv_base_dir_t;
                case MP_QSTR_align: data->align = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to lv_text_align_t;
                case MP_QSTR_flag: data->flag = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to lv_text_flag_t;
                case MP_QSTR_decor: data->decor = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to lv_text_decor_t;
                case MP_QSTR_blend_mode: data->blend_mode = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to lv_blend_mode_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_draw_label_dsc_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_draw_label_dsc_t");
}

STATIC const mp_obj_dict_t mp_lv_draw_label_dsc_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_draw_label_dsc_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_draw_label_dsc_t,
    .print = mp_lv_draw_label_dsc_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_draw_label_dsc_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_draw_label_dsc_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_draw_label_dsc_t_type()
{
    return &mp_lv_draw_label_dsc_t_type;
}
    

/*
 * lvgl extension definition for:
 * void draw_letter(struct _lv_draw_ctx_t *draw_ctx, const lv_draw_label_dsc_t *dsc, const lv_point_t *pos_p, uint32_t letter)
 */
 
STATIC mp_obj_t mp_funcptr_draw_letter(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_draw_ctx_t *draw_ctx = mp_to_ptr(mp_args[0]);
    const lv_draw_label_dsc_t *dsc = mp_write_ptr_lv_draw_label_dsc_t(mp_args[1]);
    const lv_point_t *pos_p = mp_write_ptr_lv_point_t(mp_args[2]);
    uint32_t letter = (uint32_t)mp_obj_get_int(mp_args[3]);
    ((void (*)(struct _lv_draw_ctx_t *, const lv_draw_label_dsc_t *, const lv_point_t *, uint32_t))lv_func_ptr)(draw_ctx, dsc, pos_p, letter);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_draw_letter_obj, 4, mp_funcptr_draw_letter, funcptr_draw_letter);
    
STATIC inline mp_obj_t mp_lv_funcptr_draw_letter(void *func){ return mp_lv_funcptr(&mp_funcptr_draw_letter_obj, func, NULL, MP_QSTR_, NULL); }

STATIC void lv_draw_ctx_t_draw_letter_callback(struct _lv_draw_ctx_t *draw_ctx, const lv_draw_label_dsc_t *dsc, const lv_point_t *pos_p, uint32_t letter);
#define funcptr_draw_line NULL


/*
 * Struct lv_draw_line_dsc_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_draw_line_dsc_t_type();

STATIC inline lv_draw_line_dsc_t* mp_write_ptr_lv_draw_line_dsc_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_draw_line_dsc_t_type()));
    return (lv_draw_line_dsc_t*)self->data;
}

#define mp_write_lv_draw_line_dsc_t(struct_obj) *mp_write_ptr_lv_draw_line_dsc_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_draw_line_dsc_t(lv_draw_line_dsc_t *field)
{
    return lv_to_mp_struct(get_mp_lv_draw_line_dsc_t_type(), (void*)field);
}

#define mp_read_lv_draw_line_dsc_t(field) mp_read_ptr_lv_draw_line_dsc_t(copy_buffer(&field, sizeof(lv_draw_line_dsc_t)))
#define mp_read_byref_lv_draw_line_dsc_t(field) mp_read_ptr_lv_draw_line_dsc_t(&field)

STATIC void mp_lv_draw_line_dsc_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_draw_line_dsc_t *data = (lv_draw_line_dsc_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_color: dest[0] = mp_read_byref_lv_color16_t(data->color); break; // converting from lv_color_t;
            case MP_QSTR_width: dest[0] = mp_obj_new_int(data->width); break; // converting from lv_coord_t;
            case MP_QSTR_dash_width: dest[0] = mp_obj_new_int(data->dash_width); break; // converting from lv_coord_t;
            case MP_QSTR_dash_gap: dest[0] = mp_obj_new_int(data->dash_gap); break; // converting from lv_coord_t;
            case MP_QSTR_opa: dest[0] = mp_obj_new_int_from_uint(data->opa); break; // converting from lv_opa_t;
            case MP_QSTR_blend_mode: dest[0] = mp_obj_new_int_from_uint(data->blend_mode); break; // converting from lv_blend_mode_t;
            case MP_QSTR_round_start: dest[0] = mp_obj_new_int_from_uint(data->round_start); break; // converting from uint8_t;
            case MP_QSTR_round_end: dest[0] = mp_obj_new_int_from_uint(data->round_end); break; // converting from uint8_t;
            case MP_QSTR_raw_end: dest[0] = mp_obj_new_int_from_uint(data->raw_end); break; // converting from uint8_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_color: data->color = mp_write_lv_color16_t(dest[1]); break; // converting to lv_color_t;
                case MP_QSTR_width: data->width = (int16_t)mp_obj_get_int(dest[1]); break; // converting to lv_coord_t;
                case MP_QSTR_dash_width: data->dash_width = (int16_t)mp_obj_get_int(dest[1]); break; // converting to lv_coord_t;
                case MP_QSTR_dash_gap: data->dash_gap = (int16_t)mp_obj_get_int(dest[1]); break; // converting to lv_coord_t;
                case MP_QSTR_opa: data->opa = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to lv_opa_t;
                case MP_QSTR_blend_mode: data->blend_mode = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to lv_blend_mode_t;
                case MP_QSTR_round_start: data->round_start = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                case MP_QSTR_round_end: data->round_end = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                case MP_QSTR_raw_end: data->raw_end = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_draw_line_dsc_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_draw_line_dsc_t");
}

STATIC const mp_obj_dict_t mp_lv_draw_line_dsc_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_draw_line_dsc_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_draw_line_dsc_t,
    .print = mp_lv_draw_line_dsc_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_draw_line_dsc_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_draw_line_dsc_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_draw_line_dsc_t_type()
{
    return &mp_lv_draw_line_dsc_t_type;
}
    

/*
 * lvgl extension definition for:
 * void draw_line(struct _lv_draw_ctx_t *draw_ctx, const lv_draw_line_dsc_t *dsc, const lv_point_t *point1, const lv_point_t *point2)
 */
 
STATIC mp_obj_t mp_funcptr_draw_line(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_draw_ctx_t *draw_ctx = mp_to_ptr(mp_args[0]);
    const lv_draw_line_dsc_t *dsc = mp_write_ptr_lv_draw_line_dsc_t(mp_args[1]);
    const lv_point_t *point1 = mp_write_ptr_lv_point_t(mp_args[2]);
    const lv_point_t *point2 = mp_write_ptr_lv_point_t(mp_args[3]);
    ((void (*)(struct _lv_draw_ctx_t *, const lv_draw_line_dsc_t *, const lv_point_t *, const lv_point_t *))lv_func_ptr)(draw_ctx, dsc, point1, point2);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_draw_line_obj, 4, mp_funcptr_draw_line, funcptr_draw_line);
    
STATIC inline mp_obj_t mp_lv_funcptr_draw_line(void *func){ return mp_lv_funcptr(&mp_funcptr_draw_line_obj, func, NULL, MP_QSTR_, NULL); }

STATIC void lv_draw_ctx_t_draw_line_callback(struct _lv_draw_ctx_t *draw_ctx, const lv_draw_line_dsc_t *dsc, const lv_point_t *point1, const lv_point_t *point2);
#define funcptr_draw_polygon NULL


/*
 * lvgl extension definition for:
 * void draw_polygon(struct _lv_draw_ctx_t *draw_ctx, const lv_draw_rect_dsc_t *draw_dsc, const lv_point_t *points, uint16_t point_cnt)
 */
 
STATIC mp_obj_t mp_funcptr_draw_polygon(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_draw_ctx_t *draw_ctx = mp_to_ptr(mp_args[0]);
    const lv_draw_rect_dsc_t *draw_dsc = mp_write_ptr_lv_draw_rect_dsc_t(mp_args[1]);
    const lv_point_t *points = mp_write_ptr_lv_point_t(mp_args[2]);
    uint16_t point_cnt = (uint16_t)mp_obj_get_int(mp_args[3]);
    ((void (*)(struct _lv_draw_ctx_t *, const lv_draw_rect_dsc_t *, const lv_point_t *, uint16_t))lv_func_ptr)(draw_ctx, draw_dsc, points, point_cnt);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_draw_polygon_obj, 4, mp_funcptr_draw_polygon, funcptr_draw_polygon);
    
STATIC inline mp_obj_t mp_lv_funcptr_draw_polygon(void *func){ return mp_lv_funcptr(&mp_funcptr_draw_polygon_obj, func, NULL, MP_QSTR_, NULL); }

STATIC void lv_draw_ctx_t_draw_polygon_callback(struct _lv_draw_ctx_t *draw_ctx, const lv_draw_rect_dsc_t *draw_dsc, const lv_point_t *points, uint16_t point_cnt);
#define funcptr_draw_transform NULL


/*
 * lvgl extension definition for:
 * void draw_transform(struct _lv_draw_ctx_t *draw_ctx, const lv_area_t *dest_area, const void *src_buf, lv_coord_t src_w, lv_coord_t src_h, lv_coord_t src_stride, const lv_draw_img_dsc_t *draw_dsc, lv_img_cf_t cf, lv_color_t *cbuf, lv_opa_t *abuf)
 */
 
STATIC mp_obj_t mp_funcptr_draw_transform(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_draw_ctx_t *draw_ctx = mp_to_ptr(mp_args[0]);
    const lv_area_t *dest_area = mp_write_ptr_lv_area_t(mp_args[1]);
    const void *src_buf = mp_to_ptr(mp_args[2]);
    lv_coord_t src_w = (int16_t)mp_obj_get_int(mp_args[3]);
    lv_coord_t src_h = (int16_t)mp_obj_get_int(mp_args[4]);
    lv_coord_t src_stride = (int16_t)mp_obj_get_int(mp_args[5]);
    const lv_draw_img_dsc_t *draw_dsc = mp_write_ptr_lv_draw_img_dsc_t(mp_args[6]);
    lv_img_cf_t cf = (uint8_t)mp_obj_get_int(mp_args[7]);
    lv_color_t *cbuf = mp_write_ptr_lv_color16_t(mp_args[8]);
    lv_opa_t *abuf = mp_to_ptr(mp_args[9]);
    ((void (*)(struct _lv_draw_ctx_t *, const lv_area_t *, const void *, lv_coord_t, lv_coord_t, lv_coord_t, const lv_draw_img_dsc_t *, lv_img_cf_t, lv_color_t *, lv_opa_t *))lv_func_ptr)(draw_ctx, dest_area, src_buf, src_w, src_h, src_stride, draw_dsc, cf, cbuf, abuf);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_draw_transform_obj, 10, mp_funcptr_draw_transform, funcptr_draw_transform);
    
STATIC inline mp_obj_t mp_lv_funcptr_draw_transform(void *func){ return mp_lv_funcptr(&mp_funcptr_draw_transform_obj, func, NULL, MP_QSTR_, NULL); }

STATIC void lv_draw_ctx_t_draw_transform_callback(struct _lv_draw_ctx_t *draw_ctx, const lv_area_t *dest_area, const void *src_buf, lv_coord_t src_w, lv_coord_t src_h, lv_coord_t src_stride, const lv_draw_img_dsc_t *draw_dsc, lv_img_cf_t cf, lv_color_t *cbuf, lv_opa_t *abuf);
#define funcptr_draw_bg NULL

/* Reusing funcptr_draw_rect for funcptr_draw_bg */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_draw_bg_obj, 3, mp_funcptr_draw_rect, funcptr_draw_bg);
    
STATIC inline mp_obj_t mp_lv_funcptr_draw_bg(void *func){ return mp_lv_funcptr(&mp_funcptr_draw_bg_obj, func, NULL, MP_QSTR_, NULL); }

STATIC void lv_draw_ctx_t_draw_bg_callback(struct _lv_draw_ctx_t *draw_ctx, const lv_draw_rect_dsc_t *draw_dsc, const lv_area_t *coords);
#define funcptr_wait_for_finish NULL


/*
 * lvgl extension definition for:
 * void wait_for_finish(struct _lv_draw_ctx_t *draw_ctx)
 */
 
STATIC mp_obj_t mp_funcptr_wait_for_finish(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_draw_ctx_t *draw_ctx = mp_to_ptr(mp_args[0]);
    ((void (*)(struct _lv_draw_ctx_t *))lv_func_ptr)(draw_ctx);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_wait_for_finish_obj, 1, mp_funcptr_wait_for_finish, funcptr_wait_for_finish);
    
STATIC inline mp_obj_t mp_lv_funcptr_wait_for_finish(void *func){ return mp_lv_funcptr(&mp_funcptr_wait_for_finish_obj, func, NULL, MP_QSTR_, NULL); }

STATIC void lv_draw_ctx_t_wait_for_finish_callback(struct _lv_draw_ctx_t *draw_ctx);
#define funcptr_buffer_copy NULL


/*
 * lvgl extension definition for:
 * void buffer_copy(struct _lv_draw_ctx_t *draw_ctx, void *dest_buf, lv_coord_t dest_stride, const lv_area_t *dest_area, void *src_buf, lv_coord_t src_stride, const lv_area_t *src_area)
 */
 
STATIC mp_obj_t mp_funcptr_buffer_copy(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_draw_ctx_t *draw_ctx = mp_to_ptr(mp_args[0]);
    void *dest_buf = mp_to_ptr(mp_args[1]);
    lv_coord_t dest_stride = (int16_t)mp_obj_get_int(mp_args[2]);
    const lv_area_t *dest_area = mp_write_ptr_lv_area_t(mp_args[3]);
    void *src_buf = mp_to_ptr(mp_args[4]);
    lv_coord_t src_stride = (int16_t)mp_obj_get_int(mp_args[5]);
    const lv_area_t *src_area = mp_write_ptr_lv_area_t(mp_args[6]);
    ((void (*)(struct _lv_draw_ctx_t *, void *, lv_coord_t, const lv_area_t *, void *, lv_coord_t, const lv_area_t *))lv_func_ptr)(draw_ctx, dest_buf, dest_stride, dest_area, src_buf, src_stride, src_area);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_buffer_copy_obj, 7, mp_funcptr_buffer_copy, funcptr_buffer_copy);
    
STATIC inline mp_obj_t mp_lv_funcptr_buffer_copy(void *func){ return mp_lv_funcptr(&mp_funcptr_buffer_copy_obj, func, NULL, MP_QSTR_, NULL); }

STATIC void lv_draw_ctx_t_buffer_copy_callback(struct _lv_draw_ctx_t *draw_ctx, void *dest_buf, lv_coord_t dest_stride, const lv_area_t *dest_area, void *src_buf, lv_coord_t src_stride, const lv_area_t *src_area);
#define funcptr_layer_init NULL

typedef __typeof__( ((lv_draw_layer_ctx_t*)(0))->original ) lv_draw_layer_ctx_original_t;

/*
 * Struct lv_draw_layer_ctx_original_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_draw_layer_ctx_original_t_type();

STATIC inline lv_draw_layer_ctx_original_t* mp_write_ptr_lv_draw_layer_ctx_original_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_draw_layer_ctx_original_t_type()));
    return (lv_draw_layer_ctx_original_t*)self->data;
}

#define mp_write_lv_draw_layer_ctx_original_t(struct_obj) *mp_write_ptr_lv_draw_layer_ctx_original_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_draw_layer_ctx_original_t(lv_draw_layer_ctx_original_t *field)
{
    return lv_to_mp_struct(get_mp_lv_draw_layer_ctx_original_t_type(), (void*)field);
}

#define mp_read_lv_draw_layer_ctx_original_t(field) mp_read_ptr_lv_draw_layer_ctx_original_t(copy_buffer(&field, sizeof(lv_draw_layer_ctx_original_t)))
#define mp_read_byref_lv_draw_layer_ctx_original_t(field) mp_read_ptr_lv_draw_layer_ctx_original_t(&field)

STATIC void mp_lv_draw_layer_ctx_original_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_draw_layer_ctx_original_t *data = (lv_draw_layer_ctx_original_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_clip_area: dest[0] = mp_read_ptr_lv_area_t((void*)data->clip_area); break; // converting from lv_area_t *;
            case MP_QSTR_buf_area: dest[0] = mp_read_ptr_lv_area_t((void*)data->buf_area); break; // converting from lv_area_t *;
            case MP_QSTR_buf: dest[0] = ptr_to_mp((void*)data->buf); break; // converting from void *;
            case MP_QSTR_screen_transp: dest[0] = convert_to_bool(data->screen_transp); break; // converting from bool;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_clip_area: data->clip_area = (void*)mp_write_ptr_lv_area_t(dest[1]); break; // converting to lv_area_t *;
                case MP_QSTR_buf_area: data->buf_area = (void*)mp_write_ptr_lv_area_t(dest[1]); break; // converting to lv_area_t *;
                case MP_QSTR_buf: data->buf = (void*)mp_to_ptr(dest[1]); break; // converting to void *;
                case MP_QSTR_screen_transp: data->screen_transp = mp_obj_is_true(dest[1]); break; // converting to bool;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_draw_layer_ctx_original_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_draw_layer_ctx_original_t");
}

STATIC const mp_obj_dict_t mp_lv_draw_layer_ctx_original_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_draw_layer_ctx_original_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_draw_layer_ctx_original_t,
    .print = mp_lv_draw_layer_ctx_original_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_draw_layer_ctx_original_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_draw_layer_ctx_original_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_draw_layer_ctx_original_t_type()
{
    return &mp_lv_draw_layer_ctx_original_t_type;
}
    

/*
 * Struct lv_draw_layer_ctx_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_draw_layer_ctx_t_type();

STATIC inline lv_draw_layer_ctx_t* mp_write_ptr_lv_draw_layer_ctx_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_draw_layer_ctx_t_type()));
    return (lv_draw_layer_ctx_t*)self->data;
}

#define mp_write_lv_draw_layer_ctx_t(struct_obj) *mp_write_ptr_lv_draw_layer_ctx_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_draw_layer_ctx_t(lv_draw_layer_ctx_t *field)
{
    return lv_to_mp_struct(get_mp_lv_draw_layer_ctx_t_type(), (void*)field);
}

#define mp_read_lv_draw_layer_ctx_t(field) mp_read_ptr_lv_draw_layer_ctx_t(copy_buffer(&field, sizeof(lv_draw_layer_ctx_t)))
#define mp_read_byref_lv_draw_layer_ctx_t(field) mp_read_ptr_lv_draw_layer_ctx_t(&field)

STATIC void mp_lv_draw_layer_ctx_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_draw_layer_ctx_t *data = (lv_draw_layer_ctx_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_area_full: dest[0] = mp_read_byref_lv_area_t(data->area_full); break; // converting from lv_area_t;
            case MP_QSTR_area_act: dest[0] = mp_read_byref_lv_area_t(data->area_act); break; // converting from lv_area_t;
            case MP_QSTR_max_row_with_alpha: dest[0] = mp_obj_new_int(data->max_row_with_alpha); break; // converting from lv_coord_t;
            case MP_QSTR_max_row_with_no_alpha: dest[0] = mp_obj_new_int(data->max_row_with_no_alpha); break; // converting from lv_coord_t;
            case MP_QSTR_buf: dest[0] = ptr_to_mp((void*)data->buf); break; // converting from void *;
            case MP_QSTR_original: dest[0] = mp_read_byref_lv_draw_layer_ctx_original_t(data->original); break; // converting from lv_draw_layer_ctx_original_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_area_full: data->area_full = mp_write_lv_area_t(dest[1]); break; // converting to lv_area_t;
                case MP_QSTR_area_act: data->area_act = mp_write_lv_area_t(dest[1]); break; // converting to lv_area_t;
                case MP_QSTR_max_row_with_alpha: data->max_row_with_alpha = (int16_t)mp_obj_get_int(dest[1]); break; // converting to lv_coord_t;
                case MP_QSTR_max_row_with_no_alpha: data->max_row_with_no_alpha = (int16_t)mp_obj_get_int(dest[1]); break; // converting to lv_coord_t;
                case MP_QSTR_buf: data->buf = (void*)mp_to_ptr(dest[1]); break; // converting to void *;
                case MP_QSTR_original: data->original = mp_write_lv_draw_layer_ctx_original_t(dest[1]); break; // converting to lv_draw_layer_ctx_original_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_draw_layer_ctx_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_draw_layer_ctx_t");
}

STATIC const mp_obj_dict_t mp_lv_draw_layer_ctx_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_draw_layer_ctx_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_draw_layer_ctx_t,
    .print = mp_lv_draw_layer_ctx_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_draw_layer_ctx_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_draw_layer_ctx_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_draw_layer_ctx_t_type()
{
    return &mp_lv_draw_layer_ctx_t_type;
}
    

/*
 * lvgl extension definition for:
 * struct _lv_draw_layer_ctx_t *layer_init(struct _lv_draw_ctx_t *draw_ctx, struct _lv_draw_layer_ctx_t *layer_ctx, lv_draw_layer_flags_t flags)
 */
 
STATIC mp_obj_t mp_funcptr_layer_init(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_draw_ctx_t *draw_ctx = mp_to_ptr(mp_args[0]);
    struct _lv_draw_layer_ctx_t *layer_ctx = mp_write_ptr_lv_draw_layer_ctx_t(mp_args[1]);
    lv_draw_layer_flags_t flags = (int)mp_obj_get_int(mp_args[2]);
    lv_draw_layer_ctx_t * _res = ((struct _lv_draw_layer_ctx_t *(*)(struct _lv_draw_ctx_t *, struct _lv_draw_layer_ctx_t *, lv_draw_layer_flags_t))lv_func_ptr)(draw_ctx, layer_ctx, flags);
    return mp_read_ptr_lv_draw_layer_ctx_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_layer_init_obj, 3, mp_funcptr_layer_init, funcptr_layer_init);
    
STATIC inline mp_obj_t mp_lv_funcptr_layer_init(void *func){ return mp_lv_funcptr(&mp_funcptr_layer_init_obj, func, NULL, MP_QSTR_, NULL); }

STATIC lv_draw_layer_ctx_t * lv_draw_ctx_t_layer_init_callback(struct _lv_draw_ctx_t *draw_ctx, struct _lv_draw_layer_ctx_t *layer_ctx, lv_draw_layer_flags_t flags);
#define funcptr_layer_adjust NULL


/*
 * lvgl extension definition for:
 * void layer_adjust(struct _lv_draw_ctx_t *draw_ctx, struct _lv_draw_layer_ctx_t *layer_ctx, lv_draw_layer_flags_t flags)
 */
 
STATIC mp_obj_t mp_funcptr_layer_adjust(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_draw_ctx_t *draw_ctx = mp_to_ptr(mp_args[0]);
    struct _lv_draw_layer_ctx_t *layer_ctx = mp_write_ptr_lv_draw_layer_ctx_t(mp_args[1]);
    lv_draw_layer_flags_t flags = (int)mp_obj_get_int(mp_args[2]);
    ((void (*)(struct _lv_draw_ctx_t *, struct _lv_draw_layer_ctx_t *, lv_draw_layer_flags_t))lv_func_ptr)(draw_ctx, layer_ctx, flags);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_layer_adjust_obj, 3, mp_funcptr_layer_adjust, funcptr_layer_adjust);
    
STATIC inline mp_obj_t mp_lv_funcptr_layer_adjust(void *func){ return mp_lv_funcptr(&mp_funcptr_layer_adjust_obj, func, NULL, MP_QSTR_, NULL); }

STATIC void lv_draw_ctx_t_layer_adjust_callback(struct _lv_draw_ctx_t *draw_ctx, struct _lv_draw_layer_ctx_t *layer_ctx, lv_draw_layer_flags_t flags);
#define funcptr_layer_blend NULL


/*
 * lvgl extension definition for:
 * void layer_blend(struct _lv_draw_ctx_t *draw_ctx, struct _lv_draw_layer_ctx_t *layer_ctx, const lv_draw_img_dsc_t *draw_dsc)
 */
 
STATIC mp_obj_t mp_funcptr_layer_blend(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_draw_ctx_t *draw_ctx = mp_to_ptr(mp_args[0]);
    struct _lv_draw_layer_ctx_t *layer_ctx = mp_write_ptr_lv_draw_layer_ctx_t(mp_args[1]);
    const lv_draw_img_dsc_t *draw_dsc = mp_write_ptr_lv_draw_img_dsc_t(mp_args[2]);
    ((void (*)(struct _lv_draw_ctx_t *, struct _lv_draw_layer_ctx_t *, const lv_draw_img_dsc_t *))lv_func_ptr)(draw_ctx, layer_ctx, draw_dsc);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_layer_blend_obj, 3, mp_funcptr_layer_blend, funcptr_layer_blend);
    
STATIC inline mp_obj_t mp_lv_funcptr_layer_blend(void *func){ return mp_lv_funcptr(&mp_funcptr_layer_blend_obj, func, NULL, MP_QSTR_, NULL); }

STATIC void lv_draw_ctx_t_layer_blend_callback(struct _lv_draw_ctx_t *draw_ctx, struct _lv_draw_layer_ctx_t *layer_ctx, const lv_draw_img_dsc_t *draw_dsc);
#define funcptr_layer_destroy NULL


/*
 * lvgl extension definition for:
 * void layer_destroy(struct _lv_draw_ctx_t *draw_ctx, lv_draw_layer_ctx_t *layer_ctx)
 */
 
STATIC mp_obj_t mp_funcptr_layer_destroy(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_draw_ctx_t *draw_ctx = mp_to_ptr(mp_args[0]);
    lv_draw_layer_ctx_t *layer_ctx = mp_write_ptr_lv_draw_layer_ctx_t(mp_args[1]);
    ((void (*)(struct _lv_draw_ctx_t *, lv_draw_layer_ctx_t *))lv_func_ptr)(draw_ctx, layer_ctx);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_layer_destroy_obj, 2, mp_funcptr_layer_destroy, funcptr_layer_destroy);
    
STATIC inline mp_obj_t mp_lv_funcptr_layer_destroy(void *func){ return mp_lv_funcptr(&mp_funcptr_layer_destroy_obj, func, NULL, MP_QSTR_, NULL); }

STATIC void lv_draw_ctx_t_layer_destroy_callback(struct _lv_draw_ctx_t *draw_ctx, lv_draw_layer_ctx_t *layer_ctx);

/*
 * Struct lv_draw_ctx_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_draw_ctx_t_type();

STATIC inline lv_draw_ctx_t* mp_write_ptr_lv_draw_ctx_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_draw_ctx_t_type()));
    return (lv_draw_ctx_t*)self->data;
}

#define mp_write_lv_draw_ctx_t(struct_obj) *mp_write_ptr_lv_draw_ctx_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_draw_ctx_t(lv_draw_ctx_t *field)
{
    return lv_to_mp_struct(get_mp_lv_draw_ctx_t_type(), (void*)field);
}

#define mp_read_lv_draw_ctx_t(field) mp_read_ptr_lv_draw_ctx_t(copy_buffer(&field, sizeof(lv_draw_ctx_t)))
#define mp_read_byref_lv_draw_ctx_t(field) mp_read_ptr_lv_draw_ctx_t(&field)

STATIC void mp_lv_draw_ctx_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_draw_ctx_t *data = (lv_draw_ctx_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_buf: dest[0] = ptr_to_mp((void*)data->buf); break; // converting from void *;
            case MP_QSTR_buf_area: dest[0] = mp_read_ptr_lv_area_t((void*)data->buf_area); break; // converting from lv_area_t *;
            case MP_QSTR_clip_area: dest[0] = mp_read_ptr_lv_area_t((void*)data->clip_area); break; // converting from lv_area_t *;
            case MP_QSTR_draw_rect: dest[0] = mp_lv_funcptr(&mp_funcptr_draw_rect_obj, (void*)data->draw_rect, lv_draw_ctx_t_draw_rect_callback ,MP_QSTR_lv_draw_ctx_t_draw_rect, data->user_data); break; // converting from callback void (*)(lv_draw_ctx_t *draw_ctx, lv_draw_rect_dsc_t *dsc, lv_area_t *coords);
            case MP_QSTR_draw_arc: dest[0] = mp_lv_funcptr(&mp_funcptr_draw_arc_obj, (void*)data->draw_arc, lv_draw_ctx_t_draw_arc_callback ,MP_QSTR_lv_draw_ctx_t_draw_arc, data->user_data); break; // converting from callback void (*)(lv_draw_ctx_t *draw_ctx, lv_draw_arc_dsc_t *dsc, lv_point_t *center, uint16_t radius, uint16_t start_angle, uint16_t end_angle);
            case MP_QSTR_draw_img_decoded: dest[0] = mp_lv_funcptr(&mp_funcptr_draw_img_decoded_obj, (void*)data->draw_img_decoded, lv_draw_ctx_t_draw_img_decoded_callback ,MP_QSTR_lv_draw_ctx_t_draw_img_decoded, data->user_data); break; // converting from callback void (*)(lv_draw_ctx_t *draw_ctx, lv_draw_img_dsc_t *dsc, lv_area_t *coords, uint8_t *map_p, lv_img_cf_t color_format);
            case MP_QSTR_draw_img: dest[0] = mp_lv_funcptr(&mp_funcptr_draw_img_obj, (void*)data->draw_img, lv_draw_ctx_t_draw_img_callback ,MP_QSTR_lv_draw_ctx_t_draw_img, data->user_data); break; // converting from callback lv_res_t (*)(lv_draw_ctx_t *draw_ctx, lv_draw_img_dsc_t *draw_dsc, lv_area_t *coords, void *src);
            case MP_QSTR_draw_letter: dest[0] = mp_lv_funcptr(&mp_funcptr_draw_letter_obj, (void*)data->draw_letter, lv_draw_ctx_t_draw_letter_callback ,MP_QSTR_lv_draw_ctx_t_draw_letter, data->user_data); break; // converting from callback void (*)(lv_draw_ctx_t *draw_ctx, lv_draw_label_dsc_t *dsc, lv_point_t *pos_p, uint32_t letter);
            case MP_QSTR_draw_line: dest[0] = mp_lv_funcptr(&mp_funcptr_draw_line_obj, (void*)data->draw_line, lv_draw_ctx_t_draw_line_callback ,MP_QSTR_lv_draw_ctx_t_draw_line, data->user_data); break; // converting from callback void (*)(lv_draw_ctx_t *draw_ctx, lv_draw_line_dsc_t *dsc, lv_point_t *point1, lv_point_t *point2);
            case MP_QSTR_draw_polygon: dest[0] = mp_lv_funcptr(&mp_funcptr_draw_polygon_obj, (void*)data->draw_polygon, lv_draw_ctx_t_draw_polygon_callback ,MP_QSTR_lv_draw_ctx_t_draw_polygon, data->user_data); break; // converting from callback void (*)(lv_draw_ctx_t *draw_ctx, lv_draw_rect_dsc_t *draw_dsc, lv_point_t *points, uint16_t point_cnt);
            case MP_QSTR_draw_transform: dest[0] = mp_lv_funcptr(&mp_funcptr_draw_transform_obj, (void*)data->draw_transform, lv_draw_ctx_t_draw_transform_callback ,MP_QSTR_lv_draw_ctx_t_draw_transform, data->user_data); break; // converting from callback void (*)(lv_draw_ctx_t *draw_ctx, lv_area_t *dest_area, void *src_buf, lv_coord_t src_w, lv_coord_t src_h, lv_coord_t src_stride, lv_draw_img_dsc_t *draw_dsc, lv_img_cf_t cf, lv_color_t *cbuf, lv_opa_t *abuf);
            case MP_QSTR_draw_bg: dest[0] = mp_lv_funcptr(&mp_funcptr_draw_bg_obj, (void*)data->draw_bg, lv_draw_ctx_t_draw_bg_callback ,MP_QSTR_lv_draw_ctx_t_draw_bg, data->user_data); break; // converting from callback void (*)(lv_draw_ctx_t *draw_ctx, lv_draw_rect_dsc_t *draw_dsc, lv_area_t *coords);
            case MP_QSTR_wait_for_finish: dest[0] = mp_lv_funcptr(&mp_funcptr_wait_for_finish_obj, (void*)data->wait_for_finish, lv_draw_ctx_t_wait_for_finish_callback ,MP_QSTR_lv_draw_ctx_t_wait_for_finish, data->user_data); break; // converting from callback void (*)(lv_draw_ctx_t *draw_ctx);
            case MP_QSTR_buffer_copy: dest[0] = mp_lv_funcptr(&mp_funcptr_buffer_copy_obj, (void*)data->buffer_copy, lv_draw_ctx_t_buffer_copy_callback ,MP_QSTR_lv_draw_ctx_t_buffer_copy, data->user_data); break; // converting from callback void (*)(lv_draw_ctx_t *draw_ctx, void *dest_buf, lv_coord_t dest_stride, lv_area_t *dest_area, void *src_buf, lv_coord_t src_stride, lv_area_t *src_area);
            case MP_QSTR_layer_init: dest[0] = mp_lv_funcptr(&mp_funcptr_layer_init_obj, (void*)data->layer_init, lv_draw_ctx_t_layer_init_callback ,MP_QSTR_lv_draw_ctx_t_layer_init, data->user_data); break; // converting from callback lv_draw_layer_ctx_t *(*)(lv_draw_ctx_t *draw_ctx, lv_draw_layer_ctx_t *layer_ctx, lv_draw_layer_flags_t flags);
            case MP_QSTR_layer_adjust: dest[0] = mp_lv_funcptr(&mp_funcptr_layer_adjust_obj, (void*)data->layer_adjust, lv_draw_ctx_t_layer_adjust_callback ,MP_QSTR_lv_draw_ctx_t_layer_adjust, data->user_data); break; // converting from callback void (*)(lv_draw_ctx_t *draw_ctx, lv_draw_layer_ctx_t *layer_ctx, lv_draw_layer_flags_t flags);
            case MP_QSTR_layer_blend: dest[0] = mp_lv_funcptr(&mp_funcptr_layer_blend_obj, (void*)data->layer_blend, lv_draw_ctx_t_layer_blend_callback ,MP_QSTR_lv_draw_ctx_t_layer_blend, data->user_data); break; // converting from callback void (*)(lv_draw_ctx_t *draw_ctx, lv_draw_layer_ctx_t *layer_ctx, lv_draw_img_dsc_t *draw_dsc);
            case MP_QSTR_layer_destroy: dest[0] = mp_lv_funcptr(&mp_funcptr_layer_destroy_obj, (void*)data->layer_destroy, lv_draw_ctx_t_layer_destroy_callback ,MP_QSTR_lv_draw_ctx_t_layer_destroy, data->user_data); break; // converting from callback void (*)(lv_draw_ctx_t *draw_ctx, lv_draw_layer_ctx_t *layer_ctx);
            case MP_QSTR_layer_instance_size: dest[0] = mp_obj_new_int_from_uint(data->layer_instance_size); break; // converting from size_t;
            case MP_QSTR_user_data: dest[0] = ptr_to_mp((void*)data->user_data); break; // converting from void *;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_buf: data->buf = (void*)mp_to_ptr(dest[1]); break; // converting to void *;
                case MP_QSTR_buf_area: data->buf_area = (void*)mp_write_ptr_lv_area_t(dest[1]); break; // converting to lv_area_t *;
                case MP_QSTR_clip_area: data->clip_area = (void*)mp_write_ptr_lv_area_t(dest[1]); break; // converting to lv_area_t *;
                case MP_QSTR_draw_rect: data->draw_rect = (void*)mp_lv_callback(dest[1], lv_draw_ctx_t_draw_rect_callback ,MP_QSTR_lv_draw_ctx_t_draw_rect, &data->user_data); break; // converting to callback void (*)(lv_draw_ctx_t *draw_ctx, lv_draw_rect_dsc_t *dsc, lv_area_t *coords);
                case MP_QSTR_draw_arc: data->draw_arc = (void*)mp_lv_callback(dest[1], lv_draw_ctx_t_draw_arc_callback ,MP_QSTR_lv_draw_ctx_t_draw_arc, &data->user_data); break; // converting to callback void (*)(lv_draw_ctx_t *draw_ctx, lv_draw_arc_dsc_t *dsc, lv_point_t *center, uint16_t radius, uint16_t start_angle, uint16_t end_angle);
                case MP_QSTR_draw_img_decoded: data->draw_img_decoded = (void*)mp_lv_callback(dest[1], lv_draw_ctx_t_draw_img_decoded_callback ,MP_QSTR_lv_draw_ctx_t_draw_img_decoded, &data->user_data); break; // converting to callback void (*)(lv_draw_ctx_t *draw_ctx, lv_draw_img_dsc_t *dsc, lv_area_t *coords, uint8_t *map_p, lv_img_cf_t color_format);
                case MP_QSTR_draw_img: data->draw_img = (void*)mp_lv_callback(dest[1], lv_draw_ctx_t_draw_img_callback ,MP_QSTR_lv_draw_ctx_t_draw_img, &data->user_data); break; // converting to callback lv_res_t (*)(lv_draw_ctx_t *draw_ctx, lv_draw_img_dsc_t *draw_dsc, lv_area_t *coords, void *src);
                case MP_QSTR_draw_letter: data->draw_letter = (void*)mp_lv_callback(dest[1], lv_draw_ctx_t_draw_letter_callback ,MP_QSTR_lv_draw_ctx_t_draw_letter, &data->user_data); break; // converting to callback void (*)(lv_draw_ctx_t *draw_ctx, lv_draw_label_dsc_t *dsc, lv_point_t *pos_p, uint32_t letter);
                case MP_QSTR_draw_line: data->draw_line = (void*)mp_lv_callback(dest[1], lv_draw_ctx_t_draw_line_callback ,MP_QSTR_lv_draw_ctx_t_draw_line, &data->user_data); break; // converting to callback void (*)(lv_draw_ctx_t *draw_ctx, lv_draw_line_dsc_t *dsc, lv_point_t *point1, lv_point_t *point2);
                case MP_QSTR_draw_polygon: data->draw_polygon = (void*)mp_lv_callback(dest[1], lv_draw_ctx_t_draw_polygon_callback ,MP_QSTR_lv_draw_ctx_t_draw_polygon, &data->user_data); break; // converting to callback void (*)(lv_draw_ctx_t *draw_ctx, lv_draw_rect_dsc_t *draw_dsc, lv_point_t *points, uint16_t point_cnt);
                case MP_QSTR_draw_transform: data->draw_transform = (void*)mp_lv_callback(dest[1], lv_draw_ctx_t_draw_transform_callback ,MP_QSTR_lv_draw_ctx_t_draw_transform, &data->user_data); break; // converting to callback void (*)(lv_draw_ctx_t *draw_ctx, lv_area_t *dest_area, void *src_buf, lv_coord_t src_w, lv_coord_t src_h, lv_coord_t src_stride, lv_draw_img_dsc_t *draw_dsc, lv_img_cf_t cf, lv_color_t *cbuf, lv_opa_t *abuf);
                case MP_QSTR_draw_bg: data->draw_bg = (void*)mp_lv_callback(dest[1], lv_draw_ctx_t_draw_bg_callback ,MP_QSTR_lv_draw_ctx_t_draw_bg, &data->user_data); break; // converting to callback void (*)(lv_draw_ctx_t *draw_ctx, lv_draw_rect_dsc_t *draw_dsc, lv_area_t *coords);
                case MP_QSTR_wait_for_finish: data->wait_for_finish = (void*)mp_lv_callback(dest[1], lv_draw_ctx_t_wait_for_finish_callback ,MP_QSTR_lv_draw_ctx_t_wait_for_finish, &data->user_data); break; // converting to callback void (*)(lv_draw_ctx_t *draw_ctx);
                case MP_QSTR_buffer_copy: data->buffer_copy = (void*)mp_lv_callback(dest[1], lv_draw_ctx_t_buffer_copy_callback ,MP_QSTR_lv_draw_ctx_t_buffer_copy, &data->user_data); break; // converting to callback void (*)(lv_draw_ctx_t *draw_ctx, void *dest_buf, lv_coord_t dest_stride, lv_area_t *dest_area, void *src_buf, lv_coord_t src_stride, lv_area_t *src_area);
                case MP_QSTR_layer_init: data->layer_init = (void*)mp_lv_callback(dest[1], lv_draw_ctx_t_layer_init_callback ,MP_QSTR_lv_draw_ctx_t_layer_init, &data->user_data); break; // converting to callback lv_draw_layer_ctx_t *(*)(lv_draw_ctx_t *draw_ctx, lv_draw_layer_ctx_t *layer_ctx, lv_draw_layer_flags_t flags);
                case MP_QSTR_layer_adjust: data->layer_adjust = (void*)mp_lv_callback(dest[1], lv_draw_ctx_t_layer_adjust_callback ,MP_QSTR_lv_draw_ctx_t_layer_adjust, &data->user_data); break; // converting to callback void (*)(lv_draw_ctx_t *draw_ctx, lv_draw_layer_ctx_t *layer_ctx, lv_draw_layer_flags_t flags);
                case MP_QSTR_layer_blend: data->layer_blend = (void*)mp_lv_callback(dest[1], lv_draw_ctx_t_layer_blend_callback ,MP_QSTR_lv_draw_ctx_t_layer_blend, &data->user_data); break; // converting to callback void (*)(lv_draw_ctx_t *draw_ctx, lv_draw_layer_ctx_t *layer_ctx, lv_draw_img_dsc_t *draw_dsc);
                case MP_QSTR_layer_destroy: data->layer_destroy = (void*)mp_lv_callback(dest[1], lv_draw_ctx_t_layer_destroy_callback ,MP_QSTR_lv_draw_ctx_t_layer_destroy, &data->user_data); break; // converting to callback void (*)(lv_draw_ctx_t *draw_ctx, lv_draw_layer_ctx_t *layer_ctx);
                case MP_QSTR_layer_instance_size: data->layer_instance_size = (size_t)mp_obj_get_int(dest[1]); break; // converting to size_t;
                case MP_QSTR_user_data: data->user_data = (void*)mp_to_ptr(dest[1]); break; // converting to void *;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_draw_ctx_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_draw_ctx_t");
}

STATIC const mp_obj_dict_t mp_lv_draw_ctx_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_draw_ctx_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_draw_ctx_t,
    .print = mp_lv_draw_ctx_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_draw_ctx_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_draw_ctx_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_draw_ctx_t_type()
{
    return &mp_lv_draw_ctx_t_type;
}
    
#define funcptr_draw_ctx_init NULL


/*
 * lvgl extension definition for:
 * void draw_ctx_init(struct _lv_disp_drv_t *disp_drv, lv_draw_ctx_t *draw_ctx)
 */
 
STATIC mp_obj_t mp_funcptr_draw_ctx_init(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_disp_drv_t *disp_drv = mp_to_ptr(mp_args[0]);
    lv_draw_ctx_t *draw_ctx = mp_write_ptr_lv_draw_ctx_t(mp_args[1]);
    ((void (*)(struct _lv_disp_drv_t *, lv_draw_ctx_t *))lv_func_ptr)(disp_drv, draw_ctx);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_draw_ctx_init_obj, 2, mp_funcptr_draw_ctx_init, funcptr_draw_ctx_init);
    
STATIC inline mp_obj_t mp_lv_funcptr_draw_ctx_init(void *func){ return mp_lv_funcptr(&mp_funcptr_draw_ctx_init_obj, func, NULL, MP_QSTR_, NULL); }

STATIC void lv_disp_drv_t_draw_ctx_init_callback(struct _lv_disp_drv_t *disp_drv, lv_draw_ctx_t *draw_ctx);
STATIC void lv_disp_drv_t_draw_ctx_deinit_callback(struct _lv_disp_drv_t *disp_drv, lv_draw_ctx_t *draw_ctx);

/*
 * Struct lv_disp_drv_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_disp_drv_t_type();

STATIC inline lv_disp_drv_t* mp_write_ptr_lv_disp_drv_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_disp_drv_t_type()));
    return (lv_disp_drv_t*)self->data;
}

#define mp_write_lv_disp_drv_t(struct_obj) *mp_write_ptr_lv_disp_drv_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_disp_drv_t(lv_disp_drv_t *field)
{
    return lv_to_mp_struct(get_mp_lv_disp_drv_t_type(), (void*)field);
}

#define mp_read_lv_disp_drv_t(field) mp_read_ptr_lv_disp_drv_t(copy_buffer(&field, sizeof(lv_disp_drv_t)))
#define mp_read_byref_lv_disp_drv_t(field) mp_read_ptr_lv_disp_drv_t(&field)

STATIC void mp_lv_disp_drv_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_disp_drv_t *data = (lv_disp_drv_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_hor_res: dest[0] = mp_obj_new_int(data->hor_res); break; // converting from lv_coord_t;
            case MP_QSTR_ver_res: dest[0] = mp_obj_new_int(data->ver_res); break; // converting from lv_coord_t;
            case MP_QSTR_physical_hor_res: dest[0] = mp_obj_new_int(data->physical_hor_res); break; // converting from lv_coord_t;
            case MP_QSTR_physical_ver_res: dest[0] = mp_obj_new_int(data->physical_ver_res); break; // converting from lv_coord_t;
            case MP_QSTR_offset_x: dest[0] = mp_obj_new_int(data->offset_x); break; // converting from lv_coord_t;
            case MP_QSTR_offset_y: dest[0] = mp_obj_new_int(data->offset_y); break; // converting from lv_coord_t;
            case MP_QSTR_draw_buf: dest[0] = mp_read_ptr_lv_disp_draw_buf_t((void*)data->draw_buf); break; // converting from lv_disp_draw_buf_t *;
            case MP_QSTR_direct_mode: dest[0] = mp_obj_new_int_from_uint(data->direct_mode); break; // converting from uint32_t;
            case MP_QSTR_full_refresh: dest[0] = mp_obj_new_int_from_uint(data->full_refresh); break; // converting from uint32_t;
            case MP_QSTR_sw_rotate: dest[0] = mp_obj_new_int_from_uint(data->sw_rotate); break; // converting from uint32_t;
            case MP_QSTR_antialiasing: dest[0] = mp_obj_new_int_from_uint(data->antialiasing); break; // converting from uint32_t;
            case MP_QSTR_rotated: dest[0] = mp_obj_new_int_from_uint(data->rotated); break; // converting from uint32_t;
            case MP_QSTR_screen_transp: dest[0] = mp_obj_new_int_from_uint(data->screen_transp); break; // converting from uint32_t;
            case MP_QSTR_dpi: dest[0] = mp_obj_new_int_from_uint(data->dpi); break; // converting from uint32_t;
            case MP_QSTR_flush_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_flush_cb_obj, (void*)data->flush_cb, lv_disp_drv_t_flush_cb_callback ,MP_QSTR_lv_disp_drv_t_flush_cb, data->user_data); break; // converting from callback void (*)(lv_disp_drv_t *disp_drv, lv_area_t *area, lv_color_t *color_p);
            case MP_QSTR_rounder_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_rounder_cb_obj, (void*)data->rounder_cb, lv_disp_drv_t_rounder_cb_callback ,MP_QSTR_lv_disp_drv_t_rounder_cb, data->user_data); break; // converting from callback void (*)(lv_disp_drv_t *disp_drv, lv_area_t *area);
            case MP_QSTR_set_px_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_set_px_cb_obj, (void*)data->set_px_cb, lv_disp_drv_t_set_px_cb_callback ,MP_QSTR_lv_disp_drv_t_set_px_cb, data->user_data); break; // converting from callback void (*)(lv_disp_drv_t *disp_drv, uint8_t *buf, lv_coord_t buf_w, lv_coord_t x, lv_coord_t y, lv_color_t color, lv_opa_t opa);
            case MP_QSTR_clear_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_clear_cb_obj, (void*)data->clear_cb, lv_disp_drv_t_clear_cb_callback ,MP_QSTR_lv_disp_drv_t_clear_cb, data->user_data); break; // converting from callback void (*)(lv_disp_drv_t *disp_drv, uint8_t *buf, uint32_t size);
            case MP_QSTR_monitor_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_monitor_cb_obj, (void*)data->monitor_cb, lv_disp_drv_t_monitor_cb_callback ,MP_QSTR_lv_disp_drv_t_monitor_cb, data->user_data); break; // converting from callback void (*)(lv_disp_drv_t *disp_drv, uint32_t time, uint32_t px);
            case MP_QSTR_wait_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_wait_cb_obj, (void*)data->wait_cb, lv_disp_drv_t_wait_cb_callback ,MP_QSTR_lv_disp_drv_t_wait_cb, data->user_data); break; // converting from callback void (*)(lv_disp_drv_t *disp_drv);
            case MP_QSTR_clean_dcache_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_wait_cb_obj, (void*)data->clean_dcache_cb, lv_disp_drv_t_clean_dcache_cb_callback ,MP_QSTR_lv_disp_drv_t_clean_dcache_cb, data->user_data); break; // converting from callback void (*)(lv_disp_drv_t *disp_drv);
            case MP_QSTR_drv_update_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_wait_cb_obj, (void*)data->drv_update_cb, lv_disp_drv_t_drv_update_cb_callback ,MP_QSTR_lv_disp_drv_t_drv_update_cb, data->user_data); break; // converting from callback void (*)(lv_disp_drv_t *disp_drv);
            case MP_QSTR_render_start_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_wait_cb_obj, (void*)data->render_start_cb, lv_disp_drv_t_render_start_cb_callback ,MP_QSTR_lv_disp_drv_t_render_start_cb, data->user_data); break; // converting from callback void (*)(lv_disp_drv_t *disp_drv);
            case MP_QSTR_color_chroma_key: dest[0] = mp_read_byref_lv_color16_t(data->color_chroma_key); break; // converting from lv_color_t;
            case MP_QSTR_draw_ctx: dest[0] = mp_read_ptr_lv_draw_ctx_t((void*)data->draw_ctx); break; // converting from lv_draw_ctx_t *;
            case MP_QSTR_draw_ctx_init: dest[0] = mp_lv_funcptr(&mp_funcptr_draw_ctx_init_obj, (void*)data->draw_ctx_init, lv_disp_drv_t_draw_ctx_init_callback ,MP_QSTR_lv_disp_drv_t_draw_ctx_init, data->user_data); break; // converting from callback void (*)(lv_disp_drv_t *disp_drv, lv_draw_ctx_t *draw_ctx);
            case MP_QSTR_draw_ctx_deinit: dest[0] = mp_lv_funcptr(&mp_funcptr_draw_ctx_init_obj, (void*)data->draw_ctx_deinit, lv_disp_drv_t_draw_ctx_deinit_callback ,MP_QSTR_lv_disp_drv_t_draw_ctx_deinit, data->user_data); break; // converting from callback void (*)(lv_disp_drv_t *disp_drv, lv_draw_ctx_t *draw_ctx);
            case MP_QSTR_draw_ctx_size: dest[0] = mp_obj_new_int_from_uint(data->draw_ctx_size); break; // converting from size_t;
            case MP_QSTR_user_data: dest[0] = ptr_to_mp((void*)data->user_data); break; // converting from void *;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_hor_res: data->hor_res = (int16_t)mp_obj_get_int(dest[1]); break; // converting to lv_coord_t;
                case MP_QSTR_ver_res: data->ver_res = (int16_t)mp_obj_get_int(dest[1]); break; // converting to lv_coord_t;
                case MP_QSTR_physical_hor_res: data->physical_hor_res = (int16_t)mp_obj_get_int(dest[1]); break; // converting to lv_coord_t;
                case MP_QSTR_physical_ver_res: data->physical_ver_res = (int16_t)mp_obj_get_int(dest[1]); break; // converting to lv_coord_t;
                case MP_QSTR_offset_x: data->offset_x = (int16_t)mp_obj_get_int(dest[1]); break; // converting to lv_coord_t;
                case MP_QSTR_offset_y: data->offset_y = (int16_t)mp_obj_get_int(dest[1]); break; // converting to lv_coord_t;
                case MP_QSTR_draw_buf: data->draw_buf = (void*)mp_write_ptr_lv_disp_draw_buf_t(dest[1]); break; // converting to lv_disp_draw_buf_t *;
                case MP_QSTR_direct_mode: data->direct_mode = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_full_refresh: data->full_refresh = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_sw_rotate: data->sw_rotate = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_antialiasing: data->antialiasing = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_rotated: data->rotated = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_screen_transp: data->screen_transp = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_dpi: data->dpi = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_flush_cb: data->flush_cb = (void*)mp_lv_callback(dest[1], lv_disp_drv_t_flush_cb_callback ,MP_QSTR_lv_disp_drv_t_flush_cb, &data->user_data); break; // converting to callback void (*)(lv_disp_drv_t *disp_drv, lv_area_t *area, lv_color_t *color_p);
                case MP_QSTR_rounder_cb: data->rounder_cb = (void*)mp_lv_callback(dest[1], lv_disp_drv_t_rounder_cb_callback ,MP_QSTR_lv_disp_drv_t_rounder_cb, &data->user_data); break; // converting to callback void (*)(lv_disp_drv_t *disp_drv, lv_area_t *area);
                case MP_QSTR_set_px_cb: data->set_px_cb = (void*)mp_lv_callback(dest[1], lv_disp_drv_t_set_px_cb_callback ,MP_QSTR_lv_disp_drv_t_set_px_cb, &data->user_data); break; // converting to callback void (*)(lv_disp_drv_t *disp_drv, uint8_t *buf, lv_coord_t buf_w, lv_coord_t x, lv_coord_t y, lv_color_t color, lv_opa_t opa);
                case MP_QSTR_clear_cb: data->clear_cb = (void*)mp_lv_callback(dest[1], lv_disp_drv_t_clear_cb_callback ,MP_QSTR_lv_disp_drv_t_clear_cb, &data->user_data); break; // converting to callback void (*)(lv_disp_drv_t *disp_drv, uint8_t *buf, uint32_t size);
                case MP_QSTR_monitor_cb: data->monitor_cb = (void*)mp_lv_callback(dest[1], lv_disp_drv_t_monitor_cb_callback ,MP_QSTR_lv_disp_drv_t_monitor_cb, &data->user_data); break; // converting to callback void (*)(lv_disp_drv_t *disp_drv, uint32_t time, uint32_t px);
                case MP_QSTR_wait_cb: data->wait_cb = (void*)mp_lv_callback(dest[1], lv_disp_drv_t_wait_cb_callback ,MP_QSTR_lv_disp_drv_t_wait_cb, &data->user_data); break; // converting to callback void (*)(lv_disp_drv_t *disp_drv);
                case MP_QSTR_clean_dcache_cb: data->clean_dcache_cb = (void*)mp_lv_callback(dest[1], lv_disp_drv_t_clean_dcache_cb_callback ,MP_QSTR_lv_disp_drv_t_clean_dcache_cb, &data->user_data); break; // converting to callback void (*)(lv_disp_drv_t *disp_drv);
                case MP_QSTR_drv_update_cb: data->drv_update_cb = (void*)mp_lv_callback(dest[1], lv_disp_drv_t_drv_update_cb_callback ,MP_QSTR_lv_disp_drv_t_drv_update_cb, &data->user_data); break; // converting to callback void (*)(lv_disp_drv_t *disp_drv);
                case MP_QSTR_render_start_cb: data->render_start_cb = (void*)mp_lv_callback(dest[1], lv_disp_drv_t_render_start_cb_callback ,MP_QSTR_lv_disp_drv_t_render_start_cb, &data->user_data); break; // converting to callback void (*)(lv_disp_drv_t *disp_drv);
                case MP_QSTR_color_chroma_key: data->color_chroma_key = mp_write_lv_color16_t(dest[1]); break; // converting to lv_color_t;
                case MP_QSTR_draw_ctx: data->draw_ctx = (void*)mp_write_ptr_lv_draw_ctx_t(dest[1]); break; // converting to lv_draw_ctx_t *;
                case MP_QSTR_draw_ctx_init: data->draw_ctx_init = (void*)mp_lv_callback(dest[1], lv_disp_drv_t_draw_ctx_init_callback ,MP_QSTR_lv_disp_drv_t_draw_ctx_init, &data->user_data); break; // converting to callback void (*)(lv_disp_drv_t *disp_drv, lv_draw_ctx_t *draw_ctx);
                case MP_QSTR_draw_ctx_deinit: data->draw_ctx_deinit = (void*)mp_lv_callback(dest[1], lv_disp_drv_t_draw_ctx_deinit_callback ,MP_QSTR_lv_disp_drv_t_draw_ctx_deinit, &data->user_data); break; // converting to callback void (*)(lv_disp_drv_t *disp_drv, lv_draw_ctx_t *draw_ctx);
                case MP_QSTR_draw_ctx_size: data->draw_ctx_size = (size_t)mp_obj_get_int(dest[1]); break; // converting to size_t;
                case MP_QSTR_user_data: data->user_data = (void*)mp_to_ptr(dest[1]); break; // converting to void *;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_disp_drv_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_disp_drv_t");
}

STATIC const mp_obj_dict_t mp_lv_disp_drv_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_disp_drv_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_disp_drv_t,
    .print = mp_lv_disp_drv_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_disp_drv_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_disp_drv_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_disp_drv_t_type()
{
    return &mp_lv_disp_drv_t_type;
}
    
#define funcptr_lv_timer_cb_t NULL


/*
 * lvgl extension definition for:
 * void lv_timer_cb_t(struct _lv_timer_t *)
 */
 
STATIC mp_obj_t mp_funcptr_lv_timer_cb_t(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_timer_t *arg0 = mp_to_ptr(mp_args[0]);
    ((void (*)(struct _lv_timer_t *))lv_func_ptr)(arg0);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_lv_timer_cb_t_obj, 1, mp_funcptr_lv_timer_cb_t, funcptr_lv_timer_cb_t);
    
STATIC inline mp_obj_t mp_lv_funcptr_lv_timer_cb_t(void *func){ return mp_lv_funcptr(&mp_funcptr_lv_timer_cb_t_obj, func, NULL, MP_QSTR_, NULL); }

STATIC void lv_timer_t_timer_cb_callback(struct _lv_timer_t *);

/*
 * Struct lv_timer_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_timer_t_type();

STATIC inline lv_timer_t* mp_write_ptr_lv_timer_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_timer_t_type()));
    return (lv_timer_t*)self->data;
}

#define mp_write_lv_timer_t(struct_obj) *mp_write_ptr_lv_timer_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_timer_t(lv_timer_t *field)
{
    return lv_to_mp_struct(get_mp_lv_timer_t_type(), (void*)field);
}

#define mp_read_lv_timer_t(field) mp_read_ptr_lv_timer_t(copy_buffer(&field, sizeof(lv_timer_t)))
#define mp_read_byref_lv_timer_t(field) mp_read_ptr_lv_timer_t(&field)

STATIC void mp_lv_timer_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_timer_t *data = (lv_timer_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_period: dest[0] = mp_obj_new_int_from_uint(data->period); break; // converting from uint32_t;
            case MP_QSTR_last_run: dest[0] = mp_obj_new_int_from_uint(data->last_run); break; // converting from uint32_t;
            case MP_QSTR_timer_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_lv_timer_cb_t_obj, data->timer_cb, lv_timer_t_timer_cb_callback ,MP_QSTR_lv_timer_t_timer_cb, data->user_data); break; // converting from callback lv_timer_cb_t;
            case MP_QSTR_user_data: dest[0] = ptr_to_mp((void*)data->user_data); break; // converting from void *;
            case MP_QSTR_repeat_count: dest[0] = mp_obj_new_int(data->repeat_count); break; // converting from int32_t;
            case MP_QSTR_paused: dest[0] = mp_obj_new_int_from_uint(data->paused); break; // converting from uint32_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_period: data->period = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_last_run: data->last_run = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_timer_cb: data->timer_cb = mp_lv_callback(dest[1], lv_timer_t_timer_cb_callback ,MP_QSTR_lv_timer_t_timer_cb, &data->user_data); break; // converting to callback lv_timer_cb_t;
                case MP_QSTR_user_data: data->user_data = (void*)mp_to_ptr(dest[1]); break; // converting to void *;
                case MP_QSTR_repeat_count: data->repeat_count = (int32_t)mp_obj_get_int(dest[1]); break; // converting to int32_t;
                case MP_QSTR_paused: data->paused = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_timer_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_timer_t");
}

STATIC const mp_obj_dict_t mp_lv_timer_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_timer_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_timer_t,
    .print = mp_lv_timer_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_timer_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_timer_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_timer_t_type()
{
    return &mp_lv_timer_t_type;
}
    
#define funcptr_lv_theme_apply_cb_t NULL


/*
 * lvgl extension definition for:
 * void lv_theme_apply_cb_t(struct _lv_theme_t *, lv_obj_t *)
 */
 
STATIC mp_obj_t mp_funcptr_lv_theme_apply_cb_t(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_theme_t *arg0 = mp_to_ptr(mp_args[0]);
    lv_obj_t *arg1 = mp_to_lv(mp_args[1]);
    ((void (*)(struct _lv_theme_t *, lv_obj_t *))lv_func_ptr)(arg0, arg1);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_lv_theme_apply_cb_t_obj, 2, mp_funcptr_lv_theme_apply_cb_t, funcptr_lv_theme_apply_cb_t);
    
STATIC inline mp_obj_t mp_lv_funcptr_lv_theme_apply_cb_t(void *func){ return mp_lv_funcptr(&mp_funcptr_lv_theme_apply_cb_t_obj, func, NULL, MP_QSTR_, NULL); }

STATIC void lv_theme_t_apply_cb_callback(struct _lv_theme_t *, lv_obj_t *);

/*
 * Struct lv_theme_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_theme_t_type();

STATIC inline lv_theme_t* mp_write_ptr_lv_theme_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_theme_t_type()));
    return (lv_theme_t*)self->data;
}

#define mp_write_lv_theme_t(struct_obj) *mp_write_ptr_lv_theme_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_theme_t(lv_theme_t *field)
{
    return lv_to_mp_struct(get_mp_lv_theme_t_type(), (void*)field);
}

#define mp_read_lv_theme_t(field) mp_read_ptr_lv_theme_t(copy_buffer(&field, sizeof(lv_theme_t)))
#define mp_read_byref_lv_theme_t(field) mp_read_ptr_lv_theme_t(&field)

STATIC void mp_lv_theme_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_theme_t *data = (lv_theme_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_apply_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_lv_theme_apply_cb_t_obj, data->apply_cb, lv_theme_t_apply_cb_callback ,MP_QSTR_lv_theme_t_apply_cb, data->user_data); break; // converting from callback lv_theme_apply_cb_t;
            case MP_QSTR_parent: dest[0] = ptr_to_mp((void*)data->parent); break; // converting from lv_theme_t *;
            case MP_QSTR_user_data: dest[0] = ptr_to_mp((void*)data->user_data); break; // converting from void *;
            case MP_QSTR_disp: dest[0] = ptr_to_mp((void*)data->disp); break; // converting from lv_disp_t *;
            case MP_QSTR_color_primary: dest[0] = mp_read_byref_lv_color16_t(data->color_primary); break; // converting from lv_color_t;
            case MP_QSTR_color_secondary: dest[0] = mp_read_byref_lv_color16_t(data->color_secondary); break; // converting from lv_color_t;
            case MP_QSTR_font_small: dest[0] = mp_read_ptr_lv_font_t((void*)data->font_small); break; // converting from lv_font_t *;
            case MP_QSTR_font_normal: dest[0] = mp_read_ptr_lv_font_t((void*)data->font_normal); break; // converting from lv_font_t *;
            case MP_QSTR_font_large: dest[0] = mp_read_ptr_lv_font_t((void*)data->font_large); break; // converting from lv_font_t *;
            case MP_QSTR_font_subtitle: dest[0] = mp_read_ptr_lv_font_t((void*)data->font_subtitle); break; // converting from lv_font_t *;
            case MP_QSTR_font_title: dest[0] = mp_read_ptr_lv_font_t((void*)data->font_title); break; // converting from lv_font_t *;
            case MP_QSTR_font_bigl: dest[0] = mp_read_ptr_lv_font_t((void*)data->font_bigl); break; // converting from lv_font_t *;
            case MP_QSTR_flags: dest[0] = mp_obj_new_int_from_uint(data->flags); break; // converting from uint32_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_apply_cb: data->apply_cb = mp_lv_callback(dest[1], lv_theme_t_apply_cb_callback ,MP_QSTR_lv_theme_t_apply_cb, &data->user_data); break; // converting to callback lv_theme_apply_cb_t;
                case MP_QSTR_parent: data->parent = (void*)mp_to_ptr(dest[1]); break; // converting to lv_theme_t *;
                case MP_QSTR_user_data: data->user_data = (void*)mp_to_ptr(dest[1]); break; // converting to void *;
                case MP_QSTR_disp: data->disp = (void*)mp_to_ptr(dest[1]); break; // converting to lv_disp_t *;
                case MP_QSTR_color_primary: data->color_primary = mp_write_lv_color16_t(dest[1]); break; // converting to lv_color_t;
                case MP_QSTR_color_secondary: data->color_secondary = mp_write_lv_color16_t(dest[1]); break; // converting to lv_color_t;
                case MP_QSTR_font_small: data->font_small = (void*)mp_write_ptr_lv_font_t(dest[1]); break; // converting to lv_font_t *;
                case MP_QSTR_font_normal: data->font_normal = (void*)mp_write_ptr_lv_font_t(dest[1]); break; // converting to lv_font_t *;
                case MP_QSTR_font_large: data->font_large = (void*)mp_write_ptr_lv_font_t(dest[1]); break; // converting to lv_font_t *;
                case MP_QSTR_font_subtitle: data->font_subtitle = (void*)mp_write_ptr_lv_font_t(dest[1]); break; // converting to lv_font_t *;
                case MP_QSTR_font_title: data->font_title = (void*)mp_write_ptr_lv_font_t(dest[1]); break; // converting to lv_font_t *;
                case MP_QSTR_font_bigl: data->font_bigl = (void*)mp_write_ptr_lv_font_t(dest[1]); break; // converting to lv_font_t *;
                case MP_QSTR_flags: data->flags = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_theme_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_theme_t");
}

STATIC const mp_obj_dict_t mp_lv_theme_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_theme_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_theme_t,
    .print = mp_lv_theme_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_theme_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_theme_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_theme_t_type()
{
    return &mp_lv_theme_t_type;
}
    

/*
 * Array convertors for lv_area_t [32]
 */

STATIC lv_area_t *mp_arr_to_lv_area_t___32__(mp_obj_t mp_arr)
{
    mp_obj_t mp_len = mp_obj_len_maybe(mp_arr);
    if (mp_len == MP_OBJ_NULL) return mp_to_ptr(mp_arr);
    mp_int_t len = mp_obj_get_int(mp_len);
    //TODO check dim!
    lv_area_t *lv_arr = (lv_area_t*)m_malloc(len * sizeof(lv_area_t));
    mp_obj_t iter = mp_getiter(mp_arr, NULL);
    mp_obj_t item;
    size_t i = 0;
    while ((item = mp_iternext(iter)) != MP_OBJ_STOP_ITERATION) {
        lv_arr[i++] = mp_write_lv_area_t(item);
    }
    return (lv_area_t *)lv_arr;
}
    
STATIC mp_obj_t mp_arr_from_lv_area_t___32__(lv_area_t *arr)
{
    mp_obj_t obj_arr[32];
    for (size_t i=0; i<32; i++){
        obj_arr[i] = mp_read_lv_area_t(arr[i]);
    }
    return mp_obj_new_list(32, obj_arr); // TODO: return custom iterable object!
}
    

/*
 * Array convertors for uint8_t [32]
 */

STATIC uint8_t *mp_arr_to_uint8_t___32__(mp_obj_t mp_arr)
{
    mp_obj_t mp_len = mp_obj_len_maybe(mp_arr);
    if (mp_len == MP_OBJ_NULL) return mp_to_ptr(mp_arr);
    mp_int_t len = mp_obj_get_int(mp_len);
    //TODO check dim!
    uint8_t *lv_arr = (uint8_t*)m_malloc(len * sizeof(uint8_t));
    mp_obj_t iter = mp_getiter(mp_arr, NULL);
    mp_obj_t item;
    size_t i = 0;
    while ((item = mp_iternext(iter)) != MP_OBJ_STOP_ITERATION) {
        lv_arr[i++] = (uint8_t)mp_obj_get_int(item);
    }
    return (uint8_t *)lv_arr;
}
    
STATIC mp_obj_t mp_arr_from_uint8_t___32__(uint8_t *arr)
{
    mp_obj_t obj_arr[32];
    for (size_t i=0; i<32; i++){
        obj_arr[i] = mp_obj_new_int_from_uint(arr[i]);
    }
    return mp_obj_new_list(32, obj_arr); // TODO: return custom iterable object!
}
    

/*
 * Struct lv_disp_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_disp_t_type();

STATIC inline lv_disp_t* mp_write_ptr_lv_disp_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_disp_t_type()));
    return (lv_disp_t*)self->data;
}

#define mp_write_lv_disp_t(struct_obj) *mp_write_ptr_lv_disp_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_disp_t(lv_disp_t *field)
{
    return lv_to_mp_struct(get_mp_lv_disp_t_type(), (void*)field);
}

#define mp_read_lv_disp_t(field) mp_read_ptr_lv_disp_t(copy_buffer(&field, sizeof(lv_disp_t)))
#define mp_read_byref_lv_disp_t(field) mp_read_ptr_lv_disp_t(&field)

STATIC void mp_lv_disp_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_disp_t *data = (lv_disp_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_driver: dest[0] = mp_read_ptr_lv_disp_drv_t((void*)data->driver); break; // converting from lv_disp_drv_t *;
            case MP_QSTR_refr_timer: dest[0] = mp_read_ptr_lv_timer_t((void*)data->refr_timer); break; // converting from lv_timer_t *;
            case MP_QSTR_theme: dest[0] = mp_read_ptr_lv_theme_t((void*)data->theme); break; // converting from lv_theme_t *;
            case MP_QSTR_screens: dest[0] = ptr_to_mp((void*)data->screens); break; // converting from lv_obj_t **;
            case MP_QSTR_act_scr: dest[0] = lv_to_mp((void*)data->act_scr); break; // converting from lv_obj_t *;
            case MP_QSTR_prev_scr: dest[0] = lv_to_mp((void*)data->prev_scr); break; // converting from lv_obj_t *;
            case MP_QSTR_scr_to_load: dest[0] = lv_to_mp((void*)data->scr_to_load); break; // converting from lv_obj_t *;
            case MP_QSTR_top_layer: dest[0] = lv_to_mp((void*)data->top_layer); break; // converting from lv_obj_t *;
            case MP_QSTR_sys_layer: dest[0] = lv_to_mp((void*)data->sys_layer); break; // converting from lv_obj_t *;
            case MP_QSTR_screen_cnt: dest[0] = mp_obj_new_int_from_uint(data->screen_cnt); break; // converting from uint32_t;
            case MP_QSTR_draw_prev_over_act: dest[0] = mp_obj_new_int_from_uint(data->draw_prev_over_act); break; // converting from uint8_t;
            case MP_QSTR_del_prev: dest[0] = mp_obj_new_int_from_uint(data->del_prev); break; // converting from uint8_t;
            case MP_QSTR_rendering_in_progress: dest[0] = mp_obj_new_int_from_uint(data->rendering_in_progress); break; // converting from uint8_t;
            case MP_QSTR_bg_opa: dest[0] = mp_obj_new_int_from_uint(data->bg_opa); break; // converting from lv_opa_t;
            case MP_QSTR_bg_color: dest[0] = mp_read_byref_lv_color16_t(data->bg_color); break; // converting from lv_color_t;
            case MP_QSTR_bg_img: dest[0] = ptr_to_mp((void*)data->bg_img); break; // converting from void *;
            case MP_QSTR_inv_areas: dest[0] = mp_arr_from_lv_area_t___32__(data->inv_areas); break; // converting from lv_area_t [32];
            case MP_QSTR_inv_area_joined: dest[0] = mp_arr_from_uint8_t___32__(data->inv_area_joined); break; // converting from uint8_t [32];
            case MP_QSTR_inv_p: dest[0] = mp_obj_new_int_from_uint(data->inv_p); break; // converting from uint16_t;
            case MP_QSTR_inv_en_cnt: dest[0] = mp_obj_new_int(data->inv_en_cnt); break; // converting from int32_t;
            case MP_QSTR_last_activity_time: dest[0] = mp_obj_new_int_from_uint(data->last_activity_time); break; // converting from uint32_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_driver: data->driver = (void*)mp_write_ptr_lv_disp_drv_t(dest[1]); break; // converting to lv_disp_drv_t *;
                case MP_QSTR_refr_timer: data->refr_timer = (void*)mp_write_ptr_lv_timer_t(dest[1]); break; // converting to lv_timer_t *;
                case MP_QSTR_theme: data->theme = (void*)mp_write_ptr_lv_theme_t(dest[1]); break; // converting to lv_theme_t *;
                case MP_QSTR_screens: data->screens = (void*)mp_to_ptr(dest[1]); break; // converting to lv_obj_t **;
                case MP_QSTR_act_scr: data->act_scr = (void*)mp_to_lv(dest[1]); break; // converting to lv_obj_t *;
                case MP_QSTR_prev_scr: data->prev_scr = (void*)mp_to_lv(dest[1]); break; // converting to lv_obj_t *;
                case MP_QSTR_scr_to_load: data->scr_to_load = (void*)mp_to_lv(dest[1]); break; // converting to lv_obj_t *;
                case MP_QSTR_top_layer: data->top_layer = (void*)mp_to_lv(dest[1]); break; // converting to lv_obj_t *;
                case MP_QSTR_sys_layer: data->sys_layer = (void*)mp_to_lv(dest[1]); break; // converting to lv_obj_t *;
                case MP_QSTR_screen_cnt: data->screen_cnt = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_draw_prev_over_act: data->draw_prev_over_act = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                case MP_QSTR_del_prev: data->del_prev = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                case MP_QSTR_rendering_in_progress: data->rendering_in_progress = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                case MP_QSTR_bg_opa: data->bg_opa = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to lv_opa_t;
                case MP_QSTR_bg_color: data->bg_color = mp_write_lv_color16_t(dest[1]); break; // converting to lv_color_t;
                case MP_QSTR_bg_img: data->bg_img = (void*)mp_to_ptr(dest[1]); break; // converting to void *;
                case MP_QSTR_inv_areas: memcpy((void*)&data->inv_areas, mp_arr_to_lv_area_t___32__(dest[1]), sizeof(lv_area_t)*32); break; // converting to lv_area_t [32];
                case MP_QSTR_inv_area_joined: memcpy((void*)&data->inv_area_joined, mp_arr_to_uint8_t___32__(dest[1]), sizeof(uint8_t)*32); break; // converting to uint8_t [32];
                case MP_QSTR_inv_p: data->inv_p = (uint16_t)mp_obj_get_int(dest[1]); break; // converting to uint16_t;
                case MP_QSTR_inv_en_cnt: data->inv_en_cnt = (int32_t)mp_obj_get_int(dest[1]); break; // converting to int32_t;
                case MP_QSTR_last_activity_time: data->last_activity_time = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_disp_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_disp_t");
}

STATIC const mp_obj_dict_t mp_lv_disp_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_disp_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_disp_t,
    .print = mp_lv_disp_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_disp_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_disp_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_disp_t_type()
{
    return &mp_lv_disp_t_type;
}
    

/*
 * lvgl extension definition for:
 * lv_disp_t *lv_obj_get_disp(const struct _lv_obj_t *obj)
 */
 
STATIC mp_obj_t mp_lv_obj_get_disp(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const struct _lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_disp_t * _res = ((lv_disp_t *(*)(const struct _lv_obj_t *))lv_func_ptr)(obj);
    return mp_read_ptr_lv_disp_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_disp_obj, 1, mp_lv_obj_get_disp, lv_obj_get_disp);
    
/* Reusing lv_obj_get_screen for lv_obj_get_parent */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_parent_obj, 1, mp_lv_obj_get_screen, lv_obj_get_parent);
    

/*
 * lvgl extension definition for:
 * struct _lv_obj_t *lv_obj_get_child(const struct _lv_obj_t *obj, int32_t id)
 */
 
STATIC mp_obj_t mp_lv_obj_get_child(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const struct _lv_obj_t *obj = mp_to_lv(mp_args[0]);
    int32_t id = (int32_t)mp_obj_get_int(mp_args[1]);
    lv_obj_t * _res = ((struct _lv_obj_t *(*)(const struct _lv_obj_t *, int32_t))lv_func_ptr)(obj, id);
    return lv_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_child_obj, 2, mp_lv_obj_get_child, lv_obj_get_child);
    
/* Reusing lv_obj_get_child_id for lv_obj_get_child_cnt */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_child_cnt_obj, 1, mp_lv_obj_get_child_id, lv_obj_get_child_cnt);
    
/* Reusing lv_obj_get_child_id for lv_obj_get_index */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_index_obj, 1, mp_lv_obj_get_child_id, lv_obj_get_index);
    

/*
 * Callback function cb
 * lv_obj_tree_walk_res_t lv_obj_tree_walk_cb_t(struct _lv_obj_t *, void *)
 */

STATIC lv_obj_tree_walk_res_t cb_callback(struct _lv_obj_t * arg0, void * arg1)
{
    mp_obj_t mp_args[2];
    mp_args[0] = lv_to_mp((void*)arg0);
    mp_args[1] = ptr_to_mp((void*)arg1);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    mp_obj_t callback_result = mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_cb)) , 2, 0, mp_args);
    return (int)mp_obj_get_int(callback_result);
}


/*
 * lvgl extension definition for:
 * void lv_obj_tree_walk(struct _lv_obj_t *start_obj, lv_obj_tree_walk_cb_t cb, void *user_data)
 */
 
STATIC mp_obj_t mp_lv_obj_tree_walk(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    void *user_data = mp_to_ptr(mp_args[2]);
    void *cb = mp_lv_callback(mp_args[1], &cb_callback, MP_QSTR_cb, &user_data);
    struct _lv_obj_t *start_obj = mp_to_lv(mp_args[0]);
    ((void (*)(struct _lv_obj_t *, lv_obj_tree_walk_cb_t, void *))lv_func_ptr)(start_obj, cb, user_data);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_tree_walk_obj, 3, mp_lv_obj_tree_walk, lv_obj_tree_walk);
    

/*
 * lvgl extension definition for:
 * void lv_obj_set_scrollbar_mode(struct _lv_obj_t *obj, lv_scrollbar_mode_t mode)
 */
 
STATIC mp_obj_t mp_lv_obj_set_scrollbar_mode(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_scrollbar_mode_t mode = (uint8_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(struct _lv_obj_t *, lv_scrollbar_mode_t))lv_func_ptr)(obj, mode);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_scrollbar_mode_obj, 2, mp_lv_obj_set_scrollbar_mode, lv_obj_set_scrollbar_mode);
    

/*
 * lvgl extension definition for:
 * void lv_obj_set_scroll_dir(struct _lv_obj_t *obj, lv_dir_t dir)
 */
 
STATIC mp_obj_t mp_lv_obj_set_scroll_dir(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_dir_t dir = (uint8_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(struct _lv_obj_t *, lv_dir_t))lv_func_ptr)(obj, dir);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_scroll_dir_obj, 2, mp_lv_obj_set_scroll_dir, lv_obj_set_scroll_dir);
    

/*
 * lvgl extension definition for:
 * void lv_obj_set_scroll_snap_x(struct _lv_obj_t *obj, lv_scroll_snap_t align)
 */
 
STATIC mp_obj_t mp_lv_obj_set_scroll_snap_x(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_scroll_snap_t align = (uint8_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(struct _lv_obj_t *, lv_scroll_snap_t))lv_func_ptr)(obj, align);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_scroll_snap_x_obj, 2, mp_lv_obj_set_scroll_snap_x, lv_obj_set_scroll_snap_x);
    
/* Reusing lv_obj_set_scroll_snap_x for lv_obj_set_scroll_snap_y */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_scroll_snap_y_obj, 2, mp_lv_obj_set_scroll_snap_x, lv_obj_set_scroll_snap_y);
    

/*
 * lvgl extension definition for:
 * lv_scrollbar_mode_t lv_obj_get_scrollbar_mode(const struct _lv_obj_t *obj)
 */
 
STATIC mp_obj_t mp_lv_obj_get_scrollbar_mode(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const struct _lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_scrollbar_mode_t _res = ((lv_scrollbar_mode_t (*)(const struct _lv_obj_t *))lv_func_ptr)(obj);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_scrollbar_mode_obj, 1, mp_lv_obj_get_scrollbar_mode, lv_obj_get_scrollbar_mode);
    

/*
 * lvgl extension definition for:
 * lv_dir_t lv_obj_get_scroll_dir(const struct _lv_obj_t *obj)
 */
 
STATIC mp_obj_t mp_lv_obj_get_scroll_dir(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const struct _lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_dir_t _res = ((lv_dir_t (*)(const struct _lv_obj_t *))lv_func_ptr)(obj);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_scroll_dir_obj, 1, mp_lv_obj_get_scroll_dir, lv_obj_get_scroll_dir);
    

/*
 * lvgl extension definition for:
 * lv_scroll_snap_t lv_obj_get_scroll_snap_x(const struct _lv_obj_t *obj)
 */
 
STATIC mp_obj_t mp_lv_obj_get_scroll_snap_x(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const struct _lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_scroll_snap_t _res = ((lv_scroll_snap_t (*)(const struct _lv_obj_t *))lv_func_ptr)(obj);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_scroll_snap_x_obj, 1, mp_lv_obj_get_scroll_snap_x, lv_obj_get_scroll_snap_x);
    
/* Reusing lv_obj_get_scroll_snap_x for lv_obj_get_scroll_snap_y */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_scroll_snap_y_obj, 1, mp_lv_obj_get_scroll_snap_x, lv_obj_get_scroll_snap_y);
    
/* Reusing lv_obj_get_x for lv_obj_get_scroll_x */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_scroll_x_obj, 1, mp_lv_obj_get_x, lv_obj_get_scroll_x);
    
/* Reusing lv_obj_get_x for lv_obj_get_scroll_y */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_scroll_y_obj, 1, mp_lv_obj_get_x, lv_obj_get_scroll_y);
    

/*
 * lvgl extension definition for:
 * lv_coord_t lv_obj_get_scroll_top(struct _lv_obj_t *obj)
 */
 
STATIC mp_obj_t mp_lv_obj_get_scroll_top(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_coord_t _res = ((lv_coord_t (*)(struct _lv_obj_t *))lv_func_ptr)(obj);
    return mp_obj_new_int(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_scroll_top_obj, 1, mp_lv_obj_get_scroll_top, lv_obj_get_scroll_top);
    
/* Reusing lv_obj_get_scroll_top for lv_obj_get_scroll_bottom */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_scroll_bottom_obj, 1, mp_lv_obj_get_scroll_top, lv_obj_get_scroll_bottom);
    
/* Reusing lv_obj_get_scroll_top for lv_obj_get_scroll_left */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_scroll_left_obj, 1, mp_lv_obj_get_scroll_top, lv_obj_get_scroll_left);
    
/* Reusing lv_obj_get_scroll_top for lv_obj_get_scroll_right */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_scroll_right_obj, 1, mp_lv_obj_get_scroll_top, lv_obj_get_scroll_right);
    

/*
 * lvgl extension definition for:
 * void lv_obj_get_scroll_end(struct _lv_obj_t *obj, lv_point_t *end)
 */
 
STATIC mp_obj_t mp_lv_obj_get_scroll_end(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_point_t *end = mp_write_ptr_lv_point_t(mp_args[1]);
    ((void (*)(struct _lv_obj_t *, lv_point_t *))lv_func_ptr)(obj, end);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_scroll_end_obj, 2, mp_lv_obj_get_scroll_end, lv_obj_get_scroll_end);
    

/*
 * lvgl extension definition for:
 * void lv_obj_scroll_by(struct _lv_obj_t *obj, lv_coord_t x, lv_coord_t y, lv_anim_enable_t anim_en)
 */
 
STATIC mp_obj_t mp_lv_obj_scroll_by(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_coord_t x = (int16_t)mp_obj_get_int(mp_args[1]);
    lv_coord_t y = (int16_t)mp_obj_get_int(mp_args[2]);
    lv_anim_enable_t anim_en = (int)mp_obj_get_int(mp_args[3]);
    ((void (*)(struct _lv_obj_t *, lv_coord_t, lv_coord_t, lv_anim_enable_t))lv_func_ptr)(obj, x, y, anim_en);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_scroll_by_obj, 4, mp_lv_obj_scroll_by, lv_obj_scroll_by);
    
/* Reusing lv_obj_scroll_by for lv_obj_scroll_by_bounded */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_scroll_by_bounded_obj, 4, mp_lv_obj_scroll_by, lv_obj_scroll_by_bounded);
    
/* Reusing lv_obj_scroll_by for lv_obj_scroll_to */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_scroll_to_obj, 4, mp_lv_obj_scroll_by, lv_obj_scroll_to);
    

/*
 * lvgl extension definition for:
 * void lv_obj_scroll_to_x(struct _lv_obj_t *obj, lv_coord_t x, lv_anim_enable_t anim_en)
 */
 
STATIC mp_obj_t mp_lv_obj_scroll_to_x(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_coord_t x = (int16_t)mp_obj_get_int(mp_args[1]);
    lv_anim_enable_t anim_en = (int)mp_obj_get_int(mp_args[2]);
    ((void (*)(struct _lv_obj_t *, lv_coord_t, lv_anim_enable_t))lv_func_ptr)(obj, x, anim_en);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_scroll_to_x_obj, 3, mp_lv_obj_scroll_to_x, lv_obj_scroll_to_x);
    
/* Reusing lv_obj_scroll_to_x for lv_obj_scroll_to_y */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_scroll_to_y_obj, 3, mp_lv_obj_scroll_to_x, lv_obj_scroll_to_y);
    

/*
 * lvgl extension definition for:
 * void lv_obj_scroll_to_view(struct _lv_obj_t *obj, lv_anim_enable_t anim_en)
 */
 
STATIC mp_obj_t mp_lv_obj_scroll_to_view(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_anim_enable_t anim_en = (int)mp_obj_get_int(mp_args[1]);
    ((void (*)(struct _lv_obj_t *, lv_anim_enable_t))lv_func_ptr)(obj, anim_en);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_scroll_to_view_obj, 2, mp_lv_obj_scroll_to_view, lv_obj_scroll_to_view);
    
/* Reusing lv_obj_scroll_to_view for lv_obj_scroll_to_view_recursive */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_scroll_to_view_recursive_obj, 2, mp_lv_obj_scroll_to_view, lv_obj_scroll_to_view_recursive);
    
/* Reusing lv_obj_is_layout_positioned for lv_obj_is_scrolling */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_is_scrolling_obj, 1, mp_lv_obj_is_layout_positioned, lv_obj_is_scrolling);
    
/* Reusing lv_obj_scroll_to_view for lv_obj_update_snap */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_update_snap_obj, 2, mp_lv_obj_scroll_to_view, lv_obj_update_snap);
    

/*
 * lvgl extension definition for:
 * void lv_obj_get_scrollbar_area(struct _lv_obj_t *obj, lv_area_t *hor, lv_area_t *ver)
 */
 
STATIC mp_obj_t mp_lv_obj_get_scrollbar_area(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_area_t *hor = mp_write_ptr_lv_area_t(mp_args[1]);
    lv_area_t *ver = mp_write_ptr_lv_area_t(mp_args[2]);
    ((void (*)(struct _lv_obj_t *, lv_area_t *, lv_area_t *))lv_func_ptr)(obj, hor, ver);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_scrollbar_area_obj, 3, mp_lv_obj_get_scrollbar_area, lv_obj_get_scrollbar_area);
    
/* Reusing lv_obj_center for lv_obj_scrollbar_invalidate */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_scrollbar_invalidate_obj, 1, mp_lv_obj_center, lv_obj_scrollbar_invalidate);
    
/* Reusing lv_obj_scroll_to_view for lv_obj_readjust_scroll */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_readjust_scroll_obj, 2, mp_lv_obj_scroll_to_view, lv_obj_readjust_scroll);
    
typedef __typeof__( ((lv_style_t*)(0))->v_p ) lv_style_v_p_t;

/*
 * Struct lv_style_value_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_style_value_t_type();

STATIC inline lv_style_value_t* mp_write_ptr_lv_style_value_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_style_value_t_type()));
    return (lv_style_value_t*)self->data;
}

#define mp_write_lv_style_value_t(struct_obj) *mp_write_ptr_lv_style_value_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_style_value_t(lv_style_value_t *field)
{
    return lv_to_mp_struct(get_mp_lv_style_value_t_type(), (void*)field);
}

#define mp_read_lv_style_value_t(field) mp_read_ptr_lv_style_value_t(copy_buffer(&field, sizeof(lv_style_value_t)))
#define mp_read_byref_lv_style_value_t(field) mp_read_ptr_lv_style_value_t(&field)

STATIC void mp_lv_style_value_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_style_value_t *data = (lv_style_value_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_num: dest[0] = mp_obj_new_int(data->num); break; // converting from int32_t;
            case MP_QSTR_ptr: dest[0] = ptr_to_mp((void*)data->ptr); break; // converting from void *;
            case MP_QSTR_color: dest[0] = mp_read_byref_lv_color16_t(data->color); break; // converting from lv_color_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_num: data->num = (int32_t)mp_obj_get_int(dest[1]); break; // converting to int32_t;
                case MP_QSTR_ptr: data->ptr = (void*)mp_to_ptr(dest[1]); break; // converting to void *;
                case MP_QSTR_color: data->color = mp_write_lv_color16_t(dest[1]); break; // converting to lv_color_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_style_value_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_style_value_t");
}

STATIC const mp_obj_dict_t mp_lv_style_value_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_style_value_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_style_value_t,
    .print = mp_lv_style_value_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_style_value_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_style_value_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_style_value_t_type()
{
    return &mp_lv_style_value_t_type;
}
    

/*
 * Struct lv_style_const_prop_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_style_const_prop_t_type();

STATIC inline lv_style_const_prop_t* mp_write_ptr_lv_style_const_prop_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_style_const_prop_t_type()));
    return (lv_style_const_prop_t*)self->data;
}

#define mp_write_lv_style_const_prop_t(struct_obj) *mp_write_ptr_lv_style_const_prop_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_style_const_prop_t(lv_style_const_prop_t *field)
{
    return lv_to_mp_struct(get_mp_lv_style_const_prop_t_type(), (void*)field);
}

#define mp_read_lv_style_const_prop_t(field) mp_read_ptr_lv_style_const_prop_t(copy_buffer(&field, sizeof(lv_style_const_prop_t)))
#define mp_read_byref_lv_style_const_prop_t(field) mp_read_ptr_lv_style_const_prop_t(&field)

STATIC void mp_lv_style_const_prop_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_style_const_prop_t *data = (lv_style_const_prop_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_prop: dest[0] = mp_obj_new_int(data->prop); break; // converting from lv_style_prop_t;
            case MP_QSTR_value: dest[0] = mp_read_byref_lv_style_value_t(data->value); break; // converting from lv_style_value_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_prop: data->prop = (int)mp_obj_get_int(dest[1]); break; // converting to lv_style_prop_t;
                case MP_QSTR_value: data->value = mp_write_lv_style_value_t(dest[1]); break; // converting to lv_style_value_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_style_const_prop_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_style_const_prop_t");
}

STATIC const mp_obj_dict_t mp_lv_style_const_prop_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_style_const_prop_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_style_const_prop_t,
    .print = mp_lv_style_const_prop_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_style_const_prop_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_style_const_prop_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_style_const_prop_t_type()
{
    return &mp_lv_style_const_prop_t_type;
}
    

/*
 * Struct lv_style_v_p_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_style_v_p_t_type();

STATIC inline lv_style_v_p_t* mp_write_ptr_lv_style_v_p_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_style_v_p_t_type()));
    return (lv_style_v_p_t*)self->data;
}

#define mp_write_lv_style_v_p_t(struct_obj) *mp_write_ptr_lv_style_v_p_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_style_v_p_t(lv_style_v_p_t *field)
{
    return lv_to_mp_struct(get_mp_lv_style_v_p_t_type(), (void*)field);
}

#define mp_read_lv_style_v_p_t(field) mp_read_ptr_lv_style_v_p_t(copy_buffer(&field, sizeof(lv_style_v_p_t)))
#define mp_read_byref_lv_style_v_p_t(field) mp_read_ptr_lv_style_v_p_t(&field)

STATIC void mp_lv_style_v_p_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_style_v_p_t *data = (lv_style_v_p_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_value1: dest[0] = mp_read_byref_lv_style_value_t(data->value1); break; // converting from lv_style_value_t;
            case MP_QSTR_values_and_props: dest[0] = ptr_to_mp((void*)data->values_and_props); break; // converting from uint8_t *;
            case MP_QSTR_const_props: dest[0] = mp_read_ptr_lv_style_const_prop_t((void*)data->const_props); break; // converting from lv_style_const_prop_t *;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_value1: data->value1 = mp_write_lv_style_value_t(dest[1]); break; // converting to lv_style_value_t;
                case MP_QSTR_values_and_props: data->values_and_props = (void*)mp_to_ptr(dest[1]); break; // converting to uint8_t *;
                case MP_QSTR_const_props: data->const_props = (void*)mp_write_ptr_lv_style_const_prop_t(dest[1]); break; // converting to lv_style_const_prop_t *;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_style_v_p_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_style_v_p_t");
}

STATIC const mp_obj_dict_t mp_lv_style_v_p_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_style_v_p_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_style_v_p_t,
    .print = mp_lv_style_v_p_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_style_v_p_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_style_v_p_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_style_v_p_t_type()
{
    return &mp_lv_style_v_p_t_type;
}
    

/*
 * Struct lv_style_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_style_t_type();

STATIC inline lv_style_t* mp_write_ptr_lv_style_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_style_t_type()));
    return (lv_style_t*)self->data;
}

#define mp_write_lv_style_t(struct_obj) *mp_write_ptr_lv_style_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_style_t(lv_style_t *field)
{
    return lv_to_mp_struct(get_mp_lv_style_t_type(), (void*)field);
}

#define mp_read_lv_style_t(field) mp_read_ptr_lv_style_t(copy_buffer(&field, sizeof(lv_style_t)))
#define mp_read_byref_lv_style_t(field) mp_read_ptr_lv_style_t(&field)

STATIC void mp_lv_style_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_style_t *data = (lv_style_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_v_p: dest[0] = mp_read_byref_lv_style_v_p_t(data->v_p); break; // converting from lv_style_v_p_t;
            case MP_QSTR_prop1: dest[0] = mp_obj_new_int_from_uint(data->prop1); break; // converting from uint16_t;
            case MP_QSTR_has_group: dest[0] = mp_obj_new_int_from_uint(data->has_group); break; // converting from uint8_t;
            case MP_QSTR_prop_cnt: dest[0] = mp_obj_new_int_from_uint(data->prop_cnt); break; // converting from uint8_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_v_p: data->v_p = mp_write_lv_style_v_p_t(dest[1]); break; // converting to lv_style_v_p_t;
                case MP_QSTR_prop1: data->prop1 = (uint16_t)mp_obj_get_int(dest[1]); break; // converting to uint16_t;
                case MP_QSTR_has_group: data->has_group = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                case MP_QSTR_prop_cnt: data->prop_cnt = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_style_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_style_t");
}

STATIC const mp_obj_dict_t mp_lv_style_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_style_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_style_t,
    .print = mp_lv_style_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_style_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_style_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_style_t_type()
{
    return &mp_lv_style_t_type;
}
    

/*
 * lvgl extension definition for:
 * void lv_obj_add_style(struct _lv_obj_t *obj, lv_style_t *style, lv_style_selector_t selector)
 */
 
STATIC mp_obj_t mp_lv_obj_add_style(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_style_t *style = mp_write_ptr_lv_style_t(mp_args[1]);
    lv_style_selector_t selector = (uint32_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(struct _lv_obj_t *, lv_style_t *, lv_style_selector_t))lv_func_ptr)(obj, style, selector);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_add_style_obj, 3, mp_lv_obj_add_style, lv_obj_add_style);
    
/* Reusing lv_obj_add_style for lv_obj_remove_style */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_remove_style_obj, 3, mp_lv_obj_add_style, lv_obj_remove_style);
    

/*
 * lvgl extension definition for:
 * void lv_obj_report_style_change(lv_style_t *style)
 */
 
STATIC mp_obj_t mp_lv_obj_report_style_change(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_style_t *style = mp_write_ptr_lv_style_t(mp_args[0]);
    ((void (*)(lv_style_t *))lv_func_ptr)(style);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_obj_report_style_change_obj, 1, mp_lv_obj_report_style_change, lv_obj_report_style_change);
    

/*
 * lvgl extension definition for:
 * void lv_obj_refresh_style(struct _lv_obj_t *obj, lv_part_t part, lv_style_prop_t prop)
 */
 
STATIC mp_obj_t mp_lv_obj_refresh_style(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_part_t part = (uint32_t)mp_obj_get_int(mp_args[1]);
    lv_style_prop_t prop = (int)mp_obj_get_int(mp_args[2]);
    ((void (*)(struct _lv_obj_t *, lv_part_t, lv_style_prop_t))lv_func_ptr)(obj, part, prop);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_refresh_style_obj, 3, mp_lv_obj_refresh_style, lv_obj_refresh_style);
    

/*
 * lvgl extension definition for:
 * void lv_obj_enable_style_refresh(bool en)
 */
 
STATIC mp_obj_t mp_lv_obj_enable_style_refresh(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    bool en = mp_obj_is_true(mp_args[0]);
    ((void (*)(bool))lv_func_ptr)(en);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_obj_enable_style_refresh_obj, 1, mp_lv_obj_enable_style_refresh, lv_obj_enable_style_refresh);
    

/*
 * lvgl extension definition for:
 * lv_style_value_t lv_obj_get_style_prop(const struct _lv_obj_t *obj, lv_part_t part, lv_style_prop_t prop)
 */
 
STATIC mp_obj_t mp_lv_obj_get_style_prop(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const struct _lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_part_t part = (uint32_t)mp_obj_get_int(mp_args[1]);
    lv_style_prop_t prop = (int)mp_obj_get_int(mp_args[2]);
    lv_style_value_t _res = ((lv_style_value_t (*)(const struct _lv_obj_t *, lv_part_t, lv_style_prop_t))lv_func_ptr)(obj, part, prop);
    return mp_read_lv_style_value_t(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_prop_obj, 3, mp_lv_obj_get_style_prop, lv_obj_get_style_prop);
    

/*
 * lvgl extension definition for:
 * void lv_obj_set_local_style_prop(struct _lv_obj_t *obj, lv_style_prop_t prop, lv_style_value_t value, lv_style_selector_t selector)
 */
 
STATIC mp_obj_t mp_lv_obj_set_local_style_prop(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_style_prop_t prop = (int)mp_obj_get_int(mp_args[1]);
    lv_style_value_t value = mp_write_lv_style_value_t(mp_args[2]);
    lv_style_selector_t selector = (uint32_t)mp_obj_get_int(mp_args[3]);
    ((void (*)(struct _lv_obj_t *, lv_style_prop_t, lv_style_value_t, lv_style_selector_t))lv_func_ptr)(obj, prop, value, selector);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_local_style_prop_obj, 4, mp_lv_obj_set_local_style_prop, lv_obj_set_local_style_prop);
    

/*
 * lvgl extension definition for:
 * void lv_obj_set_local_style_prop_meta(struct _lv_obj_t *obj, lv_style_prop_t prop, uint16_t meta, lv_style_selector_t selector)
 */
 
STATIC mp_obj_t mp_lv_obj_set_local_style_prop_meta(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_style_prop_t prop = (int)mp_obj_get_int(mp_args[1]);
    uint16_t meta = (uint16_t)mp_obj_get_int(mp_args[2]);
    lv_style_selector_t selector = (uint32_t)mp_obj_get_int(mp_args[3]);
    ((void (*)(struct _lv_obj_t *, lv_style_prop_t, uint16_t, lv_style_selector_t))lv_func_ptr)(obj, prop, meta, selector);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_local_style_prop_meta_obj, 4, mp_lv_obj_set_local_style_prop_meta, lv_obj_set_local_style_prop_meta);
    

/*
 * lvgl extension definition for:
 * lv_style_res_t lv_obj_get_local_style_prop(struct _lv_obj_t *obj, lv_style_prop_t prop, lv_style_value_t *value, lv_style_selector_t selector)
 */
 
STATIC mp_obj_t mp_lv_obj_get_local_style_prop(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_style_prop_t prop = (int)mp_obj_get_int(mp_args[1]);
    lv_style_value_t *value = mp_write_ptr_lv_style_value_t(mp_args[2]);
    lv_style_selector_t selector = (uint32_t)mp_obj_get_int(mp_args[3]);
    lv_style_res_t _res = ((lv_style_res_t (*)(struct _lv_obj_t *, lv_style_prop_t, lv_style_value_t *, lv_style_selector_t))lv_func_ptr)(obj, prop, value, selector);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_local_style_prop_obj, 4, mp_lv_obj_get_local_style_prop, lv_obj_get_local_style_prop);
    

/*
 * lvgl extension definition for:
 * bool lv_obj_remove_local_style_prop(struct _lv_obj_t *obj, lv_style_prop_t prop, lv_style_selector_t selector)
 */
 
STATIC mp_obj_t mp_lv_obj_remove_local_style_prop(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_style_prop_t prop = (int)mp_obj_get_int(mp_args[1]);
    lv_style_selector_t selector = (uint32_t)mp_obj_get_int(mp_args[2]);
    bool _res = ((bool (*)(struct _lv_obj_t *, lv_style_prop_t, lv_style_selector_t))lv_func_ptr)(obj, prop, selector);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_remove_local_style_prop_obj, 3, mp_lv_obj_remove_local_style_prop, lv_obj_remove_local_style_prop);
    

/*
 * lvgl extension definition for:
 * void lv_obj_fade_in(struct _lv_obj_t *obj, uint32_t time, uint32_t delay)
 */
 
STATIC mp_obj_t mp_lv_obj_fade_in(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint32_t time = (uint32_t)mp_obj_get_int(mp_args[1]);
    uint32_t delay = (uint32_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(struct _lv_obj_t *, uint32_t, uint32_t))lv_func_ptr)(obj, time, delay);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_fade_in_obj, 3, mp_lv_obj_fade_in, lv_obj_fade_in);
    
/* Reusing lv_obj_fade_in for lv_obj_fade_out */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_fade_out_obj, 3, mp_lv_obj_fade_in, lv_obj_fade_out);
    

/*
 * lvgl extension definition for:
 * lv_state_t lv_obj_style_get_selector_state(lv_style_selector_t selector)
 */
 
STATIC mp_obj_t mp_lv_obj_style_get_selector_state(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_style_selector_t selector = (uint32_t)mp_obj_get_int(mp_args[0]);
    lv_state_t _res = ((lv_state_t (*)(lv_style_selector_t))lv_func_ptr)(selector);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_obj_style_get_selector_state_obj, 1, mp_lv_obj_style_get_selector_state, lv_obj_style_get_selector_state);
    

/*
 * lvgl extension definition for:
 * lv_part_t lv_obj_style_get_selector_part(lv_style_selector_t selector)
 */
 
STATIC mp_obj_t mp_lv_obj_style_get_selector_part(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_style_selector_t selector = (uint32_t)mp_obj_get_int(mp_args[0]);
    lv_part_t _res = ((lv_part_t (*)(lv_style_selector_t))lv_func_ptr)(selector);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_obj_style_get_selector_part_obj, 1, mp_lv_obj_style_get_selector_part, lv_obj_style_get_selector_part);
    
/* Reusing lv_obj_set_style_pad_all for lv_obj_set_style_width */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_width_obj, 3, mp_lv_obj_set_style_pad_all, lv_obj_set_style_width);
    
/* Reusing lv_obj_set_style_pad_all for lv_obj_set_style_min_width */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_min_width_obj, 3, mp_lv_obj_set_style_pad_all, lv_obj_set_style_min_width);
    
/* Reusing lv_obj_set_style_pad_all for lv_obj_set_style_max_width */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_max_width_obj, 3, mp_lv_obj_set_style_pad_all, lv_obj_set_style_max_width);
    
/* Reusing lv_obj_set_style_pad_all for lv_obj_set_style_height */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_height_obj, 3, mp_lv_obj_set_style_pad_all, lv_obj_set_style_height);
    
/* Reusing lv_obj_set_style_pad_all for lv_obj_set_style_min_height */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_min_height_obj, 3, mp_lv_obj_set_style_pad_all, lv_obj_set_style_min_height);
    
/* Reusing lv_obj_set_style_pad_all for lv_obj_set_style_max_height */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_max_height_obj, 3, mp_lv_obj_set_style_pad_all, lv_obj_set_style_max_height);
    
/* Reusing lv_obj_set_style_pad_all for lv_obj_set_style_x */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_x_obj, 3, mp_lv_obj_set_style_pad_all, lv_obj_set_style_x);
    
/* Reusing lv_obj_set_style_pad_all for lv_obj_set_style_y */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_y_obj, 3, mp_lv_obj_set_style_pad_all, lv_obj_set_style_y);
    

/*
 * lvgl extension definition for:
 * void lv_obj_set_style_align(struct _lv_obj_t *obj, lv_align_t value, lv_style_selector_t selector)
 */
 
STATIC mp_obj_t mp_lv_obj_set_style_align(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_align_t value = (uint8_t)mp_obj_get_int(mp_args[1]);
    lv_style_selector_t selector = (uint32_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(struct _lv_obj_t *, lv_align_t, lv_style_selector_t))lv_func_ptr)(obj, value, selector);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_align_obj, 3, mp_lv_obj_set_style_align, lv_obj_set_style_align);
    
/* Reusing lv_obj_set_style_pad_all for lv_obj_set_style_transform_width */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_transform_width_obj, 3, mp_lv_obj_set_style_pad_all, lv_obj_set_style_transform_width);
    
/* Reusing lv_obj_set_style_pad_all for lv_obj_set_style_transform_height */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_transform_height_obj, 3, mp_lv_obj_set_style_pad_all, lv_obj_set_style_transform_height);
    
/* Reusing lv_obj_set_style_pad_all for lv_obj_set_style_translate_x */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_translate_x_obj, 3, mp_lv_obj_set_style_pad_all, lv_obj_set_style_translate_x);
    
/* Reusing lv_obj_set_style_pad_all for lv_obj_set_style_translate_y */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_translate_y_obj, 3, mp_lv_obj_set_style_pad_all, lv_obj_set_style_translate_y);
    
/* Reusing lv_obj_set_style_pad_all for lv_obj_set_style_transform_zoom */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_transform_zoom_obj, 3, mp_lv_obj_set_style_pad_all, lv_obj_set_style_transform_zoom);
    
/* Reusing lv_obj_set_style_pad_all for lv_obj_set_style_transform_angle */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_transform_angle_obj, 3, mp_lv_obj_set_style_pad_all, lv_obj_set_style_transform_angle);
    
/* Reusing lv_obj_set_style_pad_all for lv_obj_set_style_transform_pivot_x */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_transform_pivot_x_obj, 3, mp_lv_obj_set_style_pad_all, lv_obj_set_style_transform_pivot_x);
    
/* Reusing lv_obj_set_style_pad_all for lv_obj_set_style_transform_pivot_y */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_transform_pivot_y_obj, 3, mp_lv_obj_set_style_pad_all, lv_obj_set_style_transform_pivot_y);
    
/* Reusing lv_obj_set_style_pad_all for lv_obj_set_style_pad_top */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_pad_top_obj, 3, mp_lv_obj_set_style_pad_all, lv_obj_set_style_pad_top);
    
/* Reusing lv_obj_set_style_pad_all for lv_obj_set_style_pad_bottom */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_pad_bottom_obj, 3, mp_lv_obj_set_style_pad_all, lv_obj_set_style_pad_bottom);
    
/* Reusing lv_obj_set_style_pad_all for lv_obj_set_style_pad_left */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_pad_left_obj, 3, mp_lv_obj_set_style_pad_all, lv_obj_set_style_pad_left);
    
/* Reusing lv_obj_set_style_pad_all for lv_obj_set_style_pad_right */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_pad_right_obj, 3, mp_lv_obj_set_style_pad_all, lv_obj_set_style_pad_right);
    
/* Reusing lv_obj_set_style_pad_all for lv_obj_set_style_pad_row */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_pad_row_obj, 3, mp_lv_obj_set_style_pad_all, lv_obj_set_style_pad_row);
    
/* Reusing lv_obj_set_style_pad_all for lv_obj_set_style_pad_column */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_pad_column_obj, 3, mp_lv_obj_set_style_pad_all, lv_obj_set_style_pad_column);
    

/*
 * lvgl extension definition for:
 * void lv_obj_set_style_bg_color(struct _lv_obj_t *obj, lv_color_t value, lv_style_selector_t selector)
 */
 
STATIC mp_obj_t mp_lv_obj_set_style_bg_color(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_color_t value = mp_write_lv_color16_t(mp_args[1]);
    lv_style_selector_t selector = (uint32_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(struct _lv_obj_t *, lv_color_t, lv_style_selector_t))lv_func_ptr)(obj, value, selector);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_bg_color_obj, 3, mp_lv_obj_set_style_bg_color, lv_obj_set_style_bg_color);
    

/*
 * lvgl extension definition for:
 * void lv_obj_set_style_bg_opa(struct _lv_obj_t *obj, lv_opa_t value, lv_style_selector_t selector)
 */
 
STATIC mp_obj_t mp_lv_obj_set_style_bg_opa(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_opa_t value = (uint8_t)mp_obj_get_int(mp_args[1]);
    lv_style_selector_t selector = (uint32_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(struct _lv_obj_t *, lv_opa_t, lv_style_selector_t))lv_func_ptr)(obj, value, selector);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_bg_opa_obj, 3, mp_lv_obj_set_style_bg_opa, lv_obj_set_style_bg_opa);
    
/* Reusing lv_obj_set_style_bg_color for lv_obj_set_style_bg_grad_color */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_bg_grad_color_obj, 3, mp_lv_obj_set_style_bg_color, lv_obj_set_style_bg_grad_color);
    

/*
 * lvgl extension definition for:
 * void lv_obj_set_style_bg_grad_dir(struct _lv_obj_t *obj, lv_grad_dir_t value, lv_style_selector_t selector)
 */
 
STATIC mp_obj_t mp_lv_obj_set_style_bg_grad_dir(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_grad_dir_t value = (uint8_t)mp_obj_get_int(mp_args[1]);
    lv_style_selector_t selector = (uint32_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(struct _lv_obj_t *, lv_grad_dir_t, lv_style_selector_t))lv_func_ptr)(obj, value, selector);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_bg_grad_dir_obj, 3, mp_lv_obj_set_style_bg_grad_dir, lv_obj_set_style_bg_grad_dir);
    
/* Reusing lv_obj_set_style_pad_all for lv_obj_set_style_bg_main_stop */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_bg_main_stop_obj, 3, mp_lv_obj_set_style_pad_all, lv_obj_set_style_bg_main_stop);
    
/* Reusing lv_obj_set_style_pad_all for lv_obj_set_style_bg_grad_stop */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_bg_grad_stop_obj, 3, mp_lv_obj_set_style_pad_all, lv_obj_set_style_bg_grad_stop);
    

/*
 * lvgl extension definition for:
 * void lv_obj_set_style_bg_grad(struct _lv_obj_t *obj, const lv_grad_dsc_t *value, lv_style_selector_t selector)
 */
 
STATIC mp_obj_t mp_lv_obj_set_style_bg_grad(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_obj_t *obj = mp_to_lv(mp_args[0]);
    const lv_grad_dsc_t *value = mp_write_ptr_lv_grad_dsc_t(mp_args[1]);
    lv_style_selector_t selector = (uint32_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(struct _lv_obj_t *, const lv_grad_dsc_t *, lv_style_selector_t))lv_func_ptr)(obj, value, selector);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_bg_grad_obj, 3, mp_lv_obj_set_style_bg_grad, lv_obj_set_style_bg_grad);
    

/*
 * lvgl extension definition for:
 * void lv_obj_set_style_bg_dither_mode(struct _lv_obj_t *obj, lv_dither_mode_t value, lv_style_selector_t selector)
 */
 
STATIC mp_obj_t mp_lv_obj_set_style_bg_dither_mode(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_dither_mode_t value = (uint8_t)mp_obj_get_int(mp_args[1]);
    lv_style_selector_t selector = (uint32_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(struct _lv_obj_t *, lv_dither_mode_t, lv_style_selector_t))lv_func_ptr)(obj, value, selector);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_bg_dither_mode_obj, 3, mp_lv_obj_set_style_bg_dither_mode, lv_obj_set_style_bg_dither_mode);
    

/*
 * lvgl extension definition for:
 * void lv_obj_set_style_bg_img_src(struct _lv_obj_t *obj, const void *value, lv_style_selector_t selector)
 */
 
STATIC mp_obj_t mp_lv_obj_set_style_bg_img_src(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_obj_t *obj = mp_to_lv(mp_args[0]);
    const void *value = mp_to_ptr(mp_args[1]);
    lv_style_selector_t selector = (uint32_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(struct _lv_obj_t *, const void *, lv_style_selector_t))lv_func_ptr)(obj, value, selector);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_bg_img_src_obj, 3, mp_lv_obj_set_style_bg_img_src, lv_obj_set_style_bg_img_src);
    
/* Reusing lv_obj_set_style_bg_opa for lv_obj_set_style_bg_img_opa */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_bg_img_opa_obj, 3, mp_lv_obj_set_style_bg_opa, lv_obj_set_style_bg_img_opa);
    
/* Reusing lv_obj_set_style_bg_color for lv_obj_set_style_bg_img_recolor */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_bg_img_recolor_obj, 3, mp_lv_obj_set_style_bg_color, lv_obj_set_style_bg_img_recolor);
    
/* Reusing lv_obj_set_style_bg_opa for lv_obj_set_style_bg_img_recolor_opa */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_bg_img_recolor_opa_obj, 3, mp_lv_obj_set_style_bg_opa, lv_obj_set_style_bg_img_recolor_opa);
    

/*
 * lvgl extension definition for:
 * void lv_obj_set_style_bg_img_tiled(struct _lv_obj_t *obj, bool value, lv_style_selector_t selector)
 */
 
STATIC mp_obj_t mp_lv_obj_set_style_bg_img_tiled(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_obj_t *obj = mp_to_lv(mp_args[0]);
    bool value = mp_obj_is_true(mp_args[1]);
    lv_style_selector_t selector = (uint32_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(struct _lv_obj_t *, bool, lv_style_selector_t))lv_func_ptr)(obj, value, selector);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_bg_img_tiled_obj, 3, mp_lv_obj_set_style_bg_img_tiled, lv_obj_set_style_bg_img_tiled);
    
/* Reusing lv_obj_set_style_bg_color for lv_obj_set_style_border_color */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_border_color_obj, 3, mp_lv_obj_set_style_bg_color, lv_obj_set_style_border_color);
    
/* Reusing lv_obj_set_style_bg_opa for lv_obj_set_style_border_opa */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_border_opa_obj, 3, mp_lv_obj_set_style_bg_opa, lv_obj_set_style_border_opa);
    
/* Reusing lv_obj_set_style_pad_all for lv_obj_set_style_border_width */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_border_width_obj, 3, mp_lv_obj_set_style_pad_all, lv_obj_set_style_border_width);
    

/*
 * lvgl extension definition for:
 * void lv_obj_set_style_border_side(struct _lv_obj_t *obj, lv_border_side_t value, lv_style_selector_t selector)
 */
 
STATIC mp_obj_t mp_lv_obj_set_style_border_side(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_border_side_t value = (uint8_t)mp_obj_get_int(mp_args[1]);
    lv_style_selector_t selector = (uint32_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(struct _lv_obj_t *, lv_border_side_t, lv_style_selector_t))lv_func_ptr)(obj, value, selector);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_border_side_obj, 3, mp_lv_obj_set_style_border_side, lv_obj_set_style_border_side);
    
/* Reusing lv_obj_set_style_bg_img_tiled for lv_obj_set_style_border_post */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_border_post_obj, 3, mp_lv_obj_set_style_bg_img_tiled, lv_obj_set_style_border_post);
    
/* Reusing lv_obj_set_style_pad_all for lv_obj_set_style_outline_width */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_outline_width_obj, 3, mp_lv_obj_set_style_pad_all, lv_obj_set_style_outline_width);
    
/* Reusing lv_obj_set_style_bg_color for lv_obj_set_style_outline_color */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_outline_color_obj, 3, mp_lv_obj_set_style_bg_color, lv_obj_set_style_outline_color);
    
/* Reusing lv_obj_set_style_bg_opa for lv_obj_set_style_outline_opa */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_outline_opa_obj, 3, mp_lv_obj_set_style_bg_opa, lv_obj_set_style_outline_opa);
    
/* Reusing lv_obj_set_style_pad_all for lv_obj_set_style_outline_pad */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_outline_pad_obj, 3, mp_lv_obj_set_style_pad_all, lv_obj_set_style_outline_pad);
    
/* Reusing lv_obj_set_style_pad_all for lv_obj_set_style_shadow_width */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_shadow_width_obj, 3, mp_lv_obj_set_style_pad_all, lv_obj_set_style_shadow_width);
    
/* Reusing lv_obj_set_style_pad_all for lv_obj_set_style_shadow_ofs_x */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_shadow_ofs_x_obj, 3, mp_lv_obj_set_style_pad_all, lv_obj_set_style_shadow_ofs_x);
    
/* Reusing lv_obj_set_style_pad_all for lv_obj_set_style_shadow_ofs_y */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_shadow_ofs_y_obj, 3, mp_lv_obj_set_style_pad_all, lv_obj_set_style_shadow_ofs_y);
    
/* Reusing lv_obj_set_style_pad_all for lv_obj_set_style_shadow_spread */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_shadow_spread_obj, 3, mp_lv_obj_set_style_pad_all, lv_obj_set_style_shadow_spread);
    
/* Reusing lv_obj_set_style_bg_color for lv_obj_set_style_shadow_color */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_shadow_color_obj, 3, mp_lv_obj_set_style_bg_color, lv_obj_set_style_shadow_color);
    
/* Reusing lv_obj_set_style_bg_opa for lv_obj_set_style_shadow_opa */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_shadow_opa_obj, 3, mp_lv_obj_set_style_bg_opa, lv_obj_set_style_shadow_opa);
    
/* Reusing lv_obj_set_style_bg_opa for lv_obj_set_style_img_opa */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_img_opa_obj, 3, mp_lv_obj_set_style_bg_opa, lv_obj_set_style_img_opa);
    
/* Reusing lv_obj_set_style_bg_color for lv_obj_set_style_img_recolor */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_img_recolor_obj, 3, mp_lv_obj_set_style_bg_color, lv_obj_set_style_img_recolor);
    
/* Reusing lv_obj_set_style_bg_opa for lv_obj_set_style_img_recolor_opa */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_img_recolor_opa_obj, 3, mp_lv_obj_set_style_bg_opa, lv_obj_set_style_img_recolor_opa);
    
/* Reusing lv_obj_set_style_pad_all for lv_obj_set_style_line_width */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_line_width_obj, 3, mp_lv_obj_set_style_pad_all, lv_obj_set_style_line_width);
    
/* Reusing lv_obj_set_style_pad_all for lv_obj_set_style_line_dash_width */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_line_dash_width_obj, 3, mp_lv_obj_set_style_pad_all, lv_obj_set_style_line_dash_width);
    
/* Reusing lv_obj_set_style_pad_all for lv_obj_set_style_line_dash_gap */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_line_dash_gap_obj, 3, mp_lv_obj_set_style_pad_all, lv_obj_set_style_line_dash_gap);
    
/* Reusing lv_obj_set_style_bg_img_tiled for lv_obj_set_style_line_rounded */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_line_rounded_obj, 3, mp_lv_obj_set_style_bg_img_tiled, lv_obj_set_style_line_rounded);
    
/* Reusing lv_obj_set_style_bg_color for lv_obj_set_style_line_color */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_line_color_obj, 3, mp_lv_obj_set_style_bg_color, lv_obj_set_style_line_color);
    
/* Reusing lv_obj_set_style_bg_opa for lv_obj_set_style_line_opa */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_line_opa_obj, 3, mp_lv_obj_set_style_bg_opa, lv_obj_set_style_line_opa);
    
/* Reusing lv_obj_set_style_pad_all for lv_obj_set_style_arc_width */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_arc_width_obj, 3, mp_lv_obj_set_style_pad_all, lv_obj_set_style_arc_width);
    
/* Reusing lv_obj_set_style_bg_img_tiled for lv_obj_set_style_arc_rounded */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_arc_rounded_obj, 3, mp_lv_obj_set_style_bg_img_tiled, lv_obj_set_style_arc_rounded);
    
/* Reusing lv_obj_set_style_bg_color for lv_obj_set_style_arc_color */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_arc_color_obj, 3, mp_lv_obj_set_style_bg_color, lv_obj_set_style_arc_color);
    
/* Reusing lv_obj_set_style_bg_opa for lv_obj_set_style_arc_opa */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_arc_opa_obj, 3, mp_lv_obj_set_style_bg_opa, lv_obj_set_style_arc_opa);
    
/* Reusing lv_obj_set_style_bg_img_src for lv_obj_set_style_arc_img_src */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_arc_img_src_obj, 3, mp_lv_obj_set_style_bg_img_src, lv_obj_set_style_arc_img_src);
    
/* Reusing lv_obj_set_style_bg_color for lv_obj_set_style_text_color */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_text_color_obj, 3, mp_lv_obj_set_style_bg_color, lv_obj_set_style_text_color);
    
/* Reusing lv_obj_set_style_bg_opa for lv_obj_set_style_text_opa */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_text_opa_obj, 3, mp_lv_obj_set_style_bg_opa, lv_obj_set_style_text_opa);
    

/*
 * lvgl extension definition for:
 * void lv_obj_set_style_text_font(struct _lv_obj_t *obj, const lv_font_t *value, lv_style_selector_t selector)
 */
 
STATIC mp_obj_t mp_lv_obj_set_style_text_font(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_obj_t *obj = mp_to_lv(mp_args[0]);
    const lv_font_t *value = mp_write_ptr_lv_font_t(mp_args[1]);
    lv_style_selector_t selector = (uint32_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(struct _lv_obj_t *, const lv_font_t *, lv_style_selector_t))lv_func_ptr)(obj, value, selector);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_text_font_obj, 3, mp_lv_obj_set_style_text_font, lv_obj_set_style_text_font);
    
/* Reusing lv_obj_set_style_pad_all for lv_obj_set_style_text_letter_space */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_text_letter_space_obj, 3, mp_lv_obj_set_style_pad_all, lv_obj_set_style_text_letter_space);
    
/* Reusing lv_obj_set_style_pad_all for lv_obj_set_style_text_line_space */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_text_line_space_obj, 3, mp_lv_obj_set_style_pad_all, lv_obj_set_style_text_line_space);
    

/*
 * lvgl extension definition for:
 * void lv_obj_set_style_text_decor(struct _lv_obj_t *obj, lv_text_decor_t value, lv_style_selector_t selector)
 */
 
STATIC mp_obj_t mp_lv_obj_set_style_text_decor(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_text_decor_t value = (uint8_t)mp_obj_get_int(mp_args[1]);
    lv_style_selector_t selector = (uint32_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(struct _lv_obj_t *, lv_text_decor_t, lv_style_selector_t))lv_func_ptr)(obj, value, selector);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_text_decor_obj, 3, mp_lv_obj_set_style_text_decor, lv_obj_set_style_text_decor);
    

/*
 * lvgl extension definition for:
 * void lv_obj_set_style_text_align(struct _lv_obj_t *obj, lv_text_align_t value, lv_style_selector_t selector)
 */
 
STATIC mp_obj_t mp_lv_obj_set_style_text_align(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_text_align_t value = (uint8_t)mp_obj_get_int(mp_args[1]);
    lv_style_selector_t selector = (uint32_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(struct _lv_obj_t *, lv_text_align_t, lv_style_selector_t))lv_func_ptr)(obj, value, selector);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_text_align_obj, 3, mp_lv_obj_set_style_text_align, lv_obj_set_style_text_align);
    
/* Reusing lv_obj_set_style_pad_all for lv_obj_set_style_radius */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_radius_obj, 3, mp_lv_obj_set_style_pad_all, lv_obj_set_style_radius);
    
/* Reusing lv_obj_set_style_bg_img_tiled for lv_obj_set_style_clip_corner */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_clip_corner_obj, 3, mp_lv_obj_set_style_bg_img_tiled, lv_obj_set_style_clip_corner);
    
/* Reusing lv_obj_set_style_bg_opa for lv_obj_set_style_opa */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_opa_obj, 3, mp_lv_obj_set_style_bg_opa, lv_obj_set_style_opa);
    

/*
 * lvgl extension definition for:
 * void lv_obj_set_style_color_filter_dsc(struct _lv_obj_t *obj, const lv_color_filter_dsc_t *value, lv_style_selector_t selector)
 */
 
STATIC mp_obj_t mp_lv_obj_set_style_color_filter_dsc(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_obj_t *obj = mp_to_lv(mp_args[0]);
    const lv_color_filter_dsc_t *value = mp_write_ptr_lv_color_filter_dsc_t(mp_args[1]);
    lv_style_selector_t selector = (uint32_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(struct _lv_obj_t *, const lv_color_filter_dsc_t *, lv_style_selector_t))lv_func_ptr)(obj, value, selector);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_color_filter_dsc_obj, 3, mp_lv_obj_set_style_color_filter_dsc, lv_obj_set_style_color_filter_dsc);
    
/* Reusing lv_obj_set_style_bg_opa for lv_obj_set_style_color_filter_opa */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_color_filter_opa_obj, 3, mp_lv_obj_set_style_bg_opa, lv_obj_set_style_color_filter_opa);
    

/*
 * lvgl extension definition for:
 * void lv_obj_set_style_anim(struct _lv_obj_t *obj, const lv_anim_t *value, lv_style_selector_t selector)
 */
 
STATIC mp_obj_t mp_lv_obj_set_style_anim(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_obj_t *obj = mp_to_lv(mp_args[0]);
    const lv_anim_t *value = mp_write_ptr_lv_anim_t(mp_args[1]);
    lv_style_selector_t selector = (uint32_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(struct _lv_obj_t *, const lv_anim_t *, lv_style_selector_t))lv_func_ptr)(obj, value, selector);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_anim_obj, 3, mp_lv_obj_set_style_anim, lv_obj_set_style_anim);
    

/*
 * lvgl extension definition for:
 * void lv_obj_set_style_anim_time(struct _lv_obj_t *obj, uint32_t value, lv_style_selector_t selector)
 */
 
STATIC mp_obj_t mp_lv_obj_set_style_anim_time(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint32_t value = (uint32_t)mp_obj_get_int(mp_args[1]);
    lv_style_selector_t selector = (uint32_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(struct _lv_obj_t *, uint32_t, lv_style_selector_t))lv_func_ptr)(obj, value, selector);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_anim_time_obj, 3, mp_lv_obj_set_style_anim_time, lv_obj_set_style_anim_time);
    
/* Reusing lv_obj_set_style_anim_time for lv_obj_set_style_anim_speed */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_anim_speed_obj, 3, mp_lv_obj_set_style_anim_time, lv_obj_set_style_anim_speed);
    

/*
 * lvgl extension definition for:
 * void lv_obj_set_style_transition(struct _lv_obj_t *obj, const lv_style_transition_dsc_t *value, lv_style_selector_t selector)
 */
 
STATIC mp_obj_t mp_lv_obj_set_style_transition(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_obj_t *obj = mp_to_lv(mp_args[0]);
    const lv_style_transition_dsc_t *value = mp_write_ptr_lv_style_transition_dsc_t(mp_args[1]);
    lv_style_selector_t selector = (uint32_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(struct _lv_obj_t *, const lv_style_transition_dsc_t *, lv_style_selector_t))lv_func_ptr)(obj, value, selector);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_transition_obj, 3, mp_lv_obj_set_style_transition, lv_obj_set_style_transition);
    

/*
 * lvgl extension definition for:
 * void lv_obj_set_style_blend_mode(struct _lv_obj_t *obj, lv_blend_mode_t value, lv_style_selector_t selector)
 */
 
STATIC mp_obj_t mp_lv_obj_set_style_blend_mode(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_blend_mode_t value = (uint8_t)mp_obj_get_int(mp_args[1]);
    lv_style_selector_t selector = (uint32_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(struct _lv_obj_t *, lv_blend_mode_t, lv_style_selector_t))lv_func_ptr)(obj, value, selector);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_blend_mode_obj, 3, mp_lv_obj_set_style_blend_mode, lv_obj_set_style_blend_mode);
    

/*
 * lvgl extension definition for:
 * void lv_obj_set_style_layout(struct _lv_obj_t *obj, uint16_t value, lv_style_selector_t selector)
 */
 
STATIC mp_obj_t mp_lv_obj_set_style_layout(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint16_t value = (uint16_t)mp_obj_get_int(mp_args[1]);
    lv_style_selector_t selector = (uint32_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(struct _lv_obj_t *, uint16_t, lv_style_selector_t))lv_func_ptr)(obj, value, selector);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_layout_obj, 3, mp_lv_obj_set_style_layout, lv_obj_set_style_layout);
    

/*
 * lvgl extension definition for:
 * void lv_obj_set_style_base_dir(struct _lv_obj_t *obj, lv_base_dir_t value, lv_style_selector_t selector)
 */
 
STATIC mp_obj_t mp_lv_obj_set_style_base_dir(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_base_dir_t value = (uint8_t)mp_obj_get_int(mp_args[1]);
    lv_style_selector_t selector = (uint32_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(struct _lv_obj_t *, lv_base_dir_t, lv_style_selector_t))lv_func_ptr)(obj, value, selector);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_base_dir_obj, 3, mp_lv_obj_set_style_base_dir, lv_obj_set_style_base_dir);
    

/*
 * lvgl extension definition for:
 * lv_text_align_t lv_obj_calculate_style_text_align(const struct _lv_obj_t *obj, lv_part_t part, const char *txt)
 */
 
STATIC mp_obj_t mp_lv_obj_calculate_style_text_align(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const struct _lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_part_t part = (uint32_t)mp_obj_get_int(mp_args[1]);
    const char *txt = (char*)convert_from_str(mp_args[2]);
    lv_text_align_t _res = ((lv_text_align_t (*)(const struct _lv_obj_t *, lv_part_t, const char *))lv_func_ptr)(obj, part, txt);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_calculate_style_text_align_obj, 3, mp_lv_obj_calculate_style_text_align, lv_obj_calculate_style_text_align);
    

/*
 * lvgl extension definition for:
 * void lv_obj_init_draw_rect_dsc(struct _lv_obj_t *obj, uint32_t part, lv_draw_rect_dsc_t *draw_dsc)
 */
 
STATIC mp_obj_t mp_lv_obj_init_draw_rect_dsc(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint32_t part = (uint32_t)mp_obj_get_int(mp_args[1]);
    lv_draw_rect_dsc_t *draw_dsc = mp_write_ptr_lv_draw_rect_dsc_t(mp_args[2]);
    ((void (*)(struct _lv_obj_t *, uint32_t, lv_draw_rect_dsc_t *))lv_func_ptr)(obj, part, draw_dsc);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_init_draw_rect_dsc_obj, 3, mp_lv_obj_init_draw_rect_dsc, lv_obj_init_draw_rect_dsc);
    

/*
 * lvgl extension definition for:
 * void lv_obj_init_draw_label_dsc(struct _lv_obj_t *obj, uint32_t part, lv_draw_label_dsc_t *draw_dsc)
 */
 
STATIC mp_obj_t mp_lv_obj_init_draw_label_dsc(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint32_t part = (uint32_t)mp_obj_get_int(mp_args[1]);
    lv_draw_label_dsc_t *draw_dsc = mp_write_ptr_lv_draw_label_dsc_t(mp_args[2]);
    ((void (*)(struct _lv_obj_t *, uint32_t, lv_draw_label_dsc_t *))lv_func_ptr)(obj, part, draw_dsc);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_init_draw_label_dsc_obj, 3, mp_lv_obj_init_draw_label_dsc, lv_obj_init_draw_label_dsc);
    

/*
 * lvgl extension definition for:
 * void lv_obj_init_draw_img_dsc(struct _lv_obj_t *obj, uint32_t part, lv_draw_img_dsc_t *draw_dsc)
 */
 
STATIC mp_obj_t mp_lv_obj_init_draw_img_dsc(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint32_t part = (uint32_t)mp_obj_get_int(mp_args[1]);
    lv_draw_img_dsc_t *draw_dsc = mp_write_ptr_lv_draw_img_dsc_t(mp_args[2]);
    ((void (*)(struct _lv_obj_t *, uint32_t, lv_draw_img_dsc_t *))lv_func_ptr)(obj, part, draw_dsc);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_init_draw_img_dsc_obj, 3, mp_lv_obj_init_draw_img_dsc, lv_obj_init_draw_img_dsc);
    

/*
 * lvgl extension definition for:
 * void lv_obj_init_draw_line_dsc(struct _lv_obj_t *obj, uint32_t part, lv_draw_line_dsc_t *draw_dsc)
 */
 
STATIC mp_obj_t mp_lv_obj_init_draw_line_dsc(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint32_t part = (uint32_t)mp_obj_get_int(mp_args[1]);
    lv_draw_line_dsc_t *draw_dsc = mp_write_ptr_lv_draw_line_dsc_t(mp_args[2]);
    ((void (*)(struct _lv_obj_t *, uint32_t, lv_draw_line_dsc_t *))lv_func_ptr)(obj, part, draw_dsc);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_init_draw_line_dsc_obj, 3, mp_lv_obj_init_draw_line_dsc, lv_obj_init_draw_line_dsc);
    

/*
 * lvgl extension definition for:
 * void lv_obj_init_draw_arc_dsc(struct _lv_obj_t *obj, uint32_t part, lv_draw_arc_dsc_t *draw_dsc)
 */
 
STATIC mp_obj_t mp_lv_obj_init_draw_arc_dsc(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint32_t part = (uint32_t)mp_obj_get_int(mp_args[1]);
    lv_draw_arc_dsc_t *draw_dsc = mp_write_ptr_lv_draw_arc_dsc_t(mp_args[2]);
    ((void (*)(struct _lv_obj_t *, uint32_t, lv_draw_arc_dsc_t *))lv_func_ptr)(obj, part, draw_dsc);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_init_draw_arc_dsc_obj, 3, mp_lv_obj_init_draw_arc_dsc, lv_obj_init_draw_arc_dsc);
    

/*
 * lvgl extension definition for:
 * lv_coord_t lv_obj_calculate_ext_draw_size(struct _lv_obj_t *obj, uint32_t part)
 */
 
STATIC mp_obj_t mp_lv_obj_calculate_ext_draw_size(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint32_t part = (uint32_t)mp_obj_get_int(mp_args[1]);
    lv_coord_t _res = ((lv_coord_t (*)(struct _lv_obj_t *, uint32_t))lv_func_ptr)(obj, part);
    return mp_obj_new_int(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_calculate_ext_draw_size_obj, 2, mp_lv_obj_calculate_ext_draw_size, lv_obj_calculate_ext_draw_size);
    
#define funcptr_constructor_cb NULL


/*
 * lvgl extension definition for:
 * void constructor_cb(const struct _lv_obj_class_t *class_p, struct _lv_obj_t *obj)
 */
 
STATIC mp_obj_t mp_funcptr_constructor_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const struct _lv_obj_class_t *class_p = mp_to_ptr(mp_args[0]);
    struct _lv_obj_t *obj = mp_to_lv(mp_args[1]);
    ((void (*)(const struct _lv_obj_class_t *, struct _lv_obj_t *))lv_func_ptr)(class_p, obj);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_constructor_cb_obj, 2, mp_funcptr_constructor_cb, funcptr_constructor_cb);
    
STATIC inline mp_obj_t mp_lv_funcptr_constructor_cb(void *func){ return mp_lv_funcptr(&mp_funcptr_constructor_cb_obj, func, NULL, MP_QSTR_, NULL); }

STATIC void lv_obj_class_t_constructor_cb_callback(const struct _lv_obj_class_t *class_p, struct _lv_obj_t *obj);
STATIC void lv_obj_class_t_destructor_cb_callback(const struct _lv_obj_class_t *class_p, struct _lv_obj_t *obj);
#define funcptr_event_cb NULL


/*
 * Struct lv_event_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_event_t_type();

STATIC inline lv_event_t* mp_write_ptr_lv_event_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_event_t_type()));
    return (lv_event_t*)self->data;
}

#define mp_write_lv_event_t(struct_obj) *mp_write_ptr_lv_event_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_event_t(lv_event_t *field)
{
    return lv_to_mp_struct(get_mp_lv_event_t_type(), (void*)field);
}

#define mp_read_lv_event_t(field) mp_read_ptr_lv_event_t(copy_buffer(&field, sizeof(lv_event_t)))
#define mp_read_byref_lv_event_t(field) mp_read_ptr_lv_event_t(&field)

STATIC void mp_lv_event_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_event_t *data = (lv_event_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_target: dest[0] = lv_to_mp((void*)data->target); break; // converting from lv_obj_t *;
            case MP_QSTR_current_target: dest[0] = lv_to_mp((void*)data->current_target); break; // converting from lv_obj_t *;
            case MP_QSTR_code: dest[0] = mp_obj_new_int(data->code); break; // converting from lv_event_code_t;
            case MP_QSTR_user_data: dest[0] = ptr_to_mp((void*)data->user_data); break; // converting from void *;
            case MP_QSTR_param: dest[0] = ptr_to_mp((void*)data->param); break; // converting from void *;
            case MP_QSTR_prev: dest[0] = ptr_to_mp((void*)data->prev); break; // converting from lv_event_t *;
            case MP_QSTR_deleted: dest[0] = mp_obj_new_int_from_uint(data->deleted); break; // converting from uint8_t;
            case MP_QSTR_stop_processing: dest[0] = mp_obj_new_int_from_uint(data->stop_processing); break; // converting from uint8_t;
            case MP_QSTR_stop_bubbling: dest[0] = mp_obj_new_int_from_uint(data->stop_bubbling); break; // converting from uint8_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_target: data->target = (void*)mp_to_lv(dest[1]); break; // converting to lv_obj_t *;
                case MP_QSTR_current_target: data->current_target = (void*)mp_to_lv(dest[1]); break; // converting to lv_obj_t *;
                case MP_QSTR_code: data->code = (int)mp_obj_get_int(dest[1]); break; // converting to lv_event_code_t;
                case MP_QSTR_user_data: data->user_data = (void*)mp_to_ptr(dest[1]); break; // converting to void *;
                case MP_QSTR_param: data->param = (void*)mp_to_ptr(dest[1]); break; // converting to void *;
                case MP_QSTR_prev: data->prev = (void*)mp_to_ptr(dest[1]); break; // converting to lv_event_t *;
                case MP_QSTR_deleted: data->deleted = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                case MP_QSTR_stop_processing: data->stop_processing = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                case MP_QSTR_stop_bubbling: data->stop_bubbling = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_event_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_event_t");
}

STATIC const mp_obj_dict_t mp_lv_event_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_event_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_event_t,
    .print = mp_lv_event_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_event_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_event_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_event_t_type()
{
    return &mp_lv_event_t_type;
}
    

/*
 * lvgl extension definition for:
 * void event_cb(const struct _lv_obj_class_t *class_p, struct _lv_event_t *e)
 */
 
STATIC mp_obj_t mp_funcptr_event_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const struct _lv_obj_class_t *class_p = mp_to_ptr(mp_args[0]);
    struct _lv_event_t *e = mp_write_ptr_lv_event_t(mp_args[1]);
    ((void (*)(const struct _lv_obj_class_t *, struct _lv_event_t *))lv_func_ptr)(class_p, e);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_event_cb_obj, 2, mp_funcptr_event_cb, funcptr_event_cb);
    
STATIC inline mp_obj_t mp_lv_funcptr_event_cb(void *func){ return mp_lv_funcptr(&mp_funcptr_event_cb_obj, func, NULL, MP_QSTR_, NULL); }

STATIC void lv_obj_class_t_event_cb_callback(const struct _lv_obj_class_t *class_p, struct _lv_event_t *e);

/*
 * Struct lv_obj_class_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_obj_class_t_type();

STATIC inline lv_obj_class_t* mp_write_ptr_lv_obj_class_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_obj_class_t_type()));
    return (lv_obj_class_t*)self->data;
}

#define mp_write_lv_obj_class_t(struct_obj) *mp_write_ptr_lv_obj_class_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_obj_class_t(lv_obj_class_t *field)
{
    return lv_to_mp_struct(get_mp_lv_obj_class_t_type(), (void*)field);
}

#define mp_read_lv_obj_class_t(field) mp_read_ptr_lv_obj_class_t(copy_buffer(&field, sizeof(lv_obj_class_t)))
#define mp_read_byref_lv_obj_class_t(field) mp_read_ptr_lv_obj_class_t(&field)

STATIC void mp_lv_obj_class_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_obj_class_t *data = (lv_obj_class_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_base_class: dest[0] = ptr_to_mp((void*)data->base_class); break; // converting from lv_obj_class_t *;
            case MP_QSTR_constructor_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_constructor_cb_obj, (void*)data->constructor_cb, lv_obj_class_t_constructor_cb_callback ,MP_QSTR_lv_obj_class_t_constructor_cb, data->user_data); break; // converting from callback void (*)(lv_obj_class_t *class_p, lv_obj_t *obj);
            case MP_QSTR_destructor_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_constructor_cb_obj, (void*)data->destructor_cb, lv_obj_class_t_destructor_cb_callback ,MP_QSTR_lv_obj_class_t_destructor_cb, data->user_data); break; // converting from callback void (*)(lv_obj_class_t *class_p, lv_obj_t *obj);
            case MP_QSTR_user_data: dest[0] = ptr_to_mp((void*)data->user_data); break; // converting from void *;
            case MP_QSTR_event_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_event_cb_obj, (void*)data->event_cb, lv_obj_class_t_event_cb_callback ,MP_QSTR_lv_obj_class_t_event_cb, data->user_data); break; // converting from callback void (*)(lv_obj_class_t *class_p, lv_event_t *e);
            case MP_QSTR_width_def: dest[0] = mp_obj_new_int(data->width_def); break; // converting from lv_coord_t;
            case MP_QSTR_height_def: dest[0] = mp_obj_new_int(data->height_def); break; // converting from lv_coord_t;
            case MP_QSTR_editable: dest[0] = mp_obj_new_int_from_uint(data->editable); break; // converting from uint32_t;
            case MP_QSTR_group_def: dest[0] = mp_obj_new_int_from_uint(data->group_def); break; // converting from uint32_t;
            case MP_QSTR_instance_size: dest[0] = mp_obj_new_int_from_uint(data->instance_size); break; // converting from uint32_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_base_class: data->base_class = (void*)mp_to_ptr(dest[1]); break; // converting to lv_obj_class_t *;
                case MP_QSTR_constructor_cb: data->constructor_cb = (void*)mp_lv_callback(dest[1], lv_obj_class_t_constructor_cb_callback ,MP_QSTR_lv_obj_class_t_constructor_cb, &data->user_data); break; // converting to callback void (*)(lv_obj_class_t *class_p, lv_obj_t *obj);
                case MP_QSTR_destructor_cb: data->destructor_cb = (void*)mp_lv_callback(dest[1], lv_obj_class_t_destructor_cb_callback ,MP_QSTR_lv_obj_class_t_destructor_cb, &data->user_data); break; // converting to callback void (*)(lv_obj_class_t *class_p, lv_obj_t *obj);
                case MP_QSTR_user_data: data->user_data = (void*)mp_to_ptr(dest[1]); break; // converting to void *;
                case MP_QSTR_event_cb: data->event_cb = (void*)mp_lv_callback(dest[1], lv_obj_class_t_event_cb_callback ,MP_QSTR_lv_obj_class_t_event_cb, &data->user_data); break; // converting to callback void (*)(lv_obj_class_t *class_p, lv_event_t *e);
                case MP_QSTR_width_def: data->width_def = (int16_t)mp_obj_get_int(dest[1]); break; // converting to lv_coord_t;
                case MP_QSTR_height_def: data->height_def = (int16_t)mp_obj_get_int(dest[1]); break; // converting to lv_coord_t;
                case MP_QSTR_editable: data->editable = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_group_def: data->group_def = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_instance_size: data->instance_size = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_obj_class_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_obj_class_t");
}

STATIC const mp_obj_dict_t mp_lv_obj_class_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_obj_class_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_obj_class_t,
    .print = mp_lv_obj_class_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_obj_class_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_obj_class_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_obj_class_t_type()
{
    return &mp_lv_obj_class_t_type;
}
    

/*
 * Struct lv_obj_draw_part_dsc_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_obj_draw_part_dsc_t_type();

STATIC inline lv_obj_draw_part_dsc_t* mp_write_ptr_lv_obj_draw_part_dsc_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_obj_draw_part_dsc_t_type()));
    return (lv_obj_draw_part_dsc_t*)self->data;
}

#define mp_write_lv_obj_draw_part_dsc_t(struct_obj) *mp_write_ptr_lv_obj_draw_part_dsc_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_obj_draw_part_dsc_t(lv_obj_draw_part_dsc_t *field)
{
    return lv_to_mp_struct(get_mp_lv_obj_draw_part_dsc_t_type(), (void*)field);
}

#define mp_read_lv_obj_draw_part_dsc_t(field) mp_read_ptr_lv_obj_draw_part_dsc_t(copy_buffer(&field, sizeof(lv_obj_draw_part_dsc_t)))
#define mp_read_byref_lv_obj_draw_part_dsc_t(field) mp_read_ptr_lv_obj_draw_part_dsc_t(&field)

STATIC void mp_lv_obj_draw_part_dsc_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_obj_draw_part_dsc_t *data = (lv_obj_draw_part_dsc_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_draw_ctx: dest[0] = mp_read_ptr_lv_draw_ctx_t((void*)data->draw_ctx); break; // converting from lv_draw_ctx_t *;
            case MP_QSTR_class_p: dest[0] = mp_read_ptr_lv_obj_class_t((void*)data->class_p); break; // converting from lv_obj_class_t *;
            case MP_QSTR_type: dest[0] = mp_obj_new_int_from_uint(data->type); break; // converting from uint32_t;
            case MP_QSTR_draw_area: dest[0] = mp_read_ptr_lv_area_t((void*)data->draw_area); break; // converting from lv_area_t *;
            case MP_QSTR_rect_dsc: dest[0] = mp_read_ptr_lv_draw_rect_dsc_t((void*)data->rect_dsc); break; // converting from lv_draw_rect_dsc_t *;
            case MP_QSTR_label_dsc: dest[0] = mp_read_ptr_lv_draw_label_dsc_t((void*)data->label_dsc); break; // converting from lv_draw_label_dsc_t *;
            case MP_QSTR_line_dsc: dest[0] = mp_read_ptr_lv_draw_line_dsc_t((void*)data->line_dsc); break; // converting from lv_draw_line_dsc_t *;
            case MP_QSTR_img_dsc: dest[0] = mp_read_ptr_lv_draw_img_dsc_t((void*)data->img_dsc); break; // converting from lv_draw_img_dsc_t *;
            case MP_QSTR_arc_dsc: dest[0] = mp_read_ptr_lv_draw_arc_dsc_t((void*)data->arc_dsc); break; // converting from lv_draw_arc_dsc_t *;
            case MP_QSTR_p1: dest[0] = mp_read_ptr_lv_point_t((void*)data->p1); break; // converting from lv_point_t *;
            case MP_QSTR_p2: dest[0] = mp_read_ptr_lv_point_t((void*)data->p2); break; // converting from lv_point_t *;
            case MP_QSTR_text: dest[0] = convert_to_str((void*)data->text); break; // converting from char *;
            case MP_QSTR_text_length: dest[0] = mp_obj_new_int_from_uint(data->text_length); break; // converting from uint32_t;
            case MP_QSTR_part: dest[0] = mp_obj_new_int_from_uint(data->part); break; // converting from uint32_t;
            case MP_QSTR_id: dest[0] = mp_obj_new_int_from_uint(data->id); break; // converting from uint32_t;
            case MP_QSTR_radius: dest[0] = mp_obj_new_int(data->radius); break; // converting from lv_coord_t;
            case MP_QSTR_value: dest[0] = mp_obj_new_int(data->value); break; // converting from int32_t;
            case MP_QSTR_sub_part_ptr: dest[0] = ptr_to_mp((void*)data->sub_part_ptr); break; // converting from void *;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_draw_ctx: data->draw_ctx = (void*)mp_write_ptr_lv_draw_ctx_t(dest[1]); break; // converting to lv_draw_ctx_t *;
                case MP_QSTR_class_p: data->class_p = (void*)mp_write_ptr_lv_obj_class_t(dest[1]); break; // converting to lv_obj_class_t *;
                case MP_QSTR_type: data->type = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_draw_area: data->draw_area = (void*)mp_write_ptr_lv_area_t(dest[1]); break; // converting to lv_area_t *;
                case MP_QSTR_rect_dsc: data->rect_dsc = (void*)mp_write_ptr_lv_draw_rect_dsc_t(dest[1]); break; // converting to lv_draw_rect_dsc_t *;
                case MP_QSTR_label_dsc: data->label_dsc = (void*)mp_write_ptr_lv_draw_label_dsc_t(dest[1]); break; // converting to lv_draw_label_dsc_t *;
                case MP_QSTR_line_dsc: data->line_dsc = (void*)mp_write_ptr_lv_draw_line_dsc_t(dest[1]); break; // converting to lv_draw_line_dsc_t *;
                case MP_QSTR_img_dsc: data->img_dsc = (void*)mp_write_ptr_lv_draw_img_dsc_t(dest[1]); break; // converting to lv_draw_img_dsc_t *;
                case MP_QSTR_arc_dsc: data->arc_dsc = (void*)mp_write_ptr_lv_draw_arc_dsc_t(dest[1]); break; // converting to lv_draw_arc_dsc_t *;
                case MP_QSTR_p1: data->p1 = (void*)mp_write_ptr_lv_point_t(dest[1]); break; // converting to lv_point_t *;
                case MP_QSTR_p2: data->p2 = (void*)mp_write_ptr_lv_point_t(dest[1]); break; // converting to lv_point_t *;
                case MP_QSTR_text: data->text = (void*)(char*)convert_from_str(dest[1]); break; // converting to char *;
                case MP_QSTR_text_length: data->text_length = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_part: data->part = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_id: data->id = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_radius: data->radius = (int16_t)mp_obj_get_int(dest[1]); break; // converting to lv_coord_t;
                case MP_QSTR_value: data->value = (int32_t)mp_obj_get_int(dest[1]); break; // converting to int32_t;
                case MP_QSTR_sub_part_ptr: data->sub_part_ptr = (void*)mp_to_ptr(dest[1]); break; // converting to void *;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_obj_draw_part_dsc_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_obj_draw_part_dsc_t");
}

STATIC const mp_obj_dict_t mp_lv_obj_draw_part_dsc_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_obj_draw_part_dsc_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_obj_draw_part_dsc_t,
    .print = mp_lv_obj_draw_part_dsc_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_obj_draw_part_dsc_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_obj_draw_part_dsc_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_obj_draw_part_dsc_t_type()
{
    return &mp_lv_obj_draw_part_dsc_t_type;
}
    

/*
 * lvgl extension definition for:
 * void lv_obj_draw_dsc_init(lv_obj_draw_part_dsc_t *dsc, lv_draw_ctx_t *draw_ctx)
 */
 
STATIC mp_obj_t mp_lv_obj_draw_dsc_init(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_draw_part_dsc_t *dsc = mp_write_ptr_lv_obj_draw_part_dsc_t(mp_args[0]);
    lv_draw_ctx_t *draw_ctx = mp_write_ptr_lv_draw_ctx_t(mp_args[1]);
    ((void (*)(lv_obj_draw_part_dsc_t *, lv_draw_ctx_t *))lv_func_ptr)(dsc, draw_ctx);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_draw_dsc_init_obj, 2, mp_lv_obj_draw_dsc_init, lv_obj_draw_dsc_init);
    

/*
 * lvgl extension definition for:
 * bool lv_obj_draw_part_check_type(lv_obj_draw_part_dsc_t *dsc, const struct _lv_obj_class_t *class_p, uint32_t type)
 */
 
STATIC mp_obj_t mp_lv_obj_draw_part_check_type(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_draw_part_dsc_t *dsc = mp_write_ptr_lv_obj_draw_part_dsc_t(mp_args[0]);
    const struct _lv_obj_class_t *class_p = mp_write_ptr_lv_obj_class_t(mp_args[1]);
    uint32_t type = (uint32_t)mp_obj_get_int(mp_args[2]);
    bool _res = ((bool (*)(lv_obj_draw_part_dsc_t *, const struct _lv_obj_class_t *, uint32_t))lv_func_ptr)(dsc, class_p, type);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_draw_part_check_type_obj, 3, mp_lv_obj_draw_part_check_type, lv_obj_draw_part_check_type);
    
/* Reusing lv_obj_center for lv_obj_refresh_ext_draw_size */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_refresh_ext_draw_size_obj, 1, mp_lv_obj_center, lv_obj_refresh_ext_draw_size);
    

/*
 * lvgl extension definition for:
 * struct _lv_obj_t *lv_obj_class_create_obj(const struct _lv_obj_class_t *class_p, struct _lv_obj_t *parent)
 */
 
STATIC mp_obj_t mp_lv_obj_class_create_obj(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const struct _lv_obj_class_t *class_p = mp_write_ptr_lv_obj_class_t(mp_args[0]);
    struct _lv_obj_t *parent = mp_to_lv(mp_args[1]);
    lv_obj_t * _res = ((struct _lv_obj_t *(*)(const struct _lv_obj_class_t *, struct _lv_obj_t *))lv_func_ptr)(class_p, parent);
    return lv_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_class_create_obj_obj, 2, mp_lv_obj_class_create_obj, lv_obj_class_create_obj);
    
/* Reusing lv_obj_center for lv_obj_class_init_obj */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_class_init_obj_obj, 1, mp_lv_obj_center, lv_obj_class_init_obj);
    
/* Reusing lv_obj_refr_size for lv_obj_is_editable */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_is_editable_obj, 1, mp_lv_obj_refr_size, lv_obj_is_editable);
    
/* Reusing lv_obj_refr_size for lv_obj_is_group_def */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_is_group_def_obj, 1, mp_lv_obj_refr_size, lv_obj_is_group_def);
    

/*
 * lvgl extension definition for:
 * lv_res_t lv_obj_event_base(const lv_obj_class_t *class_p, lv_event_t *e)
 */
 
STATIC mp_obj_t mp_lv_obj_event_base(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_class_t *class_p = mp_write_ptr_lv_obj_class_t(mp_args[0]);
    lv_event_t *e = mp_write_ptr_lv_event_t(mp_args[1]);
    lv_res_t _res = ((lv_res_t (*)(const lv_obj_class_t *, lv_event_t *))lv_func_ptr)(class_p, e);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_event_base_obj, 2, mp_lv_obj_event_base, lv_obj_event_base);
    

/*
 * Callback function event_cb
 * void lv_event_cb_t(lv_event_t *e)
 */

STATIC void event_cb_callback(lv_event_t * arg0)
{
    mp_obj_t mp_args[1];
    mp_args[0] = mp_read_ptr_lv_event_t((void*)arg0);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_event_cb)) , 1, 0, mp_args);
    return;
}


/*
 * lvgl extension definition for:
 * struct _lv_event_dsc_t *lv_obj_add_event_cb(struct _lv_obj_t *obj, lv_event_cb_t event_cb, lv_event_code_t filter, void *user_data)
 */
 
STATIC mp_obj_t mp_lv_obj_add_event_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    void *user_data = mp_to_ptr(mp_args[3]);
    void *event_cb = mp_lv_callback(mp_args[1], &event_cb_callback, MP_QSTR_event_cb, &user_data);
    lv_event_code_t filter = (int)mp_obj_get_int(mp_args[2]);
    struct _lv_obj_t *obj = mp_to_lv(mp_args[0]);
    _lv_event_dsc_t * _res = ((struct _lv_event_dsc_t *(*)(struct _lv_obj_t *, lv_event_cb_t, lv_event_code_t, void *))lv_func_ptr)(obj, event_cb, filter, user_data);
    return ptr_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_add_event_cb_obj, 4, mp_lv_obj_add_event_cb, lv_obj_add_event_cb);
    

/*
 * Callback function lv_obj_t_event_cb
 * void lv_event_cb_t(lv_event_t *e)
 */

STATIC void lv_obj_t_event_cb_callback(lv_event_t * arg0)
{
    mp_obj_t mp_args[1];
    mp_args[0] = mp_read_ptr_lv_event_t((void*)arg0);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_obj_t_event_cb)) , 1, 0, mp_args);
    return;
}


/*
 * lvgl extension definition for:
 * bool lv_obj_remove_event_cb(struct _lv_obj_t *obj, lv_event_cb_t event_cb)
 */
 
STATIC mp_obj_t mp_lv_obj_remove_event_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_obj_t *obj = mp_to_lv(mp_args[0]);
    void *event_cb = mp_lv_callback(mp_args[1], &lv_obj_t_event_cb_callback, MP_QSTR_lv_obj_t_event_cb, &obj->user_data);
    bool _res = ((bool (*)(struct _lv_obj_t *, lv_event_cb_t))lv_func_ptr)(obj, event_cb);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_remove_event_cb_obj, 2, mp_lv_obj_remove_event_cb, lv_obj_remove_event_cb);
    

/*
 * lvgl extension definition for:
 * bool lv_obj_remove_event_cb_with_user_data(struct _lv_obj_t *obj, lv_event_cb_t event_cb, const void *event_user_data)
 */
 
STATIC mp_obj_t mp_lv_obj_remove_event_cb_with_user_data(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_obj_t *obj = mp_to_lv(mp_args[0]);
    void *event_cb = mp_lv_callback(mp_args[1], &lv_obj_t_event_cb_callback, MP_QSTR_lv_obj_t_event_cb, &obj->user_data);
    const void *event_user_data = mp_to_ptr(mp_args[2]);
    bool _res = ((bool (*)(struct _lv_obj_t *, lv_event_cb_t, const void *))lv_func_ptr)(obj, event_cb, event_user_data);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_remove_event_cb_with_user_data_obj, 3, mp_lv_obj_remove_event_cb_with_user_data, lv_obj_remove_event_cb_with_user_data);
    

/*
 * lvgl extension definition for:
 * bool lv_obj_remove_event_dsc(struct _lv_obj_t *obj, struct _lv_event_dsc_t *event_dsc)
 */
 
STATIC mp_obj_t mp_lv_obj_remove_event_dsc(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_obj_t *obj = mp_to_lv(mp_args[0]);
    struct _lv_event_dsc_t *event_dsc = mp_to_ptr(mp_args[1]);
    bool _res = ((bool (*)(struct _lv_obj_t *, struct _lv_event_dsc_t *))lv_func_ptr)(obj, event_dsc);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_remove_event_dsc_obj, 2, mp_lv_obj_remove_event_dsc, lv_obj_remove_event_dsc);
    

/*
 * lvgl extension definition for:
 * void *lv_obj_get_event_user_data(struct _lv_obj_t *obj, lv_event_cb_t event_cb)
 */
 
STATIC mp_obj_t mp_lv_obj_get_event_user_data(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_obj_t *obj = mp_to_lv(mp_args[0]);
    void *event_cb = mp_lv_callback(mp_args[1], &lv_obj_t_event_cb_callback, MP_QSTR_lv_obj_t_event_cb, &obj->user_data);
    void * _res = ((void *(*)(struct _lv_obj_t *, lv_event_cb_t))lv_func_ptr)(obj, event_cb);
    return ptr_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_event_user_data_obj, 2, mp_lv_obj_get_event_user_data, lv_obj_get_event_user_data);
    

/*
 * lvgl extension definition for:
 * void lv_obj_add_flag(lv_obj_t *obj, lv_obj_flag_t f)
 */
 
STATIC mp_obj_t mp_lv_obj_add_flag(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_obj_flag_t f = (uint32_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_obj_t *, lv_obj_flag_t))lv_func_ptr)(obj, f);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_add_flag_obj, 2, mp_lv_obj_add_flag, lv_obj_add_flag);
    
/* Reusing lv_obj_add_flag for lv_obj_clear_flag */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_clear_flag_obj, 2, mp_lv_obj_add_flag, lv_obj_clear_flag);
    

/*
 * lvgl extension definition for:
 * void lv_obj_add_state(lv_obj_t *obj, lv_state_t state)
 */
 
STATIC mp_obj_t mp_lv_obj_add_state(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_state_t state = (uint16_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_obj_t *, lv_state_t))lv_func_ptr)(obj, state);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_add_state_obj, 2, mp_lv_obj_add_state, lv_obj_add_state);
    
/* Reusing lv_obj_add_state for lv_obj_clear_state */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_clear_state_obj, 2, mp_lv_obj_add_state, lv_obj_clear_state);
    

/*
 * lvgl extension definition for:
 * bool lv_obj_has_flag(const lv_obj_t *obj, lv_obj_flag_t f)
 */
 
STATIC mp_obj_t mp_lv_obj_has_flag(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_obj_flag_t f = (uint32_t)mp_obj_get_int(mp_args[1]);
    bool _res = ((bool (*)(const lv_obj_t *, lv_obj_flag_t))lv_func_ptr)(obj, f);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_has_flag_obj, 2, mp_lv_obj_has_flag, lv_obj_has_flag);
    
/* Reusing lv_obj_has_flag for lv_obj_has_flag_any */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_has_flag_any_obj, 2, mp_lv_obj_has_flag, lv_obj_has_flag_any);
    

/*
 * lvgl extension definition for:
 * lv_state_t lv_obj_get_state(const lv_obj_t *obj)
 */
 
STATIC mp_obj_t mp_lv_obj_get_state(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_state_t _res = ((lv_state_t (*)(const lv_obj_t *))lv_func_ptr)(obj);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_state_obj, 1, mp_lv_obj_get_state, lv_obj_get_state);
    

/*
 * lvgl extension definition for:
 * bool lv_obj_has_state(const lv_obj_t *obj, lv_state_t state)
 */
 
STATIC mp_obj_t mp_lv_obj_has_state(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_state_t state = (uint16_t)mp_obj_get_int(mp_args[1]);
    bool _res = ((bool (*)(const lv_obj_t *, lv_state_t))lv_func_ptr)(obj, state);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_has_state_obj, 2, mp_lv_obj_has_state, lv_obj_has_state);
    

/*
 * lvgl extension definition for:
 * void *lv_obj_get_group(const lv_obj_t *obj)
 */
 
STATIC mp_obj_t mp_lv_obj_get_group(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = mp_to_lv(mp_args[0]);
    void * _res = ((void *(*)(const lv_obj_t *))lv_func_ptr)(obj);
    return ptr_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_group_obj, 1, mp_lv_obj_get_group, lv_obj_get_group);
    
/* Reusing lv_obj_move_foreground for lv_obj_allocate_spec_attr */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_allocate_spec_attr_obj, 1, mp_lv_obj_move_foreground, lv_obj_allocate_spec_attr);
    

/*
 * lvgl extension definition for:
 * bool lv_obj_check_type(const lv_obj_t *obj, const lv_obj_class_t *class_p)
 */
 
STATIC mp_obj_t mp_lv_obj_check_type(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = mp_to_lv(mp_args[0]);
    const lv_obj_class_t *class_p = mp_write_ptr_lv_obj_class_t(mp_args[1]);
    bool _res = ((bool (*)(const lv_obj_t *, const lv_obj_class_t *))lv_func_ptr)(obj, class_p);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_check_type_obj, 2, mp_lv_obj_check_type, lv_obj_check_type);
    
/* Reusing lv_obj_check_type for lv_obj_has_class */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_has_class_obj, 2, mp_lv_obj_check_type, lv_obj_has_class);
    

/*
 * lvgl extension definition for:
 * const lv_obj_class_t *lv_obj_get_class(const lv_obj_t *obj)
 */
 
STATIC mp_obj_t mp_lv_obj_get_class(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = mp_to_lv(mp_args[0]);
    const lv_obj_class_t * _res = ((const lv_obj_class_t *(*)(const lv_obj_t *))lv_func_ptr)(obj);
    return mp_read_ptr_lv_obj_class_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_class_obj, 1, mp_lv_obj_get_class, lv_obj_get_class);
    

/*
 * lvgl extension definition for:
 * bool lv_obj_is_valid(const lv_obj_t *obj)
 */
 
STATIC mp_obj_t mp_lv_obj_is_valid(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = mp_to_lv(mp_args[0]);
    bool _res = ((bool (*)(const lv_obj_t *))lv_func_ptr)(obj);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_is_valid_obj, 1, mp_lv_obj_is_valid, lv_obj_is_valid);
    

/*
 * lvgl extension definition for:
 * void lv_obj_redraw(lv_draw_ctx_t *draw_ctx, lv_obj_t *obj)
 */
 
STATIC mp_obj_t mp_lv_obj_redraw(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_draw_ctx_t *draw_ctx = mp_write_ptr_lv_draw_ctx_t(mp_args[0]);
    lv_obj_t *obj = mp_to_lv(mp_args[1]);
    ((void (*)(lv_draw_ctx_t *, lv_obj_t *))lv_func_ptr)(draw_ctx, obj);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_obj_redraw_obj, 2, mp_lv_obj_redraw, lv_obj_redraw);
    

/*
 * lvgl extension definition for:
 * void lv_obj_set_flex_flow(lv_obj_t *obj, lv_flex_flow_t flow)
 */
 
STATIC mp_obj_t mp_lv_obj_set_flex_flow(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_flex_flow_t flow = (int)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_obj_t *, lv_flex_flow_t))lv_func_ptr)(obj, flow);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_flex_flow_obj, 2, mp_lv_obj_set_flex_flow, lv_obj_set_flex_flow);
    

/*
 * lvgl extension definition for:
 * void lv_obj_set_flex_align(lv_obj_t *obj, lv_flex_align_t main_place, lv_flex_align_t cross_place, lv_flex_align_t track_cross_place)
 */
 
STATIC mp_obj_t mp_lv_obj_set_flex_align(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_flex_align_t main_place = (int)mp_obj_get_int(mp_args[1]);
    lv_flex_align_t cross_place = (int)mp_obj_get_int(mp_args[2]);
    lv_flex_align_t track_cross_place = (int)mp_obj_get_int(mp_args[3]);
    ((void (*)(lv_obj_t *, lv_flex_align_t, lv_flex_align_t, lv_flex_align_t))lv_func_ptr)(obj, main_place, cross_place, track_cross_place);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_flex_align_obj, 4, mp_lv_obj_set_flex_align, lv_obj_set_flex_align);
    

/*
 * lvgl extension definition for:
 * void lv_obj_set_flex_grow(lv_obj_t *obj, uint8_t grow)
 */
 
STATIC mp_obj_t mp_lv_obj_set_flex_grow(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint8_t grow = (uint8_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_obj_t *, uint8_t))lv_func_ptr)(obj, grow);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_flex_grow_obj, 2, mp_lv_obj_set_flex_grow, lv_obj_set_flex_grow);
    

/*
 * lvgl extension definition for:
 * void lv_obj_set_style_flex_flow(lv_obj_t *obj, lv_flex_flow_t value, lv_style_selector_t selector)
 */
 
STATIC mp_obj_t mp_lv_obj_set_style_flex_flow(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_flex_flow_t value = (int)mp_obj_get_int(mp_args[1]);
    lv_style_selector_t selector = (uint32_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_obj_t *, lv_flex_flow_t, lv_style_selector_t))lv_func_ptr)(obj, value, selector);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_flex_flow_obj, 3, mp_lv_obj_set_style_flex_flow, lv_obj_set_style_flex_flow);
    

/*
 * lvgl extension definition for:
 * void lv_obj_set_style_flex_main_place(lv_obj_t *obj, lv_flex_align_t value, lv_style_selector_t selector)
 */
 
STATIC mp_obj_t mp_lv_obj_set_style_flex_main_place(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_flex_align_t value = (int)mp_obj_get_int(mp_args[1]);
    lv_style_selector_t selector = (uint32_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_obj_t *, lv_flex_align_t, lv_style_selector_t))lv_func_ptr)(obj, value, selector);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_flex_main_place_obj, 3, mp_lv_obj_set_style_flex_main_place, lv_obj_set_style_flex_main_place);
    
/* Reusing lv_obj_set_style_flex_main_place for lv_obj_set_style_flex_cross_place */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_flex_cross_place_obj, 3, mp_lv_obj_set_style_flex_main_place, lv_obj_set_style_flex_cross_place);
    
/* Reusing lv_obj_set_style_flex_main_place for lv_obj_set_style_flex_track_place */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_flex_track_place_obj, 3, mp_lv_obj_set_style_flex_main_place, lv_obj_set_style_flex_track_place);
    

/*
 * lvgl extension definition for:
 * void lv_obj_set_style_flex_grow(lv_obj_t *obj, uint8_t value, lv_style_selector_t selector)
 */
 
STATIC mp_obj_t mp_lv_obj_set_style_flex_grow(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint8_t value = (uint8_t)mp_obj_get_int(mp_args[1]);
    lv_style_selector_t selector = (uint32_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_obj_t *, uint8_t, lv_style_selector_t))lv_func_ptr)(obj, value, selector);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_flex_grow_obj, 3, mp_lv_obj_set_style_flex_grow, lv_obj_set_style_flex_grow);
    

/*
 * Array convertors for lv_coord_t []
 */

STATIC const lv_coord_t *mp_arr_to_lv_coord_t_____(mp_obj_t mp_arr)
{
    mp_obj_t mp_len = mp_obj_len_maybe(mp_arr);
    if (mp_len == MP_OBJ_NULL) return mp_to_ptr(mp_arr);
    mp_int_t len = mp_obj_get_int(mp_len);
    
    lv_coord_t *lv_arr = (lv_coord_t*)m_malloc(len * sizeof(lv_coord_t));
    mp_obj_t iter = mp_getiter(mp_arr, NULL);
    mp_obj_t item;
    size_t i = 0;
    while ((item = mp_iternext(iter)) != MP_OBJ_STOP_ITERATION) {
        lv_arr[i++] = (int16_t)mp_obj_get_int(item);
    }
    return (const lv_coord_t *)lv_arr;
}
    
STATIC mp_obj_t mp_arr_from_lv_coord_t_____(const lv_coord_t *arr)
{
    mp_obj_t obj_arr[1];
    for (size_t i=0; i<1; i++){
        obj_arr[i] = mp_obj_new_int(arr[i]);
    }
    return mp_obj_new_list(1, obj_arr); // TODO: return custom iterable object!
}
    

/*
 * lvgl extension definition for:
 * void lv_obj_set_grid_dsc_array(lv_obj_t *obj, const lv_coord_t col_dsc[], const lv_coord_t row_dsc[])
 */
 
STATIC mp_obj_t mp_lv_obj_set_grid_dsc_array(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    const lv_coord_t *col_dsc = mp_arr_to_lv_coord_t_____(mp_args[1]);
    const lv_coord_t *row_dsc = mp_arr_to_lv_coord_t_____(mp_args[2]);
    ((void (*)(lv_obj_t *, const lv_coord_t [], const lv_coord_t []))lv_func_ptr)(obj, col_dsc, row_dsc);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_grid_dsc_array_obj, 3, mp_lv_obj_set_grid_dsc_array, lv_obj_set_grid_dsc_array);
    

/*
 * lvgl extension definition for:
 * void lv_obj_set_grid_align(lv_obj_t *obj, lv_grid_align_t column_align, lv_grid_align_t row_align)
 */
 
STATIC mp_obj_t mp_lv_obj_set_grid_align(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_grid_align_t column_align = (int)mp_obj_get_int(mp_args[1]);
    lv_grid_align_t row_align = (int)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_obj_t *, lv_grid_align_t, lv_grid_align_t))lv_func_ptr)(obj, column_align, row_align);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_grid_align_obj, 3, mp_lv_obj_set_grid_align, lv_obj_set_grid_align);
    

/*
 * lvgl extension definition for:
 * void lv_obj_set_grid_cell(lv_obj_t *obj, lv_grid_align_t column_align, uint8_t col_pos, uint8_t col_span, lv_grid_align_t row_align, uint8_t row_pos, uint8_t row_span)
 */
 
STATIC mp_obj_t mp_lv_obj_set_grid_cell(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_grid_align_t column_align = (int)mp_obj_get_int(mp_args[1]);
    uint8_t col_pos = (uint8_t)mp_obj_get_int(mp_args[2]);
    uint8_t col_span = (uint8_t)mp_obj_get_int(mp_args[3]);
    lv_grid_align_t row_align = (int)mp_obj_get_int(mp_args[4]);
    uint8_t row_pos = (uint8_t)mp_obj_get_int(mp_args[5]);
    uint8_t row_span = (uint8_t)mp_obj_get_int(mp_args[6]);
    ((void (*)(lv_obj_t *, lv_grid_align_t, uint8_t, uint8_t, lv_grid_align_t, uint8_t, uint8_t))lv_func_ptr)(obj, column_align, col_pos, col_span, row_align, row_pos, row_span);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_grid_cell_obj, 7, mp_lv_obj_set_grid_cell, lv_obj_set_grid_cell);
    

/*
 * lvgl extension definition for:
 * void lv_obj_set_style_grid_row_dsc_array(lv_obj_t *obj, const lv_coord_t value[], lv_style_selector_t selector)
 */
 
STATIC mp_obj_t mp_lv_obj_set_style_grid_row_dsc_array(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    const lv_coord_t *value = mp_arr_to_lv_coord_t_____(mp_args[1]);
    lv_style_selector_t selector = (uint32_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_obj_t *, const lv_coord_t [], lv_style_selector_t))lv_func_ptr)(obj, value, selector);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_grid_row_dsc_array_obj, 3, mp_lv_obj_set_style_grid_row_dsc_array, lv_obj_set_style_grid_row_dsc_array);
    
/* Reusing lv_obj_set_style_grid_row_dsc_array for lv_obj_set_style_grid_column_dsc_array */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_grid_column_dsc_array_obj, 3, mp_lv_obj_set_style_grid_row_dsc_array, lv_obj_set_style_grid_column_dsc_array);
    

/*
 * lvgl extension definition for:
 * void lv_obj_set_style_grid_row_align(lv_obj_t *obj, lv_grid_align_t value, lv_style_selector_t selector)
 */
 
STATIC mp_obj_t mp_lv_obj_set_style_grid_row_align(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_grid_align_t value = (int)mp_obj_get_int(mp_args[1]);
    lv_style_selector_t selector = (uint32_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_obj_t *, lv_grid_align_t, lv_style_selector_t))lv_func_ptr)(obj, value, selector);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_grid_row_align_obj, 3, mp_lv_obj_set_style_grid_row_align, lv_obj_set_style_grid_row_align);
    
/* Reusing lv_obj_set_style_grid_row_align for lv_obj_set_style_grid_column_align */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_grid_column_align_obj, 3, mp_lv_obj_set_style_grid_row_align, lv_obj_set_style_grid_column_align);
    

/*
 * lvgl extension definition for:
 * void lv_obj_set_style_grid_cell_column_pos(lv_obj_t *obj, lv_coord_t value, lv_style_selector_t selector)
 */
 
STATIC mp_obj_t mp_lv_obj_set_style_grid_cell_column_pos(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_coord_t value = (int16_t)mp_obj_get_int(mp_args[1]);
    lv_style_selector_t selector = (uint32_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_obj_t *, lv_coord_t, lv_style_selector_t))lv_func_ptr)(obj, value, selector);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_grid_cell_column_pos_obj, 3, mp_lv_obj_set_style_grid_cell_column_pos, lv_obj_set_style_grid_cell_column_pos);
    
/* Reusing lv_obj_set_style_grid_cell_column_pos for lv_obj_set_style_grid_cell_column_span */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_grid_cell_column_span_obj, 3, mp_lv_obj_set_style_grid_cell_column_pos, lv_obj_set_style_grid_cell_column_span);
    
/* Reusing lv_obj_set_style_grid_cell_column_pos for lv_obj_set_style_grid_cell_row_pos */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_grid_cell_row_pos_obj, 3, mp_lv_obj_set_style_grid_cell_column_pos, lv_obj_set_style_grid_cell_row_pos);
    
/* Reusing lv_obj_set_style_grid_cell_column_pos for lv_obj_set_style_grid_cell_row_span */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_grid_cell_row_span_obj, 3, mp_lv_obj_set_style_grid_cell_column_pos, lv_obj_set_style_grid_cell_row_span);
    
/* Reusing lv_obj_set_style_grid_cell_column_pos for lv_obj_set_style_grid_cell_x_align */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_grid_cell_x_align_obj, 3, mp_lv_obj_set_style_grid_cell_column_pos, lv_obj_set_style_grid_cell_x_align);
    
/* Reusing lv_obj_set_style_grid_cell_column_pos for lv_obj_set_style_grid_cell_y_align */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_grid_cell_y_align_obj, 3, mp_lv_obj_set_style_grid_cell_column_pos, lv_obj_set_style_grid_cell_y_align);
    

/*
 * lvgl extension definition for:
 * void lv_obj_set_tile(lv_obj_t *tv, lv_obj_t *tile_obj, lv_anim_enable_t anim_en)
 */
 
STATIC mp_obj_t mp_lv_obj_set_tile(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *tv = mp_to_lv(mp_args[0]);
    lv_obj_t *tile_obj = mp_to_lv(mp_args[1]);
    lv_anim_enable_t anim_en = (int)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_obj_t *, lv_obj_t *, lv_anim_enable_t))lv_func_ptr)(tv, tile_obj, anim_en);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_tile_obj, 3, mp_lv_obj_set_tile, lv_obj_set_tile);
    

/*
 * lvgl extension definition for:
 * void lv_obj_set_tile_id(lv_obj_t *tv, uint32_t col_id, uint32_t row_id, lv_anim_enable_t anim_en)
 */
 
STATIC mp_obj_t mp_lv_obj_set_tile_id(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *tv = mp_to_lv(mp_args[0]);
    uint32_t col_id = (uint32_t)mp_obj_get_int(mp_args[1]);
    uint32_t row_id = (uint32_t)mp_obj_get_int(mp_args[2]);
    lv_anim_enable_t anim_en = (int)mp_obj_get_int(mp_args[3]);
    ((void (*)(lv_obj_t *, uint32_t, uint32_t, lv_anim_enable_t))lv_func_ptr)(tv, col_id, row_id, anim_en);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_tile_id_obj, 4, mp_lv_obj_set_tile_id, lv_obj_set_tile_id);
    

/*
 * lvgl extension definition for:
 * void lv_obj_set_local_font(lv_obj_t *obj, uint16_t size, lv_color_t color)
 */
 
STATIC mp_obj_t mp_lv_obj_set_local_font(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint16_t size = (uint16_t)mp_obj_get_int(mp_args[1]);
    lv_color_t color = mp_write_lv_color16_t(mp_args[2]);
    ((void (*)(lv_obj_t *, uint16_t, lv_color_t))lv_func_ptr)(obj, size, color);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_local_font_obj, 3, mp_lv_obj_set_local_font, lv_obj_set_local_font);
    

/*
 * lvgl extension definition for:
 * void lv_obj_set_page_glue(lv_obj_t *obj, bool glue)
 */
 
STATIC mp_obj_t mp_lv_obj_set_page_glue(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    bool glue = mp_obj_is_true(mp_args[1]);
    ((void (*)(lv_obj_t *, bool))lv_func_ptr)(obj, glue);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_page_glue_obj, 2, mp_lv_obj_set_page_glue, lv_obj_set_page_glue);
    

/*
 * lvgl obj object definitions
 */
    

STATIC const mp_rom_map_elem_t obj_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_center), MP_ROM_PTR(&mp_lv_obj_center_obj) },
    { MP_ROM_QSTR(MP_QSTR_remove_style_all), MP_ROM_PTR(&mp_lv_obj_remove_style_all_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_width), MP_ROM_PTR(&mp_lv_obj_get_style_width_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_min_width), MP_ROM_PTR(&mp_lv_obj_get_style_min_width_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_max_width), MP_ROM_PTR(&mp_lv_obj_get_style_max_width_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_height), MP_ROM_PTR(&mp_lv_obj_get_style_height_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_min_height), MP_ROM_PTR(&mp_lv_obj_get_style_min_height_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_max_height), MP_ROM_PTR(&mp_lv_obj_get_style_max_height_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_x), MP_ROM_PTR(&mp_lv_obj_get_style_x_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_y), MP_ROM_PTR(&mp_lv_obj_get_style_y_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_align), MP_ROM_PTR(&mp_lv_obj_get_style_align_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_transform_width), MP_ROM_PTR(&mp_lv_obj_get_style_transform_width_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_transform_height), MP_ROM_PTR(&mp_lv_obj_get_style_transform_height_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_translate_x), MP_ROM_PTR(&mp_lv_obj_get_style_translate_x_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_translate_y), MP_ROM_PTR(&mp_lv_obj_get_style_translate_y_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_transform_zoom), MP_ROM_PTR(&mp_lv_obj_get_style_transform_zoom_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_transform_angle), MP_ROM_PTR(&mp_lv_obj_get_style_transform_angle_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_transform_pivot_x), MP_ROM_PTR(&mp_lv_obj_get_style_transform_pivot_x_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_transform_pivot_y), MP_ROM_PTR(&mp_lv_obj_get_style_transform_pivot_y_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_pad_top), MP_ROM_PTR(&mp_lv_obj_get_style_pad_top_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_pad_bottom), MP_ROM_PTR(&mp_lv_obj_get_style_pad_bottom_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_pad_left), MP_ROM_PTR(&mp_lv_obj_get_style_pad_left_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_pad_right), MP_ROM_PTR(&mp_lv_obj_get_style_pad_right_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_pad_row), MP_ROM_PTR(&mp_lv_obj_get_style_pad_row_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_pad_column), MP_ROM_PTR(&mp_lv_obj_get_style_pad_column_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_bg_color), MP_ROM_PTR(&mp_lv_obj_get_style_bg_color_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_bg_color_filtered), MP_ROM_PTR(&mp_lv_obj_get_style_bg_color_filtered_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_bg_opa), MP_ROM_PTR(&mp_lv_obj_get_style_bg_opa_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_bg_grad_color), MP_ROM_PTR(&mp_lv_obj_get_style_bg_grad_color_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_bg_grad_color_filtered), MP_ROM_PTR(&mp_lv_obj_get_style_bg_grad_color_filtered_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_bg_grad_dir), MP_ROM_PTR(&mp_lv_obj_get_style_bg_grad_dir_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_bg_main_stop), MP_ROM_PTR(&mp_lv_obj_get_style_bg_main_stop_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_bg_grad_stop), MP_ROM_PTR(&mp_lv_obj_get_style_bg_grad_stop_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_bg_grad), MP_ROM_PTR(&mp_lv_obj_get_style_bg_grad_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_bg_dither_mode), MP_ROM_PTR(&mp_lv_obj_get_style_bg_dither_mode_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_bg_img_src), MP_ROM_PTR(&mp_lv_obj_get_style_bg_img_src_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_bg_img_opa), MP_ROM_PTR(&mp_lv_obj_get_style_bg_img_opa_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_bg_img_recolor), MP_ROM_PTR(&mp_lv_obj_get_style_bg_img_recolor_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_bg_img_recolor_filtered), MP_ROM_PTR(&mp_lv_obj_get_style_bg_img_recolor_filtered_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_bg_img_recolor_opa), MP_ROM_PTR(&mp_lv_obj_get_style_bg_img_recolor_opa_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_bg_img_tiled), MP_ROM_PTR(&mp_lv_obj_get_style_bg_img_tiled_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_border_color), MP_ROM_PTR(&mp_lv_obj_get_style_border_color_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_border_color_filtered), MP_ROM_PTR(&mp_lv_obj_get_style_border_color_filtered_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_border_opa), MP_ROM_PTR(&mp_lv_obj_get_style_border_opa_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_border_width), MP_ROM_PTR(&mp_lv_obj_get_style_border_width_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_border_side), MP_ROM_PTR(&mp_lv_obj_get_style_border_side_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_border_post), MP_ROM_PTR(&mp_lv_obj_get_style_border_post_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_outline_width), MP_ROM_PTR(&mp_lv_obj_get_style_outline_width_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_outline_color), MP_ROM_PTR(&mp_lv_obj_get_style_outline_color_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_outline_color_filtered), MP_ROM_PTR(&mp_lv_obj_get_style_outline_color_filtered_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_outline_opa), MP_ROM_PTR(&mp_lv_obj_get_style_outline_opa_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_outline_pad), MP_ROM_PTR(&mp_lv_obj_get_style_outline_pad_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_shadow_width), MP_ROM_PTR(&mp_lv_obj_get_style_shadow_width_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_shadow_ofs_x), MP_ROM_PTR(&mp_lv_obj_get_style_shadow_ofs_x_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_shadow_ofs_y), MP_ROM_PTR(&mp_lv_obj_get_style_shadow_ofs_y_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_shadow_spread), MP_ROM_PTR(&mp_lv_obj_get_style_shadow_spread_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_shadow_color), MP_ROM_PTR(&mp_lv_obj_get_style_shadow_color_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_shadow_color_filtered), MP_ROM_PTR(&mp_lv_obj_get_style_shadow_color_filtered_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_shadow_opa), MP_ROM_PTR(&mp_lv_obj_get_style_shadow_opa_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_img_opa), MP_ROM_PTR(&mp_lv_obj_get_style_img_opa_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_img_recolor), MP_ROM_PTR(&mp_lv_obj_get_style_img_recolor_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_img_recolor_filtered), MP_ROM_PTR(&mp_lv_obj_get_style_img_recolor_filtered_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_img_recolor_opa), MP_ROM_PTR(&mp_lv_obj_get_style_img_recolor_opa_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_line_width), MP_ROM_PTR(&mp_lv_obj_get_style_line_width_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_line_dash_width), MP_ROM_PTR(&mp_lv_obj_get_style_line_dash_width_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_line_dash_gap), MP_ROM_PTR(&mp_lv_obj_get_style_line_dash_gap_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_line_rounded), MP_ROM_PTR(&mp_lv_obj_get_style_line_rounded_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_line_color), MP_ROM_PTR(&mp_lv_obj_get_style_line_color_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_line_color_filtered), MP_ROM_PTR(&mp_lv_obj_get_style_line_color_filtered_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_line_opa), MP_ROM_PTR(&mp_lv_obj_get_style_line_opa_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_arc_width), MP_ROM_PTR(&mp_lv_obj_get_style_arc_width_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_arc_rounded), MP_ROM_PTR(&mp_lv_obj_get_style_arc_rounded_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_arc_color), MP_ROM_PTR(&mp_lv_obj_get_style_arc_color_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_arc_color_filtered), MP_ROM_PTR(&mp_lv_obj_get_style_arc_color_filtered_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_arc_opa), MP_ROM_PTR(&mp_lv_obj_get_style_arc_opa_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_arc_img_src), MP_ROM_PTR(&mp_lv_obj_get_style_arc_img_src_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_text_color), MP_ROM_PTR(&mp_lv_obj_get_style_text_color_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_text_color_filtered), MP_ROM_PTR(&mp_lv_obj_get_style_text_color_filtered_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_text_opa), MP_ROM_PTR(&mp_lv_obj_get_style_text_opa_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_text_font), MP_ROM_PTR(&mp_lv_obj_get_style_text_font_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_text_letter_space), MP_ROM_PTR(&mp_lv_obj_get_style_text_letter_space_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_text_line_space), MP_ROM_PTR(&mp_lv_obj_get_style_text_line_space_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_text_decor), MP_ROM_PTR(&mp_lv_obj_get_style_text_decor_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_text_align), MP_ROM_PTR(&mp_lv_obj_get_style_text_align_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_radius), MP_ROM_PTR(&mp_lv_obj_get_style_radius_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_clip_corner), MP_ROM_PTR(&mp_lv_obj_get_style_clip_corner_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_opa), MP_ROM_PTR(&mp_lv_obj_get_style_opa_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_color_filter_dsc), MP_ROM_PTR(&mp_lv_obj_get_style_color_filter_dsc_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_color_filter_opa), MP_ROM_PTR(&mp_lv_obj_get_style_color_filter_opa_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_anim), MP_ROM_PTR(&mp_lv_obj_get_style_anim_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_anim_time), MP_ROM_PTR(&mp_lv_obj_get_style_anim_time_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_anim_speed), MP_ROM_PTR(&mp_lv_obj_get_style_anim_speed_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_transition), MP_ROM_PTR(&mp_lv_obj_get_style_transition_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_blend_mode), MP_ROM_PTR(&mp_lv_obj_get_style_blend_mode_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_layout), MP_ROM_PTR(&mp_lv_obj_get_style_layout_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_base_dir), MP_ROM_PTR(&mp_lv_obj_get_style_base_dir_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_pad_all), MP_ROM_PTR(&mp_lv_obj_set_style_pad_all_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_pad_hor), MP_ROM_PTR(&mp_lv_obj_set_style_pad_hor_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_pad_ver), MP_ROM_PTR(&mp_lv_obj_set_style_pad_ver_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_pad_gap), MP_ROM_PTR(&mp_lv_obj_set_style_pad_gap_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_size), MP_ROM_PTR(&mp_lv_obj_set_style_size_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_user_data), MP_ROM_PTR(&mp_lv_obj_set_user_data_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_user_data), MP_ROM_PTR(&mp_lv_obj_get_user_data_obj) },
    { MP_ROM_QSTR(MP_QSTR_dpx), MP_ROM_PTR(&mp_lv_obj_dpx_obj) },
    { MP_ROM_QSTR(MP_QSTR_move_foreground), MP_ROM_PTR(&mp_lv_obj_move_foreground_obj) },
    { MP_ROM_QSTR(MP_QSTR_move_background), MP_ROM_PTR(&mp_lv_obj_move_background_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_child_id), MP_ROM_PTR(&mp_lv_obj_get_child_id_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_flex_flow), MP_ROM_PTR(&mp_lv_obj_get_style_flex_flow_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_flex_main_place), MP_ROM_PTR(&mp_lv_obj_get_style_flex_main_place_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_flex_cross_place), MP_ROM_PTR(&mp_lv_obj_get_style_flex_cross_place_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_flex_track_place), MP_ROM_PTR(&mp_lv_obj_get_style_flex_track_place_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_flex_grow), MP_ROM_PTR(&mp_lv_obj_get_style_flex_grow_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_grid_row_dsc_array), MP_ROM_PTR(&mp_lv_obj_get_style_grid_row_dsc_array_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_grid_column_dsc_array), MP_ROM_PTR(&mp_lv_obj_get_style_grid_column_dsc_array_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_grid_row_align), MP_ROM_PTR(&mp_lv_obj_get_style_grid_row_align_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_grid_column_align), MP_ROM_PTR(&mp_lv_obj_get_style_grid_column_align_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_grid_cell_column_pos), MP_ROM_PTR(&mp_lv_obj_get_style_grid_cell_column_pos_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_grid_cell_column_span), MP_ROM_PTR(&mp_lv_obj_get_style_grid_cell_column_span_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_grid_cell_row_pos), MP_ROM_PTR(&mp_lv_obj_get_style_grid_cell_row_pos_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_grid_cell_row_span), MP_ROM_PTR(&mp_lv_obj_get_style_grid_cell_row_span_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_grid_cell_x_align), MP_ROM_PTR(&mp_lv_obj_get_style_grid_cell_x_align_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_grid_cell_y_align), MP_ROM_PTR(&mp_lv_obj_get_style_grid_cell_y_align_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_pos), MP_ROM_PTR(&mp_lv_obj_set_pos_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_x), MP_ROM_PTR(&mp_lv_obj_set_x_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_y), MP_ROM_PTR(&mp_lv_obj_set_y_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_size), MP_ROM_PTR(&mp_lv_obj_set_size_obj) },
    { MP_ROM_QSTR(MP_QSTR_refr_size), MP_ROM_PTR(&mp_lv_obj_refr_size_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_width), MP_ROM_PTR(&mp_lv_obj_set_width_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_height), MP_ROM_PTR(&mp_lv_obj_set_height_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_content_width), MP_ROM_PTR(&mp_lv_obj_set_content_width_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_content_height), MP_ROM_PTR(&mp_lv_obj_set_content_height_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_layout), MP_ROM_PTR(&mp_lv_obj_set_layout_obj) },
    { MP_ROM_QSTR(MP_QSTR_is_layout_positioned), MP_ROM_PTR(&mp_lv_obj_is_layout_positioned_obj) },
    { MP_ROM_QSTR(MP_QSTR_mark_layout_as_dirty), MP_ROM_PTR(&mp_lv_obj_mark_layout_as_dirty_obj) },
    { MP_ROM_QSTR(MP_QSTR_update_layout), MP_ROM_PTR(&mp_lv_obj_update_layout_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_align), MP_ROM_PTR(&mp_lv_obj_set_align_obj) },
    { MP_ROM_QSTR(MP_QSTR_align), MP_ROM_PTR(&mp_lv_obj_align_obj) },
    { MP_ROM_QSTR(MP_QSTR_align_to), MP_ROM_PTR(&mp_lv_obj_align_to_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_coords), MP_ROM_PTR(&mp_lv_obj_get_coords_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_x), MP_ROM_PTR(&mp_lv_obj_get_x_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_x2), MP_ROM_PTR(&mp_lv_obj_get_x2_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_y), MP_ROM_PTR(&mp_lv_obj_get_y_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_y2), MP_ROM_PTR(&mp_lv_obj_get_y2_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_x_aligned), MP_ROM_PTR(&mp_lv_obj_get_x_aligned_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_y_aligned), MP_ROM_PTR(&mp_lv_obj_get_y_aligned_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_width), MP_ROM_PTR(&mp_lv_obj_get_width_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_height), MP_ROM_PTR(&mp_lv_obj_get_height_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_content_width), MP_ROM_PTR(&mp_lv_obj_get_content_width_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_content_height), MP_ROM_PTR(&mp_lv_obj_get_content_height_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_content_coords), MP_ROM_PTR(&mp_lv_obj_get_content_coords_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_self_width), MP_ROM_PTR(&mp_lv_obj_get_self_width_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_self_height), MP_ROM_PTR(&mp_lv_obj_get_self_height_obj) },
    { MP_ROM_QSTR(MP_QSTR_refresh_self_size), MP_ROM_PTR(&mp_lv_obj_refresh_self_size_obj) },
    { MP_ROM_QSTR(MP_QSTR_refr_pos), MP_ROM_PTR(&mp_lv_obj_refr_pos_obj) },
    { MP_ROM_QSTR(MP_QSTR_move_to), MP_ROM_PTR(&mp_lv_obj_move_to_obj) },
    { MP_ROM_QSTR(MP_QSTR_move_children_by), MP_ROM_PTR(&mp_lv_obj_move_children_by_obj) },
    { MP_ROM_QSTR(MP_QSTR_transform_point), MP_ROM_PTR(&mp_lv_obj_transform_point_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_transformed_area), MP_ROM_PTR(&mp_lv_obj_get_transformed_area_obj) },
    { MP_ROM_QSTR(MP_QSTR_invalidate_area), MP_ROM_PTR(&mp_lv_obj_invalidate_area_obj) },
    { MP_ROM_QSTR(MP_QSTR_invalidate), MP_ROM_PTR(&mp_lv_obj_invalidate_obj) },
    { MP_ROM_QSTR(MP_QSTR_area_is_visible), MP_ROM_PTR(&mp_lv_obj_area_is_visible_obj) },
    { MP_ROM_QSTR(MP_QSTR_is_visible), MP_ROM_PTR(&mp_lv_obj_is_visible_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_ext_click_area), MP_ROM_PTR(&mp_lv_obj_set_ext_click_area_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_click_area), MP_ROM_PTR(&mp_lv_obj_get_click_area_obj) },
    { MP_ROM_QSTR(MP_QSTR_hit_test), MP_ROM_PTR(&mp_lv_obj_hit_test_obj) },
    { MP_ROM_QSTR(MP_QSTR_delete), MP_ROM_PTR(&mp_lv_obj_del_obj) },
    { MP_ROM_QSTR(MP_QSTR_clean), MP_ROM_PTR(&mp_lv_obj_clean_obj) },
    { MP_ROM_QSTR(MP_QSTR_del_delayed), MP_ROM_PTR(&mp_lv_obj_del_delayed_obj) },
    { MP_ROM_QSTR(MP_QSTR_del_anim_ready_cb), MP_ROM_PTR(&mp_lv_obj_del_anim_ready_cb_obj) },
    { MP_ROM_QSTR(MP_QSTR_del_async), MP_ROM_PTR(&mp_lv_obj_del_async_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_parent), MP_ROM_PTR(&mp_lv_obj_set_parent_obj) },
    { MP_ROM_QSTR(MP_QSTR_swap), MP_ROM_PTR(&mp_lv_obj_swap_obj) },
    { MP_ROM_QSTR(MP_QSTR_move_to_index), MP_ROM_PTR(&mp_lv_obj_move_to_index_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_screen), MP_ROM_PTR(&mp_lv_obj_get_screen_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_disp), MP_ROM_PTR(&mp_lv_obj_get_disp_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_parent), MP_ROM_PTR(&mp_lv_obj_get_parent_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_child), MP_ROM_PTR(&mp_lv_obj_get_child_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_child_cnt), MP_ROM_PTR(&mp_lv_obj_get_child_cnt_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_index), MP_ROM_PTR(&mp_lv_obj_get_index_obj) },
    { MP_ROM_QSTR(MP_QSTR_tree_walk), MP_ROM_PTR(&mp_lv_obj_tree_walk_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_scrollbar_mode), MP_ROM_PTR(&mp_lv_obj_set_scrollbar_mode_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_scroll_dir), MP_ROM_PTR(&mp_lv_obj_set_scroll_dir_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_scroll_snap_x), MP_ROM_PTR(&mp_lv_obj_set_scroll_snap_x_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_scroll_snap_y), MP_ROM_PTR(&mp_lv_obj_set_scroll_snap_y_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_scrollbar_mode), MP_ROM_PTR(&mp_lv_obj_get_scrollbar_mode_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_scroll_dir), MP_ROM_PTR(&mp_lv_obj_get_scroll_dir_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_scroll_snap_x), MP_ROM_PTR(&mp_lv_obj_get_scroll_snap_x_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_scroll_snap_y), MP_ROM_PTR(&mp_lv_obj_get_scroll_snap_y_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_scroll_x), MP_ROM_PTR(&mp_lv_obj_get_scroll_x_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_scroll_y), MP_ROM_PTR(&mp_lv_obj_get_scroll_y_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_scroll_top), MP_ROM_PTR(&mp_lv_obj_get_scroll_top_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_scroll_bottom), MP_ROM_PTR(&mp_lv_obj_get_scroll_bottom_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_scroll_left), MP_ROM_PTR(&mp_lv_obj_get_scroll_left_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_scroll_right), MP_ROM_PTR(&mp_lv_obj_get_scroll_right_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_scroll_end), MP_ROM_PTR(&mp_lv_obj_get_scroll_end_obj) },
    { MP_ROM_QSTR(MP_QSTR_scroll_by), MP_ROM_PTR(&mp_lv_obj_scroll_by_obj) },
    { MP_ROM_QSTR(MP_QSTR_scroll_by_bounded), MP_ROM_PTR(&mp_lv_obj_scroll_by_bounded_obj) },
    { MP_ROM_QSTR(MP_QSTR_scroll_to), MP_ROM_PTR(&mp_lv_obj_scroll_to_obj) },
    { MP_ROM_QSTR(MP_QSTR_scroll_to_x), MP_ROM_PTR(&mp_lv_obj_scroll_to_x_obj) },
    { MP_ROM_QSTR(MP_QSTR_scroll_to_y), MP_ROM_PTR(&mp_lv_obj_scroll_to_y_obj) },
    { MP_ROM_QSTR(MP_QSTR_scroll_to_view), MP_ROM_PTR(&mp_lv_obj_scroll_to_view_obj) },
    { MP_ROM_QSTR(MP_QSTR_scroll_to_view_recursive), MP_ROM_PTR(&mp_lv_obj_scroll_to_view_recursive_obj) },
    { MP_ROM_QSTR(MP_QSTR_is_scrolling), MP_ROM_PTR(&mp_lv_obj_is_scrolling_obj) },
    { MP_ROM_QSTR(MP_QSTR_update_snap), MP_ROM_PTR(&mp_lv_obj_update_snap_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_scrollbar_area), MP_ROM_PTR(&mp_lv_obj_get_scrollbar_area_obj) },
    { MP_ROM_QSTR(MP_QSTR_scrollbar_invalidate), MP_ROM_PTR(&mp_lv_obj_scrollbar_invalidate_obj) },
    { MP_ROM_QSTR(MP_QSTR_readjust_scroll), MP_ROM_PTR(&mp_lv_obj_readjust_scroll_obj) },
    { MP_ROM_QSTR(MP_QSTR_add_style), MP_ROM_PTR(&mp_lv_obj_add_style_obj) },
    { MP_ROM_QSTR(MP_QSTR_remove_style), MP_ROM_PTR(&mp_lv_obj_remove_style_obj) },
    { MP_ROM_QSTR(MP_QSTR_report_style_change), MP_ROM_PTR(&mp_lv_obj_report_style_change_obj) },
    { MP_ROM_QSTR(MP_QSTR_refresh_style), MP_ROM_PTR(&mp_lv_obj_refresh_style_obj) },
    { MP_ROM_QSTR(MP_QSTR_enable_style_refresh), MP_ROM_PTR(&mp_lv_obj_enable_style_refresh_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_prop), MP_ROM_PTR(&mp_lv_obj_get_style_prop_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_local_style_prop), MP_ROM_PTR(&mp_lv_obj_set_local_style_prop_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_local_style_prop_meta), MP_ROM_PTR(&mp_lv_obj_set_local_style_prop_meta_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_local_style_prop), MP_ROM_PTR(&mp_lv_obj_get_local_style_prop_obj) },
    { MP_ROM_QSTR(MP_QSTR_remove_local_style_prop), MP_ROM_PTR(&mp_lv_obj_remove_local_style_prop_obj) },
    { MP_ROM_QSTR(MP_QSTR_fade_in), MP_ROM_PTR(&mp_lv_obj_fade_in_obj) },
    { MP_ROM_QSTR(MP_QSTR_fade_out), MP_ROM_PTR(&mp_lv_obj_fade_out_obj) },
    { MP_ROM_QSTR(MP_QSTR_style_get_selector_state), MP_ROM_PTR(&mp_lv_obj_style_get_selector_state_obj) },
    { MP_ROM_QSTR(MP_QSTR_style_get_selector_part), MP_ROM_PTR(&mp_lv_obj_style_get_selector_part_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_width), MP_ROM_PTR(&mp_lv_obj_set_style_width_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_min_width), MP_ROM_PTR(&mp_lv_obj_set_style_min_width_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_max_width), MP_ROM_PTR(&mp_lv_obj_set_style_max_width_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_height), MP_ROM_PTR(&mp_lv_obj_set_style_height_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_min_height), MP_ROM_PTR(&mp_lv_obj_set_style_min_height_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_max_height), MP_ROM_PTR(&mp_lv_obj_set_style_max_height_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_x), MP_ROM_PTR(&mp_lv_obj_set_style_x_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_y), MP_ROM_PTR(&mp_lv_obj_set_style_y_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_align), MP_ROM_PTR(&mp_lv_obj_set_style_align_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_transform_width), MP_ROM_PTR(&mp_lv_obj_set_style_transform_width_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_transform_height), MP_ROM_PTR(&mp_lv_obj_set_style_transform_height_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_translate_x), MP_ROM_PTR(&mp_lv_obj_set_style_translate_x_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_translate_y), MP_ROM_PTR(&mp_lv_obj_set_style_translate_y_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_transform_zoom), MP_ROM_PTR(&mp_lv_obj_set_style_transform_zoom_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_transform_angle), MP_ROM_PTR(&mp_lv_obj_set_style_transform_angle_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_transform_pivot_x), MP_ROM_PTR(&mp_lv_obj_set_style_transform_pivot_x_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_transform_pivot_y), MP_ROM_PTR(&mp_lv_obj_set_style_transform_pivot_y_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_pad_top), MP_ROM_PTR(&mp_lv_obj_set_style_pad_top_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_pad_bottom), MP_ROM_PTR(&mp_lv_obj_set_style_pad_bottom_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_pad_left), MP_ROM_PTR(&mp_lv_obj_set_style_pad_left_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_pad_right), MP_ROM_PTR(&mp_lv_obj_set_style_pad_right_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_pad_row), MP_ROM_PTR(&mp_lv_obj_set_style_pad_row_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_pad_column), MP_ROM_PTR(&mp_lv_obj_set_style_pad_column_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_bg_color), MP_ROM_PTR(&mp_lv_obj_set_style_bg_color_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_bg_opa), MP_ROM_PTR(&mp_lv_obj_set_style_bg_opa_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_bg_grad_color), MP_ROM_PTR(&mp_lv_obj_set_style_bg_grad_color_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_bg_grad_dir), MP_ROM_PTR(&mp_lv_obj_set_style_bg_grad_dir_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_bg_main_stop), MP_ROM_PTR(&mp_lv_obj_set_style_bg_main_stop_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_bg_grad_stop), MP_ROM_PTR(&mp_lv_obj_set_style_bg_grad_stop_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_bg_grad), MP_ROM_PTR(&mp_lv_obj_set_style_bg_grad_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_bg_dither_mode), MP_ROM_PTR(&mp_lv_obj_set_style_bg_dither_mode_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_bg_img_src), MP_ROM_PTR(&mp_lv_obj_set_style_bg_img_src_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_bg_img_opa), MP_ROM_PTR(&mp_lv_obj_set_style_bg_img_opa_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_bg_img_recolor), MP_ROM_PTR(&mp_lv_obj_set_style_bg_img_recolor_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_bg_img_recolor_opa), MP_ROM_PTR(&mp_lv_obj_set_style_bg_img_recolor_opa_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_bg_img_tiled), MP_ROM_PTR(&mp_lv_obj_set_style_bg_img_tiled_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_border_color), MP_ROM_PTR(&mp_lv_obj_set_style_border_color_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_border_opa), MP_ROM_PTR(&mp_lv_obj_set_style_border_opa_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_border_width), MP_ROM_PTR(&mp_lv_obj_set_style_border_width_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_border_side), MP_ROM_PTR(&mp_lv_obj_set_style_border_side_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_border_post), MP_ROM_PTR(&mp_lv_obj_set_style_border_post_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_outline_width), MP_ROM_PTR(&mp_lv_obj_set_style_outline_width_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_outline_color), MP_ROM_PTR(&mp_lv_obj_set_style_outline_color_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_outline_opa), MP_ROM_PTR(&mp_lv_obj_set_style_outline_opa_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_outline_pad), MP_ROM_PTR(&mp_lv_obj_set_style_outline_pad_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_shadow_width), MP_ROM_PTR(&mp_lv_obj_set_style_shadow_width_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_shadow_ofs_x), MP_ROM_PTR(&mp_lv_obj_set_style_shadow_ofs_x_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_shadow_ofs_y), MP_ROM_PTR(&mp_lv_obj_set_style_shadow_ofs_y_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_shadow_spread), MP_ROM_PTR(&mp_lv_obj_set_style_shadow_spread_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_shadow_color), MP_ROM_PTR(&mp_lv_obj_set_style_shadow_color_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_shadow_opa), MP_ROM_PTR(&mp_lv_obj_set_style_shadow_opa_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_img_opa), MP_ROM_PTR(&mp_lv_obj_set_style_img_opa_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_img_recolor), MP_ROM_PTR(&mp_lv_obj_set_style_img_recolor_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_img_recolor_opa), MP_ROM_PTR(&mp_lv_obj_set_style_img_recolor_opa_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_line_width), MP_ROM_PTR(&mp_lv_obj_set_style_line_width_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_line_dash_width), MP_ROM_PTR(&mp_lv_obj_set_style_line_dash_width_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_line_dash_gap), MP_ROM_PTR(&mp_lv_obj_set_style_line_dash_gap_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_line_rounded), MP_ROM_PTR(&mp_lv_obj_set_style_line_rounded_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_line_color), MP_ROM_PTR(&mp_lv_obj_set_style_line_color_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_line_opa), MP_ROM_PTR(&mp_lv_obj_set_style_line_opa_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_arc_width), MP_ROM_PTR(&mp_lv_obj_set_style_arc_width_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_arc_rounded), MP_ROM_PTR(&mp_lv_obj_set_style_arc_rounded_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_arc_color), MP_ROM_PTR(&mp_lv_obj_set_style_arc_color_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_arc_opa), MP_ROM_PTR(&mp_lv_obj_set_style_arc_opa_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_arc_img_src), MP_ROM_PTR(&mp_lv_obj_set_style_arc_img_src_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_text_color), MP_ROM_PTR(&mp_lv_obj_set_style_text_color_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_text_opa), MP_ROM_PTR(&mp_lv_obj_set_style_text_opa_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_text_font), MP_ROM_PTR(&mp_lv_obj_set_style_text_font_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_text_letter_space), MP_ROM_PTR(&mp_lv_obj_set_style_text_letter_space_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_text_line_space), MP_ROM_PTR(&mp_lv_obj_set_style_text_line_space_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_text_decor), MP_ROM_PTR(&mp_lv_obj_set_style_text_decor_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_text_align), MP_ROM_PTR(&mp_lv_obj_set_style_text_align_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_radius), MP_ROM_PTR(&mp_lv_obj_set_style_radius_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_clip_corner), MP_ROM_PTR(&mp_lv_obj_set_style_clip_corner_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_opa), MP_ROM_PTR(&mp_lv_obj_set_style_opa_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_color_filter_dsc), MP_ROM_PTR(&mp_lv_obj_set_style_color_filter_dsc_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_color_filter_opa), MP_ROM_PTR(&mp_lv_obj_set_style_color_filter_opa_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_anim), MP_ROM_PTR(&mp_lv_obj_set_style_anim_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_anim_time), MP_ROM_PTR(&mp_lv_obj_set_style_anim_time_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_anim_speed), MP_ROM_PTR(&mp_lv_obj_set_style_anim_speed_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_transition), MP_ROM_PTR(&mp_lv_obj_set_style_transition_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_blend_mode), MP_ROM_PTR(&mp_lv_obj_set_style_blend_mode_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_layout), MP_ROM_PTR(&mp_lv_obj_set_style_layout_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_base_dir), MP_ROM_PTR(&mp_lv_obj_set_style_base_dir_obj) },
    { MP_ROM_QSTR(MP_QSTR_calculate_style_text_align), MP_ROM_PTR(&mp_lv_obj_calculate_style_text_align_obj) },
    { MP_ROM_QSTR(MP_QSTR_init_draw_rect_dsc), MP_ROM_PTR(&mp_lv_obj_init_draw_rect_dsc_obj) },
    { MP_ROM_QSTR(MP_QSTR_init_draw_label_dsc), MP_ROM_PTR(&mp_lv_obj_init_draw_label_dsc_obj) },
    { MP_ROM_QSTR(MP_QSTR_init_draw_img_dsc), MP_ROM_PTR(&mp_lv_obj_init_draw_img_dsc_obj) },
    { MP_ROM_QSTR(MP_QSTR_init_draw_line_dsc), MP_ROM_PTR(&mp_lv_obj_init_draw_line_dsc_obj) },
    { MP_ROM_QSTR(MP_QSTR_init_draw_arc_dsc), MP_ROM_PTR(&mp_lv_obj_init_draw_arc_dsc_obj) },
    { MP_ROM_QSTR(MP_QSTR_calculate_ext_draw_size), MP_ROM_PTR(&mp_lv_obj_calculate_ext_draw_size_obj) },
    { MP_ROM_QSTR(MP_QSTR_draw_dsc_init), MP_ROM_PTR(&mp_lv_obj_draw_dsc_init_obj) },
    { MP_ROM_QSTR(MP_QSTR_draw_part_check_type), MP_ROM_PTR(&mp_lv_obj_draw_part_check_type_obj) },
    { MP_ROM_QSTR(MP_QSTR_refresh_ext_draw_size), MP_ROM_PTR(&mp_lv_obj_refresh_ext_draw_size_obj) },
    { MP_ROM_QSTR(MP_QSTR_class_create_obj), MP_ROM_PTR(&mp_lv_obj_class_create_obj_obj) },
    { MP_ROM_QSTR(MP_QSTR_class_init_obj), MP_ROM_PTR(&mp_lv_obj_class_init_obj_obj) },
    { MP_ROM_QSTR(MP_QSTR_is_editable), MP_ROM_PTR(&mp_lv_obj_is_editable_obj) },
    { MP_ROM_QSTR(MP_QSTR_is_group_def), MP_ROM_PTR(&mp_lv_obj_is_group_def_obj) },
    { MP_ROM_QSTR(MP_QSTR_event_base), MP_ROM_PTR(&mp_lv_obj_event_base_obj) },
    { MP_ROM_QSTR(MP_QSTR_add_event_cb), MP_ROM_PTR(&mp_lv_obj_add_event_cb_obj) },
    { MP_ROM_QSTR(MP_QSTR_remove_event_cb), MP_ROM_PTR(&mp_lv_obj_remove_event_cb_obj) },
    { MP_ROM_QSTR(MP_QSTR_remove_event_cb_with_user_data), MP_ROM_PTR(&mp_lv_obj_remove_event_cb_with_user_data_obj) },
    { MP_ROM_QSTR(MP_QSTR_remove_event_dsc), MP_ROM_PTR(&mp_lv_obj_remove_event_dsc_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_event_user_data), MP_ROM_PTR(&mp_lv_obj_get_event_user_data_obj) },
    { MP_ROM_QSTR(MP_QSTR_add_flag), MP_ROM_PTR(&mp_lv_obj_add_flag_obj) },
    { MP_ROM_QSTR(MP_QSTR_clear_flag), MP_ROM_PTR(&mp_lv_obj_clear_flag_obj) },
    { MP_ROM_QSTR(MP_QSTR_add_state), MP_ROM_PTR(&mp_lv_obj_add_state_obj) },
    { MP_ROM_QSTR(MP_QSTR_clear_state), MP_ROM_PTR(&mp_lv_obj_clear_state_obj) },
    { MP_ROM_QSTR(MP_QSTR_has_flag), MP_ROM_PTR(&mp_lv_obj_has_flag_obj) },
    { MP_ROM_QSTR(MP_QSTR_has_flag_any), MP_ROM_PTR(&mp_lv_obj_has_flag_any_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_state), MP_ROM_PTR(&mp_lv_obj_get_state_obj) },
    { MP_ROM_QSTR(MP_QSTR_has_state), MP_ROM_PTR(&mp_lv_obj_has_state_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_group), MP_ROM_PTR(&mp_lv_obj_get_group_obj) },
    { MP_ROM_QSTR(MP_QSTR_allocate_spec_attr), MP_ROM_PTR(&mp_lv_obj_allocate_spec_attr_obj) },
    { MP_ROM_QSTR(MP_QSTR_check_type), MP_ROM_PTR(&mp_lv_obj_check_type_obj) },
    { MP_ROM_QSTR(MP_QSTR_has_class), MP_ROM_PTR(&mp_lv_obj_has_class_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_class), MP_ROM_PTR(&mp_lv_obj_get_class_obj) },
    { MP_ROM_QSTR(MP_QSTR_is_valid), MP_ROM_PTR(&mp_lv_obj_is_valid_obj) },
    { MP_ROM_QSTR(MP_QSTR_redraw), MP_ROM_PTR(&mp_lv_obj_redraw_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_flex_flow), MP_ROM_PTR(&mp_lv_obj_set_flex_flow_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_flex_align), MP_ROM_PTR(&mp_lv_obj_set_flex_align_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_flex_grow), MP_ROM_PTR(&mp_lv_obj_set_flex_grow_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_flex_flow), MP_ROM_PTR(&mp_lv_obj_set_style_flex_flow_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_flex_main_place), MP_ROM_PTR(&mp_lv_obj_set_style_flex_main_place_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_flex_cross_place), MP_ROM_PTR(&mp_lv_obj_set_style_flex_cross_place_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_flex_track_place), MP_ROM_PTR(&mp_lv_obj_set_style_flex_track_place_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_flex_grow), MP_ROM_PTR(&mp_lv_obj_set_style_flex_grow_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_grid_dsc_array), MP_ROM_PTR(&mp_lv_obj_set_grid_dsc_array_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_grid_align), MP_ROM_PTR(&mp_lv_obj_set_grid_align_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_grid_cell), MP_ROM_PTR(&mp_lv_obj_set_grid_cell_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_grid_row_dsc_array), MP_ROM_PTR(&mp_lv_obj_set_style_grid_row_dsc_array_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_grid_column_dsc_array), MP_ROM_PTR(&mp_lv_obj_set_style_grid_column_dsc_array_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_grid_row_align), MP_ROM_PTR(&mp_lv_obj_set_style_grid_row_align_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_grid_column_align), MP_ROM_PTR(&mp_lv_obj_set_style_grid_column_align_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_grid_cell_column_pos), MP_ROM_PTR(&mp_lv_obj_set_style_grid_cell_column_pos_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_grid_cell_column_span), MP_ROM_PTR(&mp_lv_obj_set_style_grid_cell_column_span_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_grid_cell_row_pos), MP_ROM_PTR(&mp_lv_obj_set_style_grid_cell_row_pos_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_grid_cell_row_span), MP_ROM_PTR(&mp_lv_obj_set_style_grid_cell_row_span_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_grid_cell_x_align), MP_ROM_PTR(&mp_lv_obj_set_style_grid_cell_x_align_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_grid_cell_y_align), MP_ROM_PTR(&mp_lv_obj_set_style_grid_cell_y_align_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_tile), MP_ROM_PTR(&mp_lv_obj_set_tile_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_tile_id), MP_ROM_PTR(&mp_lv_obj_set_tile_id_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_local_font), MP_ROM_PTR(&mp_lv_obj_set_local_font_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_page_glue), MP_ROM_PTR(&mp_lv_obj_set_page_glue_obj) },
    { MP_ROM_QSTR(MP_QSTR_FLAG), MP_ROM_PTR(&mp_LV_OBJ_FLAG_type) },
    { MP_ROM_QSTR(MP_QSTR_DRAW_PART), MP_ROM_PTR(&mp_LV_OBJ_DRAW_PART_type) },
    { MP_ROM_QSTR(MP_QSTR_TREE_WALK), MP_ROM_PTR(&mp_LV_OBJ_TREE_WALK_type) },
    { MP_ROM_QSTR(MP_QSTR_CLASS_EDITABLE), MP_ROM_PTR(&mp_LV_OBJ_CLASS_EDITABLE_type) },
    { MP_ROM_QSTR(MP_QSTR_CLASS_GROUP_DEF), MP_ROM_PTR(&mp_LV_OBJ_CLASS_GROUP_DEF_type) },
    { MP_ROM_QSTR(MP_QSTR___cast__), MP_ROM_PTR(&cast_obj_class_method) }
};

STATIC MP_DEFINE_CONST_DICT(obj_locals_dict, obj_locals_dict_table);

STATIC void obj_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl obj");
}


STATIC mp_obj_t obj_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&lv_obj_create, type, n_args, n_kw, args);           
}


STATIC const mp_obj_type_t mp_obj_type = {
    { &mp_type_type },
    .name = MP_QSTR_obj,
    .print = obj_print,
    .make_new = obj_make_new,
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&obj_locals_dict,
    .buffer_p = { .get_buffer = mp_lv_obj_get_buffer },
    .parent = NULL,
};
    

/*
 * lvgl extension definition for:
 * void lv_arc_set_start_angle(lv_obj_t *obj, uint16_t start)
 */
 
STATIC mp_obj_t mp_lv_arc_set_start_angle(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint16_t start = (uint16_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_obj_t *, uint16_t))lv_func_ptr)(obj, start);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_arc_set_start_angle_obj, 2, mp_lv_arc_set_start_angle, lv_arc_set_start_angle);
    
/* Reusing lv_arc_set_start_angle for lv_arc_set_end_angle */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_arc_set_end_angle_obj, 2, mp_lv_arc_set_start_angle, lv_arc_set_end_angle);
    

/*
 * lvgl extension definition for:
 * void lv_arc_set_angles(lv_obj_t *obj, uint16_t start, uint16_t end)
 */
 
STATIC mp_obj_t mp_lv_arc_set_angles(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint16_t start = (uint16_t)mp_obj_get_int(mp_args[1]);
    uint16_t end = (uint16_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_obj_t *, uint16_t, uint16_t))lv_func_ptr)(obj, start, end);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_arc_set_angles_obj, 3, mp_lv_arc_set_angles, lv_arc_set_angles);
    
/* Reusing lv_arc_set_start_angle for lv_arc_set_bg_start_angle */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_arc_set_bg_start_angle_obj, 2, mp_lv_arc_set_start_angle, lv_arc_set_bg_start_angle);
    
/* Reusing lv_arc_set_start_angle for lv_arc_set_bg_end_angle */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_arc_set_bg_end_angle_obj, 2, mp_lv_arc_set_start_angle, lv_arc_set_bg_end_angle);
    
/* Reusing lv_arc_set_angles for lv_arc_set_bg_angles */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_arc_set_bg_angles_obj, 3, mp_lv_arc_set_angles, lv_arc_set_bg_angles);
    
/* Reusing lv_arc_set_start_angle for lv_arc_set_rotation */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_arc_set_rotation_obj, 2, mp_lv_arc_set_start_angle, lv_arc_set_rotation);
    

/*
 * lvgl extension definition for:
 * void lv_arc_set_mode(lv_obj_t *obj, lv_arc_mode_t type)
 */
 
STATIC mp_obj_t mp_lv_arc_set_mode(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_arc_mode_t type = (uint8_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_obj_t *, lv_arc_mode_t))lv_func_ptr)(obj, type);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_arc_set_mode_obj, 2, mp_lv_arc_set_mode, lv_arc_set_mode);
    

/*
 * lvgl extension definition for:
 * void lv_arc_set_value(lv_obj_t *obj, int16_t value)
 */
 
STATIC mp_obj_t mp_lv_arc_set_value(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    int16_t value = (int16_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_obj_t *, int16_t))lv_func_ptr)(obj, value);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_arc_set_value_obj, 2, mp_lv_arc_set_value, lv_arc_set_value);
    

/*
 * lvgl extension definition for:
 * void lv_arc_set_range(lv_obj_t *obj, int16_t min, int16_t max)
 */
 
STATIC mp_obj_t mp_lv_arc_set_range(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    int16_t min = (int16_t)mp_obj_get_int(mp_args[1]);
    int16_t max = (int16_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_obj_t *, int16_t, int16_t))lv_func_ptr)(obj, min, max);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_arc_set_range_obj, 3, mp_lv_arc_set_range, lv_arc_set_range);
    
/* Reusing lv_arc_set_start_angle for lv_arc_set_change_rate */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_arc_set_change_rate_obj, 2, mp_lv_arc_set_start_angle, lv_arc_set_change_rate);
    

/*
 * lvgl extension definition for:
 * uint16_t lv_arc_get_angle_start(lv_obj_t *obj)
 */
 
STATIC mp_obj_t mp_lv_arc_get_angle_start(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint16_t _res = ((uint16_t (*)(lv_obj_t *))lv_func_ptr)(obj);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_arc_get_angle_start_obj, 1, mp_lv_arc_get_angle_start, lv_arc_get_angle_start);
    
/* Reusing lv_arc_get_angle_start for lv_arc_get_angle_end */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_arc_get_angle_end_obj, 1, mp_lv_arc_get_angle_start, lv_arc_get_angle_end);
    
/* Reusing lv_arc_get_angle_start for lv_arc_get_bg_angle_start */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_arc_get_bg_angle_start_obj, 1, mp_lv_arc_get_angle_start, lv_arc_get_bg_angle_start);
    
/* Reusing lv_arc_get_angle_start for lv_arc_get_bg_angle_end */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_arc_get_bg_angle_end_obj, 1, mp_lv_arc_get_angle_start, lv_arc_get_bg_angle_end);
    

/*
 * lvgl extension definition for:
 * int16_t lv_arc_get_value(const lv_obj_t *obj)
 */
 
STATIC mp_obj_t mp_lv_arc_get_value(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = mp_to_lv(mp_args[0]);
    int16_t _res = ((int16_t (*)(const lv_obj_t *))lv_func_ptr)(obj);
    return mp_obj_new_int(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_arc_get_value_obj, 1, mp_lv_arc_get_value, lv_arc_get_value);
    
/* Reusing lv_arc_get_value for lv_arc_get_min_value */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_arc_get_min_value_obj, 1, mp_lv_arc_get_value, lv_arc_get_min_value);
    
/* Reusing lv_arc_get_value for lv_arc_get_max_value */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_arc_get_max_value_obj, 1, mp_lv_arc_get_value, lv_arc_get_max_value);
    

/*
 * lvgl extension definition for:
 * lv_arc_mode_t lv_arc_get_mode(const lv_obj_t *obj)
 */
 
STATIC mp_obj_t mp_lv_arc_get_mode(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_arc_mode_t _res = ((lv_arc_mode_t (*)(const lv_obj_t *))lv_func_ptr)(obj);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_arc_get_mode_obj, 1, mp_lv_arc_get_mode, lv_arc_get_mode);
    

/*
 * lvgl extension definition for:
 * void lv_arc_align_obj_to_angle(const lv_obj_t *obj, lv_obj_t *obj_to_align, lv_coord_t r_offset)
 */
 
STATIC mp_obj_t mp_lv_arc_align_obj_to_angle(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_obj_t *obj_to_align = mp_to_lv(mp_args[1]);
    lv_coord_t r_offset = (int16_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(const lv_obj_t *, lv_obj_t *, lv_coord_t))lv_func_ptr)(obj, obj_to_align, r_offset);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_arc_align_obj_to_angle_obj, 3, mp_lv_arc_align_obj_to_angle, lv_arc_align_obj_to_angle);
    
/* Reusing lv_arc_align_obj_to_angle for lv_arc_rotate_obj_to_angle */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_arc_rotate_obj_to_angle_obj, 3, mp_lv_arc_align_obj_to_angle, lv_arc_rotate_obj_to_angle);
    

/*
 * lvgl arc object definitions
 */
    

STATIC const mp_rom_map_elem_t arc_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_set_start_angle), MP_ROM_PTR(&mp_lv_arc_set_start_angle_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_end_angle), MP_ROM_PTR(&mp_lv_arc_set_end_angle_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_angles), MP_ROM_PTR(&mp_lv_arc_set_angles_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_bg_start_angle), MP_ROM_PTR(&mp_lv_arc_set_bg_start_angle_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_bg_end_angle), MP_ROM_PTR(&mp_lv_arc_set_bg_end_angle_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_bg_angles), MP_ROM_PTR(&mp_lv_arc_set_bg_angles_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_rotation), MP_ROM_PTR(&mp_lv_arc_set_rotation_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_mode), MP_ROM_PTR(&mp_lv_arc_set_mode_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_value), MP_ROM_PTR(&mp_lv_arc_set_value_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_range), MP_ROM_PTR(&mp_lv_arc_set_range_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_change_rate), MP_ROM_PTR(&mp_lv_arc_set_change_rate_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_angle_start), MP_ROM_PTR(&mp_lv_arc_get_angle_start_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_angle_end), MP_ROM_PTR(&mp_lv_arc_get_angle_end_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_bg_angle_start), MP_ROM_PTR(&mp_lv_arc_get_bg_angle_start_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_bg_angle_end), MP_ROM_PTR(&mp_lv_arc_get_bg_angle_end_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_value), MP_ROM_PTR(&mp_lv_arc_get_value_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_min_value), MP_ROM_PTR(&mp_lv_arc_get_min_value_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_max_value), MP_ROM_PTR(&mp_lv_arc_get_max_value_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_mode), MP_ROM_PTR(&mp_lv_arc_get_mode_obj) },
    { MP_ROM_QSTR(MP_QSTR_align_obj_to_angle), MP_ROM_PTR(&mp_lv_arc_align_obj_to_angle_obj) },
    { MP_ROM_QSTR(MP_QSTR_rotate_obj_to_angle), MP_ROM_PTR(&mp_lv_arc_rotate_obj_to_angle_obj) },
    { MP_ROM_QSTR(MP_QSTR_MODE), MP_ROM_PTR(&mp_LV_ARC_MODE_type) },
    { MP_ROM_QSTR(MP_QSTR_DRAW_PART), MP_ROM_PTR(&mp_LV_ARC_DRAW_PART_type) }
};

STATIC MP_DEFINE_CONST_DICT(arc_locals_dict, arc_locals_dict_table);

STATIC void arc_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl arc");
}


STATIC mp_obj_t arc_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&lv_arc_create, type, n_args, n_kw, args);           
}


STATIC const mp_obj_type_t mp_arc_type = {
    { &mp_type_type },
    .name = MP_QSTR_arc,
    .print = arc_print,
    .make_new = arc_make_new,
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&arc_locals_dict,
    .buffer_p = { .get_buffer = mp_lv_obj_get_buffer },
    .parent = &mp_obj_type,
};
    

/*
 * lvgl btn object definitions
 */
    

STATIC const mp_rom_map_elem_t btn_locals_dict_table[] = {
    
};

STATIC MP_DEFINE_CONST_DICT(btn_locals_dict, btn_locals_dict_table);

STATIC void btn_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl btn");
}


STATIC mp_obj_t btn_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&lv_btn_create, type, n_args, n_kw, args);           
}


STATIC const mp_obj_type_t mp_btn_type = {
    { &mp_type_type },
    .name = MP_QSTR_btn,
    .print = btn_print,
    .make_new = btn_make_new,
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&btn_locals_dict,
    .buffer_p = { .get_buffer = mp_lv_obj_get_buffer },
    .parent = &mp_obj_type,
};
    

/*
 * Struct lv_img_header_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_img_header_t_type();

STATIC inline lv_img_header_t* mp_write_ptr_lv_img_header_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_img_header_t_type()));
    return (lv_img_header_t*)self->data;
}

#define mp_write_lv_img_header_t(struct_obj) *mp_write_ptr_lv_img_header_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_img_header_t(lv_img_header_t *field)
{
    return lv_to_mp_struct(get_mp_lv_img_header_t_type(), (void*)field);
}

#define mp_read_lv_img_header_t(field) mp_read_ptr_lv_img_header_t(copy_buffer(&field, sizeof(lv_img_header_t)))
#define mp_read_byref_lv_img_header_t(field) mp_read_ptr_lv_img_header_t(&field)

STATIC void mp_lv_img_header_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_img_header_t *data = (lv_img_header_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_cf: dest[0] = mp_obj_new_int_from_uint(data->cf); break; // converting from uint32_t;
            case MP_QSTR_always_zero: dest[0] = mp_obj_new_int_from_uint(data->always_zero); break; // converting from uint32_t;
            case MP_QSTR_reserved: dest[0] = mp_obj_new_int_from_uint(data->reserved); break; // converting from uint32_t;
            case MP_QSTR_w: dest[0] = mp_obj_new_int_from_uint(data->w); break; // converting from uint32_t;
            case MP_QSTR_h: dest[0] = mp_obj_new_int_from_uint(data->h); break; // converting from uint32_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_cf: data->cf = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_always_zero: data->always_zero = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_reserved: data->reserved = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_w: data->w = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_h: data->h = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_img_header_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_img_header_t");
}

STATIC const mp_obj_dict_t mp_lv_img_header_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_img_header_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_img_header_t,
    .print = mp_lv_img_header_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_img_header_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_img_header_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_img_header_t_type()
{
    return &mp_lv_img_header_t_type;
}
    

/*
 * Struct lv_img_dsc_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_img_dsc_t_type();

STATIC inline lv_img_dsc_t* mp_write_ptr_lv_img_dsc_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_img_dsc_t_type()));
    return (lv_img_dsc_t*)self->data;
}

#define mp_write_lv_img_dsc_t(struct_obj) *mp_write_ptr_lv_img_dsc_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_img_dsc_t(lv_img_dsc_t *field)
{
    return lv_to_mp_struct(get_mp_lv_img_dsc_t_type(), (void*)field);
}

#define mp_read_lv_img_dsc_t(field) mp_read_ptr_lv_img_dsc_t(copy_buffer(&field, sizeof(lv_img_dsc_t)))
#define mp_read_byref_lv_img_dsc_t(field) mp_read_ptr_lv_img_dsc_t(&field)

STATIC void mp_lv_img_dsc_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_img_dsc_t *data = (lv_img_dsc_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_header: dest[0] = mp_read_byref_lv_img_header_t(data->header); break; // converting from lv_img_header_t;
            case MP_QSTR_data_size: dest[0] = mp_obj_new_int_from_uint(data->data_size); break; // converting from uint32_t;
            case MP_QSTR_data: dest[0] = ptr_to_mp((void*)data->data); break; // converting from uint8_t *;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_header: data->header = mp_write_lv_img_header_t(dest[1]); break; // converting to lv_img_header_t;
                case MP_QSTR_data_size: data->data_size = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_data: data->data = (void*)mp_to_ptr(dest[1]); break; // converting to uint8_t *;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_img_dsc_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_img_dsc_t");
}

STATIC const mp_obj_dict_t mp_lv_img_dsc_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_img_dsc_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_img_dsc_t,
    .print = mp_lv_img_dsc_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_img_dsc_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_img_dsc_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_img_dsc_t_type()
{
    return &mp_lv_img_dsc_t_type;
}
    

/*
 * lvgl extension definition for:
 * lv_img_dsc_t *lv_img_buf_alloc(lv_coord_t w, lv_coord_t h, lv_img_cf_t cf)
 */
 
STATIC mp_obj_t mp_lv_img_buf_alloc(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_coord_t w = (int16_t)mp_obj_get_int(mp_args[0]);
    lv_coord_t h = (int16_t)mp_obj_get_int(mp_args[1]);
    lv_img_cf_t cf = (uint8_t)mp_obj_get_int(mp_args[2]);
    lv_img_dsc_t * _res = ((lv_img_dsc_t *(*)(lv_coord_t, lv_coord_t, lv_img_cf_t))lv_func_ptr)(w, h, cf);
    return mp_read_ptr_lv_img_dsc_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_img_buf_alloc_obj, 3, mp_lv_img_buf_alloc, lv_img_buf_alloc);
    

/*
 * lvgl extension definition for:
 * lv_color_t lv_img_buf_get_px_color(lv_img_dsc_t *dsc, lv_coord_t x, lv_coord_t y, lv_color_t color)
 */
 
STATIC mp_obj_t mp_lv_img_buf_get_px_color(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_img_dsc_t *dsc = mp_write_ptr_lv_img_dsc_t(mp_args[0]);
    lv_coord_t x = (int16_t)mp_obj_get_int(mp_args[1]);
    lv_coord_t y = (int16_t)mp_obj_get_int(mp_args[2]);
    lv_color_t color = mp_write_lv_color16_t(mp_args[3]);
    lv_color_t _res = ((lv_color_t (*)(lv_img_dsc_t *, lv_coord_t, lv_coord_t, lv_color_t))lv_func_ptr)(dsc, x, y, color);
    return mp_read_lv_color16_t(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_img_buf_get_px_color_obj, 4, mp_lv_img_buf_get_px_color, lv_img_buf_get_px_color);
    

/*
 * lvgl extension definition for:
 * lv_opa_t lv_img_buf_get_px_alpha(lv_img_dsc_t *dsc, lv_coord_t x, lv_coord_t y)
 */
 
STATIC mp_obj_t mp_lv_img_buf_get_px_alpha(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_img_dsc_t *dsc = mp_write_ptr_lv_img_dsc_t(mp_args[0]);
    lv_coord_t x = (int16_t)mp_obj_get_int(mp_args[1]);
    lv_coord_t y = (int16_t)mp_obj_get_int(mp_args[2]);
    lv_opa_t _res = ((lv_opa_t (*)(lv_img_dsc_t *, lv_coord_t, lv_coord_t))lv_func_ptr)(dsc, x, y);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_img_buf_get_px_alpha_obj, 3, mp_lv_img_buf_get_px_alpha, lv_img_buf_get_px_alpha);
    

/*
 * lvgl extension definition for:
 * void lv_img_buf_set_px_color(lv_img_dsc_t *dsc, lv_coord_t x, lv_coord_t y, lv_color_t c)
 */
 
STATIC mp_obj_t mp_lv_img_buf_set_px_color(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_img_dsc_t *dsc = mp_write_ptr_lv_img_dsc_t(mp_args[0]);
    lv_coord_t x = (int16_t)mp_obj_get_int(mp_args[1]);
    lv_coord_t y = (int16_t)mp_obj_get_int(mp_args[2]);
    lv_color_t c = mp_write_lv_color16_t(mp_args[3]);
    ((void (*)(lv_img_dsc_t *, lv_coord_t, lv_coord_t, lv_color_t))lv_func_ptr)(dsc, x, y, c);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_img_buf_set_px_color_obj, 4, mp_lv_img_buf_set_px_color, lv_img_buf_set_px_color);
    

/*
 * lvgl extension definition for:
 * void lv_img_buf_set_px_alpha(lv_img_dsc_t *dsc, lv_coord_t x, lv_coord_t y, lv_opa_t opa)
 */
 
STATIC mp_obj_t mp_lv_img_buf_set_px_alpha(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_img_dsc_t *dsc = mp_write_ptr_lv_img_dsc_t(mp_args[0]);
    lv_coord_t x = (int16_t)mp_obj_get_int(mp_args[1]);
    lv_coord_t y = (int16_t)mp_obj_get_int(mp_args[2]);
    lv_opa_t opa = (uint8_t)mp_obj_get_int(mp_args[3]);
    ((void (*)(lv_img_dsc_t *, lv_coord_t, lv_coord_t, lv_opa_t))lv_func_ptr)(dsc, x, y, opa);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_img_buf_set_px_alpha_obj, 4, mp_lv_img_buf_set_px_alpha, lv_img_buf_set_px_alpha);
    

/*
 * lvgl extension definition for:
 * void lv_img_buf_set_palette(lv_img_dsc_t *dsc, uint8_t id, lv_color_t c)
 */
 
STATIC mp_obj_t mp_lv_img_buf_set_palette(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_img_dsc_t *dsc = mp_write_ptr_lv_img_dsc_t(mp_args[0]);
    uint8_t id = (uint8_t)mp_obj_get_int(mp_args[1]);
    lv_color_t c = mp_write_lv_color16_t(mp_args[2]);
    ((void (*)(lv_img_dsc_t *, uint8_t, lv_color_t))lv_func_ptr)(dsc, id, c);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_img_buf_set_palette_obj, 3, mp_lv_img_buf_set_palette, lv_img_buf_set_palette);
    

/*
 * lvgl extension definition for:
 * void lv_img_buf_free(lv_img_dsc_t *dsc)
 */
 
STATIC mp_obj_t mp_lv_img_buf_free(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_img_dsc_t *dsc = mp_write_ptr_lv_img_dsc_t(mp_args[0]);
    ((void (*)(lv_img_dsc_t *))lv_func_ptr)(dsc);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_img_buf_free_obj, 1, mp_lv_img_buf_free, lv_img_buf_free);
    

/*
 * lvgl extension definition for:
 * uint32_t lv_img_buf_get_img_size(lv_coord_t w, lv_coord_t h, lv_img_cf_t cf)
 */
 
STATIC mp_obj_t mp_lv_img_buf_get_img_size(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_coord_t w = (int16_t)mp_obj_get_int(mp_args[0]);
    lv_coord_t h = (int16_t)mp_obj_get_int(mp_args[1]);
    lv_img_cf_t cf = (uint8_t)mp_obj_get_int(mp_args[2]);
    uint32_t _res = ((uint32_t (*)(lv_coord_t, lv_coord_t, lv_img_cf_t))lv_func_ptr)(w, h, cf);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_img_buf_get_img_size_obj, 3, mp_lv_img_buf_get_img_size, lv_img_buf_get_img_size);
    

/*
 * lvgl extension definition for:
 * lv_res_t lv_img_decoder_get_info(const void *src, lv_img_header_t *header)
 */
 
STATIC mp_obj_t mp_lv_img_decoder_get_info(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const void *src = mp_to_ptr(mp_args[0]);
    lv_img_header_t *header = mp_write_ptr_lv_img_header_t(mp_args[1]);
    lv_res_t _res = ((lv_res_t (*)(const void *, lv_img_header_t *))lv_func_ptr)(src, header);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_img_decoder_get_info_obj, 2, mp_lv_img_decoder_get_info, lv_img_decoder_get_info);
    
#define funcptr_lv_img_decoder_info_f_t NULL


/*
 * lvgl extension definition for:
 * lv_res_t lv_img_decoder_info_f_t(struct _lv_img_decoder_t *decoder, const void *src, lv_img_header_t *header)
 */
 
STATIC mp_obj_t mp_funcptr_lv_img_decoder_info_f_t(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_img_decoder_t *decoder = mp_to_ptr(mp_args[0]);
    const void *src = mp_to_ptr(mp_args[1]);
    lv_img_header_t *header = mp_write_ptr_lv_img_header_t(mp_args[2]);
    lv_res_t _res = ((lv_res_t (*)(struct _lv_img_decoder_t *, const void *, lv_img_header_t *))lv_func_ptr)(decoder, src, header);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_lv_img_decoder_info_f_t_obj, 3, mp_funcptr_lv_img_decoder_info_f_t, funcptr_lv_img_decoder_info_f_t);
    
STATIC inline mp_obj_t mp_lv_funcptr_lv_img_decoder_info_f_t(void *func){ return mp_lv_funcptr(&mp_funcptr_lv_img_decoder_info_f_t_obj, func, NULL, MP_QSTR_, NULL); }

STATIC lv_res_t lv_img_decoder_t_info_cb_callback(struct _lv_img_decoder_t *decoder, const void *src, lv_img_header_t *header);
#define funcptr_lv_img_decoder_open_f_t NULL


/*
 * lvgl extension definition for:
 * lv_res_t lv_img_decoder_open_f_t(struct _lv_img_decoder_t *decoder, struct _lv_img_decoder_dsc_t *dsc)
 */
 
STATIC mp_obj_t mp_funcptr_lv_img_decoder_open_f_t(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_img_decoder_t *decoder = mp_to_ptr(mp_args[0]);
    struct _lv_img_decoder_dsc_t *dsc = mp_to_ptr(mp_args[1]);
    lv_res_t _res = ((lv_res_t (*)(struct _lv_img_decoder_t *, struct _lv_img_decoder_dsc_t *))lv_func_ptr)(decoder, dsc);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_lv_img_decoder_open_f_t_obj, 2, mp_funcptr_lv_img_decoder_open_f_t, funcptr_lv_img_decoder_open_f_t);
    
STATIC inline mp_obj_t mp_lv_funcptr_lv_img_decoder_open_f_t(void *func){ return mp_lv_funcptr(&mp_funcptr_lv_img_decoder_open_f_t_obj, func, NULL, MP_QSTR_, NULL); }

STATIC lv_res_t lv_img_decoder_t_open_cb_callback(struct _lv_img_decoder_t *decoder, struct _lv_img_decoder_dsc_t *dsc);
#define funcptr_lv_img_decoder_read_line_f_t NULL


/*
 * lvgl extension definition for:
 * lv_res_t lv_img_decoder_read_line_f_t(struct _lv_img_decoder_t *decoder, struct _lv_img_decoder_dsc_t *dsc, lv_coord_t x, lv_coord_t y, lv_coord_t len, uint8_t *buf)
 */
 
STATIC mp_obj_t mp_funcptr_lv_img_decoder_read_line_f_t(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_img_decoder_t *decoder = mp_to_ptr(mp_args[0]);
    struct _lv_img_decoder_dsc_t *dsc = mp_to_ptr(mp_args[1]);
    lv_coord_t x = (int16_t)mp_obj_get_int(mp_args[2]);
    lv_coord_t y = (int16_t)mp_obj_get_int(mp_args[3]);
    lv_coord_t len = (int16_t)mp_obj_get_int(mp_args[4]);
    uint8_t *buf = mp_to_ptr(mp_args[5]);
    lv_res_t _res = ((lv_res_t (*)(struct _lv_img_decoder_t *, struct _lv_img_decoder_dsc_t *, lv_coord_t, lv_coord_t, lv_coord_t, uint8_t *))lv_func_ptr)(decoder, dsc, x, y, len, buf);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_lv_img_decoder_read_line_f_t_obj, 6, mp_funcptr_lv_img_decoder_read_line_f_t, funcptr_lv_img_decoder_read_line_f_t);
    
STATIC inline mp_obj_t mp_lv_funcptr_lv_img_decoder_read_line_f_t(void *func){ return mp_lv_funcptr(&mp_funcptr_lv_img_decoder_read_line_f_t_obj, func, NULL, MP_QSTR_, NULL); }

STATIC lv_res_t lv_img_decoder_t_read_line_cb_callback(struct _lv_img_decoder_t *decoder, struct _lv_img_decoder_dsc_t *dsc, lv_coord_t x, lv_coord_t y, lv_coord_t len, uint8_t *buf);
#define funcptr_lv_img_decoder_close_f_t NULL


/*
 * lvgl extension definition for:
 * void lv_img_decoder_close_f_t(struct _lv_img_decoder_t *decoder, struct _lv_img_decoder_dsc_t *dsc)
 */
 
STATIC mp_obj_t mp_funcptr_lv_img_decoder_close_f_t(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_img_decoder_t *decoder = mp_to_ptr(mp_args[0]);
    struct _lv_img_decoder_dsc_t *dsc = mp_to_ptr(mp_args[1]);
    ((void (*)(struct _lv_img_decoder_t *, struct _lv_img_decoder_dsc_t *))lv_func_ptr)(decoder, dsc);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_lv_img_decoder_close_f_t_obj, 2, mp_funcptr_lv_img_decoder_close_f_t, funcptr_lv_img_decoder_close_f_t);
    
STATIC inline mp_obj_t mp_lv_funcptr_lv_img_decoder_close_f_t(void *func){ return mp_lv_funcptr(&mp_funcptr_lv_img_decoder_close_f_t_obj, func, NULL, MP_QSTR_, NULL); }

STATIC void lv_img_decoder_t_close_cb_callback(struct _lv_img_decoder_t *decoder, struct _lv_img_decoder_dsc_t *dsc);

/*
 * Struct lv_img_decoder_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_img_decoder_t_type();

STATIC inline lv_img_decoder_t* mp_write_ptr_lv_img_decoder_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_img_decoder_t_type()));
    return (lv_img_decoder_t*)self->data;
}

#define mp_write_lv_img_decoder_t(struct_obj) *mp_write_ptr_lv_img_decoder_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_img_decoder_t(lv_img_decoder_t *field)
{
    return lv_to_mp_struct(get_mp_lv_img_decoder_t_type(), (void*)field);
}

#define mp_read_lv_img_decoder_t(field) mp_read_ptr_lv_img_decoder_t(copy_buffer(&field, sizeof(lv_img_decoder_t)))
#define mp_read_byref_lv_img_decoder_t(field) mp_read_ptr_lv_img_decoder_t(&field)

STATIC void mp_lv_img_decoder_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_img_decoder_t *data = (lv_img_decoder_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_info_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_lv_img_decoder_info_f_t_obj, data->info_cb, lv_img_decoder_t_info_cb_callback ,MP_QSTR_lv_img_decoder_t_info_cb, data->user_data); break; // converting from callback lv_img_decoder_info_f_t;
            case MP_QSTR_open_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_lv_img_decoder_open_f_t_obj, data->open_cb, lv_img_decoder_t_open_cb_callback ,MP_QSTR_lv_img_decoder_t_open_cb, data->user_data); break; // converting from callback lv_img_decoder_open_f_t;
            case MP_QSTR_read_line_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_lv_img_decoder_read_line_f_t_obj, data->read_line_cb, lv_img_decoder_t_read_line_cb_callback ,MP_QSTR_lv_img_decoder_t_read_line_cb, data->user_data); break; // converting from callback lv_img_decoder_read_line_f_t;
            case MP_QSTR_close_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_lv_img_decoder_close_f_t_obj, data->close_cb, lv_img_decoder_t_close_cb_callback ,MP_QSTR_lv_img_decoder_t_close_cb, data->user_data); break; // converting from callback lv_img_decoder_close_f_t;
            case MP_QSTR_user_data: dest[0] = ptr_to_mp((void*)data->user_data); break; // converting from void *;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_info_cb: data->info_cb = mp_lv_callback(dest[1], lv_img_decoder_t_info_cb_callback ,MP_QSTR_lv_img_decoder_t_info_cb, &data->user_data); break; // converting to callback lv_img_decoder_info_f_t;
                case MP_QSTR_open_cb: data->open_cb = mp_lv_callback(dest[1], lv_img_decoder_t_open_cb_callback ,MP_QSTR_lv_img_decoder_t_open_cb, &data->user_data); break; // converting to callback lv_img_decoder_open_f_t;
                case MP_QSTR_read_line_cb: data->read_line_cb = mp_lv_callback(dest[1], lv_img_decoder_t_read_line_cb_callback ,MP_QSTR_lv_img_decoder_t_read_line_cb, &data->user_data); break; // converting to callback lv_img_decoder_read_line_f_t;
                case MP_QSTR_close_cb: data->close_cb = mp_lv_callback(dest[1], lv_img_decoder_t_close_cb_callback ,MP_QSTR_lv_img_decoder_t_close_cb, &data->user_data); break; // converting to callback lv_img_decoder_close_f_t;
                case MP_QSTR_user_data: data->user_data = (void*)mp_to_ptr(dest[1]); break; // converting to void *;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_img_decoder_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_img_decoder_t");
}

STATIC const mp_obj_dict_t mp_lv_img_decoder_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_img_decoder_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_img_decoder_t,
    .print = mp_lv_img_decoder_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_img_decoder_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_img_decoder_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_img_decoder_t_type()
{
    return &mp_lv_img_decoder_t_type;
}
    

/*
 * Struct lv_img_decoder_dsc_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_img_decoder_dsc_t_type();

STATIC inline lv_img_decoder_dsc_t* mp_write_ptr_lv_img_decoder_dsc_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_img_decoder_dsc_t_type()));
    return (lv_img_decoder_dsc_t*)self->data;
}

#define mp_write_lv_img_decoder_dsc_t(struct_obj) *mp_write_ptr_lv_img_decoder_dsc_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_img_decoder_dsc_t(lv_img_decoder_dsc_t *field)
{
    return lv_to_mp_struct(get_mp_lv_img_decoder_dsc_t_type(), (void*)field);
}

#define mp_read_lv_img_decoder_dsc_t(field) mp_read_ptr_lv_img_decoder_dsc_t(copy_buffer(&field, sizeof(lv_img_decoder_dsc_t)))
#define mp_read_byref_lv_img_decoder_dsc_t(field) mp_read_ptr_lv_img_decoder_dsc_t(&field)

STATIC void mp_lv_img_decoder_dsc_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_img_decoder_dsc_t *data = (lv_img_decoder_dsc_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_decoder: dest[0] = mp_read_ptr_lv_img_decoder_t((void*)data->decoder); break; // converting from lv_img_decoder_t *;
            case MP_QSTR_src: dest[0] = ptr_to_mp((void*)data->src); break; // converting from void *;
            case MP_QSTR_color: dest[0] = mp_read_byref_lv_color16_t(data->color); break; // converting from lv_color_t;
            case MP_QSTR_frame_id: dest[0] = mp_obj_new_int(data->frame_id); break; // converting from int32_t;
            case MP_QSTR_src_type: dest[0] = mp_obj_new_int_from_uint(data->src_type); break; // converting from lv_img_src_t;
            case MP_QSTR_header: dest[0] = mp_read_byref_lv_img_header_t(data->header); break; // converting from lv_img_header_t;
            case MP_QSTR_img_data: dest[0] = ptr_to_mp((void*)data->img_data); break; // converting from uint8_t *;
            case MP_QSTR_img_data_size: dest[0] = mp_obj_new_int_from_uint(data->img_data_size); break; // converting from uint32_t;
            case MP_QSTR_time_to_open: dest[0] = mp_obj_new_int_from_uint(data->time_to_open); break; // converting from uint32_t;
            case MP_QSTR_error_msg: dest[0] = convert_to_str((void*)data->error_msg); break; // converting from char *;
            case MP_QSTR_user_data: dest[0] = ptr_to_mp((void*)data->user_data); break; // converting from void *;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_decoder: data->decoder = (void*)mp_write_ptr_lv_img_decoder_t(dest[1]); break; // converting to lv_img_decoder_t *;
                case MP_QSTR_src: data->src = (void*)mp_to_ptr(dest[1]); break; // converting to void *;
                case MP_QSTR_color: data->color = mp_write_lv_color16_t(dest[1]); break; // converting to lv_color_t;
                case MP_QSTR_frame_id: data->frame_id = (int32_t)mp_obj_get_int(dest[1]); break; // converting to int32_t;
                case MP_QSTR_src_type: data->src_type = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to lv_img_src_t;
                case MP_QSTR_header: data->header = mp_write_lv_img_header_t(dest[1]); break; // converting to lv_img_header_t;
                case MP_QSTR_img_data: data->img_data = (void*)mp_to_ptr(dest[1]); break; // converting to uint8_t *;
                case MP_QSTR_img_data_size: data->img_data_size = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_time_to_open: data->time_to_open = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_error_msg: data->error_msg = (void*)(char*)convert_from_str(dest[1]); break; // converting to char *;
                case MP_QSTR_user_data: data->user_data = (void*)mp_to_ptr(dest[1]); break; // converting to void *;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_img_decoder_dsc_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_img_decoder_dsc_t");
}

STATIC const mp_obj_dict_t mp_lv_img_decoder_dsc_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_img_decoder_dsc_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_img_decoder_dsc_t,
    .print = mp_lv_img_decoder_dsc_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_img_decoder_dsc_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_img_decoder_dsc_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_img_decoder_dsc_t_type()
{
    return &mp_lv_img_decoder_dsc_t_type;
}
    

/*
 * lvgl extension definition for:
 * lv_res_t lv_img_decoder_open(lv_img_decoder_dsc_t *dsc, const void *src, lv_color_t color, int32_t frame_id)
 */
 
STATIC mp_obj_t mp_lv_img_decoder_open(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_img_decoder_dsc_t *dsc = mp_write_ptr_lv_img_decoder_dsc_t(mp_args[0]);
    const void *src = mp_to_ptr(mp_args[1]);
    lv_color_t color = mp_write_lv_color16_t(mp_args[2]);
    int32_t frame_id = (int32_t)mp_obj_get_int(mp_args[3]);
    lv_res_t _res = ((lv_res_t (*)(lv_img_decoder_dsc_t *, const void *, lv_color_t, int32_t))lv_func_ptr)(dsc, src, color, frame_id);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_img_decoder_open_obj, 4, mp_lv_img_decoder_open, lv_img_decoder_open);
    

/*
 * lvgl extension definition for:
 * lv_res_t lv_img_decoder_read_line(lv_img_decoder_dsc_t *dsc, lv_coord_t x, lv_coord_t y, lv_coord_t len, uint8_t *buf)
 */
 
STATIC mp_obj_t mp_lv_img_decoder_read_line(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_img_decoder_dsc_t *dsc = mp_write_ptr_lv_img_decoder_dsc_t(mp_args[0]);
    lv_coord_t x = (int16_t)mp_obj_get_int(mp_args[1]);
    lv_coord_t y = (int16_t)mp_obj_get_int(mp_args[2]);
    lv_coord_t len = (int16_t)mp_obj_get_int(mp_args[3]);
    uint8_t *buf = mp_to_ptr(mp_args[4]);
    lv_res_t _res = ((lv_res_t (*)(lv_img_decoder_dsc_t *, lv_coord_t, lv_coord_t, lv_coord_t, uint8_t *))lv_func_ptr)(dsc, x, y, len, buf);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_img_decoder_read_line_obj, 5, mp_lv_img_decoder_read_line, lv_img_decoder_read_line);
    

/*
 * lvgl extension definition for:
 * void lv_img_decoder_close(lv_img_decoder_dsc_t *dsc)
 */
 
STATIC mp_obj_t mp_lv_img_decoder_close(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_img_decoder_dsc_t *dsc = mp_write_ptr_lv_img_decoder_dsc_t(mp_args[0]);
    ((void (*)(lv_img_decoder_dsc_t *))lv_func_ptr)(dsc);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_img_decoder_close_obj, 1, mp_lv_img_decoder_close, lv_img_decoder_close);
    

/*
 * lvgl extension definition for:
 * lv_img_decoder_t *lv_img_decoder_create(void)
 */
 
STATIC mp_obj_t mp_lv_img_decoder_create(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    
    lv_img_decoder_t * _res = ((lv_img_decoder_t *(*)(void))lv_func_ptr)();
    return mp_read_ptr_lv_img_decoder_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_img_decoder_create_obj, 0, mp_lv_img_decoder_create, lv_img_decoder_create);
    

/*
 * lvgl extension definition for:
 * void lv_img_decoder_delete(lv_img_decoder_t *decoder)
 */
 
STATIC mp_obj_t mp_lv_img_decoder_delete(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_img_decoder_t *decoder = mp_write_ptr_lv_img_decoder_t(mp_args[0]);
    ((void (*)(lv_img_decoder_t *))lv_func_ptr)(decoder);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_img_decoder_delete_obj, 1, mp_lv_img_decoder_delete, lv_img_decoder_delete);
    

/*
 * Callback function lv_img_decoder_t_info_cb
 * lv_res_t lv_img_decoder_info_f_t(struct _lv_img_decoder_t *decoder, const void *src, lv_img_header_t *header)
 */

STATIC lv_res_t lv_img_decoder_t_info_cb_callback(struct _lv_img_decoder_t * arg0, const void * arg1, lv_img_header_t * arg2)
{
    mp_obj_t mp_args[3];
    mp_args[0] = mp_read_ptr_lv_img_decoder_t((void*)arg0);
    mp_args[1] = ptr_to_mp((void*)arg1);
    mp_args[2] = mp_read_ptr_lv_img_header_t((void*)arg2);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    mp_obj_t callback_result = mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_img_decoder_t_info_cb)) , 3, 0, mp_args);
    return (uint8_t)mp_obj_get_int(callback_result);
}


/*
 * lvgl extension definition for:
 * void lv_img_decoder_set_info_cb(lv_img_decoder_t *decoder, lv_img_decoder_info_f_t info_cb)
 */
 
STATIC mp_obj_t mp_lv_img_decoder_set_info_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_img_decoder_t *decoder = mp_write_ptr_lv_img_decoder_t(mp_args[0]);
    void *info_cb = mp_lv_callback(mp_args[1], &lv_img_decoder_t_info_cb_callback, MP_QSTR_lv_img_decoder_t_info_cb, &decoder->user_data);
    ((void (*)(lv_img_decoder_t *, lv_img_decoder_info_f_t))lv_func_ptr)(decoder, info_cb);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_img_decoder_set_info_cb_obj, 2, mp_lv_img_decoder_set_info_cb, lv_img_decoder_set_info_cb);
    

/*
 * Callback function lv_img_decoder_t_open_cb
 * lv_res_t lv_img_decoder_open_f_t(struct _lv_img_decoder_t *decoder, struct _lv_img_decoder_dsc_t *dsc)
 */

STATIC lv_res_t lv_img_decoder_t_open_cb_callback(struct _lv_img_decoder_t * arg0, struct _lv_img_decoder_dsc_t * arg1)
{
    mp_obj_t mp_args[2];
    mp_args[0] = mp_read_ptr_lv_img_decoder_t((void*)arg0);
    mp_args[1] = mp_read_ptr_lv_img_decoder_dsc_t((void*)arg1);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    mp_obj_t callback_result = mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_img_decoder_t_open_cb)) , 2, 0, mp_args);
    return (uint8_t)mp_obj_get_int(callback_result);
}


/*
 * lvgl extension definition for:
 * void lv_img_decoder_set_open_cb(lv_img_decoder_t *decoder, lv_img_decoder_open_f_t open_cb)
 */
 
STATIC mp_obj_t mp_lv_img_decoder_set_open_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_img_decoder_t *decoder = mp_write_ptr_lv_img_decoder_t(mp_args[0]);
    void *open_cb = mp_lv_callback(mp_args[1], &lv_img_decoder_t_open_cb_callback, MP_QSTR_lv_img_decoder_t_open_cb, &decoder->user_data);
    ((void (*)(lv_img_decoder_t *, lv_img_decoder_open_f_t))lv_func_ptr)(decoder, open_cb);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_img_decoder_set_open_cb_obj, 2, mp_lv_img_decoder_set_open_cb, lv_img_decoder_set_open_cb);
    

/*
 * Callback function lv_img_decoder_t_read_line_cb
 * lv_res_t lv_img_decoder_read_line_f_t(struct _lv_img_decoder_t *decoder, struct _lv_img_decoder_dsc_t *dsc, lv_coord_t x, lv_coord_t y, lv_coord_t len, uint8_t *buf)
 */

STATIC lv_res_t lv_img_decoder_t_read_line_cb_callback(struct _lv_img_decoder_t * arg0, struct _lv_img_decoder_dsc_t * arg1, lv_coord_t arg2, lv_coord_t arg3, lv_coord_t arg4, uint8_t * arg5)
{
    mp_obj_t mp_args[6];
    mp_args[0] = mp_read_ptr_lv_img_decoder_t((void*)arg0);
    mp_args[1] = mp_read_ptr_lv_img_decoder_dsc_t((void*)arg1);
    mp_args[2] = mp_obj_new_int(arg2);
    mp_args[3] = mp_obj_new_int(arg3);
    mp_args[4] = mp_obj_new_int(arg4);
    mp_args[5] = ptr_to_mp((void*)arg5);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    mp_obj_t callback_result = mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_img_decoder_t_read_line_cb)) , 6, 0, mp_args);
    return (uint8_t)mp_obj_get_int(callback_result);
}


/*
 * lvgl extension definition for:
 * void lv_img_decoder_set_read_line_cb(lv_img_decoder_t *decoder, lv_img_decoder_read_line_f_t read_line_cb)
 */
 
STATIC mp_obj_t mp_lv_img_decoder_set_read_line_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_img_decoder_t *decoder = mp_write_ptr_lv_img_decoder_t(mp_args[0]);
    void *read_line_cb = mp_lv_callback(mp_args[1], &lv_img_decoder_t_read_line_cb_callback, MP_QSTR_lv_img_decoder_t_read_line_cb, &decoder->user_data);
    ((void (*)(lv_img_decoder_t *, lv_img_decoder_read_line_f_t))lv_func_ptr)(decoder, read_line_cb);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_img_decoder_set_read_line_cb_obj, 2, mp_lv_img_decoder_set_read_line_cb, lv_img_decoder_set_read_line_cb);
    

/*
 * Callback function lv_img_decoder_t_close_cb
 * void lv_img_decoder_close_f_t(struct _lv_img_decoder_t *decoder, struct _lv_img_decoder_dsc_t *dsc)
 */

STATIC void lv_img_decoder_t_close_cb_callback(struct _lv_img_decoder_t * arg0, struct _lv_img_decoder_dsc_t * arg1)
{
    mp_obj_t mp_args[2];
    mp_args[0] = mp_read_ptr_lv_img_decoder_t((void*)arg0);
    mp_args[1] = mp_read_ptr_lv_img_decoder_dsc_t((void*)arg1);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_img_decoder_t_close_cb)) , 2, 0, mp_args);
    return;
}


/*
 * lvgl extension definition for:
 * void lv_img_decoder_set_close_cb(lv_img_decoder_t *decoder, lv_img_decoder_close_f_t close_cb)
 */
 
STATIC mp_obj_t mp_lv_img_decoder_set_close_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_img_decoder_t *decoder = mp_write_ptr_lv_img_decoder_t(mp_args[0]);
    void *close_cb = mp_lv_callback(mp_args[1], &lv_img_decoder_t_close_cb_callback, MP_QSTR_lv_img_decoder_t_close_cb, &decoder->user_data);
    ((void (*)(lv_img_decoder_t *, lv_img_decoder_close_f_t))lv_func_ptr)(decoder, close_cb);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_img_decoder_set_close_cb_obj, 2, mp_lv_img_decoder_set_close_cb, lv_img_decoder_set_close_cb);
    

/*
 * lvgl extension definition for:
 * lv_res_t lv_img_decoder_built_in_info(lv_img_decoder_t *decoder, const void *src, lv_img_header_t *header)
 */
 
STATIC mp_obj_t mp_lv_img_decoder_built_in_info(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_img_decoder_t *decoder = mp_write_ptr_lv_img_decoder_t(mp_args[0]);
    const void *src = mp_to_ptr(mp_args[1]);
    lv_img_header_t *header = mp_write_ptr_lv_img_header_t(mp_args[2]);
    lv_res_t _res = ((lv_res_t (*)(lv_img_decoder_t *, const void *, lv_img_header_t *))lv_func_ptr)(decoder, src, header);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_img_decoder_built_in_info_obj, 3, mp_lv_img_decoder_built_in_info, lv_img_decoder_built_in_info);
    

/*
 * lvgl extension definition for:
 * lv_res_t lv_img_decoder_built_in_open(lv_img_decoder_t *decoder, lv_img_decoder_dsc_t *dsc)
 */
 
STATIC mp_obj_t mp_lv_img_decoder_built_in_open(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_img_decoder_t *decoder = mp_write_ptr_lv_img_decoder_t(mp_args[0]);
    lv_img_decoder_dsc_t *dsc = mp_write_ptr_lv_img_decoder_dsc_t(mp_args[1]);
    lv_res_t _res = ((lv_res_t (*)(lv_img_decoder_t *, lv_img_decoder_dsc_t *))lv_func_ptr)(decoder, dsc);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_img_decoder_built_in_open_obj, 2, mp_lv_img_decoder_built_in_open, lv_img_decoder_built_in_open);
    

/*
 * lvgl extension definition for:
 * lv_res_t lv_img_decoder_built_in_read_line(lv_img_decoder_t *decoder, lv_img_decoder_dsc_t *dsc, lv_coord_t x, lv_coord_t y, lv_coord_t len, uint8_t *buf)
 */
 
STATIC mp_obj_t mp_lv_img_decoder_built_in_read_line(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_img_decoder_t *decoder = mp_write_ptr_lv_img_decoder_t(mp_args[0]);
    lv_img_decoder_dsc_t *dsc = mp_write_ptr_lv_img_decoder_dsc_t(mp_args[1]);
    lv_coord_t x = (int16_t)mp_obj_get_int(mp_args[2]);
    lv_coord_t y = (int16_t)mp_obj_get_int(mp_args[3]);
    lv_coord_t len = (int16_t)mp_obj_get_int(mp_args[4]);
    uint8_t *buf = mp_to_ptr(mp_args[5]);
    lv_res_t _res = ((lv_res_t (*)(lv_img_decoder_t *, lv_img_decoder_dsc_t *, lv_coord_t, lv_coord_t, lv_coord_t, uint8_t *))lv_func_ptr)(decoder, dsc, x, y, len, buf);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_img_decoder_built_in_read_line_obj, 6, mp_lv_img_decoder_built_in_read_line, lv_img_decoder_built_in_read_line);
    

/*
 * lvgl extension definition for:
 * void lv_img_decoder_built_in_close(lv_img_decoder_t *decoder, lv_img_decoder_dsc_t *dsc)
 */
 
STATIC mp_obj_t mp_lv_img_decoder_built_in_close(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_img_decoder_t *decoder = mp_write_ptr_lv_img_decoder_t(mp_args[0]);
    lv_img_decoder_dsc_t *dsc = mp_write_ptr_lv_img_decoder_dsc_t(mp_args[1]);
    ((void (*)(lv_img_decoder_t *, lv_img_decoder_dsc_t *))lv_func_ptr)(decoder, dsc);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_img_decoder_built_in_close_obj, 2, mp_lv_img_decoder_built_in_close, lv_img_decoder_built_in_close);
    

/*
 * lvgl extension definition for:
 * void lv_img_cache_set_size(uint16_t new_slot_num)
 */
 
STATIC mp_obj_t mp_lv_img_cache_set_size(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    uint16_t new_slot_num = (uint16_t)mp_obj_get_int(mp_args[0]);
    ((void (*)(uint16_t))lv_func_ptr)(new_slot_num);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_img_cache_set_size_obj, 1, mp_lv_img_cache_set_size, lv_img_cache_set_size);
    

/*
 * lvgl extension definition for:
 * void lv_img_cache_invalidate_src(const void *src)
 */
 
STATIC mp_obj_t mp_lv_img_cache_invalidate_src(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const void *src = mp_to_ptr(mp_args[0]);
    ((void (*)(const void *))lv_func_ptr)(src);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_img_cache_invalidate_src_obj, 1, mp_lv_img_cache_invalidate_src, lv_img_cache_invalidate_src);
    

/*
 * lvgl extension definition for:
 * lv_img_src_t lv_img_src_get_type(const void *src)
 */
 
STATIC mp_obj_t mp_lv_img_src_get_type(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const void *src = mp_to_ptr(mp_args[0]);
    lv_img_src_t _res = ((lv_img_src_t (*)(const void *))lv_func_ptr)(src);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_img_src_get_type_obj, 1, mp_lv_img_src_get_type, lv_img_src_get_type);
    

/*
 * lvgl extension definition for:
 * uint8_t lv_img_cf_get_px_size(lv_img_cf_t cf)
 */
 
STATIC mp_obj_t mp_lv_img_cf_get_px_size(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_img_cf_t cf = (uint8_t)mp_obj_get_int(mp_args[0]);
    uint8_t _res = ((uint8_t (*)(lv_img_cf_t))lv_func_ptr)(cf);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_img_cf_get_px_size_obj, 1, mp_lv_img_cf_get_px_size, lv_img_cf_get_px_size);
    

/*
 * lvgl extension definition for:
 * bool lv_img_cf_is_chroma_keyed(lv_img_cf_t cf)
 */
 
STATIC mp_obj_t mp_lv_img_cf_is_chroma_keyed(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_img_cf_t cf = (uint8_t)mp_obj_get_int(mp_args[0]);
    bool _res = ((bool (*)(lv_img_cf_t))lv_func_ptr)(cf);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_img_cf_is_chroma_keyed_obj, 1, mp_lv_img_cf_is_chroma_keyed, lv_img_cf_is_chroma_keyed);
    
/* Reusing lv_img_cf_is_chroma_keyed for lv_img_cf_has_alpha */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_img_cf_has_alpha_obj, 1, mp_lv_img_cf_is_chroma_keyed, lv_img_cf_has_alpha);
    

/*
 * lvgl extension definition for:
 * void lv_img_set_src(lv_obj_t *obj, const void *src)
 */
 
STATIC mp_obj_t mp_lv_img_set_src(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    const void *src = mp_to_ptr(mp_args[1]);
    ((void (*)(lv_obj_t *, const void *))lv_func_ptr)(obj, src);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_img_set_src_obj, 2, mp_lv_img_set_src, lv_img_set_src);
    

/*
 * lvgl extension definition for:
 * void lv_img_set_offset_x(lv_obj_t *obj, lv_coord_t x)
 */
 
STATIC mp_obj_t mp_lv_img_set_offset_x(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_coord_t x = (int16_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_obj_t *, lv_coord_t))lv_func_ptr)(obj, x);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_img_set_offset_x_obj, 2, mp_lv_img_set_offset_x, lv_img_set_offset_x);
    
/* Reusing lv_img_set_offset_x for lv_img_set_offset_y */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_img_set_offset_y_obj, 2, mp_lv_img_set_offset_x, lv_img_set_offset_y);
    
/* Reusing lv_arc_set_value for lv_img_set_angle */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_img_set_angle_obj, 2, mp_lv_arc_set_value, lv_img_set_angle);
    

/*
 * lvgl extension definition for:
 * void lv_img_set_pivot(lv_obj_t *obj, lv_coord_t x, lv_coord_t y)
 */
 
STATIC mp_obj_t mp_lv_img_set_pivot(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_coord_t x = (int16_t)mp_obj_get_int(mp_args[1]);
    lv_coord_t y = (int16_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_obj_t *, lv_coord_t, lv_coord_t))lv_func_ptr)(obj, x, y);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_img_set_pivot_obj, 3, mp_lv_img_set_pivot, lv_img_set_pivot);
    
/* Reusing lv_arc_set_start_angle for lv_img_set_zoom */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_img_set_zoom_obj, 2, mp_lv_arc_set_start_angle, lv_img_set_zoom);
    
/* Reusing lv_obj_set_page_glue for lv_img_set_antialias */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_img_set_antialias_obj, 2, mp_lv_obj_set_page_glue, lv_img_set_antialias);
    

/*
 * lvgl extension definition for:
 * void lv_img_set_size_mode(lv_obj_t *obj, lv_img_size_mode_t mode)
 */
 
STATIC mp_obj_t mp_lv_img_set_size_mode(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_img_size_mode_t mode = (uint8_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_obj_t *, lv_img_size_mode_t))lv_func_ptr)(obj, mode);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_img_set_size_mode_obj, 2, mp_lv_img_set_size_mode, lv_img_set_size_mode);
    

/*
 * lvgl extension definition for:
 * const void *lv_img_get_src(lv_obj_t *obj)
 */
 
STATIC mp_obj_t mp_lv_img_get_src(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    const void * _res = ((const void *(*)(lv_obj_t *))lv_func_ptr)(obj);
    return ptr_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_img_get_src_obj, 1, mp_lv_img_get_src, lv_img_get_src);
    

/*
 * lvgl extension definition for:
 * lv_coord_t lv_img_get_offset_x(lv_obj_t *obj)
 */
 
STATIC mp_obj_t mp_lv_img_get_offset_x(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_coord_t _res = ((lv_coord_t (*)(lv_obj_t *))lv_func_ptr)(obj);
    return mp_obj_new_int(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_img_get_offset_x_obj, 1, mp_lv_img_get_offset_x, lv_img_get_offset_x);
    
/* Reusing lv_img_get_offset_x for lv_img_get_offset_y */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_img_get_offset_y_obj, 1, mp_lv_img_get_offset_x, lv_img_get_offset_y);
    
/* Reusing lv_arc_get_angle_start for lv_img_get_angle */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_img_get_angle_obj, 1, mp_lv_arc_get_angle_start, lv_img_get_angle);
    

/*
 * lvgl extension definition for:
 * void lv_img_get_pivot(lv_obj_t *obj, lv_point_t *pivot)
 */
 
STATIC mp_obj_t mp_lv_img_get_pivot(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_point_t *pivot = mp_write_ptr_lv_point_t(mp_args[1]);
    ((void (*)(lv_obj_t *, lv_point_t *))lv_func_ptr)(obj, pivot);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_img_get_pivot_obj, 2, mp_lv_img_get_pivot, lv_img_get_pivot);
    
/* Reusing lv_arc_get_angle_start for lv_img_get_zoom */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_img_get_zoom_obj, 1, mp_lv_arc_get_angle_start, lv_img_get_zoom);
    

/*
 * lvgl extension definition for:
 * bool lv_img_get_antialias(lv_obj_t *obj)
 */
 
STATIC mp_obj_t mp_lv_img_get_antialias(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    bool _res = ((bool (*)(lv_obj_t *))lv_func_ptr)(obj);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_img_get_antialias_obj, 1, mp_lv_img_get_antialias, lv_img_get_antialias);
    

/*
 * lvgl extension definition for:
 * lv_img_size_mode_t lv_img_get_size_mode(lv_obj_t *obj)
 */
 
STATIC mp_obj_t mp_lv_img_get_size_mode(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_img_size_mode_t _res = ((lv_img_size_mode_t (*)(lv_obj_t *))lv_func_ptr)(obj);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_img_get_size_mode_obj, 1, mp_lv_img_get_size_mode, lv_img_get_size_mode);
    

/*
 * lvgl img object definitions
 */
    

STATIC const mp_rom_map_elem_t img_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_buf_alloc), MP_ROM_PTR(&mp_lv_img_buf_alloc_obj) },
    { MP_ROM_QSTR(MP_QSTR_buf_get_px_color), MP_ROM_PTR(&mp_lv_img_buf_get_px_color_obj) },
    { MP_ROM_QSTR(MP_QSTR_buf_get_px_alpha), MP_ROM_PTR(&mp_lv_img_buf_get_px_alpha_obj) },
    { MP_ROM_QSTR(MP_QSTR_buf_set_px_color), MP_ROM_PTR(&mp_lv_img_buf_set_px_color_obj) },
    { MP_ROM_QSTR(MP_QSTR_buf_set_px_alpha), MP_ROM_PTR(&mp_lv_img_buf_set_px_alpha_obj) },
    { MP_ROM_QSTR(MP_QSTR_buf_set_palette), MP_ROM_PTR(&mp_lv_img_buf_set_palette_obj) },
    { MP_ROM_QSTR(MP_QSTR_buf_free), MP_ROM_PTR(&mp_lv_img_buf_free_obj) },
    { MP_ROM_QSTR(MP_QSTR_buf_get_img_size), MP_ROM_PTR(&mp_lv_img_buf_get_img_size_obj) },
    { MP_ROM_QSTR(MP_QSTR_decoder_get_info), MP_ROM_PTR(&mp_lv_img_decoder_get_info_obj) },
    { MP_ROM_QSTR(MP_QSTR_decoder_open), MP_ROM_PTR(&mp_lv_img_decoder_open_obj) },
    { MP_ROM_QSTR(MP_QSTR_decoder_read_line), MP_ROM_PTR(&mp_lv_img_decoder_read_line_obj) },
    { MP_ROM_QSTR(MP_QSTR_decoder_close), MP_ROM_PTR(&mp_lv_img_decoder_close_obj) },
    { MP_ROM_QSTR(MP_QSTR_decoder_create), MP_ROM_PTR(&mp_lv_img_decoder_create_obj) },
    { MP_ROM_QSTR(MP_QSTR_decoder_delete), MP_ROM_PTR(&mp_lv_img_decoder_delete_obj) },
    { MP_ROM_QSTR(MP_QSTR_decoder_set_info_cb), MP_ROM_PTR(&mp_lv_img_decoder_set_info_cb_obj) },
    { MP_ROM_QSTR(MP_QSTR_decoder_set_open_cb), MP_ROM_PTR(&mp_lv_img_decoder_set_open_cb_obj) },
    { MP_ROM_QSTR(MP_QSTR_decoder_set_read_line_cb), MP_ROM_PTR(&mp_lv_img_decoder_set_read_line_cb_obj) },
    { MP_ROM_QSTR(MP_QSTR_decoder_set_close_cb), MP_ROM_PTR(&mp_lv_img_decoder_set_close_cb_obj) },
    { MP_ROM_QSTR(MP_QSTR_decoder_built_in_info), MP_ROM_PTR(&mp_lv_img_decoder_built_in_info_obj) },
    { MP_ROM_QSTR(MP_QSTR_decoder_built_in_open), MP_ROM_PTR(&mp_lv_img_decoder_built_in_open_obj) },
    { MP_ROM_QSTR(MP_QSTR_decoder_built_in_read_line), MP_ROM_PTR(&mp_lv_img_decoder_built_in_read_line_obj) },
    { MP_ROM_QSTR(MP_QSTR_decoder_built_in_close), MP_ROM_PTR(&mp_lv_img_decoder_built_in_close_obj) },
    { MP_ROM_QSTR(MP_QSTR_cache_set_size), MP_ROM_PTR(&mp_lv_img_cache_set_size_obj) },
    { MP_ROM_QSTR(MP_QSTR_cache_invalidate_src), MP_ROM_PTR(&mp_lv_img_cache_invalidate_src_obj) },
    { MP_ROM_QSTR(MP_QSTR_src_get_type), MP_ROM_PTR(&mp_lv_img_src_get_type_obj) },
    { MP_ROM_QSTR(MP_QSTR_cf_get_px_size), MP_ROM_PTR(&mp_lv_img_cf_get_px_size_obj) },
    { MP_ROM_QSTR(MP_QSTR_cf_is_chroma_keyed), MP_ROM_PTR(&mp_lv_img_cf_is_chroma_keyed_obj) },
    { MP_ROM_QSTR(MP_QSTR_cf_has_alpha), MP_ROM_PTR(&mp_lv_img_cf_has_alpha_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_src), MP_ROM_PTR(&mp_lv_img_set_src_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_offset_x), MP_ROM_PTR(&mp_lv_img_set_offset_x_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_offset_y), MP_ROM_PTR(&mp_lv_img_set_offset_y_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_angle), MP_ROM_PTR(&mp_lv_img_set_angle_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_pivot), MP_ROM_PTR(&mp_lv_img_set_pivot_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_zoom), MP_ROM_PTR(&mp_lv_img_set_zoom_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_antialias), MP_ROM_PTR(&mp_lv_img_set_antialias_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_size_mode), MP_ROM_PTR(&mp_lv_img_set_size_mode_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_src), MP_ROM_PTR(&mp_lv_img_get_src_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_offset_x), MP_ROM_PTR(&mp_lv_img_get_offset_x_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_offset_y), MP_ROM_PTR(&mp_lv_img_get_offset_y_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_angle), MP_ROM_PTR(&mp_lv_img_get_angle_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_pivot), MP_ROM_PTR(&mp_lv_img_get_pivot_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_zoom), MP_ROM_PTR(&mp_lv_img_get_zoom_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_antialias), MP_ROM_PTR(&mp_lv_img_get_antialias_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_size_mode), MP_ROM_PTR(&mp_lv_img_get_size_mode_obj) },
    { MP_ROM_QSTR(MP_QSTR_CF), MP_ROM_PTR(&mp_LV_IMG_CF_type) },
    { MP_ROM_QSTR(MP_QSTR_SRC), MP_ROM_PTR(&mp_LV_IMG_SRC_type) },
    { MP_ROM_QSTR(MP_QSTR_SIZE_MODE), MP_ROM_PTR(&mp_LV_IMG_SIZE_MODE_type) }
};

STATIC MP_DEFINE_CONST_DICT(img_locals_dict, img_locals_dict_table);

STATIC void img_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl img");
}


STATIC mp_obj_t img_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&lv_img_create, type, n_args, n_kw, args);           
}


STATIC const mp_obj_type_t mp_img_type = {
    { &mp_type_type },
    .name = MP_QSTR_img,
    .print = img_print,
    .make_new = img_make_new,
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&img_locals_dict,
    .buffer_p = { .get_buffer = mp_lv_obj_get_buffer },
    .parent = &mp_obj_type,
};
    

/*
 * lvgl extension definition for:
 * void lv_label_set_text(lv_obj_t *obj, const char *text)
 */
 
STATIC mp_obj_t mp_lv_label_set_text(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    const char *text = (char*)convert_from_str(mp_args[1]);
    ((void (*)(lv_obj_t *, const char *))lv_func_ptr)(obj, text);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_label_set_text_obj, 2, mp_lv_label_set_text, lv_label_set_text);
    

/*
 * Function NOT generated:
 * Cannot convert ellipsis param
 * void lv_label_set_text_fmt(lv_obj_t *obj, const char *fmt, ...)
 */
    
/* Reusing lv_label_set_text for lv_label_set_text_static */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_label_set_text_static_obj, 2, mp_lv_label_set_text, lv_label_set_text_static);
    

/*
 * lvgl extension definition for:
 * void lv_label_set_long_mode(lv_obj_t *obj, lv_label_long_mode_t long_mode)
 */
 
STATIC mp_obj_t mp_lv_label_set_long_mode(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_label_long_mode_t long_mode = (uint8_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_obj_t *, lv_label_long_mode_t))lv_func_ptr)(obj, long_mode);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_label_set_long_mode_obj, 2, mp_lv_label_set_long_mode, lv_label_set_long_mode);
    
/* Reusing lv_obj_set_page_glue for lv_label_set_recolor */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_label_set_recolor_obj, 2, mp_lv_obj_set_page_glue, lv_label_set_recolor);
    

/*
 * lvgl extension definition for:
 * void lv_label_set_text_sel_start(lv_obj_t *obj, uint32_t index)
 */
 
STATIC mp_obj_t mp_lv_label_set_text_sel_start(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint32_t index = (uint32_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_obj_t *, uint32_t))lv_func_ptr)(obj, index);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_label_set_text_sel_start_obj, 2, mp_lv_label_set_text_sel_start, lv_label_set_text_sel_start);
    
/* Reusing lv_label_set_text_sel_start for lv_label_set_text_sel_end */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_label_set_text_sel_end_obj, 2, mp_lv_label_set_text_sel_start, lv_label_set_text_sel_end);
    

/*
 * lvgl extension definition for:
 * char *lv_label_get_text(const lv_obj_t *obj)
 */
 
STATIC mp_obj_t mp_lv_label_get_text(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = mp_to_lv(mp_args[0]);
    char * _res = ((char *(*)(const lv_obj_t *))lv_func_ptr)(obj);
    return convert_to_str((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_label_get_text_obj, 1, mp_lv_label_get_text, lv_label_get_text);
    

/*
 * lvgl extension definition for:
 * lv_label_long_mode_t lv_label_get_long_mode(const lv_obj_t *obj)
 */
 
STATIC mp_obj_t mp_lv_label_get_long_mode(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_label_long_mode_t _res = ((lv_label_long_mode_t (*)(const lv_obj_t *))lv_func_ptr)(obj);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_label_get_long_mode_obj, 1, mp_lv_label_get_long_mode, lv_label_get_long_mode);
    
/* Reusing lv_obj_is_valid for lv_label_get_recolor */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_label_get_recolor_obj, 1, mp_lv_obj_is_valid, lv_label_get_recolor);
    

/*
 * lvgl extension definition for:
 * void lv_label_get_letter_pos(const lv_obj_t *obj, uint32_t char_id, lv_point_t *pos)
 */
 
STATIC mp_obj_t mp_lv_label_get_letter_pos(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint32_t char_id = (uint32_t)mp_obj_get_int(mp_args[1]);
    lv_point_t *pos = mp_write_ptr_lv_point_t(mp_args[2]);
    ((void (*)(const lv_obj_t *, uint32_t, lv_point_t *))lv_func_ptr)(obj, char_id, pos);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_label_get_letter_pos_obj, 3, mp_lv_label_get_letter_pos, lv_label_get_letter_pos);
    

/*
 * lvgl extension definition for:
 * uint32_t lv_label_get_letter_on(const lv_obj_t *obj, lv_point_t *pos_in)
 */
 
STATIC mp_obj_t mp_lv_label_get_letter_on(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_point_t *pos_in = mp_write_ptr_lv_point_t(mp_args[1]);
    uint32_t _res = ((uint32_t (*)(const lv_obj_t *, lv_point_t *))lv_func_ptr)(obj, pos_in);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_label_get_letter_on_obj, 2, mp_lv_label_get_letter_on, lv_label_get_letter_on);
    

/*
 * lvgl extension definition for:
 * bool lv_label_is_char_under_pos(const lv_obj_t *obj, lv_point_t *pos)
 */
 
STATIC mp_obj_t mp_lv_label_is_char_under_pos(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_point_t *pos = mp_write_ptr_lv_point_t(mp_args[1]);
    bool _res = ((bool (*)(const lv_obj_t *, lv_point_t *))lv_func_ptr)(obj, pos);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_label_is_char_under_pos_obj, 2, mp_lv_label_is_char_under_pos, lv_label_is_char_under_pos);
    

/*
 * lvgl extension definition for:
 * uint32_t lv_label_get_text_selection_start(const lv_obj_t *obj)
 */
 
STATIC mp_obj_t mp_lv_label_get_text_selection_start(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint32_t _res = ((uint32_t (*)(const lv_obj_t *))lv_func_ptr)(obj);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_label_get_text_selection_start_obj, 1, mp_lv_label_get_text_selection_start, lv_label_get_text_selection_start);
    
/* Reusing lv_label_get_text_selection_start for lv_label_get_text_selection_end */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_label_get_text_selection_end_obj, 1, mp_lv_label_get_text_selection_start, lv_label_get_text_selection_end);
    

/*
 * lvgl extension definition for:
 * void lv_label_ins_text(lv_obj_t *obj, uint32_t pos, const char *txt)
 */
 
STATIC mp_obj_t mp_lv_label_ins_text(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint32_t pos = (uint32_t)mp_obj_get_int(mp_args[1]);
    const char *txt = (char*)convert_from_str(mp_args[2]);
    ((void (*)(lv_obj_t *, uint32_t, const char *))lv_func_ptr)(obj, pos, txt);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_label_ins_text_obj, 3, mp_lv_label_ins_text, lv_label_ins_text);
    

/*
 * lvgl extension definition for:
 * void lv_label_cut_text(lv_obj_t *obj, uint32_t pos, uint32_t cnt)
 */
 
STATIC mp_obj_t mp_lv_label_cut_text(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint32_t pos = (uint32_t)mp_obj_get_int(mp_args[1]);
    uint32_t cnt = (uint32_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_obj_t *, uint32_t, uint32_t))lv_func_ptr)(obj, pos, cnt);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_label_cut_text_obj, 3, mp_lv_label_cut_text, lv_label_cut_text);
    

/*
 * lvgl label object definitions
 */
    

STATIC const mp_rom_map_elem_t label_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_set_text), MP_ROM_PTR(&mp_lv_label_set_text_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_text_static), MP_ROM_PTR(&mp_lv_label_set_text_static_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_long_mode), MP_ROM_PTR(&mp_lv_label_set_long_mode_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_recolor), MP_ROM_PTR(&mp_lv_label_set_recolor_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_text_sel_start), MP_ROM_PTR(&mp_lv_label_set_text_sel_start_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_text_sel_end), MP_ROM_PTR(&mp_lv_label_set_text_sel_end_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_text), MP_ROM_PTR(&mp_lv_label_get_text_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_long_mode), MP_ROM_PTR(&mp_lv_label_get_long_mode_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_recolor), MP_ROM_PTR(&mp_lv_label_get_recolor_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_letter_pos), MP_ROM_PTR(&mp_lv_label_get_letter_pos_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_letter_on), MP_ROM_PTR(&mp_lv_label_get_letter_on_obj) },
    { MP_ROM_QSTR(MP_QSTR_is_char_under_pos), MP_ROM_PTR(&mp_lv_label_is_char_under_pos_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_text_selection_start), MP_ROM_PTR(&mp_lv_label_get_text_selection_start_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_text_selection_end), MP_ROM_PTR(&mp_lv_label_get_text_selection_end_obj) },
    { MP_ROM_QSTR(MP_QSTR_ins_text), MP_ROM_PTR(&mp_lv_label_ins_text_obj) },
    { MP_ROM_QSTR(MP_QSTR_cut_text), MP_ROM_PTR(&mp_lv_label_cut_text_obj) },
    { MP_ROM_QSTR(MP_QSTR_LONG), MP_ROM_PTR(&mp_LV_LABEL_LONG_type) }
};

STATIC MP_DEFINE_CONST_DICT(label_locals_dict, label_locals_dict_table);

STATIC void label_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl label");
}


STATIC mp_obj_t label_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&lv_label_create, type, n_args, n_kw, args);           
}


STATIC const mp_obj_type_t mp_label_type = {
    { &mp_type_type },
    .name = MP_QSTR_label,
    .print = label_print,
    .make_new = label_make_new,
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&label_locals_dict,
    .buffer_p = { .get_buffer = mp_lv_obj_get_buffer },
    .parent = &mp_obj_type,
};
    

/*
 * Array convertors for lv_point_t []
 */

STATIC const lv_point_t *mp_arr_to_lv_point_t_____(mp_obj_t mp_arr)
{
    mp_obj_t mp_len = mp_obj_len_maybe(mp_arr);
    if (mp_len == MP_OBJ_NULL) return mp_to_ptr(mp_arr);
    mp_int_t len = mp_obj_get_int(mp_len);
    
    lv_point_t *lv_arr = (lv_point_t*)m_malloc(len * sizeof(lv_point_t));
    mp_obj_t iter = mp_getiter(mp_arr, NULL);
    mp_obj_t item;
    size_t i = 0;
    while ((item = mp_iternext(iter)) != MP_OBJ_STOP_ITERATION) {
        lv_arr[i++] = mp_write_lv_point_t(item);
    }
    return (const lv_point_t *)lv_arr;
}
    
STATIC mp_obj_t mp_arr_from_lv_point_t_____(const lv_point_t *arr)
{
    mp_obj_t obj_arr[1];
    for (size_t i=0; i<1; i++){
        obj_arr[i] = mp_read_lv_point_t(arr[i]);
    }
    return mp_obj_new_list(1, obj_arr); // TODO: return custom iterable object!
}
    

/*
 * lvgl extension definition for:
 * void lv_line_set_points(lv_obj_t *obj, const lv_point_t points[], uint16_t point_num)
 */
 
STATIC mp_obj_t mp_lv_line_set_points(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    const lv_point_t *points = mp_arr_to_lv_point_t_____(mp_args[1]);
    uint16_t point_num = (uint16_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_obj_t *, const lv_point_t [], uint16_t))lv_func_ptr)(obj, points, point_num);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_line_set_points_obj, 3, mp_lv_line_set_points, lv_line_set_points);
    
/* Reusing lv_obj_set_page_glue for lv_line_set_y_invert */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_line_set_y_invert_obj, 2, mp_lv_obj_set_page_glue, lv_line_set_y_invert);
    
/* Reusing lv_obj_is_valid for lv_line_get_y_invert */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_line_get_y_invert_obj, 1, mp_lv_obj_is_valid, lv_line_get_y_invert);
    

/*
 * lvgl line object definitions
 */
    

STATIC const mp_rom_map_elem_t line_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_set_points), MP_ROM_PTR(&mp_lv_line_set_points_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_y_invert), MP_ROM_PTR(&mp_lv_line_set_y_invert_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_y_invert), MP_ROM_PTR(&mp_lv_line_get_y_invert_obj) }
};

STATIC MP_DEFINE_CONST_DICT(line_locals_dict, line_locals_dict_table);

STATIC void line_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl line");
}


STATIC mp_obj_t line_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&lv_line_create, type, n_args, n_kw, args);           
}


STATIC const mp_obj_type_t mp_line_type = {
    { &mp_type_type },
    .name = MP_QSTR_line,
    .print = line_print,
    .make_new = line_make_new,
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&line_locals_dict,
    .buffer_p = { .get_buffer = mp_lv_obj_get_buffer },
    .parent = &mp_obj_type,
};
    

/*
 * lvgl extension definition for:
 * void lv_table_set_cell_value(lv_obj_t *obj, uint16_t row, uint16_t col, const char *txt)
 */
 
STATIC mp_obj_t mp_lv_table_set_cell_value(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint16_t row = (uint16_t)mp_obj_get_int(mp_args[1]);
    uint16_t col = (uint16_t)mp_obj_get_int(mp_args[2]);
    const char *txt = (char*)convert_from_str(mp_args[3]);
    ((void (*)(lv_obj_t *, uint16_t, uint16_t, const char *))lv_func_ptr)(obj, row, col, txt);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_table_set_cell_value_obj, 4, mp_lv_table_set_cell_value, lv_table_set_cell_value);
    

/*
 * Function NOT generated:
 * Cannot convert ellipsis param
 * void lv_table_set_cell_value_fmt(lv_obj_t *obj, uint16_t row, uint16_t col, const char *fmt, ...)
 */
    
/* Reusing lv_arc_set_start_angle for lv_table_set_row_cnt */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_table_set_row_cnt_obj, 2, mp_lv_arc_set_start_angle, lv_table_set_row_cnt);
    
/* Reusing lv_arc_set_start_angle for lv_table_set_col_cnt */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_table_set_col_cnt_obj, 2, mp_lv_arc_set_start_angle, lv_table_set_col_cnt);
    

/*
 * lvgl extension definition for:
 * void lv_table_set_col_width(lv_obj_t *obj, uint16_t col_id, lv_coord_t w)
 */
 
STATIC mp_obj_t mp_lv_table_set_col_width(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint16_t col_id = (uint16_t)mp_obj_get_int(mp_args[1]);
    lv_coord_t w = (int16_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_obj_t *, uint16_t, lv_coord_t))lv_func_ptr)(obj, col_id, w);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_table_set_col_width_obj, 3, mp_lv_table_set_col_width, lv_table_set_col_width);
    

/*
 * lvgl extension definition for:
 * void lv_table_add_cell_ctrl(lv_obj_t *obj, uint16_t row, uint16_t col, lv_table_cell_ctrl_t ctrl)
 */
 
STATIC mp_obj_t mp_lv_table_add_cell_ctrl(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint16_t row = (uint16_t)mp_obj_get_int(mp_args[1]);
    uint16_t col = (uint16_t)mp_obj_get_int(mp_args[2]);
    lv_table_cell_ctrl_t ctrl = (uint8_t)mp_obj_get_int(mp_args[3]);
    ((void (*)(lv_obj_t *, uint16_t, uint16_t, lv_table_cell_ctrl_t))lv_func_ptr)(obj, row, col, ctrl);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_table_add_cell_ctrl_obj, 4, mp_lv_table_add_cell_ctrl, lv_table_add_cell_ctrl);
    
/* Reusing lv_table_add_cell_ctrl for lv_table_clear_cell_ctrl */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_table_clear_cell_ctrl_obj, 4, mp_lv_table_add_cell_ctrl, lv_table_clear_cell_ctrl);
    

/*
 * lvgl extension definition for:
 * const char *lv_table_get_cell_value(lv_obj_t *obj, uint16_t row, uint16_t col)
 */
 
STATIC mp_obj_t mp_lv_table_get_cell_value(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint16_t row = (uint16_t)mp_obj_get_int(mp_args[1]);
    uint16_t col = (uint16_t)mp_obj_get_int(mp_args[2]);
    const char * _res = ((const char *(*)(lv_obj_t *, uint16_t, uint16_t))lv_func_ptr)(obj, row, col);
    return convert_to_str((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_table_get_cell_value_obj, 3, mp_lv_table_get_cell_value, lv_table_get_cell_value);
    
/* Reusing lv_arc_get_angle_start for lv_table_get_row_cnt */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_table_get_row_cnt_obj, 1, mp_lv_arc_get_angle_start, lv_table_get_row_cnt);
    
/* Reusing lv_arc_get_angle_start for lv_table_get_col_cnt */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_table_get_col_cnt_obj, 1, mp_lv_arc_get_angle_start, lv_table_get_col_cnt);
    

/*
 * lvgl extension definition for:
 * lv_coord_t lv_table_get_col_width(lv_obj_t *obj, uint16_t col)
 */
 
STATIC mp_obj_t mp_lv_table_get_col_width(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint16_t col = (uint16_t)mp_obj_get_int(mp_args[1]);
    lv_coord_t _res = ((lv_coord_t (*)(lv_obj_t *, uint16_t))lv_func_ptr)(obj, col);
    return mp_obj_new_int(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_table_get_col_width_obj, 2, mp_lv_table_get_col_width, lv_table_get_col_width);
    

/*
 * lvgl extension definition for:
 * bool lv_table_has_cell_ctrl(lv_obj_t *obj, uint16_t row, uint16_t col, lv_table_cell_ctrl_t ctrl)
 */
 
STATIC mp_obj_t mp_lv_table_has_cell_ctrl(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint16_t row = (uint16_t)mp_obj_get_int(mp_args[1]);
    uint16_t col = (uint16_t)mp_obj_get_int(mp_args[2]);
    lv_table_cell_ctrl_t ctrl = (uint8_t)mp_obj_get_int(mp_args[3]);
    bool _res = ((bool (*)(lv_obj_t *, uint16_t, uint16_t, lv_table_cell_ctrl_t))lv_func_ptr)(obj, row, col, ctrl);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_table_has_cell_ctrl_obj, 4, mp_lv_table_has_cell_ctrl, lv_table_has_cell_ctrl);
    

/*
 * lvgl extension definition for:
 * void lv_table_get_selected_cell(lv_obj_t *obj, uint16_t *row, uint16_t *col)
 */
 
STATIC mp_obj_t mp_lv_table_get_selected_cell(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint16_t *row = mp_to_ptr(mp_args[1]);
    uint16_t *col = mp_to_ptr(mp_args[2]);
    ((void (*)(lv_obj_t *, uint16_t *, uint16_t *))lv_func_ptr)(obj, row, col);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_table_get_selected_cell_obj, 3, mp_lv_table_get_selected_cell, lv_table_get_selected_cell);
    

/*
 * lvgl table object definitions
 */
    

STATIC const mp_rom_map_elem_t table_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_set_cell_value), MP_ROM_PTR(&mp_lv_table_set_cell_value_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_row_cnt), MP_ROM_PTR(&mp_lv_table_set_row_cnt_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_col_cnt), MP_ROM_PTR(&mp_lv_table_set_col_cnt_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_col_width), MP_ROM_PTR(&mp_lv_table_set_col_width_obj) },
    { MP_ROM_QSTR(MP_QSTR_add_cell_ctrl), MP_ROM_PTR(&mp_lv_table_add_cell_ctrl_obj) },
    { MP_ROM_QSTR(MP_QSTR_clear_cell_ctrl), MP_ROM_PTR(&mp_lv_table_clear_cell_ctrl_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_cell_value), MP_ROM_PTR(&mp_lv_table_get_cell_value_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_row_cnt), MP_ROM_PTR(&mp_lv_table_get_row_cnt_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_col_cnt), MP_ROM_PTR(&mp_lv_table_get_col_cnt_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_col_width), MP_ROM_PTR(&mp_lv_table_get_col_width_obj) },
    { MP_ROM_QSTR(MP_QSTR_has_cell_ctrl), MP_ROM_PTR(&mp_lv_table_has_cell_ctrl_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_selected_cell), MP_ROM_PTR(&mp_lv_table_get_selected_cell_obj) },
    { MP_ROM_QSTR(MP_QSTR_CELL_CTRL), MP_ROM_PTR(&mp_LV_TABLE_CELL_CTRL_type) },
    { MP_ROM_QSTR(MP_QSTR_DRAW_PART), MP_ROM_PTR(&mp_LV_TABLE_DRAW_PART_type) }
};

STATIC MP_DEFINE_CONST_DICT(table_locals_dict, table_locals_dict_table);

STATIC void table_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl table");
}


STATIC mp_obj_t table_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&lv_table_create, type, n_args, n_kw, args);           
}


STATIC const mp_obj_type_t mp_table_type = {
    { &mp_type_type },
    .name = MP_QSTR_table,
    .print = table_print,
    .make_new = table_make_new,
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&table_locals_dict,
    .buffer_p = { .get_buffer = mp_lv_obj_get_buffer },
    .parent = &mp_obj_type,
};
    
/* Reusing lv_label_set_text for lv_checkbox_set_text */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_checkbox_set_text_obj, 2, mp_lv_label_set_text, lv_checkbox_set_text);
    
/* Reusing lv_label_set_text for lv_checkbox_set_text_static */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_checkbox_set_text_static_obj, 2, mp_lv_label_set_text, lv_checkbox_set_text_static);
    

/*
 * lvgl extension definition for:
 * const char *lv_checkbox_get_text(const lv_obj_t *obj)
 */
 
STATIC mp_obj_t mp_lv_checkbox_get_text(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = mp_to_lv(mp_args[0]);
    const char * _res = ((const char *(*)(const lv_obj_t *))lv_func_ptr)(obj);
    return convert_to_str((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_checkbox_get_text_obj, 1, mp_lv_checkbox_get_text, lv_checkbox_get_text);
    

/*
 * lvgl checkbox object definitions
 */
    

STATIC const mp_rom_map_elem_t checkbox_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_set_text), MP_ROM_PTR(&mp_lv_checkbox_set_text_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_text_static), MP_ROM_PTR(&mp_lv_checkbox_set_text_static_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_text), MP_ROM_PTR(&mp_lv_checkbox_get_text_obj) },
    { MP_ROM_QSTR(MP_QSTR_DRAW_PART), MP_ROM_PTR(&mp_LV_CHECKBOX_DRAW_PART_type) }
};

STATIC MP_DEFINE_CONST_DICT(checkbox_locals_dict, checkbox_locals_dict_table);

STATIC void checkbox_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl checkbox");
}


STATIC mp_obj_t checkbox_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&lv_checkbox_create, type, n_args, n_kw, args);           
}


STATIC const mp_obj_type_t mp_checkbox_type = {
    { &mp_type_type },
    .name = MP_QSTR_checkbox,
    .print = checkbox_print,
    .make_new = checkbox_make_new,
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&checkbox_locals_dict,
    .buffer_p = { .get_buffer = mp_lv_obj_get_buffer },
    .parent = &mp_obj_type,
};
    

/*
 * lvgl extension definition for:
 * void lv_bar_set_value(lv_obj_t *obj, int32_t value, lv_anim_enable_t anim)
 */
 
STATIC mp_obj_t mp_lv_bar_set_value(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    int32_t value = (int32_t)mp_obj_get_int(mp_args[1]);
    lv_anim_enable_t anim = (int)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_obj_t *, int32_t, lv_anim_enable_t))lv_func_ptr)(obj, value, anim);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_bar_set_value_obj, 3, mp_lv_bar_set_value, lv_bar_set_value);
    
/* Reusing lv_bar_set_value for lv_bar_set_start_value */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_bar_set_start_value_obj, 3, mp_lv_bar_set_value, lv_bar_set_start_value);
    

/*
 * lvgl extension definition for:
 * void lv_bar_set_range(lv_obj_t *obj, int32_t min, int32_t max)
 */
 
STATIC mp_obj_t mp_lv_bar_set_range(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    int32_t min = (int32_t)mp_obj_get_int(mp_args[1]);
    int32_t max = (int32_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_obj_t *, int32_t, int32_t))lv_func_ptr)(obj, min, max);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_bar_set_range_obj, 3, mp_lv_bar_set_range, lv_bar_set_range);
    

/*
 * lvgl extension definition for:
 * void lv_bar_set_mode(lv_obj_t *obj, lv_bar_mode_t mode)
 */
 
STATIC mp_obj_t mp_lv_bar_set_mode(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_bar_mode_t mode = (uint8_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_obj_t *, lv_bar_mode_t))lv_func_ptr)(obj, mode);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_bar_set_mode_obj, 2, mp_lv_bar_set_mode, lv_bar_set_mode);
    

/*
 * lvgl extension definition for:
 * int32_t lv_bar_get_value(const lv_obj_t *obj)
 */
 
STATIC mp_obj_t mp_lv_bar_get_value(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = mp_to_lv(mp_args[0]);
    int32_t _res = ((int32_t (*)(const lv_obj_t *))lv_func_ptr)(obj);
    return mp_obj_new_int(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_bar_get_value_obj, 1, mp_lv_bar_get_value, lv_bar_get_value);
    
/* Reusing lv_bar_get_value for lv_bar_get_start_value */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_bar_get_start_value_obj, 1, mp_lv_bar_get_value, lv_bar_get_start_value);
    
/* Reusing lv_bar_get_value for lv_bar_get_min_value */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_bar_get_min_value_obj, 1, mp_lv_bar_get_value, lv_bar_get_min_value);
    
/* Reusing lv_bar_get_value for lv_bar_get_max_value */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_bar_get_max_value_obj, 1, mp_lv_bar_get_value, lv_bar_get_max_value);
    

/*
 * lvgl extension definition for:
 * lv_bar_mode_t lv_bar_get_mode(lv_obj_t *obj)
 */
 
STATIC mp_obj_t mp_lv_bar_get_mode(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_bar_mode_t _res = ((lv_bar_mode_t (*)(lv_obj_t *))lv_func_ptr)(obj);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_bar_get_mode_obj, 1, mp_lv_bar_get_mode, lv_bar_get_mode);
    

/*
 * lvgl bar object definitions
 */
    

STATIC const mp_rom_map_elem_t bar_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_set_value), MP_ROM_PTR(&mp_lv_bar_set_value_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_start_value), MP_ROM_PTR(&mp_lv_bar_set_start_value_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_range), MP_ROM_PTR(&mp_lv_bar_set_range_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_mode), MP_ROM_PTR(&mp_lv_bar_set_mode_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_value), MP_ROM_PTR(&mp_lv_bar_get_value_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_start_value), MP_ROM_PTR(&mp_lv_bar_get_start_value_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_min_value), MP_ROM_PTR(&mp_lv_bar_get_min_value_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_max_value), MP_ROM_PTR(&mp_lv_bar_get_max_value_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_mode), MP_ROM_PTR(&mp_lv_bar_get_mode_obj) },
    { MP_ROM_QSTR(MP_QSTR_MODE), MP_ROM_PTR(&mp_LV_BAR_MODE_type) },
    { MP_ROM_QSTR(MP_QSTR_DRAW_PART), MP_ROM_PTR(&mp_LV_BAR_DRAW_PART_type) }
};

STATIC MP_DEFINE_CONST_DICT(bar_locals_dict, bar_locals_dict_table);

STATIC void bar_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl bar");
}


STATIC mp_obj_t bar_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&lv_bar_create, type, n_args, n_kw, args);           
}


STATIC const mp_obj_type_t mp_bar_type = {
    { &mp_type_type },
    .name = MP_QSTR_bar,
    .print = bar_print,
    .make_new = bar_make_new,
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&bar_locals_dict,
    .buffer_p = { .get_buffer = mp_lv_obj_get_buffer },
    .parent = &mp_obj_type,
};
    
/* Reusing lv_bar_set_value for lv_slider_set_value */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_slider_set_value_obj, 3, mp_lv_bar_set_value, lv_slider_set_value);
    
/* Reusing lv_bar_set_value for lv_slider_set_left_value */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_slider_set_left_value_obj, 3, mp_lv_bar_set_value, lv_slider_set_left_value);
    
/* Reusing lv_bar_set_range for lv_slider_set_range */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_slider_set_range_obj, 3, mp_lv_bar_set_range, lv_slider_set_range);
    

/*
 * lvgl extension definition for:
 * inline static void lv_slider_set_mode(lv_obj_t *obj, lv_slider_mode_t mode)
 */
 
STATIC mp_obj_t mp_lv_slider_set_mode(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_slider_mode_t mode = (uint8_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_obj_t *, lv_slider_mode_t))lv_func_ptr)(obj, mode);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_slider_set_mode_obj, 2, mp_lv_slider_set_mode, lv_slider_set_mode);
    
/* Reusing lv_bar_get_value for lv_slider_get_value */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_slider_get_value_obj, 1, mp_lv_bar_get_value, lv_slider_get_value);
    
/* Reusing lv_bar_get_value for lv_slider_get_left_value */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_slider_get_left_value_obj, 1, mp_lv_bar_get_value, lv_slider_get_left_value);
    
/* Reusing lv_bar_get_value for lv_slider_get_min_value */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_slider_get_min_value_obj, 1, mp_lv_bar_get_value, lv_slider_get_min_value);
    
/* Reusing lv_bar_get_value for lv_slider_get_max_value */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_slider_get_max_value_obj, 1, mp_lv_bar_get_value, lv_slider_get_max_value);
    

/*
 * lvgl extension definition for:
 * inline static lv_slider_mode_t lv_slider_get_mode(lv_obj_t *slider)
 */
 
STATIC mp_obj_t mp_lv_slider_get_mode(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *slider = mp_to_lv(mp_args[0]);
    lv_slider_mode_t _res = ((lv_slider_mode_t (*)(lv_obj_t *))lv_func_ptr)(slider);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_slider_get_mode_obj, 1, mp_lv_slider_get_mode, lv_slider_get_mode);
    
/* Reusing lv_obj_is_valid for lv_slider_is_dragged */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_slider_is_dragged_obj, 1, mp_lv_obj_is_valid, lv_slider_is_dragged);
    

/*
 * lvgl slider object definitions
 */
    

STATIC const mp_rom_map_elem_t slider_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_set_value), MP_ROM_PTR(&mp_lv_slider_set_value_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_left_value), MP_ROM_PTR(&mp_lv_slider_set_left_value_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_range), MP_ROM_PTR(&mp_lv_slider_set_range_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_mode), MP_ROM_PTR(&mp_lv_slider_set_mode_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_value), MP_ROM_PTR(&mp_lv_slider_get_value_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_left_value), MP_ROM_PTR(&mp_lv_slider_get_left_value_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_min_value), MP_ROM_PTR(&mp_lv_slider_get_min_value_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_max_value), MP_ROM_PTR(&mp_lv_slider_get_max_value_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_mode), MP_ROM_PTR(&mp_lv_slider_get_mode_obj) },
    { MP_ROM_QSTR(MP_QSTR_is_dragged), MP_ROM_PTR(&mp_lv_slider_is_dragged_obj) },
    { MP_ROM_QSTR(MP_QSTR_MODE), MP_ROM_PTR(&mp_LV_SLIDER_MODE_type) },
    { MP_ROM_QSTR(MP_QSTR_DRAW_PART), MP_ROM_PTR(&mp_LV_SLIDER_DRAW_PART_type) }
};

STATIC MP_DEFINE_CONST_DICT(slider_locals_dict, slider_locals_dict_table);

STATIC void slider_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl slider");
}


STATIC mp_obj_t slider_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&lv_slider_create, type, n_args, n_kw, args);           
}


STATIC const mp_obj_type_t mp_slider_type = {
    { &mp_type_type },
    .name = MP_QSTR_slider,
    .print = slider_print,
    .make_new = slider_make_new,
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&slider_locals_dict,
    .buffer_p = { .get_buffer = mp_lv_obj_get_buffer },
    .parent = &mp_obj_type,
};
    

/*
 * Array convertors for char *[]
 */

STATIC const char * *mp_arr_to_char_ptr____(mp_obj_t mp_arr)
{
    mp_obj_t mp_len = mp_obj_len_maybe(mp_arr);
    if (mp_len == MP_OBJ_NULL) return mp_to_ptr(mp_arr);
    mp_int_t len = mp_obj_get_int(mp_len);
    
    char * *lv_arr = (char **)m_malloc(len * sizeof(char *));
    mp_obj_t iter = mp_getiter(mp_arr, NULL);
    mp_obj_t item;
    size_t i = 0;
    while ((item = mp_iternext(iter)) != MP_OBJ_STOP_ITERATION) {
        lv_arr[i++] = (char*)convert_from_str(item);
    }
    return (const char * *)lv_arr;
}
    
STATIC mp_obj_t mp_arr_from_char_ptr____(const char * *arr)
{
    mp_obj_t obj_arr[1];
    for (size_t i=0; i<1; i++){
        obj_arr[i] = convert_to_str(arr[i]);
    }
    return mp_obj_new_list(1, obj_arr); // TODO: return custom iterable object!
}
    

/*
 * lvgl extension definition for:
 * void lv_btnmatrix_set_map(lv_obj_t *obj, const char *map[])
 */
 
STATIC mp_obj_t mp_lv_btnmatrix_set_map(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    const char **map = mp_arr_to_char_ptr____(mp_args[1]);
    ((void (*)(lv_obj_t *, const char *[]))lv_func_ptr)(obj, map);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_btnmatrix_set_map_obj, 2, mp_lv_btnmatrix_set_map, lv_btnmatrix_set_map);
    

/*
 * Array convertors for lv_btnmatrix_ctrl_t []
 */

STATIC const lv_btnmatrix_ctrl_t *mp_arr_to_lv_btnmatrix_ctrl_t_____(mp_obj_t mp_arr)
{
    mp_obj_t mp_len = mp_obj_len_maybe(mp_arr);
    if (mp_len == MP_OBJ_NULL) return mp_to_ptr(mp_arr);
    mp_int_t len = mp_obj_get_int(mp_len);
    
    lv_btnmatrix_ctrl_t *lv_arr = (lv_btnmatrix_ctrl_t*)m_malloc(len * sizeof(lv_btnmatrix_ctrl_t));
    mp_obj_t iter = mp_getiter(mp_arr, NULL);
    mp_obj_t item;
    size_t i = 0;
    while ((item = mp_iternext(iter)) != MP_OBJ_STOP_ITERATION) {
        lv_arr[i++] = (uint16_t)mp_obj_get_int(item);
    }
    return (const lv_btnmatrix_ctrl_t *)lv_arr;
}
    
STATIC mp_obj_t mp_arr_from_lv_btnmatrix_ctrl_t_____(const lv_btnmatrix_ctrl_t *arr)
{
    mp_obj_t obj_arr[1];
    for (size_t i=0; i<1; i++){
        obj_arr[i] = mp_obj_new_int_from_uint(arr[i]);
    }
    return mp_obj_new_list(1, obj_arr); // TODO: return custom iterable object!
}
    

/*
 * lvgl extension definition for:
 * void lv_btnmatrix_set_ctrl_map(lv_obj_t *obj, const lv_btnmatrix_ctrl_t ctrl_map[])
 */
 
STATIC mp_obj_t mp_lv_btnmatrix_set_ctrl_map(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    const lv_btnmatrix_ctrl_t *ctrl_map = mp_arr_to_lv_btnmatrix_ctrl_t_____(mp_args[1]);
    ((void (*)(lv_obj_t *, const lv_btnmatrix_ctrl_t []))lv_func_ptr)(obj, ctrl_map);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_btnmatrix_set_ctrl_map_obj, 2, mp_lv_btnmatrix_set_ctrl_map, lv_btnmatrix_set_ctrl_map);
    
/* Reusing lv_arc_set_start_angle for lv_btnmatrix_set_selected_btn */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_btnmatrix_set_selected_btn_obj, 2, mp_lv_arc_set_start_angle, lv_btnmatrix_set_selected_btn);
    

/*
 * lvgl extension definition for:
 * void lv_btnmatrix_set_btn_ctrl(lv_obj_t *obj, uint16_t btn_id, lv_btnmatrix_ctrl_t ctrl)
 */
 
STATIC mp_obj_t mp_lv_btnmatrix_set_btn_ctrl(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint16_t btn_id = (uint16_t)mp_obj_get_int(mp_args[1]);
    lv_btnmatrix_ctrl_t ctrl = (uint16_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_obj_t *, uint16_t, lv_btnmatrix_ctrl_t))lv_func_ptr)(obj, btn_id, ctrl);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_btnmatrix_set_btn_ctrl_obj, 3, mp_lv_btnmatrix_set_btn_ctrl, lv_btnmatrix_set_btn_ctrl);
    
/* Reusing lv_btnmatrix_set_btn_ctrl for lv_btnmatrix_clear_btn_ctrl */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_btnmatrix_clear_btn_ctrl_obj, 3, mp_lv_btnmatrix_set_btn_ctrl, lv_btnmatrix_clear_btn_ctrl);
    

/*
 * lvgl extension definition for:
 * void lv_btnmatrix_set_btn_ctrl_all(lv_obj_t *obj, lv_btnmatrix_ctrl_t ctrl)
 */
 
STATIC mp_obj_t mp_lv_btnmatrix_set_btn_ctrl_all(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_btnmatrix_ctrl_t ctrl = (uint16_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_obj_t *, lv_btnmatrix_ctrl_t))lv_func_ptr)(obj, ctrl);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_btnmatrix_set_btn_ctrl_all_obj, 2, mp_lv_btnmatrix_set_btn_ctrl_all, lv_btnmatrix_set_btn_ctrl_all);
    
/* Reusing lv_btnmatrix_set_btn_ctrl_all for lv_btnmatrix_clear_btn_ctrl_all */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_btnmatrix_clear_btn_ctrl_all_obj, 2, mp_lv_btnmatrix_set_btn_ctrl_all, lv_btnmatrix_clear_btn_ctrl_all);
    

/*
 * lvgl extension definition for:
 * void lv_btnmatrix_set_btn_width(lv_obj_t *obj, uint16_t btn_id, uint8_t width)
 */
 
STATIC mp_obj_t mp_lv_btnmatrix_set_btn_width(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint16_t btn_id = (uint16_t)mp_obj_get_int(mp_args[1]);
    uint8_t width = (uint8_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_obj_t *, uint16_t, uint8_t))lv_func_ptr)(obj, btn_id, width);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_btnmatrix_set_btn_width_obj, 3, mp_lv_btnmatrix_set_btn_width, lv_btnmatrix_set_btn_width);
    
/* Reusing lv_obj_set_page_glue for lv_btnmatrix_set_one_checked */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_btnmatrix_set_one_checked_obj, 2, mp_lv_obj_set_page_glue, lv_btnmatrix_set_one_checked);
    

/*
 * lvgl extension definition for:
 * const char **lv_btnmatrix_get_map(const lv_obj_t *obj)
 */
 
STATIC mp_obj_t mp_lv_btnmatrix_get_map(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = mp_to_lv(mp_args[0]);
    const char ** _res = ((const char **(*)(const lv_obj_t *))lv_func_ptr)(obj);
    return ptr_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_btnmatrix_get_map_obj, 1, mp_lv_btnmatrix_get_map, lv_btnmatrix_get_map);
    

/*
 * lvgl extension definition for:
 * uint16_t lv_btnmatrix_get_selected_btn(const lv_obj_t *obj)
 */
 
STATIC mp_obj_t mp_lv_btnmatrix_get_selected_btn(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint16_t _res = ((uint16_t (*)(const lv_obj_t *))lv_func_ptr)(obj);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_btnmatrix_get_selected_btn_obj, 1, mp_lv_btnmatrix_get_selected_btn, lv_btnmatrix_get_selected_btn);
    

/*
 * lvgl extension definition for:
 * const char *lv_btnmatrix_get_btn_text(const lv_obj_t *obj, uint16_t btn_id)
 */
 
STATIC mp_obj_t mp_lv_btnmatrix_get_btn_text(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint16_t btn_id = (uint16_t)mp_obj_get_int(mp_args[1]);
    const char * _res = ((const char *(*)(const lv_obj_t *, uint16_t))lv_func_ptr)(obj, btn_id);
    return convert_to_str((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_btnmatrix_get_btn_text_obj, 2, mp_lv_btnmatrix_get_btn_text, lv_btnmatrix_get_btn_text);
    

/*
 * lvgl extension definition for:
 * bool lv_btnmatrix_has_btn_ctrl(lv_obj_t *obj, uint16_t btn_id, lv_btnmatrix_ctrl_t ctrl)
 */
 
STATIC mp_obj_t mp_lv_btnmatrix_has_btn_ctrl(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint16_t btn_id = (uint16_t)mp_obj_get_int(mp_args[1]);
    lv_btnmatrix_ctrl_t ctrl = (uint16_t)mp_obj_get_int(mp_args[2]);
    bool _res = ((bool (*)(lv_obj_t *, uint16_t, lv_btnmatrix_ctrl_t))lv_func_ptr)(obj, btn_id, ctrl);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_btnmatrix_has_btn_ctrl_obj, 3, mp_lv_btnmatrix_has_btn_ctrl, lv_btnmatrix_has_btn_ctrl);
    
/* Reusing lv_obj_is_valid for lv_btnmatrix_get_one_checked */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_btnmatrix_get_one_checked_obj, 1, mp_lv_obj_is_valid, lv_btnmatrix_get_one_checked);
    
/* Reusing lv_obj_is_valid for lv_btnmatrix_get_popovers */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_btnmatrix_get_popovers_obj, 1, mp_lv_obj_is_valid, lv_btnmatrix_get_popovers);
    

/*
 * lvgl btnmatrix object definitions
 */
    

STATIC const mp_rom_map_elem_t btnmatrix_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_set_map), MP_ROM_PTR(&mp_lv_btnmatrix_set_map_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_ctrl_map), MP_ROM_PTR(&mp_lv_btnmatrix_set_ctrl_map_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_selected_btn), MP_ROM_PTR(&mp_lv_btnmatrix_set_selected_btn_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_btn_ctrl), MP_ROM_PTR(&mp_lv_btnmatrix_set_btn_ctrl_obj) },
    { MP_ROM_QSTR(MP_QSTR_clear_btn_ctrl), MP_ROM_PTR(&mp_lv_btnmatrix_clear_btn_ctrl_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_btn_ctrl_all), MP_ROM_PTR(&mp_lv_btnmatrix_set_btn_ctrl_all_obj) },
    { MP_ROM_QSTR(MP_QSTR_clear_btn_ctrl_all), MP_ROM_PTR(&mp_lv_btnmatrix_clear_btn_ctrl_all_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_btn_width), MP_ROM_PTR(&mp_lv_btnmatrix_set_btn_width_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_one_checked), MP_ROM_PTR(&mp_lv_btnmatrix_set_one_checked_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_map), MP_ROM_PTR(&mp_lv_btnmatrix_get_map_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_selected_btn), MP_ROM_PTR(&mp_lv_btnmatrix_get_selected_btn_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_btn_text), MP_ROM_PTR(&mp_lv_btnmatrix_get_btn_text_obj) },
    { MP_ROM_QSTR(MP_QSTR_has_btn_ctrl), MP_ROM_PTR(&mp_lv_btnmatrix_has_btn_ctrl_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_one_checked), MP_ROM_PTR(&mp_lv_btnmatrix_get_one_checked_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_popovers), MP_ROM_PTR(&mp_lv_btnmatrix_get_popovers_obj) },
    { MP_ROM_QSTR(MP_QSTR_CTRL), MP_ROM_PTR(&mp_LV_BTNMATRIX_CTRL_type) },
    { MP_ROM_QSTR(MP_QSTR_DRAW_PART), MP_ROM_PTR(&mp_LV_BTNMATRIX_DRAW_PART_type) }
};

STATIC MP_DEFINE_CONST_DICT(btnmatrix_locals_dict, btnmatrix_locals_dict_table);

STATIC void btnmatrix_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl btnmatrix");
}


STATIC mp_obj_t btnmatrix_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&lv_btnmatrix_create, type, n_args, n_kw, args);           
}


STATIC const mp_obj_type_t mp_btnmatrix_type = {
    { &mp_type_type },
    .name = MP_QSTR_btnmatrix,
    .print = btnmatrix_print,
    .make_new = btnmatrix_make_new,
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&btnmatrix_locals_dict,
    .buffer_p = { .get_buffer = mp_lv_obj_get_buffer },
    .parent = &mp_obj_type,
};
    
/* Reusing lv_label_set_text for lv_dropdown_set_text */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_dropdown_set_text_obj, 2, mp_lv_label_set_text, lv_dropdown_set_text);
    
/* Reusing lv_label_set_text for lv_dropdown_set_options */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_dropdown_set_options_obj, 2, mp_lv_label_set_text, lv_dropdown_set_options);
    
/* Reusing lv_label_set_text for lv_dropdown_set_options_static */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_dropdown_set_options_static_obj, 2, mp_lv_label_set_text, lv_dropdown_set_options_static);
    

/*
 * lvgl extension definition for:
 * void lv_dropdown_add_option(lv_obj_t *obj, const char *option, uint32_t pos)
 */
 
STATIC mp_obj_t mp_lv_dropdown_add_option(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    const char *option = (char*)convert_from_str(mp_args[1]);
    uint32_t pos = (uint32_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_obj_t *, const char *, uint32_t))lv_func_ptr)(obj, option, pos);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_dropdown_add_option_obj, 3, mp_lv_dropdown_add_option, lv_dropdown_add_option);
    
/* Reusing lv_obj_move_foreground for lv_dropdown_clear_options */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_dropdown_clear_options_obj, 1, mp_lv_obj_move_foreground, lv_dropdown_clear_options);
    
/* Reusing lv_arc_set_start_angle for lv_dropdown_set_selected */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_dropdown_set_selected_obj, 2, mp_lv_arc_set_start_angle, lv_dropdown_set_selected);
    

/*
 * lvgl extension definition for:
 * void lv_dropdown_set_dir(lv_obj_t *obj, lv_dir_t dir)
 */
 
STATIC mp_obj_t mp_lv_dropdown_set_dir(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_dir_t dir = (uint8_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_obj_t *, lv_dir_t))lv_func_ptr)(obj, dir);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_dropdown_set_dir_obj, 2, mp_lv_dropdown_set_dir, lv_dropdown_set_dir);
    
/* Reusing lv_img_set_src for lv_dropdown_set_symbol */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_dropdown_set_symbol_obj, 2, mp_lv_img_set_src, lv_dropdown_set_symbol);
    
/* Reusing lv_obj_set_page_glue for lv_dropdown_set_selected_highlight */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_dropdown_set_selected_highlight_obj, 2, mp_lv_obj_set_page_glue, lv_dropdown_set_selected_highlight);
    

/*
 * lvgl extension definition for:
 * lv_obj_t *lv_dropdown_get_list(lv_obj_t *obj)
 */
 
STATIC mp_obj_t mp_lv_dropdown_get_list(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_obj_t * _res = ((lv_obj_t *(*)(lv_obj_t *))lv_func_ptr)(obj);
    return lv_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_dropdown_get_list_obj, 1, mp_lv_dropdown_get_list, lv_dropdown_get_list);
    

/*
 * lvgl extension definition for:
 * const char *lv_dropdown_get_text(lv_obj_t *obj)
 */
 
STATIC mp_obj_t mp_lv_dropdown_get_text(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    const char * _res = ((const char *(*)(lv_obj_t *))lv_func_ptr)(obj);
    return convert_to_str((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_dropdown_get_text_obj, 1, mp_lv_dropdown_get_text, lv_dropdown_get_text);
    
/* Reusing lv_checkbox_get_text for lv_dropdown_get_options */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_dropdown_get_options_obj, 1, mp_lv_checkbox_get_text, lv_dropdown_get_options);
    
/* Reusing lv_btnmatrix_get_selected_btn for lv_dropdown_get_selected */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_dropdown_get_selected_obj, 1, mp_lv_btnmatrix_get_selected_btn, lv_dropdown_get_selected);
    
/* Reusing lv_btnmatrix_get_selected_btn for lv_dropdown_get_option_cnt */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_dropdown_get_option_cnt_obj, 1, mp_lv_btnmatrix_get_selected_btn, lv_dropdown_get_option_cnt);
    

/*
 * lvgl extension definition for:
 * void lv_dropdown_get_selected_str(const lv_obj_t *obj, char *buf, uint32_t buf_size)
 */
 
STATIC mp_obj_t mp_lv_dropdown_get_selected_str(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = mp_to_lv(mp_args[0]);
    char *buf = (char*)convert_from_str(mp_args[1]);
    uint32_t buf_size = (uint32_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(const lv_obj_t *, char *, uint32_t))lv_func_ptr)(obj, buf, buf_size);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_dropdown_get_selected_str_obj, 3, mp_lv_dropdown_get_selected_str, lv_dropdown_get_selected_str);
    

/*
 * lvgl extension definition for:
 * int32_t lv_dropdown_get_option_index(lv_obj_t *obj, const char *option)
 */
 
STATIC mp_obj_t mp_lv_dropdown_get_option_index(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    const char *option = (char*)convert_from_str(mp_args[1]);
    int32_t _res = ((int32_t (*)(lv_obj_t *, const char *))lv_func_ptr)(obj, option);
    return mp_obj_new_int(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_dropdown_get_option_index_obj, 2, mp_lv_dropdown_get_option_index, lv_dropdown_get_option_index);
    
/* Reusing lv_dropdown_get_text for lv_dropdown_get_symbol */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_dropdown_get_symbol_obj, 1, mp_lv_dropdown_get_text, lv_dropdown_get_symbol);
    
/* Reusing lv_img_get_antialias for lv_dropdown_get_selected_highlight */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_dropdown_get_selected_highlight_obj, 1, mp_lv_img_get_antialias, lv_dropdown_get_selected_highlight);
    

/*
 * lvgl extension definition for:
 * lv_dir_t lv_dropdown_get_dir(const lv_obj_t *obj)
 */
 
STATIC mp_obj_t mp_lv_dropdown_get_dir(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_dir_t _res = ((lv_dir_t (*)(const lv_obj_t *))lv_func_ptr)(obj);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_dropdown_get_dir_obj, 1, mp_lv_dropdown_get_dir, lv_dropdown_get_dir);
    
/* Reusing lv_obj_move_foreground for lv_dropdown_open */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_dropdown_open_obj, 1, mp_lv_obj_move_foreground, lv_dropdown_open);
    
/* Reusing lv_obj_move_foreground for lv_dropdown_close */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_dropdown_close_obj, 1, mp_lv_obj_move_foreground, lv_dropdown_close);
    
/* Reusing lv_img_get_antialias for lv_dropdown_is_open */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_dropdown_is_open_obj, 1, mp_lv_img_get_antialias, lv_dropdown_is_open);
    

/*
 * lvgl dropdown object definitions
 */
    

STATIC const mp_rom_map_elem_t dropdown_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_set_text), MP_ROM_PTR(&mp_lv_dropdown_set_text_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_options), MP_ROM_PTR(&mp_lv_dropdown_set_options_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_options_static), MP_ROM_PTR(&mp_lv_dropdown_set_options_static_obj) },
    { MP_ROM_QSTR(MP_QSTR_add_option), MP_ROM_PTR(&mp_lv_dropdown_add_option_obj) },
    { MP_ROM_QSTR(MP_QSTR_clear_options), MP_ROM_PTR(&mp_lv_dropdown_clear_options_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_selected), MP_ROM_PTR(&mp_lv_dropdown_set_selected_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_dir), MP_ROM_PTR(&mp_lv_dropdown_set_dir_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_symbol), MP_ROM_PTR(&mp_lv_dropdown_set_symbol_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_selected_highlight), MP_ROM_PTR(&mp_lv_dropdown_set_selected_highlight_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_list), MP_ROM_PTR(&mp_lv_dropdown_get_list_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_text), MP_ROM_PTR(&mp_lv_dropdown_get_text_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_options), MP_ROM_PTR(&mp_lv_dropdown_get_options_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_selected), MP_ROM_PTR(&mp_lv_dropdown_get_selected_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_option_cnt), MP_ROM_PTR(&mp_lv_dropdown_get_option_cnt_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_selected_str), MP_ROM_PTR(&mp_lv_dropdown_get_selected_str_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_option_index), MP_ROM_PTR(&mp_lv_dropdown_get_option_index_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_symbol), MP_ROM_PTR(&mp_lv_dropdown_get_symbol_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_selected_highlight), MP_ROM_PTR(&mp_lv_dropdown_get_selected_highlight_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_dir), MP_ROM_PTR(&mp_lv_dropdown_get_dir_obj) },
    { MP_ROM_QSTR(MP_QSTR_open), MP_ROM_PTR(&mp_lv_dropdown_open_obj) },
    { MP_ROM_QSTR(MP_QSTR_close), MP_ROM_PTR(&mp_lv_dropdown_close_obj) },
    { MP_ROM_QSTR(MP_QSTR_is_open), MP_ROM_PTR(&mp_lv_dropdown_is_open_obj) }
};

STATIC MP_DEFINE_CONST_DICT(dropdown_locals_dict, dropdown_locals_dict_table);

STATIC void dropdown_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl dropdown");
}


STATIC mp_obj_t dropdown_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&lv_dropdown_create, type, n_args, n_kw, args);           
}


STATIC const mp_obj_type_t mp_dropdown_type = {
    { &mp_type_type },
    .name = MP_QSTR_dropdown,
    .print = dropdown_print,
    .make_new = dropdown_make_new,
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&dropdown_locals_dict,
    .buffer_p = { .get_buffer = mp_lv_obj_get_buffer },
    .parent = &mp_obj_type,
};
    

/*
 * lvgl extension definition for:
 * void lv_roller_set_options(lv_obj_t *obj, const char *options, lv_roller_mode_t mode)
 */
 
STATIC mp_obj_t mp_lv_roller_set_options(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    const char *options = (char*)convert_from_str(mp_args[1]);
    lv_roller_mode_t mode = (uint8_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_obj_t *, const char *, lv_roller_mode_t))lv_func_ptr)(obj, options, mode);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_roller_set_options_obj, 3, mp_lv_roller_set_options, lv_roller_set_options);
    

/*
 * lvgl extension definition for:
 * void lv_roller_set_selected(lv_obj_t *obj, uint16_t sel_opt, lv_anim_enable_t anim)
 */
 
STATIC mp_obj_t mp_lv_roller_set_selected(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint16_t sel_opt = (uint16_t)mp_obj_get_int(mp_args[1]);
    lv_anim_enable_t anim = (int)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_obj_t *, uint16_t, lv_anim_enable_t))lv_func_ptr)(obj, sel_opt, anim);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_roller_set_selected_obj, 3, mp_lv_roller_set_selected, lv_roller_set_selected);
    
/* Reusing lv_obj_set_flex_grow for lv_roller_set_visible_row_count */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_roller_set_visible_row_count_obj, 2, mp_lv_obj_set_flex_grow, lv_roller_set_visible_row_count);
    
/* Reusing lv_btnmatrix_get_selected_btn for lv_roller_get_selected */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_roller_get_selected_obj, 1, mp_lv_btnmatrix_get_selected_btn, lv_roller_get_selected);
    
/* Reusing lv_dropdown_get_selected_str for lv_roller_get_selected_str */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_roller_get_selected_str_obj, 3, mp_lv_dropdown_get_selected_str, lv_roller_get_selected_str);
    
/* Reusing lv_checkbox_get_text for lv_roller_get_options */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_roller_get_options_obj, 1, mp_lv_checkbox_get_text, lv_roller_get_options);
    
/* Reusing lv_btnmatrix_get_selected_btn for lv_roller_get_option_cnt */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_roller_get_option_cnt_obj, 1, mp_lv_btnmatrix_get_selected_btn, lv_roller_get_option_cnt);
    

/*
 * lvgl roller object definitions
 */
    

STATIC const mp_rom_map_elem_t roller_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_set_options), MP_ROM_PTR(&mp_lv_roller_set_options_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_selected), MP_ROM_PTR(&mp_lv_roller_set_selected_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_visible_row_count), MP_ROM_PTR(&mp_lv_roller_set_visible_row_count_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_selected), MP_ROM_PTR(&mp_lv_roller_get_selected_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_selected_str), MP_ROM_PTR(&mp_lv_roller_get_selected_str_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_options), MP_ROM_PTR(&mp_lv_roller_get_options_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_option_cnt), MP_ROM_PTR(&mp_lv_roller_get_option_cnt_obj) },
    { MP_ROM_QSTR(MP_QSTR_MODE), MP_ROM_PTR(&mp_LV_ROLLER_MODE_type) }
};

STATIC MP_DEFINE_CONST_DICT(roller_locals_dict, roller_locals_dict_table);

STATIC void roller_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl roller");
}


STATIC mp_obj_t roller_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&lv_roller_create, type, n_args, n_kw, args);           
}


STATIC const mp_obj_type_t mp_roller_type = {
    { &mp_type_type },
    .name = MP_QSTR_roller,
    .print = roller_print,
    .make_new = roller_make_new,
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&roller_locals_dict,
    .buffer_p = { .get_buffer = mp_lv_obj_get_buffer },
    .parent = &mp_obj_type,
};
    
/* Reusing lv_label_set_text_sel_start for lv_textarea_add_char */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_textarea_add_char_obj, 2, mp_lv_label_set_text_sel_start, lv_textarea_add_char);
    
/* Reusing lv_label_set_text for lv_textarea_add_text */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_textarea_add_text_obj, 2, mp_lv_label_set_text, lv_textarea_add_text);
    
/* Reusing lv_obj_move_foreground for lv_textarea_del_char */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_textarea_del_char_obj, 1, mp_lv_obj_move_foreground, lv_textarea_del_char);
    
/* Reusing lv_obj_move_foreground for lv_textarea_del_char_forward */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_textarea_del_char_forward_obj, 1, mp_lv_obj_move_foreground, lv_textarea_del_char_forward);
    
/* Reusing lv_label_set_text for lv_textarea_set_text */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_textarea_set_text_obj, 2, mp_lv_label_set_text, lv_textarea_set_text);
    
/* Reusing lv_label_set_text for lv_textarea_set_placeholder_text */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_textarea_set_placeholder_text_obj, 2, mp_lv_label_set_text, lv_textarea_set_placeholder_text);
    

/*
 * lvgl extension definition for:
 * void lv_textarea_set_cursor_pos(lv_obj_t *obj, int32_t pos)
 */
 
STATIC mp_obj_t mp_lv_textarea_set_cursor_pos(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    int32_t pos = (int32_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_obj_t *, int32_t))lv_func_ptr)(obj, pos);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_textarea_set_cursor_pos_obj, 2, mp_lv_textarea_set_cursor_pos, lv_textarea_set_cursor_pos);
    
/* Reusing lv_obj_set_page_glue for lv_textarea_set_cursor_click_pos */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_textarea_set_cursor_click_pos_obj, 2, mp_lv_obj_set_page_glue, lv_textarea_set_cursor_click_pos);
    
/* Reusing lv_obj_set_page_glue for lv_textarea_set_password_mode */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_textarea_set_password_mode_obj, 2, mp_lv_obj_set_page_glue, lv_textarea_set_password_mode);
    
/* Reusing lv_label_set_text for lv_textarea_set_password_bullet */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_textarea_set_password_bullet_obj, 2, mp_lv_label_set_text, lv_textarea_set_password_bullet);
    
/* Reusing lv_obj_set_page_glue for lv_textarea_set_one_line */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_textarea_set_one_line_obj, 2, mp_lv_obj_set_page_glue, lv_textarea_set_one_line);
    
/* Reusing lv_label_set_text for lv_textarea_set_accepted_chars */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_textarea_set_accepted_chars_obj, 2, mp_lv_label_set_text, lv_textarea_set_accepted_chars);
    
/* Reusing lv_label_set_text_sel_start for lv_textarea_set_max_length */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_textarea_set_max_length_obj, 2, mp_lv_label_set_text_sel_start, lv_textarea_set_max_length);
    
/* Reusing lv_label_set_text for lv_textarea_set_insert_replace */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_textarea_set_insert_replace_obj, 2, mp_lv_label_set_text, lv_textarea_set_insert_replace);
    
/* Reusing lv_obj_set_page_glue for lv_textarea_set_text_selection */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_textarea_set_text_selection_obj, 2, mp_lv_obj_set_page_glue, lv_textarea_set_text_selection);
    
/* Reusing lv_arc_set_start_angle for lv_textarea_set_password_show_time */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_textarea_set_password_show_time_obj, 2, mp_lv_arc_set_start_angle, lv_textarea_set_password_show_time);
    

/*
 * lvgl extension definition for:
 * void lv_textarea_set_align(lv_obj_t *obj, lv_text_align_t align)
 */
 
STATIC mp_obj_t mp_lv_textarea_set_align(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_text_align_t align = (uint8_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_obj_t *, lv_text_align_t))lv_func_ptr)(obj, align);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_textarea_set_align_obj, 2, mp_lv_textarea_set_align, lv_textarea_set_align);
    
/* Reusing lv_checkbox_get_text for lv_textarea_get_text */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_textarea_get_text_obj, 1, mp_lv_checkbox_get_text, lv_textarea_get_text);
    
/* Reusing lv_dropdown_get_text for lv_textarea_get_placeholder_text */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_textarea_get_placeholder_text_obj, 1, mp_lv_dropdown_get_text, lv_textarea_get_placeholder_text);
    

/*
 * lvgl extension definition for:
 * lv_obj_t *lv_textarea_get_label(const lv_obj_t *obj)
 */
 
STATIC mp_obj_t mp_lv_textarea_get_label(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_obj_t * _res = ((lv_obj_t *(*)(const lv_obj_t *))lv_func_ptr)(obj);
    return lv_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_textarea_get_label_obj, 1, mp_lv_textarea_get_label, lv_textarea_get_label);
    
/* Reusing lv_label_get_text_selection_start for lv_textarea_get_cursor_pos */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_textarea_get_cursor_pos_obj, 1, mp_lv_label_get_text_selection_start, lv_textarea_get_cursor_pos);
    
/* Reusing lv_img_get_antialias for lv_textarea_get_cursor_click_pos */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_textarea_get_cursor_click_pos_obj, 1, mp_lv_img_get_antialias, lv_textarea_get_cursor_click_pos);
    
/* Reusing lv_obj_is_valid for lv_textarea_get_password_mode */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_textarea_get_password_mode_obj, 1, mp_lv_obj_is_valid, lv_textarea_get_password_mode);
    
/* Reusing lv_dropdown_get_text for lv_textarea_get_password_bullet */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_textarea_get_password_bullet_obj, 1, mp_lv_dropdown_get_text, lv_textarea_get_password_bullet);
    
/* Reusing lv_obj_is_valid for lv_textarea_get_one_line */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_textarea_get_one_line_obj, 1, mp_lv_obj_is_valid, lv_textarea_get_one_line);
    
/* Reusing lv_dropdown_get_text for lv_textarea_get_accepted_chars */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_textarea_get_accepted_chars_obj, 1, mp_lv_dropdown_get_text, lv_textarea_get_accepted_chars);
    

/*
 * lvgl extension definition for:
 * uint32_t lv_textarea_get_max_length(lv_obj_t *obj)
 */
 
STATIC mp_obj_t mp_lv_textarea_get_max_length(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint32_t _res = ((uint32_t (*)(lv_obj_t *))lv_func_ptr)(obj);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_textarea_get_max_length_obj, 1, mp_lv_textarea_get_max_length, lv_textarea_get_max_length);
    
/* Reusing lv_obj_is_valid for lv_textarea_text_is_selected */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_textarea_text_is_selected_obj, 1, mp_lv_obj_is_valid, lv_textarea_text_is_selected);
    
/* Reusing lv_img_get_antialias for lv_textarea_get_text_selection */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_textarea_get_text_selection_obj, 1, mp_lv_img_get_antialias, lv_textarea_get_text_selection);
    
/* Reusing lv_arc_get_angle_start for lv_textarea_get_password_show_time */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_textarea_get_password_show_time_obj, 1, mp_lv_arc_get_angle_start, lv_textarea_get_password_show_time);
    
/* Reusing lv_obj_move_foreground for lv_textarea_clear_selection */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_textarea_clear_selection_obj, 1, mp_lv_obj_move_foreground, lv_textarea_clear_selection);
    
/* Reusing lv_obj_move_foreground for lv_textarea_cursor_right */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_textarea_cursor_right_obj, 1, mp_lv_obj_move_foreground, lv_textarea_cursor_right);
    
/* Reusing lv_obj_move_foreground for lv_textarea_cursor_left */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_textarea_cursor_left_obj, 1, mp_lv_obj_move_foreground, lv_textarea_cursor_left);
    
/* Reusing lv_obj_move_foreground for lv_textarea_cursor_down */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_textarea_cursor_down_obj, 1, mp_lv_obj_move_foreground, lv_textarea_cursor_down);
    
/* Reusing lv_obj_move_foreground for lv_textarea_cursor_up */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_textarea_cursor_up_obj, 1, mp_lv_obj_move_foreground, lv_textarea_cursor_up);
    

/*
 * lvgl textarea object definitions
 */
    

STATIC const mp_rom_map_elem_t textarea_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_add_char), MP_ROM_PTR(&mp_lv_textarea_add_char_obj) },
    { MP_ROM_QSTR(MP_QSTR_add_text), MP_ROM_PTR(&mp_lv_textarea_add_text_obj) },
    { MP_ROM_QSTR(MP_QSTR_del_char), MP_ROM_PTR(&mp_lv_textarea_del_char_obj) },
    { MP_ROM_QSTR(MP_QSTR_del_char_forward), MP_ROM_PTR(&mp_lv_textarea_del_char_forward_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_text), MP_ROM_PTR(&mp_lv_textarea_set_text_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_placeholder_text), MP_ROM_PTR(&mp_lv_textarea_set_placeholder_text_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_cursor_pos), MP_ROM_PTR(&mp_lv_textarea_set_cursor_pos_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_cursor_click_pos), MP_ROM_PTR(&mp_lv_textarea_set_cursor_click_pos_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_password_mode), MP_ROM_PTR(&mp_lv_textarea_set_password_mode_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_password_bullet), MP_ROM_PTR(&mp_lv_textarea_set_password_bullet_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_one_line), MP_ROM_PTR(&mp_lv_textarea_set_one_line_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_accepted_chars), MP_ROM_PTR(&mp_lv_textarea_set_accepted_chars_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_max_length), MP_ROM_PTR(&mp_lv_textarea_set_max_length_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_insert_replace), MP_ROM_PTR(&mp_lv_textarea_set_insert_replace_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_text_selection), MP_ROM_PTR(&mp_lv_textarea_set_text_selection_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_password_show_time), MP_ROM_PTR(&mp_lv_textarea_set_password_show_time_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_align), MP_ROM_PTR(&mp_lv_textarea_set_align_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_text), MP_ROM_PTR(&mp_lv_textarea_get_text_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_placeholder_text), MP_ROM_PTR(&mp_lv_textarea_get_placeholder_text_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_label), MP_ROM_PTR(&mp_lv_textarea_get_label_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_cursor_pos), MP_ROM_PTR(&mp_lv_textarea_get_cursor_pos_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_cursor_click_pos), MP_ROM_PTR(&mp_lv_textarea_get_cursor_click_pos_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_password_mode), MP_ROM_PTR(&mp_lv_textarea_get_password_mode_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_password_bullet), MP_ROM_PTR(&mp_lv_textarea_get_password_bullet_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_one_line), MP_ROM_PTR(&mp_lv_textarea_get_one_line_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_accepted_chars), MP_ROM_PTR(&mp_lv_textarea_get_accepted_chars_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_max_length), MP_ROM_PTR(&mp_lv_textarea_get_max_length_obj) },
    { MP_ROM_QSTR(MP_QSTR_text_is_selected), MP_ROM_PTR(&mp_lv_textarea_text_is_selected_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_text_selection), MP_ROM_PTR(&mp_lv_textarea_get_text_selection_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_password_show_time), MP_ROM_PTR(&mp_lv_textarea_get_password_show_time_obj) },
    { MP_ROM_QSTR(MP_QSTR_clear_selection), MP_ROM_PTR(&mp_lv_textarea_clear_selection_obj) },
    { MP_ROM_QSTR(MP_QSTR_cursor_right), MP_ROM_PTR(&mp_lv_textarea_cursor_right_obj) },
    { MP_ROM_QSTR(MP_QSTR_cursor_left), MP_ROM_PTR(&mp_lv_textarea_cursor_left_obj) },
    { MP_ROM_QSTR(MP_QSTR_cursor_down), MP_ROM_PTR(&mp_lv_textarea_cursor_down_obj) },
    { MP_ROM_QSTR(MP_QSTR_cursor_up), MP_ROM_PTR(&mp_lv_textarea_cursor_up_obj) }
};

STATIC MP_DEFINE_CONST_DICT(textarea_locals_dict, textarea_locals_dict_table);

STATIC void textarea_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl textarea");
}


STATIC mp_obj_t textarea_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&lv_textarea_create, type, n_args, n_kw, args);           
}


STATIC const mp_obj_type_t mp_textarea_type = {
    { &mp_type_type },
    .name = MP_QSTR_textarea,
    .print = textarea_print,
    .make_new = textarea_make_new,
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&textarea_locals_dict,
    .buffer_p = { .get_buffer = mp_lv_obj_get_buffer },
    .parent = &mp_obj_type,
};
    

/*
 * lvgl extension definition for:
 * inline static void lv_canvas_set_px(lv_obj_t *canvas, lv_coord_t x, lv_coord_t y, lv_color_t c)
 */
 
STATIC mp_obj_t mp_lv_canvas_set_px(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *canvas = mp_to_lv(mp_args[0]);
    lv_coord_t x = (int16_t)mp_obj_get_int(mp_args[1]);
    lv_coord_t y = (int16_t)mp_obj_get_int(mp_args[2]);
    lv_color_t c = mp_write_lv_color16_t(mp_args[3]);
    ((void (*)(lv_obj_t *, lv_coord_t, lv_coord_t, lv_color_t))lv_func_ptr)(canvas, x, y, c);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_canvas_set_px_obj, 4, mp_lv_canvas_set_px, lv_canvas_set_px);
    

/*
 * lvgl extension definition for:
 * void lv_canvas_set_buffer(lv_obj_t *canvas, void *buf, lv_coord_t w, lv_coord_t h, lv_img_cf_t cf)
 */
 
STATIC mp_obj_t mp_lv_canvas_set_buffer(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *canvas = mp_to_lv(mp_args[0]);
    void *buf = mp_to_ptr(mp_args[1]);
    lv_coord_t w = (int16_t)mp_obj_get_int(mp_args[2]);
    lv_coord_t h = (int16_t)mp_obj_get_int(mp_args[3]);
    lv_img_cf_t cf = (uint8_t)mp_obj_get_int(mp_args[4]);
    ((void (*)(lv_obj_t *, void *, lv_coord_t, lv_coord_t, lv_img_cf_t))lv_func_ptr)(canvas, buf, w, h, cf);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_canvas_set_buffer_obj, 5, mp_lv_canvas_set_buffer, lv_canvas_set_buffer);
    
/* Reusing lv_canvas_set_px for lv_canvas_set_px_color */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_canvas_set_px_color_obj, 4, mp_lv_canvas_set_px, lv_canvas_set_px_color);
    

/*
 * lvgl extension definition for:
 * void lv_canvas_set_px_opa(lv_obj_t *canvas, lv_coord_t x, lv_coord_t y, lv_opa_t opa)
 */
 
STATIC mp_obj_t mp_lv_canvas_set_px_opa(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *canvas = mp_to_lv(mp_args[0]);
    lv_coord_t x = (int16_t)mp_obj_get_int(mp_args[1]);
    lv_coord_t y = (int16_t)mp_obj_get_int(mp_args[2]);
    lv_opa_t opa = (uint8_t)mp_obj_get_int(mp_args[3]);
    ((void (*)(lv_obj_t *, lv_coord_t, lv_coord_t, lv_opa_t))lv_func_ptr)(canvas, x, y, opa);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_canvas_set_px_opa_obj, 4, mp_lv_canvas_set_px_opa, lv_canvas_set_px_opa);
    

/*
 * lvgl extension definition for:
 * void lv_canvas_set_palette(lv_obj_t *canvas, uint8_t id, lv_color_t c)
 */
 
STATIC mp_obj_t mp_lv_canvas_set_palette(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *canvas = mp_to_lv(mp_args[0]);
    uint8_t id = (uint8_t)mp_obj_get_int(mp_args[1]);
    lv_color_t c = mp_write_lv_color16_t(mp_args[2]);
    ((void (*)(lv_obj_t *, uint8_t, lv_color_t))lv_func_ptr)(canvas, id, c);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_canvas_set_palette_obj, 3, mp_lv_canvas_set_palette, lv_canvas_set_palette);
    

/*
 * lvgl extension definition for:
 * lv_color_t lv_canvas_get_px(lv_obj_t *canvas, lv_coord_t x, lv_coord_t y)
 */
 
STATIC mp_obj_t mp_lv_canvas_get_px(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *canvas = mp_to_lv(mp_args[0]);
    lv_coord_t x = (int16_t)mp_obj_get_int(mp_args[1]);
    lv_coord_t y = (int16_t)mp_obj_get_int(mp_args[2]);
    lv_color_t _res = ((lv_color_t (*)(lv_obj_t *, lv_coord_t, lv_coord_t))lv_func_ptr)(canvas, x, y);
    return mp_read_lv_color16_t(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_canvas_get_px_obj, 3, mp_lv_canvas_get_px, lv_canvas_get_px);
    

/*
 * lvgl extension definition for:
 * lv_img_dsc_t *lv_canvas_get_img(lv_obj_t *canvas)
 */
 
STATIC mp_obj_t mp_lv_canvas_get_img(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *canvas = mp_to_lv(mp_args[0]);
    lv_img_dsc_t * _res = ((lv_img_dsc_t *(*)(lv_obj_t *))lv_func_ptr)(canvas);
    return mp_read_ptr_lv_img_dsc_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_canvas_get_img_obj, 1, mp_lv_canvas_get_img, lv_canvas_get_img);
    

/*
 * lvgl extension definition for:
 * void lv_canvas_copy_buf(lv_obj_t *canvas, const void *to_copy, lv_coord_t x, lv_coord_t y, lv_coord_t w, lv_coord_t h)
 */
 
STATIC mp_obj_t mp_lv_canvas_copy_buf(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *canvas = mp_to_lv(mp_args[0]);
    const void *to_copy = mp_to_ptr(mp_args[1]);
    lv_coord_t x = (int16_t)mp_obj_get_int(mp_args[2]);
    lv_coord_t y = (int16_t)mp_obj_get_int(mp_args[3]);
    lv_coord_t w = (int16_t)mp_obj_get_int(mp_args[4]);
    lv_coord_t h = (int16_t)mp_obj_get_int(mp_args[5]);
    ((void (*)(lv_obj_t *, const void *, lv_coord_t, lv_coord_t, lv_coord_t, lv_coord_t))lv_func_ptr)(canvas, to_copy, x, y, w, h);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_canvas_copy_buf_obj, 6, mp_lv_canvas_copy_buf, lv_canvas_copy_buf);
    

/*
 * lvgl extension definition for:
 * void lv_canvas_transform(lv_obj_t *canvas, lv_img_dsc_t *img, int16_t angle, uint16_t zoom, lv_coord_t offset_x, lv_coord_t offset_y, int32_t pivot_x, int32_t pivot_y, bool antialias)
 */
 
STATIC mp_obj_t mp_lv_canvas_transform(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *canvas = mp_to_lv(mp_args[0]);
    lv_img_dsc_t *img = mp_write_ptr_lv_img_dsc_t(mp_args[1]);
    int16_t angle = (int16_t)mp_obj_get_int(mp_args[2]);
    uint16_t zoom = (uint16_t)mp_obj_get_int(mp_args[3]);
    lv_coord_t offset_x = (int16_t)mp_obj_get_int(mp_args[4]);
    lv_coord_t offset_y = (int16_t)mp_obj_get_int(mp_args[5]);
    int32_t pivot_x = (int32_t)mp_obj_get_int(mp_args[6]);
    int32_t pivot_y = (int32_t)mp_obj_get_int(mp_args[7]);
    bool antialias = mp_obj_is_true(mp_args[8]);
    ((void (*)(lv_obj_t *, lv_img_dsc_t *, int16_t, uint16_t, lv_coord_t, lv_coord_t, int32_t, int32_t, bool))lv_func_ptr)(canvas, img, angle, zoom, offset_x, offset_y, pivot_x, pivot_y, antialias);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_canvas_transform_obj, 9, mp_lv_canvas_transform, lv_canvas_transform);
    

/*
 * lvgl extension definition for:
 * void lv_canvas_blur_hor(lv_obj_t *canvas, const lv_area_t *area, uint16_t r)
 */
 
STATIC mp_obj_t mp_lv_canvas_blur_hor(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *canvas = mp_to_lv(mp_args[0]);
    const lv_area_t *area = mp_write_ptr_lv_area_t(mp_args[1]);
    uint16_t r = (uint16_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_obj_t *, const lv_area_t *, uint16_t))lv_func_ptr)(canvas, area, r);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_canvas_blur_hor_obj, 3, mp_lv_canvas_blur_hor, lv_canvas_blur_hor);
    
/* Reusing lv_canvas_blur_hor for lv_canvas_blur_ver */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_canvas_blur_ver_obj, 3, mp_lv_canvas_blur_hor, lv_canvas_blur_ver);
    

/*
 * lvgl extension definition for:
 * void lv_canvas_fill_bg(lv_obj_t *canvas, lv_color_t color, lv_opa_t opa)
 */
 
STATIC mp_obj_t mp_lv_canvas_fill_bg(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *canvas = mp_to_lv(mp_args[0]);
    lv_color_t color = mp_write_lv_color16_t(mp_args[1]);
    lv_opa_t opa = (uint8_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_obj_t *, lv_color_t, lv_opa_t))lv_func_ptr)(canvas, color, opa);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_canvas_fill_bg_obj, 3, mp_lv_canvas_fill_bg, lv_canvas_fill_bg);
    

/*
 * lvgl extension definition for:
 * void lv_canvas_draw_rect(lv_obj_t *canvas, lv_coord_t x, lv_coord_t y, lv_coord_t w, lv_coord_t h, const lv_draw_rect_dsc_t *draw_dsc)
 */
 
STATIC mp_obj_t mp_lv_canvas_draw_rect(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *canvas = mp_to_lv(mp_args[0]);
    lv_coord_t x = (int16_t)mp_obj_get_int(mp_args[1]);
    lv_coord_t y = (int16_t)mp_obj_get_int(mp_args[2]);
    lv_coord_t w = (int16_t)mp_obj_get_int(mp_args[3]);
    lv_coord_t h = (int16_t)mp_obj_get_int(mp_args[4]);
    const lv_draw_rect_dsc_t *draw_dsc = mp_write_ptr_lv_draw_rect_dsc_t(mp_args[5]);
    ((void (*)(lv_obj_t *, lv_coord_t, lv_coord_t, lv_coord_t, lv_coord_t, const lv_draw_rect_dsc_t *))lv_func_ptr)(canvas, x, y, w, h, draw_dsc);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_canvas_draw_rect_obj, 6, mp_lv_canvas_draw_rect, lv_canvas_draw_rect);
    

/*
 * lvgl extension definition for:
 * void lv_canvas_draw_text(lv_obj_t *canvas, lv_coord_t x, lv_coord_t y, lv_coord_t max_w, lv_draw_label_dsc_t *draw_dsc, const char *txt)
 */
 
STATIC mp_obj_t mp_lv_canvas_draw_text(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *canvas = mp_to_lv(mp_args[0]);
    lv_coord_t x = (int16_t)mp_obj_get_int(mp_args[1]);
    lv_coord_t y = (int16_t)mp_obj_get_int(mp_args[2]);
    lv_coord_t max_w = (int16_t)mp_obj_get_int(mp_args[3]);
    lv_draw_label_dsc_t *draw_dsc = mp_write_ptr_lv_draw_label_dsc_t(mp_args[4]);
    const char *txt = (char*)convert_from_str(mp_args[5]);
    ((void (*)(lv_obj_t *, lv_coord_t, lv_coord_t, lv_coord_t, lv_draw_label_dsc_t *, const char *))lv_func_ptr)(canvas, x, y, max_w, draw_dsc, txt);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_canvas_draw_text_obj, 6, mp_lv_canvas_draw_text, lv_canvas_draw_text);
    

/*
 * lvgl extension definition for:
 * void lv_canvas_draw_img(lv_obj_t *canvas, lv_coord_t x, lv_coord_t y, const void *src, const lv_draw_img_dsc_t *draw_dsc)
 */
 
STATIC mp_obj_t mp_lv_canvas_draw_img(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *canvas = mp_to_lv(mp_args[0]);
    lv_coord_t x = (int16_t)mp_obj_get_int(mp_args[1]);
    lv_coord_t y = (int16_t)mp_obj_get_int(mp_args[2]);
    const void *src = mp_to_ptr(mp_args[3]);
    const lv_draw_img_dsc_t *draw_dsc = mp_write_ptr_lv_draw_img_dsc_t(mp_args[4]);
    ((void (*)(lv_obj_t *, lv_coord_t, lv_coord_t, const void *, const lv_draw_img_dsc_t *))lv_func_ptr)(canvas, x, y, src, draw_dsc);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_canvas_draw_img_obj, 5, mp_lv_canvas_draw_img, lv_canvas_draw_img);
    

/*
 * lvgl extension definition for:
 * void lv_canvas_draw_line(lv_obj_t *canvas, const lv_point_t points[], uint32_t point_cnt, const lv_draw_line_dsc_t *draw_dsc)
 */
 
STATIC mp_obj_t mp_lv_canvas_draw_line(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *canvas = mp_to_lv(mp_args[0]);
    const lv_point_t *points = mp_arr_to_lv_point_t_____(mp_args[1]);
    uint32_t point_cnt = (uint32_t)mp_obj_get_int(mp_args[2]);
    const lv_draw_line_dsc_t *draw_dsc = mp_write_ptr_lv_draw_line_dsc_t(mp_args[3]);
    ((void (*)(lv_obj_t *, const lv_point_t [], uint32_t, const lv_draw_line_dsc_t *))lv_func_ptr)(canvas, points, point_cnt, draw_dsc);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_canvas_draw_line_obj, 4, mp_lv_canvas_draw_line, lv_canvas_draw_line);
    

/*
 * lvgl extension definition for:
 * void lv_canvas_draw_polygon(lv_obj_t *canvas, const lv_point_t points[], uint32_t point_cnt, const lv_draw_rect_dsc_t *draw_dsc)
 */
 
STATIC mp_obj_t mp_lv_canvas_draw_polygon(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *canvas = mp_to_lv(mp_args[0]);
    const lv_point_t *points = mp_arr_to_lv_point_t_____(mp_args[1]);
    uint32_t point_cnt = (uint32_t)mp_obj_get_int(mp_args[2]);
    const lv_draw_rect_dsc_t *draw_dsc = mp_write_ptr_lv_draw_rect_dsc_t(mp_args[3]);
    ((void (*)(lv_obj_t *, const lv_point_t [], uint32_t, const lv_draw_rect_dsc_t *))lv_func_ptr)(canvas, points, point_cnt, draw_dsc);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_canvas_draw_polygon_obj, 4, mp_lv_canvas_draw_polygon, lv_canvas_draw_polygon);
    

/*
 * lvgl extension definition for:
 * void lv_canvas_draw_arc(lv_obj_t *canvas, lv_coord_t x, lv_coord_t y, lv_coord_t r, int32_t start_angle, int32_t end_angle, const lv_draw_arc_dsc_t *draw_dsc)
 */
 
STATIC mp_obj_t mp_lv_canvas_draw_arc(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *canvas = mp_to_lv(mp_args[0]);
    lv_coord_t x = (int16_t)mp_obj_get_int(mp_args[1]);
    lv_coord_t y = (int16_t)mp_obj_get_int(mp_args[2]);
    lv_coord_t r = (int16_t)mp_obj_get_int(mp_args[3]);
    int32_t start_angle = (int32_t)mp_obj_get_int(mp_args[4]);
    int32_t end_angle = (int32_t)mp_obj_get_int(mp_args[5]);
    const lv_draw_arc_dsc_t *draw_dsc = mp_write_ptr_lv_draw_arc_dsc_t(mp_args[6]);
    ((void (*)(lv_obj_t *, lv_coord_t, lv_coord_t, lv_coord_t, int32_t, int32_t, const lv_draw_arc_dsc_t *))lv_func_ptr)(canvas, x, y, r, start_angle, end_angle, draw_dsc);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_canvas_draw_arc_obj, 7, mp_lv_canvas_draw_arc, lv_canvas_draw_arc);
    

/*
 * lvgl canvas object definitions
 */
    

STATIC const mp_rom_map_elem_t canvas_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_set_px), MP_ROM_PTR(&mp_lv_canvas_set_px_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_buffer), MP_ROM_PTR(&mp_lv_canvas_set_buffer_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_px_color), MP_ROM_PTR(&mp_lv_canvas_set_px_color_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_px_opa), MP_ROM_PTR(&mp_lv_canvas_set_px_opa_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_palette), MP_ROM_PTR(&mp_lv_canvas_set_palette_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_px), MP_ROM_PTR(&mp_lv_canvas_get_px_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_img), MP_ROM_PTR(&mp_lv_canvas_get_img_obj) },
    { MP_ROM_QSTR(MP_QSTR_copy_buf), MP_ROM_PTR(&mp_lv_canvas_copy_buf_obj) },
    { MP_ROM_QSTR(MP_QSTR_transform), MP_ROM_PTR(&mp_lv_canvas_transform_obj) },
    { MP_ROM_QSTR(MP_QSTR_blur_hor), MP_ROM_PTR(&mp_lv_canvas_blur_hor_obj) },
    { MP_ROM_QSTR(MP_QSTR_blur_ver), MP_ROM_PTR(&mp_lv_canvas_blur_ver_obj) },
    { MP_ROM_QSTR(MP_QSTR_fill_bg), MP_ROM_PTR(&mp_lv_canvas_fill_bg_obj) },
    { MP_ROM_QSTR(MP_QSTR_draw_rect), MP_ROM_PTR(&mp_lv_canvas_draw_rect_obj) },
    { MP_ROM_QSTR(MP_QSTR_draw_text), MP_ROM_PTR(&mp_lv_canvas_draw_text_obj) },
    { MP_ROM_QSTR(MP_QSTR_draw_img), MP_ROM_PTR(&mp_lv_canvas_draw_img_obj) },
    { MP_ROM_QSTR(MP_QSTR_draw_line), MP_ROM_PTR(&mp_lv_canvas_draw_line_obj) },
    { MP_ROM_QSTR(MP_QSTR_draw_polygon), MP_ROM_PTR(&mp_lv_canvas_draw_polygon_obj) },
    { MP_ROM_QSTR(MP_QSTR_draw_arc), MP_ROM_PTR(&mp_lv_canvas_draw_arc_obj) }
};

STATIC MP_DEFINE_CONST_DICT(canvas_locals_dict, canvas_locals_dict_table);

STATIC void canvas_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl canvas");
}


STATIC mp_obj_t canvas_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&lv_canvas_create, type, n_args, n_kw, args);           
}


STATIC const mp_obj_type_t mp_canvas_type = {
    { &mp_type_type },
    .name = MP_QSTR_canvas,
    .print = canvas_print,
    .make_new = canvas_make_new,
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&canvas_locals_dict,
    .buffer_p = { .get_buffer = mp_lv_obj_get_buffer },
    .parent = &mp_obj_type,
};
    

/*
 * lvgl switch object definitions
 */
    

STATIC const mp_rom_map_elem_t switch_locals_dict_table[] = {
    
};

STATIC MP_DEFINE_CONST_DICT(switch_locals_dict, switch_locals_dict_table);

STATIC void switch_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl switch");
}


STATIC mp_obj_t switch_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&lv_switch_create, type, n_args, n_kw, args);           
}


STATIC const mp_obj_type_t mp_switch_type = {
    { &mp_type_type },
    .name = MP_QSTR_switch,
    .print = switch_print,
    .make_new = switch_make_new,
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&switch_locals_dict,
    .buffer_p = { .get_buffer = mp_lv_obj_get_buffer },
    .parent = &mp_obj_type,
};
    
/* Reusing lv_img_set_src for lv_gif_set_src */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_gif_set_src_obj, 2, mp_lv_img_set_src, lv_gif_set_src);
    
/* Reusing lv_obj_move_foreground for lv_gif_restart */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_gif_restart_obj, 1, mp_lv_obj_move_foreground, lv_gif_restart);
    
/* Reusing lv_obj_move_foreground for lv_gif_pause */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_gif_pause_obj, 1, mp_lv_obj_move_foreground, lv_gif_pause);
    
/* Reusing lv_obj_move_foreground for lv_gif_resume */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_gif_resume_obj, 1, mp_lv_obj_move_foreground, lv_gif_resume);
    

/*
 * lvgl gif object definitions
 */
    

STATIC const mp_rom_map_elem_t gif_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_set_src), MP_ROM_PTR(&mp_lv_gif_set_src_obj) },
    { MP_ROM_QSTR(MP_QSTR_restart), MP_ROM_PTR(&mp_lv_gif_restart_obj) },
    { MP_ROM_QSTR(MP_QSTR_pause), MP_ROM_PTR(&mp_lv_gif_pause_obj) },
    { MP_ROM_QSTR(MP_QSTR_resume), MP_ROM_PTR(&mp_lv_gif_resume_obj) }
};

STATIC MP_DEFINE_CONST_DICT(gif_locals_dict, gif_locals_dict_table);

STATIC void gif_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl gif");
}


STATIC mp_obj_t gif_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&lv_gif_create, type, n_args, n_kw, args);           
}


STATIC const mp_obj_type_t mp_gif_type = {
    { &mp_type_type },
    .name = MP_QSTR_gif,
    .print = gif_print,
    .make_new = gif_make_new,
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&gif_locals_dict,
    .buffer_p = { .get_buffer = mp_lv_obj_get_buffer },
    .parent = &mp_obj_type,
};
    

/*
 * lvgl extension definition for:
 * lv_obj_t *lv_qrcode_setparam(lv_obj_t *qrcode, lv_coord_t size, lv_color_t dark_color, lv_color_t light_color)
 */
 
STATIC mp_obj_t mp_lv_qrcode_setparam(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *qrcode = mp_to_lv(mp_args[0]);
    lv_coord_t size = (int16_t)mp_obj_get_int(mp_args[1]);
    lv_color_t dark_color = mp_write_lv_color16_t(mp_args[2]);
    lv_color_t light_color = mp_write_lv_color16_t(mp_args[3]);
    lv_obj_t * _res = ((lv_obj_t *(*)(lv_obj_t *, lv_coord_t, lv_color_t, lv_color_t))lv_func_ptr)(qrcode, size, dark_color, light_color);
    return lv_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_qrcode_setparam_obj, 4, mp_lv_qrcode_setparam, lv_qrcode_setparam);
    

/*
 * lvgl extension definition for:
 * lv_res_t lv_qrcode_update(lv_obj_t *qrcode, const void *data, uint32_t data_len)
 */
 
STATIC mp_obj_t mp_lv_qrcode_update(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *qrcode = mp_to_lv(mp_args[0]);
    const void *data = mp_to_ptr(mp_args[1]);
    uint32_t data_len = (uint32_t)mp_obj_get_int(mp_args[2]);
    lv_res_t _res = ((lv_res_t (*)(lv_obj_t *, const void *, uint32_t))lv_func_ptr)(qrcode, data, data_len);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_qrcode_update_obj, 3, mp_lv_qrcode_update, lv_qrcode_update);
    

/*
 * lvgl extension definition for:
 * void lv_qrcode_set_text(lv_obj_t *qrcode, char *text)
 */
 
STATIC mp_obj_t mp_lv_qrcode_set_text(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *qrcode = mp_to_lv(mp_args[0]);
    char *text = (char*)convert_from_str(mp_args[1]);
    ((void (*)(lv_obj_t *, char *))lv_func_ptr)(qrcode, text);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_qrcode_set_text_obj, 2, mp_lv_qrcode_set_text, lv_qrcode_set_text);
    
/* Reusing lv_obj_move_foreground for lv_qrcode_delete */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_qrcode_delete_obj, 1, mp_lv_obj_move_foreground, lv_qrcode_delete);
    

/*
 * lvgl qrcode object definitions
 */
    

STATIC const mp_rom_map_elem_t qrcode_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_setparam), MP_ROM_PTR(&mp_lv_qrcode_setparam_obj) },
    { MP_ROM_QSTR(MP_QSTR_update), MP_ROM_PTR(&mp_lv_qrcode_update_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_text), MP_ROM_PTR(&mp_lv_qrcode_set_text_obj) },
    { MP_ROM_QSTR(MP_QSTR_delete), MP_ROM_PTR(&mp_lv_qrcode_delete_obj) }
};

STATIC MP_DEFINE_CONST_DICT(qrcode_locals_dict, qrcode_locals_dict_table);

STATIC void qrcode_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl qrcode");
}


STATIC mp_obj_t qrcode_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&lv_qrcode_create, type, n_args, n_kw, args);           
}


STATIC const mp_obj_type_t mp_qrcode_type = {
    { &mp_type_type },
    .name = MP_QSTR_qrcode,
    .print = qrcode_print,
    .make_new = qrcode_make_new,
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&qrcode_locals_dict,
    .buffer_p = { .get_buffer = mp_lv_obj_get_buffer },
    .parent = &mp_obj_type,
};
    

/*
 * Array convertors for lv_img_dsc_t *[]
 */

STATIC lv_img_dsc_t * *mp_arr_to_lv_img_dsc_t_ptr____(mp_obj_t mp_arr)
{
    mp_obj_t mp_len = mp_obj_len_maybe(mp_arr);
    if (mp_len == MP_OBJ_NULL) return mp_to_ptr(mp_arr);
    mp_int_t len = mp_obj_get_int(mp_len);
    
    lv_img_dsc_t * *lv_arr = (lv_img_dsc_t **)m_malloc(len * sizeof(lv_img_dsc_t *));
    mp_obj_t iter = mp_getiter(mp_arr, NULL);
    mp_obj_t item;
    size_t i = 0;
    while ((item = mp_iternext(iter)) != MP_OBJ_STOP_ITERATION) {
        lv_arr[i++] = mp_write_ptr_lv_img_dsc_t(item);
    }
    return (lv_img_dsc_t * *)lv_arr;
}
    
STATIC mp_obj_t mp_arr_from_lv_img_dsc_t_ptr____(lv_img_dsc_t * *arr)
{
    mp_obj_t obj_arr[1];
    for (size_t i=0; i<1; i++){
        obj_arr[i] = mp_read_ptr_lv_img_dsc_t(arr[i]);
    }
    return mp_obj_new_list(1, obj_arr); // TODO: return custom iterable object!
}
    

/*
 * lvgl extension definition for:
 * void lv_animimg_set_src(lv_obj_t *img, lv_img_dsc_t *dsc[], uint8_t num)
 */
 
STATIC mp_obj_t mp_lv_animimg_set_src(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *img = mp_to_lv(mp_args[0]);
    lv_img_dsc_t **dsc = mp_arr_to_lv_img_dsc_t_ptr____(mp_args[1]);
    uint8_t num = (uint8_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_obj_t *, lv_img_dsc_t *[], uint8_t))lv_func_ptr)(img, dsc, num);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_animimg_set_src_obj, 3, mp_lv_animimg_set_src, lv_animimg_set_src);
    
/* Reusing lv_obj_move_foreground for lv_animimg_start */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_animimg_start_obj, 1, mp_lv_obj_move_foreground, lv_animimg_start);
    
/* Reusing lv_label_set_text_sel_start for lv_animimg_set_duration */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_animimg_set_duration_obj, 2, mp_lv_label_set_text_sel_start, lv_animimg_set_duration);
    
/* Reusing lv_arc_set_start_angle for lv_animimg_set_repeat_count */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_animimg_set_repeat_count_obj, 2, mp_lv_arc_set_start_angle, lv_animimg_set_repeat_count);
    

/*
 * lvgl animimg object definitions
 */
    

STATIC const mp_rom_map_elem_t animimg_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_set_src), MP_ROM_PTR(&mp_lv_animimg_set_src_obj) },
    { MP_ROM_QSTR(MP_QSTR_start), MP_ROM_PTR(&mp_lv_animimg_start_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_duration), MP_ROM_PTR(&mp_lv_animimg_set_duration_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_repeat_count), MP_ROM_PTR(&mp_lv_animimg_set_repeat_count_obj) }
};

STATIC MP_DEFINE_CONST_DICT(animimg_locals_dict, animimg_locals_dict_table);

STATIC void animimg_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl animimg");
}


STATIC mp_obj_t animimg_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&lv_animimg_create, type, n_args, n_kw, args);           
}


STATIC const mp_obj_type_t mp_animimg_type = {
    { &mp_type_type },
    .name = MP_QSTR_animimg,
    .print = animimg_print,
    .make_new = animimg_make_new,
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&animimg_locals_dict,
    .buffer_p = { .get_buffer = mp_lv_obj_get_buffer },
    .parent = &mp_obj_type,
};
    

/*
 * lvgl extension definition for:
 * void lv_calendar_set_today_date(lv_obj_t *obj, uint32_t year, uint32_t month, uint32_t day)
 */
 
STATIC mp_obj_t mp_lv_calendar_set_today_date(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint32_t year = (uint32_t)mp_obj_get_int(mp_args[1]);
    uint32_t month = (uint32_t)mp_obj_get_int(mp_args[2]);
    uint32_t day = (uint32_t)mp_obj_get_int(mp_args[3]);
    ((void (*)(lv_obj_t *, uint32_t, uint32_t, uint32_t))lv_func_ptr)(obj, year, month, day);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_calendar_set_today_date_obj, 4, mp_lv_calendar_set_today_date, lv_calendar_set_today_date);
    
/* Reusing lv_label_cut_text for lv_calendar_set_showed_date */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_calendar_set_showed_date_obj, 3, mp_lv_label_cut_text, lv_calendar_set_showed_date);
    

/*
 * Struct lv_calendar_date_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_calendar_date_t_type();

STATIC inline lv_calendar_date_t* mp_write_ptr_lv_calendar_date_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_calendar_date_t_type()));
    return (lv_calendar_date_t*)self->data;
}

#define mp_write_lv_calendar_date_t(struct_obj) *mp_write_ptr_lv_calendar_date_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_calendar_date_t(lv_calendar_date_t *field)
{
    return lv_to_mp_struct(get_mp_lv_calendar_date_t_type(), (void*)field);
}

#define mp_read_lv_calendar_date_t(field) mp_read_ptr_lv_calendar_date_t(copy_buffer(&field, sizeof(lv_calendar_date_t)))
#define mp_read_byref_lv_calendar_date_t(field) mp_read_ptr_lv_calendar_date_t(&field)

STATIC void mp_lv_calendar_date_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_calendar_date_t *data = (lv_calendar_date_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_year: dest[0] = mp_obj_new_int_from_uint(data->year); break; // converting from uint16_t;
            case MP_QSTR_month: dest[0] = mp_obj_new_int(data->month); break; // converting from int8_t;
            case MP_QSTR_day: dest[0] = mp_obj_new_int(data->day); break; // converting from int8_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_year: data->year = (uint16_t)mp_obj_get_int(dest[1]); break; // converting to uint16_t;
                case MP_QSTR_month: data->month = (int8_t)mp_obj_get_int(dest[1]); break; // converting to int8_t;
                case MP_QSTR_day: data->day = (int8_t)mp_obj_get_int(dest[1]); break; // converting to int8_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_calendar_date_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_calendar_date_t");
}

STATIC const mp_obj_dict_t mp_lv_calendar_date_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_calendar_date_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_calendar_date_t,
    .print = mp_lv_calendar_date_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_calendar_date_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_calendar_date_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_calendar_date_t_type()
{
    return &mp_lv_calendar_date_t_type;
}
    

/*
 * Array convertors for lv_calendar_date_t []
 */

STATIC lv_calendar_date_t *mp_arr_to_lv_calendar_date_t_____(mp_obj_t mp_arr)
{
    mp_obj_t mp_len = mp_obj_len_maybe(mp_arr);
    if (mp_len == MP_OBJ_NULL) return mp_to_ptr(mp_arr);
    mp_int_t len = mp_obj_get_int(mp_len);
    
    lv_calendar_date_t *lv_arr = (lv_calendar_date_t*)m_malloc(len * sizeof(lv_calendar_date_t));
    mp_obj_t iter = mp_getiter(mp_arr, NULL);
    mp_obj_t item;
    size_t i = 0;
    while ((item = mp_iternext(iter)) != MP_OBJ_STOP_ITERATION) {
        lv_arr[i++] = mp_write_lv_calendar_date_t(item);
    }
    return (lv_calendar_date_t *)lv_arr;
}
    
STATIC mp_obj_t mp_arr_from_lv_calendar_date_t_____(lv_calendar_date_t *arr)
{
    mp_obj_t obj_arr[1];
    for (size_t i=0; i<1; i++){
        obj_arr[i] = mp_read_lv_calendar_date_t(arr[i]);
    }
    return mp_obj_new_list(1, obj_arr); // TODO: return custom iterable object!
}
    

/*
 * lvgl extension definition for:
 * void lv_calendar_set_highlighted_dates(lv_obj_t *obj, lv_calendar_date_t highlighted[], uint16_t date_num)
 */
 
STATIC mp_obj_t mp_lv_calendar_set_highlighted_dates(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_calendar_date_t *highlighted = mp_arr_to_lv_calendar_date_t_____(mp_args[1]);
    uint16_t date_num = (uint16_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_obj_t *, lv_calendar_date_t [], uint16_t))lv_func_ptr)(obj, highlighted, date_num);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_calendar_set_highlighted_dates_obj, 3, mp_lv_calendar_set_highlighted_dates, lv_calendar_set_highlighted_dates);
    

/*
 * lvgl extension definition for:
 * void lv_calendar_set_day_names(lv_obj_t *obj, const char **day_names)
 */
 
STATIC mp_obj_t mp_lv_calendar_set_day_names(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    const char **day_names = mp_to_ptr(mp_args[1]);
    ((void (*)(lv_obj_t *, const char **))lv_func_ptr)(obj, day_names);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_calendar_set_day_names_obj, 2, mp_lv_calendar_set_day_names, lv_calendar_set_day_names);
    
/* Reusing lv_textarea_get_label for lv_calendar_get_btnmatrix */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_calendar_get_btnmatrix_obj, 1, mp_lv_textarea_get_label, lv_calendar_get_btnmatrix);
    

/*
 * lvgl extension definition for:
 * const lv_calendar_date_t *lv_calendar_get_today_date(const lv_obj_t *calendar)
 */
 
STATIC mp_obj_t mp_lv_calendar_get_today_date(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *calendar = mp_to_lv(mp_args[0]);
    const lv_calendar_date_t * _res = ((const lv_calendar_date_t *(*)(const lv_obj_t *))lv_func_ptr)(calendar);
    return mp_read_ptr_lv_calendar_date_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_calendar_get_today_date_obj, 1, mp_lv_calendar_get_today_date, lv_calendar_get_today_date);
    
/* Reusing lv_calendar_get_today_date for lv_calendar_get_showed_date */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_calendar_get_showed_date_obj, 1, mp_lv_calendar_get_today_date, lv_calendar_get_showed_date);
    

/*
 * lvgl extension definition for:
 * lv_calendar_date_t *lv_calendar_get_highlighted_dates(const lv_obj_t *calendar)
 */
 
STATIC mp_obj_t mp_lv_calendar_get_highlighted_dates(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *calendar = mp_to_lv(mp_args[0]);
    lv_calendar_date_t * _res = ((lv_calendar_date_t *(*)(const lv_obj_t *))lv_func_ptr)(calendar);
    return mp_read_ptr_lv_calendar_date_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_calendar_get_highlighted_dates_obj, 1, mp_lv_calendar_get_highlighted_dates, lv_calendar_get_highlighted_dates);
    
/* Reusing lv_btnmatrix_get_selected_btn for lv_calendar_get_highlighted_dates_num */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_calendar_get_highlighted_dates_num_obj, 1, mp_lv_btnmatrix_get_selected_btn, lv_calendar_get_highlighted_dates_num);
    

/*
 * lvgl extension definition for:
 * lv_res_t lv_calendar_get_pressed_date(const lv_obj_t *calendar, lv_calendar_date_t *date)
 */
 
STATIC mp_obj_t mp_lv_calendar_get_pressed_date(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *calendar = mp_to_lv(mp_args[0]);
    lv_calendar_date_t *date = mp_write_ptr_lv_calendar_date_t(mp_args[1]);
    lv_res_t _res = ((lv_res_t (*)(const lv_obj_t *, lv_calendar_date_t *))lv_func_ptr)(calendar, date);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_calendar_get_pressed_date_obj, 2, mp_lv_calendar_get_pressed_date, lv_calendar_get_pressed_date);
    
/* Reusing lv_dropdown_get_list for lv_calendar_header_arrow_create */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_calendar_header_arrow_create_obj, 1, mp_lv_dropdown_get_list, lv_calendar_header_arrow_create);
    
/* Reusing lv_dropdown_get_list for lv_calendar_header_dropdown_create */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_calendar_header_dropdown_create_obj, 1, mp_lv_dropdown_get_list, lv_calendar_header_dropdown_create);
    

/*
 * lvgl calendar object definitions
 */
    

STATIC const mp_rom_map_elem_t calendar_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_set_today_date), MP_ROM_PTR(&mp_lv_calendar_set_today_date_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_showed_date), MP_ROM_PTR(&mp_lv_calendar_set_showed_date_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_highlighted_dates), MP_ROM_PTR(&mp_lv_calendar_set_highlighted_dates_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_day_names), MP_ROM_PTR(&mp_lv_calendar_set_day_names_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_btnmatrix), MP_ROM_PTR(&mp_lv_calendar_get_btnmatrix_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_today_date), MP_ROM_PTR(&mp_lv_calendar_get_today_date_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_showed_date), MP_ROM_PTR(&mp_lv_calendar_get_showed_date_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_highlighted_dates), MP_ROM_PTR(&mp_lv_calendar_get_highlighted_dates_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_highlighted_dates_num), MP_ROM_PTR(&mp_lv_calendar_get_highlighted_dates_num_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_pressed_date), MP_ROM_PTR(&mp_lv_calendar_get_pressed_date_obj) },
    { MP_ROM_QSTR(MP_QSTR_header_arrow_create), MP_ROM_PTR(&mp_lv_calendar_header_arrow_create_obj) },
    { MP_ROM_QSTR(MP_QSTR_header_dropdown_create), MP_ROM_PTR(&mp_lv_calendar_header_dropdown_create_obj) }
};

STATIC MP_DEFINE_CONST_DICT(calendar_locals_dict, calendar_locals_dict_table);

STATIC void calendar_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl calendar");
}


STATIC mp_obj_t calendar_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&lv_calendar_create, type, n_args, n_kw, args);           
}


STATIC const mp_obj_type_t mp_calendar_type = {
    { &mp_type_type },
    .name = MP_QSTR_calendar,
    .print = calendar_print,
    .make_new = calendar_make_new,
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&calendar_locals_dict,
    .buffer_p = { .get_buffer = mp_lv_obj_get_buffer },
    .parent = &mp_obj_type,
};
    

/*
 * lvgl extension definition for:
 * void lv_chart_set_type(lv_obj_t *obj, lv_chart_type_t type)
 */
 
STATIC mp_obj_t mp_lv_chart_set_type(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_chart_type_t type = (uint8_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_obj_t *, lv_chart_type_t))lv_func_ptr)(obj, type);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_chart_set_type_obj, 2, mp_lv_chart_set_type, lv_chart_set_type);
    
/* Reusing lv_arc_set_start_angle for lv_chart_set_point_count */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_chart_set_point_count_obj, 2, mp_lv_arc_set_start_angle, lv_chart_set_point_count);
    

/*
 * lvgl extension definition for:
 * void lv_chart_set_range(lv_obj_t *obj, lv_chart_axis_t axis, lv_coord_t min, lv_coord_t max)
 */
 
STATIC mp_obj_t mp_lv_chart_set_range(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_chart_axis_t axis = (uint8_t)mp_obj_get_int(mp_args[1]);
    lv_coord_t min = (int16_t)mp_obj_get_int(mp_args[2]);
    lv_coord_t max = (int16_t)mp_obj_get_int(mp_args[3]);
    ((void (*)(lv_obj_t *, lv_chart_axis_t, lv_coord_t, lv_coord_t))lv_func_ptr)(obj, axis, min, max);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_chart_set_range_obj, 4, mp_lv_chart_set_range, lv_chart_set_range);
    

/*
 * lvgl extension definition for:
 * void lv_chart_set_update_mode(lv_obj_t *obj, lv_chart_update_mode_t update_mode)
 */
 
STATIC mp_obj_t mp_lv_chart_set_update_mode(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_chart_update_mode_t update_mode = (uint8_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_obj_t *, lv_chart_update_mode_t))lv_func_ptr)(obj, update_mode);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_chart_set_update_mode_obj, 2, mp_lv_chart_set_update_mode, lv_chart_set_update_mode);
    

/*
 * lvgl extension definition for:
 * void lv_chart_set_div_line_count(lv_obj_t *obj, uint8_t hdiv, uint8_t vdiv)
 */
 
STATIC mp_obj_t mp_lv_chart_set_div_line_count(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint8_t hdiv = (uint8_t)mp_obj_get_int(mp_args[1]);
    uint8_t vdiv = (uint8_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_obj_t *, uint8_t, uint8_t))lv_func_ptr)(obj, hdiv, vdiv);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_chart_set_div_line_count_obj, 3, mp_lv_chart_set_div_line_count, lv_chart_set_div_line_count);
    
/* Reusing lv_arc_set_start_angle for lv_chart_set_zoom_x */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_chart_set_zoom_x_obj, 2, mp_lv_arc_set_start_angle, lv_chart_set_zoom_x);
    
/* Reusing lv_arc_set_start_angle for lv_chart_set_zoom_y */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_chart_set_zoom_y_obj, 2, mp_lv_arc_set_start_angle, lv_chart_set_zoom_y);
    
/* Reusing lv_btnmatrix_get_selected_btn for lv_chart_get_zoom_x */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_chart_get_zoom_x_obj, 1, mp_lv_btnmatrix_get_selected_btn, lv_chart_get_zoom_x);
    
/* Reusing lv_btnmatrix_get_selected_btn for lv_chart_get_zoom_y */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_chart_get_zoom_y_obj, 1, mp_lv_btnmatrix_get_selected_btn, lv_chart_get_zoom_y);
    

/*
 * lvgl extension definition for:
 * void lv_chart_set_axis_tick(lv_obj_t *obj, lv_chart_axis_t axis, lv_coord_t major_len, lv_coord_t minor_len, lv_coord_t major_cnt, lv_coord_t minor_cnt, bool label_en, lv_coord_t draw_size)
 */
 
STATIC mp_obj_t mp_lv_chart_set_axis_tick(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_chart_axis_t axis = (uint8_t)mp_obj_get_int(mp_args[1]);
    lv_coord_t major_len = (int16_t)mp_obj_get_int(mp_args[2]);
    lv_coord_t minor_len = (int16_t)mp_obj_get_int(mp_args[3]);
    lv_coord_t major_cnt = (int16_t)mp_obj_get_int(mp_args[4]);
    lv_coord_t minor_cnt = (int16_t)mp_obj_get_int(mp_args[5]);
    bool label_en = mp_obj_is_true(mp_args[6]);
    lv_coord_t draw_size = (int16_t)mp_obj_get_int(mp_args[7]);
    ((void (*)(lv_obj_t *, lv_chart_axis_t, lv_coord_t, lv_coord_t, lv_coord_t, lv_coord_t, bool, lv_coord_t))lv_func_ptr)(obj, axis, major_len, minor_len, major_cnt, minor_cnt, label_en, draw_size);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_chart_set_axis_tick_obj, 8, mp_lv_chart_set_axis_tick, lv_chart_set_axis_tick);
    

/*
 * lvgl extension definition for:
 * lv_chart_type_t lv_chart_get_type(const lv_obj_t *obj)
 */
 
STATIC mp_obj_t mp_lv_chart_get_type(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_chart_type_t _res = ((lv_chart_type_t (*)(const lv_obj_t *))lv_func_ptr)(obj);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_chart_get_type_obj, 1, mp_lv_chart_get_type, lv_chart_get_type);
    
/* Reusing lv_btnmatrix_get_selected_btn for lv_chart_get_point_count */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_chart_get_point_count_obj, 1, mp_lv_btnmatrix_get_selected_btn, lv_chart_get_point_count);
    

/*
 * Struct lv_chart_series_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_chart_series_t_type();

STATIC inline lv_chart_series_t* mp_write_ptr_lv_chart_series_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_chart_series_t_type()));
    return (lv_chart_series_t*)self->data;
}

#define mp_write_lv_chart_series_t(struct_obj) *mp_write_ptr_lv_chart_series_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_chart_series_t(lv_chart_series_t *field)
{
    return lv_to_mp_struct(get_mp_lv_chart_series_t_type(), (void*)field);
}

#define mp_read_lv_chart_series_t(field) mp_read_ptr_lv_chart_series_t(copy_buffer(&field, sizeof(lv_chart_series_t)))
#define mp_read_byref_lv_chart_series_t(field) mp_read_ptr_lv_chart_series_t(&field)

STATIC void mp_lv_chart_series_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_chart_series_t *data = (lv_chart_series_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_x_points: dest[0] = mp_arr_from_lv_coord_t_ptr((void*)data->x_points); break; // converting from lv_coord_t *;
            case MP_QSTR_y_points: dest[0] = mp_arr_from_lv_coord_t_ptr((void*)data->y_points); break; // converting from lv_coord_t *;
            case MP_QSTR_color: dest[0] = mp_read_byref_lv_color16_t(data->color); break; // converting from lv_color_t;
            case MP_QSTR_start_point: dest[0] = mp_obj_new_int_from_uint(data->start_point); break; // converting from uint16_t;
            case MP_QSTR_hidden: dest[0] = mp_obj_new_int_from_uint(data->hidden); break; // converting from uint8_t;
            case MP_QSTR_x_ext_buf_assigned: dest[0] = mp_obj_new_int_from_uint(data->x_ext_buf_assigned); break; // converting from uint8_t;
            case MP_QSTR_y_ext_buf_assigned: dest[0] = mp_obj_new_int_from_uint(data->y_ext_buf_assigned); break; // converting from uint8_t;
            case MP_QSTR_x_axis_sec: dest[0] = mp_obj_new_int_from_uint(data->x_axis_sec); break; // converting from uint8_t;
            case MP_QSTR_y_axis_sec: dest[0] = mp_obj_new_int_from_uint(data->y_axis_sec); break; // converting from uint8_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_x_points: data->x_points = (void*)mp_arr_to_lv_coord_t_ptr(dest[1]); break; // converting to lv_coord_t *;
                case MP_QSTR_y_points: data->y_points = (void*)mp_arr_to_lv_coord_t_ptr(dest[1]); break; // converting to lv_coord_t *;
                case MP_QSTR_color: data->color = mp_write_lv_color16_t(dest[1]); break; // converting to lv_color_t;
                case MP_QSTR_start_point: data->start_point = (uint16_t)mp_obj_get_int(dest[1]); break; // converting to uint16_t;
                case MP_QSTR_hidden: data->hidden = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                case MP_QSTR_x_ext_buf_assigned: data->x_ext_buf_assigned = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                case MP_QSTR_y_ext_buf_assigned: data->y_ext_buf_assigned = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                case MP_QSTR_x_axis_sec: data->x_axis_sec = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                case MP_QSTR_y_axis_sec: data->y_axis_sec = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_chart_series_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_chart_series_t");
}

STATIC const mp_obj_dict_t mp_lv_chart_series_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_chart_series_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_chart_series_t,
    .print = mp_lv_chart_series_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_chart_series_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_chart_series_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_chart_series_t_type()
{
    return &mp_lv_chart_series_t_type;
}
    

/*
 * lvgl extension definition for:
 * uint16_t lv_chart_get_x_start_point(const lv_obj_t *obj, lv_chart_series_t *ser)
 */
 
STATIC mp_obj_t mp_lv_chart_get_x_start_point(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_chart_series_t *ser = mp_write_ptr_lv_chart_series_t(mp_args[1]);
    uint16_t _res = ((uint16_t (*)(const lv_obj_t *, lv_chart_series_t *))lv_func_ptr)(obj, ser);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_chart_get_x_start_point_obj, 2, mp_lv_chart_get_x_start_point, lv_chart_get_x_start_point);
    

/*
 * lvgl extension definition for:
 * void lv_chart_get_point_pos_by_id(lv_obj_t *obj, lv_chart_series_t *ser, uint16_t id, lv_point_t *p_out)
 */
 
STATIC mp_obj_t mp_lv_chart_get_point_pos_by_id(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_chart_series_t *ser = mp_write_ptr_lv_chart_series_t(mp_args[1]);
    uint16_t id = (uint16_t)mp_obj_get_int(mp_args[2]);
    lv_point_t *p_out = mp_write_ptr_lv_point_t(mp_args[3]);
    ((void (*)(lv_obj_t *, lv_chart_series_t *, uint16_t, lv_point_t *))lv_func_ptr)(obj, ser, id, p_out);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_chart_get_point_pos_by_id_obj, 4, mp_lv_chart_get_point_pos_by_id, lv_chart_get_point_pos_by_id);
    
/* Reusing lv_obj_move_foreground for lv_chart_refresh */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_chart_refresh_obj, 1, mp_lv_obj_move_foreground, lv_chart_refresh);
    

/*
 * lvgl extension definition for:
 * lv_chart_series_t *lv_chart_add_series(lv_obj_t *obj, lv_color_t color, lv_chart_axis_t axis)
 */
 
STATIC mp_obj_t mp_lv_chart_add_series(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_color_t color = mp_write_lv_color16_t(mp_args[1]);
    lv_chart_axis_t axis = (uint8_t)mp_obj_get_int(mp_args[2]);
    lv_chart_series_t * _res = ((lv_chart_series_t *(*)(lv_obj_t *, lv_color_t, lv_chart_axis_t))lv_func_ptr)(obj, color, axis);
    return mp_read_ptr_lv_chart_series_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_chart_add_series_obj, 3, mp_lv_chart_add_series, lv_chart_add_series);
    

/*
 * lvgl extension definition for:
 * void lv_chart_remove_series(lv_obj_t *obj, lv_chart_series_t *series)
 */
 
STATIC mp_obj_t mp_lv_chart_remove_series(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_chart_series_t *series = mp_write_ptr_lv_chart_series_t(mp_args[1]);
    ((void (*)(lv_obj_t *, lv_chart_series_t *))lv_func_ptr)(obj, series);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_chart_remove_series_obj, 2, mp_lv_chart_remove_series, lv_chart_remove_series);
    

/*
 * lvgl extension definition for:
 * void lv_chart_hide_series(lv_obj_t *chart, lv_chart_series_t *series, bool hide)
 */
 
STATIC mp_obj_t mp_lv_chart_hide_series(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *chart = mp_to_lv(mp_args[0]);
    lv_chart_series_t *series = mp_write_ptr_lv_chart_series_t(mp_args[1]);
    bool hide = mp_obj_is_true(mp_args[2]);
    ((void (*)(lv_obj_t *, lv_chart_series_t *, bool))lv_func_ptr)(chart, series, hide);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_chart_hide_series_obj, 3, mp_lv_chart_hide_series, lv_chart_hide_series);
    

/*
 * lvgl extension definition for:
 * void lv_chart_set_series_color(lv_obj_t *chart, lv_chart_series_t *series, lv_color_t color)
 */
 
STATIC mp_obj_t mp_lv_chart_set_series_color(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *chart = mp_to_lv(mp_args[0]);
    lv_chart_series_t *series = mp_write_ptr_lv_chart_series_t(mp_args[1]);
    lv_color_t color = mp_write_lv_color16_t(mp_args[2]);
    ((void (*)(lv_obj_t *, lv_chart_series_t *, lv_color_t))lv_func_ptr)(chart, series, color);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_chart_set_series_color_obj, 3, mp_lv_chart_set_series_color, lv_chart_set_series_color);
    

/*
 * lvgl extension definition for:
 * void lv_chart_set_x_start_point(lv_obj_t *obj, lv_chart_series_t *ser, uint16_t id)
 */
 
STATIC mp_obj_t mp_lv_chart_set_x_start_point(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_chart_series_t *ser = mp_write_ptr_lv_chart_series_t(mp_args[1]);
    uint16_t id = (uint16_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_obj_t *, lv_chart_series_t *, uint16_t))lv_func_ptr)(obj, ser, id);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_chart_set_x_start_point_obj, 3, mp_lv_chart_set_x_start_point, lv_chart_set_x_start_point);
    

/*
 * lvgl extension definition for:
 * lv_chart_series_t *lv_chart_get_series_next(const lv_obj_t *chart, const lv_chart_series_t *ser)
 */
 
STATIC mp_obj_t mp_lv_chart_get_series_next(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *chart = mp_to_lv(mp_args[0]);
    const lv_chart_series_t *ser = mp_write_ptr_lv_chart_series_t(mp_args[1]);
    lv_chart_series_t * _res = ((lv_chart_series_t *(*)(const lv_obj_t *, const lv_chart_series_t *))lv_func_ptr)(chart, ser);
    return mp_read_ptr_lv_chart_series_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_chart_get_series_next_obj, 2, mp_lv_chart_get_series_next, lv_chart_get_series_next);
    

/*
 * Struct lv_chart_cursor_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_chart_cursor_t_type();

STATIC inline lv_chart_cursor_t* mp_write_ptr_lv_chart_cursor_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_chart_cursor_t_type()));
    return (lv_chart_cursor_t*)self->data;
}

#define mp_write_lv_chart_cursor_t(struct_obj) *mp_write_ptr_lv_chart_cursor_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_chart_cursor_t(lv_chart_cursor_t *field)
{
    return lv_to_mp_struct(get_mp_lv_chart_cursor_t_type(), (void*)field);
}

#define mp_read_lv_chart_cursor_t(field) mp_read_ptr_lv_chart_cursor_t(copy_buffer(&field, sizeof(lv_chart_cursor_t)))
#define mp_read_byref_lv_chart_cursor_t(field) mp_read_ptr_lv_chart_cursor_t(&field)

STATIC void mp_lv_chart_cursor_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_chart_cursor_t *data = (lv_chart_cursor_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_pos: dest[0] = mp_read_byref_lv_point_t(data->pos); break; // converting from lv_point_t;
            case MP_QSTR_point_id: dest[0] = mp_obj_new_int(data->point_id); break; // converting from lv_coord_t;
            case MP_QSTR_color: dest[0] = mp_read_byref_lv_color16_t(data->color); break; // converting from lv_color_t;
            case MP_QSTR_ser: dest[0] = mp_read_ptr_lv_chart_series_t((void*)data->ser); break; // converting from lv_chart_series_t *;
            case MP_QSTR_dir: dest[0] = mp_obj_new_int_from_uint(data->dir); break; // converting from lv_dir_t;
            case MP_QSTR_pos_set: dest[0] = mp_obj_new_int_from_uint(data->pos_set); break; // converting from uint8_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_pos: data->pos = mp_write_lv_point_t(dest[1]); break; // converting to lv_point_t;
                case MP_QSTR_point_id: data->point_id = (int16_t)mp_obj_get_int(dest[1]); break; // converting to lv_coord_t;
                case MP_QSTR_color: data->color = mp_write_lv_color16_t(dest[1]); break; // converting to lv_color_t;
                case MP_QSTR_ser: data->ser = (void*)mp_write_ptr_lv_chart_series_t(dest[1]); break; // converting to lv_chart_series_t *;
                case MP_QSTR_dir: data->dir = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to lv_dir_t;
                case MP_QSTR_pos_set: data->pos_set = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_chart_cursor_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_chart_cursor_t");
}

STATIC const mp_obj_dict_t mp_lv_chart_cursor_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_chart_cursor_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_chart_cursor_t,
    .print = mp_lv_chart_cursor_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_chart_cursor_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_chart_cursor_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_chart_cursor_t_type()
{
    return &mp_lv_chart_cursor_t_type;
}
    

/*
 * lvgl extension definition for:
 * lv_chart_cursor_t *lv_chart_add_cursor(lv_obj_t *obj, lv_color_t color, lv_dir_t dir)
 */
 
STATIC mp_obj_t mp_lv_chart_add_cursor(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_color_t color = mp_write_lv_color16_t(mp_args[1]);
    lv_dir_t dir = (uint8_t)mp_obj_get_int(mp_args[2]);
    lv_chart_cursor_t * _res = ((lv_chart_cursor_t *(*)(lv_obj_t *, lv_color_t, lv_dir_t))lv_func_ptr)(obj, color, dir);
    return mp_read_ptr_lv_chart_cursor_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_chart_add_cursor_obj, 3, mp_lv_chart_add_cursor, lv_chart_add_cursor);
    

/*
 * lvgl extension definition for:
 * void lv_chart_set_cursor_pos(lv_obj_t *chart, lv_chart_cursor_t *cursor, lv_point_t *pos)
 */
 
STATIC mp_obj_t mp_lv_chart_set_cursor_pos(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *chart = mp_to_lv(mp_args[0]);
    lv_chart_cursor_t *cursor = mp_write_ptr_lv_chart_cursor_t(mp_args[1]);
    lv_point_t *pos = mp_write_ptr_lv_point_t(mp_args[2]);
    ((void (*)(lv_obj_t *, lv_chart_cursor_t *, lv_point_t *))lv_func_ptr)(chart, cursor, pos);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_chart_set_cursor_pos_obj, 3, mp_lv_chart_set_cursor_pos, lv_chart_set_cursor_pos);
    

/*
 * lvgl extension definition for:
 * void lv_chart_set_cursor_point(lv_obj_t *chart, lv_chart_cursor_t *cursor, lv_chart_series_t *ser, uint16_t point_id)
 */
 
STATIC mp_obj_t mp_lv_chart_set_cursor_point(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *chart = mp_to_lv(mp_args[0]);
    lv_chart_cursor_t *cursor = mp_write_ptr_lv_chart_cursor_t(mp_args[1]);
    lv_chart_series_t *ser = mp_write_ptr_lv_chart_series_t(mp_args[2]);
    uint16_t point_id = (uint16_t)mp_obj_get_int(mp_args[3]);
    ((void (*)(lv_obj_t *, lv_chart_cursor_t *, lv_chart_series_t *, uint16_t))lv_func_ptr)(chart, cursor, ser, point_id);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_chart_set_cursor_point_obj, 4, mp_lv_chart_set_cursor_point, lv_chart_set_cursor_point);
    

/*
 * lvgl extension definition for:
 * lv_point_t lv_chart_get_cursor_point(lv_obj_t *chart, lv_chart_cursor_t *cursor)
 */
 
STATIC mp_obj_t mp_lv_chart_get_cursor_point(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *chart = mp_to_lv(mp_args[0]);
    lv_chart_cursor_t *cursor = mp_write_ptr_lv_chart_cursor_t(mp_args[1]);
    lv_point_t _res = ((lv_point_t (*)(lv_obj_t *, lv_chart_cursor_t *))lv_func_ptr)(chart, cursor);
    return mp_read_lv_point_t(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_chart_get_cursor_point_obj, 2, mp_lv_chart_get_cursor_point, lv_chart_get_cursor_point);
    

/*
 * lvgl extension definition for:
 * void lv_chart_set_all_value(lv_obj_t *obj, lv_chart_series_t *ser, lv_coord_t value)
 */
 
STATIC mp_obj_t mp_lv_chart_set_all_value(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_chart_series_t *ser = mp_write_ptr_lv_chart_series_t(mp_args[1]);
    lv_coord_t value = (int16_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_obj_t *, lv_chart_series_t *, lv_coord_t))lv_func_ptr)(obj, ser, value);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_chart_set_all_value_obj, 3, mp_lv_chart_set_all_value, lv_chart_set_all_value);
    
/* Reusing lv_chart_set_all_value for lv_chart_set_next_value */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_chart_set_next_value_obj, 3, mp_lv_chart_set_all_value, lv_chart_set_next_value);
    

/*
 * lvgl extension definition for:
 * void lv_chart_set_next_value2(lv_obj_t *obj, lv_chart_series_t *ser, lv_coord_t x_value, lv_coord_t y_value)
 */
 
STATIC mp_obj_t mp_lv_chart_set_next_value2(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_chart_series_t *ser = mp_write_ptr_lv_chart_series_t(mp_args[1]);
    lv_coord_t x_value = (int16_t)mp_obj_get_int(mp_args[2]);
    lv_coord_t y_value = (int16_t)mp_obj_get_int(mp_args[3]);
    ((void (*)(lv_obj_t *, lv_chart_series_t *, lv_coord_t, lv_coord_t))lv_func_ptr)(obj, ser, x_value, y_value);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_chart_set_next_value2_obj, 4, mp_lv_chart_set_next_value2, lv_chart_set_next_value2);
    

/*
 * lvgl extension definition for:
 * void lv_chart_set_value_by_id(lv_obj_t *obj, lv_chart_series_t *ser, uint16_t id, lv_coord_t value)
 */
 
STATIC mp_obj_t mp_lv_chart_set_value_by_id(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_chart_series_t *ser = mp_write_ptr_lv_chart_series_t(mp_args[1]);
    uint16_t id = (uint16_t)mp_obj_get_int(mp_args[2]);
    lv_coord_t value = (int16_t)mp_obj_get_int(mp_args[3]);
    ((void (*)(lv_obj_t *, lv_chart_series_t *, uint16_t, lv_coord_t))lv_func_ptr)(obj, ser, id, value);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_chart_set_value_by_id_obj, 4, mp_lv_chart_set_value_by_id, lv_chart_set_value_by_id);
    

/*
 * lvgl extension definition for:
 * void lv_chart_set_value_by_id2(lv_obj_t *obj, lv_chart_series_t *ser, uint16_t id, lv_coord_t x_value, lv_coord_t y_value)
 */
 
STATIC mp_obj_t mp_lv_chart_set_value_by_id2(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_chart_series_t *ser = mp_write_ptr_lv_chart_series_t(mp_args[1]);
    uint16_t id = (uint16_t)mp_obj_get_int(mp_args[2]);
    lv_coord_t x_value = (int16_t)mp_obj_get_int(mp_args[3]);
    lv_coord_t y_value = (int16_t)mp_obj_get_int(mp_args[4]);
    ((void (*)(lv_obj_t *, lv_chart_series_t *, uint16_t, lv_coord_t, lv_coord_t))lv_func_ptr)(obj, ser, id, x_value, y_value);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_chart_set_value_by_id2_obj, 5, mp_lv_chart_set_value_by_id2, lv_chart_set_value_by_id2);
    

/*
 * lvgl extension definition for:
 * void lv_chart_set_ext_y_array(lv_obj_t *obj, lv_chart_series_t *ser, lv_coord_t array[])
 */
 
STATIC mp_obj_t mp_lv_chart_set_ext_y_array(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_chart_series_t *ser = mp_write_ptr_lv_chart_series_t(mp_args[1]);
    lv_coord_t *array = mp_arr_to_lv_coord_t_____(mp_args[2]);
    ((void (*)(lv_obj_t *, lv_chart_series_t *, lv_coord_t []))lv_func_ptr)(obj, ser, array);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_chart_set_ext_y_array_obj, 3, mp_lv_chart_set_ext_y_array, lv_chart_set_ext_y_array);
    
/* Reusing lv_chart_set_ext_y_array for lv_chart_set_ext_x_array */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_chart_set_ext_x_array_obj, 3, mp_lv_chart_set_ext_y_array, lv_chart_set_ext_x_array);
    

/*
 * lvgl extension definition for:
 * lv_coord_t *lv_chart_get_y_array(const lv_obj_t *obj, lv_chart_series_t *ser)
 */
 
STATIC mp_obj_t mp_lv_chart_get_y_array(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_chart_series_t *ser = mp_write_ptr_lv_chart_series_t(mp_args[1]);
    lv_coord_t * _res = ((lv_coord_t *(*)(const lv_obj_t *, lv_chart_series_t *))lv_func_ptr)(obj, ser);
    return mp_arr_from_lv_coord_t_ptr((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_chart_get_y_array_obj, 2, mp_lv_chart_get_y_array, lv_chart_get_y_array);
    
/* Reusing lv_chart_get_y_array for lv_chart_get_x_array */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_chart_get_x_array_obj, 2, mp_lv_chart_get_y_array, lv_chart_get_x_array);
    
/* Reusing lv_label_get_text_selection_start for lv_chart_get_pressed_point */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_chart_get_pressed_point_obj, 1, mp_lv_label_get_text_selection_start, lv_chart_get_pressed_point);
    

/*
 * lvgl chart object definitions
 */
    

STATIC const mp_rom_map_elem_t chart_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_set_type), MP_ROM_PTR(&mp_lv_chart_set_type_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_point_count), MP_ROM_PTR(&mp_lv_chart_set_point_count_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_range), MP_ROM_PTR(&mp_lv_chart_set_range_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_update_mode), MP_ROM_PTR(&mp_lv_chart_set_update_mode_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_div_line_count), MP_ROM_PTR(&mp_lv_chart_set_div_line_count_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_zoom_x), MP_ROM_PTR(&mp_lv_chart_set_zoom_x_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_zoom_y), MP_ROM_PTR(&mp_lv_chart_set_zoom_y_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_zoom_x), MP_ROM_PTR(&mp_lv_chart_get_zoom_x_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_zoom_y), MP_ROM_PTR(&mp_lv_chart_get_zoom_y_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_axis_tick), MP_ROM_PTR(&mp_lv_chart_set_axis_tick_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_type), MP_ROM_PTR(&mp_lv_chart_get_type_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_point_count), MP_ROM_PTR(&mp_lv_chart_get_point_count_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_x_start_point), MP_ROM_PTR(&mp_lv_chart_get_x_start_point_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_point_pos_by_id), MP_ROM_PTR(&mp_lv_chart_get_point_pos_by_id_obj) },
    { MP_ROM_QSTR(MP_QSTR_refresh), MP_ROM_PTR(&mp_lv_chart_refresh_obj) },
    { MP_ROM_QSTR(MP_QSTR_add_series), MP_ROM_PTR(&mp_lv_chart_add_series_obj) },
    { MP_ROM_QSTR(MP_QSTR_remove_series), MP_ROM_PTR(&mp_lv_chart_remove_series_obj) },
    { MP_ROM_QSTR(MP_QSTR_hide_series), MP_ROM_PTR(&mp_lv_chart_hide_series_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_series_color), MP_ROM_PTR(&mp_lv_chart_set_series_color_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_x_start_point), MP_ROM_PTR(&mp_lv_chart_set_x_start_point_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_series_next), MP_ROM_PTR(&mp_lv_chart_get_series_next_obj) },
    { MP_ROM_QSTR(MP_QSTR_add_cursor), MP_ROM_PTR(&mp_lv_chart_add_cursor_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_cursor_pos), MP_ROM_PTR(&mp_lv_chart_set_cursor_pos_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_cursor_point), MP_ROM_PTR(&mp_lv_chart_set_cursor_point_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_cursor_point), MP_ROM_PTR(&mp_lv_chart_get_cursor_point_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_all_value), MP_ROM_PTR(&mp_lv_chart_set_all_value_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_next_value), MP_ROM_PTR(&mp_lv_chart_set_next_value_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_next_value2), MP_ROM_PTR(&mp_lv_chart_set_next_value2_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_value_by_id), MP_ROM_PTR(&mp_lv_chart_set_value_by_id_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_value_by_id2), MP_ROM_PTR(&mp_lv_chart_set_value_by_id2_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_ext_y_array), MP_ROM_PTR(&mp_lv_chart_set_ext_y_array_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_ext_x_array), MP_ROM_PTR(&mp_lv_chart_set_ext_x_array_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_y_array), MP_ROM_PTR(&mp_lv_chart_get_y_array_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_x_array), MP_ROM_PTR(&mp_lv_chart_get_x_array_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_pressed_point), MP_ROM_PTR(&mp_lv_chart_get_pressed_point_obj) },
    { MP_ROM_QSTR(MP_QSTR_TYPE), MP_ROM_PTR(&mp_LV_CHART_TYPE_type) },
    { MP_ROM_QSTR(MP_QSTR_UPDATE_MODE), MP_ROM_PTR(&mp_LV_CHART_UPDATE_MODE_type) },
    { MP_ROM_QSTR(MP_QSTR_AXIS), MP_ROM_PTR(&mp_LV_CHART_AXIS_type) },
    { MP_ROM_QSTR(MP_QSTR_DRAW_PART), MP_ROM_PTR(&mp_LV_CHART_DRAW_PART_type) }
};

STATIC MP_DEFINE_CONST_DICT(chart_locals_dict, chart_locals_dict_table);

STATIC void chart_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl chart");
}


STATIC mp_obj_t chart_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&lv_chart_create, type, n_args, n_kw, args);           
}


STATIC const mp_obj_type_t mp_chart_type = {
    { &mp_type_type },
    .name = MP_QSTR_chart,
    .print = chart_print,
    .make_new = chart_make_new,
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&chart_locals_dict,
    .buffer_p = { .get_buffer = mp_lv_obj_get_buffer },
    .parent = &mp_obj_type,
};
    
/* Reusing lv_btnmatrix_get_map for lv_keyboard_get_map_array */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_keyboard_get_map_array_obj, 1, mp_lv_btnmatrix_get_map, lv_keyboard_get_map_array);
    
/* Reusing lv_btnmatrix_get_selected_btn for lv_keyboard_get_selected_btn */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_keyboard_get_selected_btn_obj, 1, mp_lv_btnmatrix_get_selected_btn, lv_keyboard_get_selected_btn);
    
/* Reusing lv_btnmatrix_get_btn_text for lv_keyboard_get_btn_text */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_keyboard_get_btn_text_obj, 2, mp_lv_btnmatrix_get_btn_text, lv_keyboard_get_btn_text);
    

/*
 * lvgl extension definition for:
 * void lv_keyboard_set_textarea(lv_obj_t *kb, lv_obj_t *ta)
 */
 
STATIC mp_obj_t mp_lv_keyboard_set_textarea(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *kb = mp_to_lv(mp_args[0]);
    lv_obj_t *ta = mp_to_lv(mp_args[1]);
    ((void (*)(lv_obj_t *, lv_obj_t *))lv_func_ptr)(kb, ta);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_keyboard_set_textarea_obj, 2, mp_lv_keyboard_set_textarea, lv_keyboard_set_textarea);
    

/*
 * lvgl extension definition for:
 * void lv_keyboard_set_mode(lv_obj_t *kb, lv_keyboard_mode_t mode)
 */
 
STATIC mp_obj_t mp_lv_keyboard_set_mode(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *kb = mp_to_lv(mp_args[0]);
    lv_keyboard_mode_t mode = (uint8_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_obj_t *, lv_keyboard_mode_t))lv_func_ptr)(kb, mode);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_keyboard_set_mode_obj, 2, mp_lv_keyboard_set_mode, lv_keyboard_set_mode);
    
/* Reusing lv_obj_set_page_glue for lv_keyboard_set_popovers */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_keyboard_set_popovers_obj, 2, mp_lv_obj_set_page_glue, lv_keyboard_set_popovers);
    

/*
 * lvgl extension definition for:
 * void lv_keyboard_set_map(lv_obj_t *kb, lv_keyboard_mode_t mode, const char *map[], const lv_btnmatrix_ctrl_t ctrl_map[])
 */
 
STATIC mp_obj_t mp_lv_keyboard_set_map(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *kb = mp_to_lv(mp_args[0]);
    lv_keyboard_mode_t mode = (uint8_t)mp_obj_get_int(mp_args[1]);
    const char **map = mp_arr_to_char_ptr____(mp_args[2]);
    const lv_btnmatrix_ctrl_t *ctrl_map = mp_arr_to_lv_btnmatrix_ctrl_t_____(mp_args[3]);
    ((void (*)(lv_obj_t *, lv_keyboard_mode_t, const char *[], const lv_btnmatrix_ctrl_t []))lv_func_ptr)(kb, mode, map, ctrl_map);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_keyboard_set_map_obj, 4, mp_lv_keyboard_set_map, lv_keyboard_set_map);
    
/* Reusing lv_textarea_get_label for lv_keyboard_get_textarea */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_keyboard_get_textarea_obj, 1, mp_lv_textarea_get_label, lv_keyboard_get_textarea);
    

/*
 * lvgl extension definition for:
 * lv_keyboard_mode_t lv_keyboard_get_mode(const lv_obj_t *kb)
 */
 
STATIC mp_obj_t mp_lv_keyboard_get_mode(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *kb = mp_to_lv(mp_args[0]);
    lv_keyboard_mode_t _res = ((lv_keyboard_mode_t (*)(const lv_obj_t *))lv_func_ptr)(kb);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_keyboard_get_mode_obj, 1, mp_lv_keyboard_get_mode, lv_keyboard_get_mode);
    

/*
 * lvgl extension definition for:
 * void lv_keyboard_def_event_cb(lv_event_t *e)
 */
 
STATIC mp_obj_t mp_lv_keyboard_def_event_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_event_t *e = mp_write_ptr_lv_event_t(mp_args[0]);
    ((void (*)(lv_event_t *))lv_func_ptr)(e);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_keyboard_def_event_cb_obj, 1, mp_lv_keyboard_def_event_cb, lv_keyboard_def_event_cb);
    

/*
 * lvgl keyboard object definitions
 */
    

STATIC const mp_rom_map_elem_t keyboard_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_get_map_array), MP_ROM_PTR(&mp_lv_keyboard_get_map_array_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_selected_btn), MP_ROM_PTR(&mp_lv_keyboard_get_selected_btn_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_btn_text), MP_ROM_PTR(&mp_lv_keyboard_get_btn_text_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_textarea), MP_ROM_PTR(&mp_lv_keyboard_set_textarea_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_mode), MP_ROM_PTR(&mp_lv_keyboard_set_mode_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_popovers), MP_ROM_PTR(&mp_lv_keyboard_set_popovers_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_map), MP_ROM_PTR(&mp_lv_keyboard_set_map_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_textarea), MP_ROM_PTR(&mp_lv_keyboard_get_textarea_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_mode), MP_ROM_PTR(&mp_lv_keyboard_get_mode_obj) },
    { MP_ROM_QSTR(MP_QSTR_def_event_cb), MP_ROM_PTR(&mp_lv_keyboard_def_event_cb_obj) },
    { MP_ROM_QSTR(MP_QSTR_MODE), MP_ROM_PTR(&mp_LV_KEYBOARD_MODE_type) }
};

STATIC MP_DEFINE_CONST_DICT(keyboard_locals_dict, keyboard_locals_dict_table);

STATIC void keyboard_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl keyboard");
}


STATIC mp_obj_t keyboard_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&lv_keyboard_create, type, n_args, n_kw, args);           
}


STATIC const mp_obj_type_t mp_keyboard_type = {
    { &mp_type_type },
    .name = MP_QSTR_keyboard,
    .print = keyboard_print,
    .make_new = keyboard_make_new,
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&keyboard_locals_dict,
    .buffer_p = { .get_buffer = mp_lv_obj_get_buffer },
    .parent = &mp_obj_type,
};
    

/*
 * lvgl extension definition for:
 * lv_obj_t *lv_list_add_text(lv_obj_t *list, const char *txt)
 */
 
STATIC mp_obj_t mp_lv_list_add_text(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *list = mp_to_lv(mp_args[0]);
    const char *txt = (char*)convert_from_str(mp_args[1]);
    lv_obj_t * _res = ((lv_obj_t *(*)(lv_obj_t *, const char *))lv_func_ptr)(list, txt);
    return lv_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_list_add_text_obj, 2, mp_lv_list_add_text, lv_list_add_text);
    

/*
 * lvgl extension definition for:
 * lv_obj_t *lv_list_add_btn(lv_obj_t *list, const void *icon, const char *txt)
 */
 
STATIC mp_obj_t mp_lv_list_add_btn(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *list = mp_to_lv(mp_args[0]);
    const void *icon = mp_to_ptr(mp_args[1]);
    const char *txt = (char*)convert_from_str(mp_args[2]);
    lv_obj_t * _res = ((lv_obj_t *(*)(lv_obj_t *, const void *, const char *))lv_func_ptr)(list, icon, txt);
    return lv_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_list_add_btn_obj, 3, mp_lv_list_add_btn, lv_list_add_btn);
    

/*
 * lvgl extension definition for:
 * const char *lv_list_get_btn_text(lv_obj_t *list, lv_obj_t *btn)
 */
 
STATIC mp_obj_t mp_lv_list_get_btn_text(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *list = mp_to_lv(mp_args[0]);
    lv_obj_t *btn = mp_to_lv(mp_args[1]);
    const char * _res = ((const char *(*)(lv_obj_t *, lv_obj_t *))lv_func_ptr)(list, btn);
    return convert_to_str((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_list_get_btn_text_obj, 2, mp_lv_list_get_btn_text, lv_list_get_btn_text);
    

/*
 * lvgl list object definitions
 */
    

STATIC const mp_rom_map_elem_t list_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_add_text), MP_ROM_PTR(&mp_lv_list_add_text_obj) },
    { MP_ROM_QSTR(MP_QSTR_add_btn), MP_ROM_PTR(&mp_lv_list_add_btn_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_btn_text), MP_ROM_PTR(&mp_lv_list_get_btn_text_obj) }
};

STATIC MP_DEFINE_CONST_DICT(list_locals_dict, list_locals_dict_table);

STATIC void list_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl list");
}


STATIC mp_obj_t list_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&lv_list_create, type, n_args, n_kw, args);           
}


STATIC const mp_obj_type_t mp_list_type = {
    { &mp_type_type },
    .name = MP_QSTR_list,
    .print = list_print,
    .make_new = list_make_new,
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&list_locals_dict,
    .buffer_p = { .get_buffer = mp_lv_obj_get_buffer },
    .parent = &mp_obj_type,
};
    

/*
 * lvgl extension definition for:
 * lv_obj_t *lv_menu_page_create(lv_obj_t *parent, char *title)
 */
 
STATIC mp_obj_t mp_lv_menu_page_create(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *parent = mp_to_lv(mp_args[0]);
    char *title = (char*)convert_from_str(mp_args[1]);
    lv_obj_t * _res = ((lv_obj_t *(*)(lv_obj_t *, char *))lv_func_ptr)(parent, title);
    return lv_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_menu_page_create_obj, 2, mp_lv_menu_page_create, lv_menu_page_create);
    
/* Reusing lv_dropdown_get_list for lv_menu_cont_create */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_menu_cont_create_obj, 1, mp_lv_dropdown_get_list, lv_menu_cont_create);
    
/* Reusing lv_dropdown_get_list for lv_menu_section_create */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_menu_section_create_obj, 1, mp_lv_dropdown_get_list, lv_menu_section_create);
    
/* Reusing lv_dropdown_get_list for lv_menu_separator_create */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_menu_separator_create_obj, 1, mp_lv_dropdown_get_list, lv_menu_separator_create);
    
/* Reusing lv_keyboard_set_textarea for lv_menu_set_page */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_menu_set_page_obj, 2, mp_lv_keyboard_set_textarea, lv_menu_set_page);
    
/* Reusing lv_keyboard_set_textarea for lv_menu_set_sidebar_page */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_menu_set_sidebar_page_obj, 2, mp_lv_keyboard_set_textarea, lv_menu_set_sidebar_page);
    

/*
 * lvgl extension definition for:
 * void lv_menu_set_mode_header(lv_obj_t *obj, lv_menu_mode_header_t mode_header)
 */
 
STATIC mp_obj_t mp_lv_menu_set_mode_header(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_menu_mode_header_t mode_header = (uint8_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_obj_t *, lv_menu_mode_header_t))lv_func_ptr)(obj, mode_header);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_menu_set_mode_header_obj, 2, mp_lv_menu_set_mode_header, lv_menu_set_mode_header);
    

/*
 * lvgl extension definition for:
 * void lv_menu_set_mode_root_back_btn(lv_obj_t *obj, lv_menu_mode_root_back_btn_t mode_root_back_btn)
 */
 
STATIC mp_obj_t mp_lv_menu_set_mode_root_back_btn(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_menu_mode_root_back_btn_t mode_root_back_btn = (uint8_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_obj_t *, lv_menu_mode_root_back_btn_t))lv_func_ptr)(obj, mode_root_back_btn);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_menu_set_mode_root_back_btn_obj, 2, mp_lv_menu_set_mode_root_back_btn, lv_menu_set_mode_root_back_btn);
    

/*
 * lvgl extension definition for:
 * void lv_menu_set_load_page_event(lv_obj_t *menu, lv_obj_t *obj, lv_obj_t *page)
 */
 
STATIC mp_obj_t mp_lv_menu_set_load_page_event(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *menu = mp_to_lv(mp_args[0]);
    lv_obj_t *obj = mp_to_lv(mp_args[1]);
    lv_obj_t *page = mp_to_lv(mp_args[2]);
    ((void (*)(lv_obj_t *, lv_obj_t *, lv_obj_t *))lv_func_ptr)(menu, obj, page);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_menu_set_load_page_event_obj, 3, mp_lv_menu_set_load_page_event, lv_menu_set_load_page_event);
    
/* Reusing lv_dropdown_get_list for lv_menu_get_cur_main_page */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_menu_get_cur_main_page_obj, 1, mp_lv_dropdown_get_list, lv_menu_get_cur_main_page);
    
/* Reusing lv_dropdown_get_list for lv_menu_get_cur_sidebar_page */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_menu_get_cur_sidebar_page_obj, 1, mp_lv_dropdown_get_list, lv_menu_get_cur_sidebar_page);
    
/* Reusing lv_dropdown_get_list for lv_menu_get_main_header */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_menu_get_main_header_obj, 1, mp_lv_dropdown_get_list, lv_menu_get_main_header);
    
/* Reusing lv_dropdown_get_list for lv_menu_get_main_header_back_btn */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_menu_get_main_header_back_btn_obj, 1, mp_lv_dropdown_get_list, lv_menu_get_main_header_back_btn);
    
/* Reusing lv_dropdown_get_list for lv_menu_get_sidebar_header */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_menu_get_sidebar_header_obj, 1, mp_lv_dropdown_get_list, lv_menu_get_sidebar_header);
    
/* Reusing lv_dropdown_get_list for lv_menu_get_sidebar_header_back_btn */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_menu_get_sidebar_header_back_btn_obj, 1, mp_lv_dropdown_get_list, lv_menu_get_sidebar_header_back_btn);
    

/*
 * lvgl extension definition for:
 * bool lv_menu_back_btn_is_root(lv_obj_t *menu, lv_obj_t *obj)
 */
 
STATIC mp_obj_t mp_lv_menu_back_btn_is_root(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *menu = mp_to_lv(mp_args[0]);
    lv_obj_t *obj = mp_to_lv(mp_args[1]);
    bool _res = ((bool (*)(lv_obj_t *, lv_obj_t *))lv_func_ptr)(menu, obj);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_menu_back_btn_is_root_obj, 2, mp_lv_menu_back_btn_is_root, lv_menu_back_btn_is_root);
    
/* Reusing lv_obj_move_foreground for lv_menu_clear_history */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_menu_clear_history_obj, 1, mp_lv_obj_move_foreground, lv_menu_clear_history);
    

/*
 * lvgl menu object definitions
 */
    

STATIC const mp_rom_map_elem_t menu_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_page_create), MP_ROM_PTR(&mp_lv_menu_page_create_obj) },
    { MP_ROM_QSTR(MP_QSTR_cont_create), MP_ROM_PTR(&mp_lv_menu_cont_create_obj) },
    { MP_ROM_QSTR(MP_QSTR_section_create), MP_ROM_PTR(&mp_lv_menu_section_create_obj) },
    { MP_ROM_QSTR(MP_QSTR_separator_create), MP_ROM_PTR(&mp_lv_menu_separator_create_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_page), MP_ROM_PTR(&mp_lv_menu_set_page_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_sidebar_page), MP_ROM_PTR(&mp_lv_menu_set_sidebar_page_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_mode_header), MP_ROM_PTR(&mp_lv_menu_set_mode_header_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_mode_root_back_btn), MP_ROM_PTR(&mp_lv_menu_set_mode_root_back_btn_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_load_page_event), MP_ROM_PTR(&mp_lv_menu_set_load_page_event_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_cur_main_page), MP_ROM_PTR(&mp_lv_menu_get_cur_main_page_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_cur_sidebar_page), MP_ROM_PTR(&mp_lv_menu_get_cur_sidebar_page_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_main_header), MP_ROM_PTR(&mp_lv_menu_get_main_header_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_main_header_back_btn), MP_ROM_PTR(&mp_lv_menu_get_main_header_back_btn_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_sidebar_header), MP_ROM_PTR(&mp_lv_menu_get_sidebar_header_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_sidebar_header_back_btn), MP_ROM_PTR(&mp_lv_menu_get_sidebar_header_back_btn_obj) },
    { MP_ROM_QSTR(MP_QSTR_back_btn_is_root), MP_ROM_PTR(&mp_lv_menu_back_btn_is_root_obj) },
    { MP_ROM_QSTR(MP_QSTR_clear_history), MP_ROM_PTR(&mp_lv_menu_clear_history_obj) },
    { MP_ROM_QSTR(MP_QSTR_HEADER), MP_ROM_PTR(&mp_LV_MENU_HEADER_type) },
    { MP_ROM_QSTR(MP_QSTR_ROOT_BACK_BTN), MP_ROM_PTR(&mp_LV_MENU_ROOT_BACK_BTN_type) }
};

STATIC MP_DEFINE_CONST_DICT(menu_locals_dict, menu_locals_dict_table);

STATIC void menu_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl menu");
}


STATIC mp_obj_t menu_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&lv_menu_create, type, n_args, n_kw, args);           
}


STATIC const mp_obj_type_t mp_menu_type = {
    { &mp_type_type },
    .name = MP_QSTR_menu,
    .print = menu_print,
    .make_new = menu_make_new,
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&menu_locals_dict,
    .buffer_p = { .get_buffer = mp_lv_obj_get_buffer },
    .parent = &mp_obj_type,
};
    
/* Reusing lv_dropdown_get_list for lv_msgbox_get_title */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_msgbox_get_title_obj, 1, mp_lv_dropdown_get_list, lv_msgbox_get_title);
    
/* Reusing lv_dropdown_get_list for lv_msgbox_get_close_btn */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_msgbox_get_close_btn_obj, 1, mp_lv_dropdown_get_list, lv_msgbox_get_close_btn);
    
/* Reusing lv_dropdown_get_list for lv_msgbox_get_text */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_msgbox_get_text_obj, 1, mp_lv_dropdown_get_list, lv_msgbox_get_text);
    
/* Reusing lv_dropdown_get_list for lv_msgbox_get_content */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_msgbox_get_content_obj, 1, mp_lv_dropdown_get_list, lv_msgbox_get_content);
    
/* Reusing lv_dropdown_get_list for lv_msgbox_get_btns */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_msgbox_get_btns_obj, 1, mp_lv_dropdown_get_list, lv_msgbox_get_btns);
    
/* Reusing lv_arc_get_angle_start for lv_msgbox_get_active_btn */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_msgbox_get_active_btn_obj, 1, mp_lv_arc_get_angle_start, lv_msgbox_get_active_btn);
    
/* Reusing lv_dropdown_get_text for lv_msgbox_get_active_btn_text */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_msgbox_get_active_btn_text_obj, 1, mp_lv_dropdown_get_text, lv_msgbox_get_active_btn_text);
    
/* Reusing lv_obj_move_foreground for lv_msgbox_close */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_msgbox_close_obj, 1, mp_lv_obj_move_foreground, lv_msgbox_close);
    
/* Reusing lv_obj_move_foreground for lv_msgbox_close_async */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_msgbox_close_async_obj, 1, mp_lv_obj_move_foreground, lv_msgbox_close_async);
    

/*
 * lvgl msgbox object definitions
 */
    

STATIC const mp_rom_map_elem_t msgbox_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_get_title), MP_ROM_PTR(&mp_lv_msgbox_get_title_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_close_btn), MP_ROM_PTR(&mp_lv_msgbox_get_close_btn_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_text), MP_ROM_PTR(&mp_lv_msgbox_get_text_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_content), MP_ROM_PTR(&mp_lv_msgbox_get_content_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_btns), MP_ROM_PTR(&mp_lv_msgbox_get_btns_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_active_btn), MP_ROM_PTR(&mp_lv_msgbox_get_active_btn_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_active_btn_text), MP_ROM_PTR(&mp_lv_msgbox_get_active_btn_text_obj) },
    { MP_ROM_QSTR(MP_QSTR_close), MP_ROM_PTR(&mp_lv_msgbox_close_obj) },
    { MP_ROM_QSTR(MP_QSTR_close_async), MP_ROM_PTR(&mp_lv_msgbox_close_async_obj) }
};

STATIC MP_DEFINE_CONST_DICT(msgbox_locals_dict, msgbox_locals_dict_table);

STATIC void msgbox_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl msgbox");
}


STATIC mp_obj_t msgbox_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&lv_msgbox_create, type, n_args, n_kw, args);           
}


STATIC const mp_obj_type_t mp_msgbox_type = {
    { &mp_type_type },
    .name = MP_QSTR_msgbox,
    .print = msgbox_print,
    .make_new = msgbox_make_new,
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&msgbox_locals_dict,
    .buffer_p = { .get_buffer = mp_lv_obj_get_buffer },
    .parent = &mp_obj_type,
};
    

/*
 * Struct lv_meter_scale_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_meter_scale_t_type();

STATIC inline lv_meter_scale_t* mp_write_ptr_lv_meter_scale_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_meter_scale_t_type()));
    return (lv_meter_scale_t*)self->data;
}

#define mp_write_lv_meter_scale_t(struct_obj) *mp_write_ptr_lv_meter_scale_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_meter_scale_t(lv_meter_scale_t *field)
{
    return lv_to_mp_struct(get_mp_lv_meter_scale_t_type(), (void*)field);
}

#define mp_read_lv_meter_scale_t(field) mp_read_ptr_lv_meter_scale_t(copy_buffer(&field, sizeof(lv_meter_scale_t)))
#define mp_read_byref_lv_meter_scale_t(field) mp_read_ptr_lv_meter_scale_t(&field)

STATIC void mp_lv_meter_scale_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_meter_scale_t *data = (lv_meter_scale_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_tick_color: dest[0] = mp_read_byref_lv_color16_t(data->tick_color); break; // converting from lv_color_t;
            case MP_QSTR_tick_cnt: dest[0] = mp_obj_new_int_from_uint(data->tick_cnt); break; // converting from uint16_t;
            case MP_QSTR_tick_length: dest[0] = mp_obj_new_int_from_uint(data->tick_length); break; // converting from uint16_t;
            case MP_QSTR_tick_width: dest[0] = mp_obj_new_int_from_uint(data->tick_width); break; // converting from uint16_t;
            case MP_QSTR_tick_major_color: dest[0] = mp_read_byref_lv_color16_t(data->tick_major_color); break; // converting from lv_color_t;
            case MP_QSTR_tick_major_nth: dest[0] = mp_obj_new_int_from_uint(data->tick_major_nth); break; // converting from uint16_t;
            case MP_QSTR_tick_major_length: dest[0] = mp_obj_new_int_from_uint(data->tick_major_length); break; // converting from uint16_t;
            case MP_QSTR_tick_major_width: dest[0] = mp_obj_new_int_from_uint(data->tick_major_width); break; // converting from uint16_t;
            case MP_QSTR_label_gap: dest[0] = mp_obj_new_int(data->label_gap); break; // converting from int16_t;
            case MP_QSTR_label_color: dest[0] = mp_obj_new_int(data->label_color); break; // converting from int16_t;
            case MP_QSTR_min: dest[0] = mp_obj_new_int(data->min); break; // converting from int32_t;
            case MP_QSTR_max: dest[0] = mp_obj_new_int(data->max); break; // converting from int32_t;
            case MP_QSTR_r_mod: dest[0] = mp_obj_new_int(data->r_mod); break; // converting from int16_t;
            case MP_QSTR_angle_range: dest[0] = mp_obj_new_int_from_uint(data->angle_range); break; // converting from uint16_t;
            case MP_QSTR_rotation: dest[0] = mp_obj_new_int(data->rotation); break; // converting from int16_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_tick_color: data->tick_color = mp_write_lv_color16_t(dest[1]); break; // converting to lv_color_t;
                case MP_QSTR_tick_cnt: data->tick_cnt = (uint16_t)mp_obj_get_int(dest[1]); break; // converting to uint16_t;
                case MP_QSTR_tick_length: data->tick_length = (uint16_t)mp_obj_get_int(dest[1]); break; // converting to uint16_t;
                case MP_QSTR_tick_width: data->tick_width = (uint16_t)mp_obj_get_int(dest[1]); break; // converting to uint16_t;
                case MP_QSTR_tick_major_color: data->tick_major_color = mp_write_lv_color16_t(dest[1]); break; // converting to lv_color_t;
                case MP_QSTR_tick_major_nth: data->tick_major_nth = (uint16_t)mp_obj_get_int(dest[1]); break; // converting to uint16_t;
                case MP_QSTR_tick_major_length: data->tick_major_length = (uint16_t)mp_obj_get_int(dest[1]); break; // converting to uint16_t;
                case MP_QSTR_tick_major_width: data->tick_major_width = (uint16_t)mp_obj_get_int(dest[1]); break; // converting to uint16_t;
                case MP_QSTR_label_gap: data->label_gap = (int16_t)mp_obj_get_int(dest[1]); break; // converting to int16_t;
                case MP_QSTR_label_color: data->label_color = (int16_t)mp_obj_get_int(dest[1]); break; // converting to int16_t;
                case MP_QSTR_min: data->min = (int32_t)mp_obj_get_int(dest[1]); break; // converting to int32_t;
                case MP_QSTR_max: data->max = (int32_t)mp_obj_get_int(dest[1]); break; // converting to int32_t;
                case MP_QSTR_r_mod: data->r_mod = (int16_t)mp_obj_get_int(dest[1]); break; // converting to int16_t;
                case MP_QSTR_angle_range: data->angle_range = (uint16_t)mp_obj_get_int(dest[1]); break; // converting to uint16_t;
                case MP_QSTR_rotation: data->rotation = (int16_t)mp_obj_get_int(dest[1]); break; // converting to int16_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_meter_scale_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_meter_scale_t");
}

STATIC const mp_obj_dict_t mp_lv_meter_scale_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_meter_scale_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_meter_scale_t,
    .print = mp_lv_meter_scale_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_meter_scale_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_meter_scale_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_meter_scale_t_type()
{
    return &mp_lv_meter_scale_t_type;
}
    

/*
 * lvgl extension definition for:
 * lv_meter_scale_t *lv_meter_add_scale(lv_obj_t *obj)
 */
 
STATIC mp_obj_t mp_lv_meter_add_scale(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_meter_scale_t * _res = ((lv_meter_scale_t *(*)(lv_obj_t *))lv_func_ptr)(obj);
    return mp_read_ptr_lv_meter_scale_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_meter_add_scale_obj, 1, mp_lv_meter_add_scale, lv_meter_add_scale);
    

/*
 * lvgl extension definition for:
 * void lv_meter_set_scale_ticks(lv_obj_t *obj, lv_meter_scale_t *scale, uint16_t cnt, uint16_t width, uint16_t len, lv_color_t color)
 */
 
STATIC mp_obj_t mp_lv_meter_set_scale_ticks(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_meter_scale_t *scale = mp_write_ptr_lv_meter_scale_t(mp_args[1]);
    uint16_t cnt = (uint16_t)mp_obj_get_int(mp_args[2]);
    uint16_t width = (uint16_t)mp_obj_get_int(mp_args[3]);
    uint16_t len = (uint16_t)mp_obj_get_int(mp_args[4]);
    lv_color_t color = mp_write_lv_color16_t(mp_args[5]);
    ((void (*)(lv_obj_t *, lv_meter_scale_t *, uint16_t, uint16_t, uint16_t, lv_color_t))lv_func_ptr)(obj, scale, cnt, width, len, color);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_meter_set_scale_ticks_obj, 6, mp_lv_meter_set_scale_ticks, lv_meter_set_scale_ticks);
    

/*
 * lvgl extension definition for:
 * void lv_meter_set_scale_major_ticks(lv_obj_t *obj, lv_meter_scale_t *scale, uint16_t nth, uint16_t width, uint16_t len, lv_color_t color, int16_t label_gap)
 */
 
STATIC mp_obj_t mp_lv_meter_set_scale_major_ticks(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_meter_scale_t *scale = mp_write_ptr_lv_meter_scale_t(mp_args[1]);
    uint16_t nth = (uint16_t)mp_obj_get_int(mp_args[2]);
    uint16_t width = (uint16_t)mp_obj_get_int(mp_args[3]);
    uint16_t len = (uint16_t)mp_obj_get_int(mp_args[4]);
    lv_color_t color = mp_write_lv_color16_t(mp_args[5]);
    int16_t label_gap = (int16_t)mp_obj_get_int(mp_args[6]);
    ((void (*)(lv_obj_t *, lv_meter_scale_t *, uint16_t, uint16_t, uint16_t, lv_color_t, int16_t))lv_func_ptr)(obj, scale, nth, width, len, color, label_gap);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_meter_set_scale_major_ticks_obj, 7, mp_lv_meter_set_scale_major_ticks, lv_meter_set_scale_major_ticks);
    

/*
 * lvgl extension definition for:
 * void lv_meter_set_scale_range(lv_obj_t *obj, lv_meter_scale_t *scale, int32_t min, int32_t max, uint32_t angle_range, uint32_t rotation)
 */
 
STATIC mp_obj_t mp_lv_meter_set_scale_range(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_meter_scale_t *scale = mp_write_ptr_lv_meter_scale_t(mp_args[1]);
    int32_t min = (int32_t)mp_obj_get_int(mp_args[2]);
    int32_t max = (int32_t)mp_obj_get_int(mp_args[3]);
    uint32_t angle_range = (uint32_t)mp_obj_get_int(mp_args[4]);
    uint32_t rotation = (uint32_t)mp_obj_get_int(mp_args[5]);
    ((void (*)(lv_obj_t *, lv_meter_scale_t *, int32_t, int32_t, uint32_t, uint32_t))lv_func_ptr)(obj, scale, min, max, angle_range, rotation);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_meter_set_scale_range_obj, 6, mp_lv_meter_set_scale_range, lv_meter_set_scale_range);
    
typedef __typeof__( ((lv_meter_indicator_t*)(0))->type_data ) lv_meter_indicator_type_data_t;
typedef __typeof__( ((lv_meter_indicator_type_data_t*)(0))->needle_img ) lv_meter_indicator_type_data_needle_img_t;

/*
 * Struct lv_meter_indicator_type_data_needle_img_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_meter_indicator_type_data_needle_img_t_type();

STATIC inline lv_meter_indicator_type_data_needle_img_t* mp_write_ptr_lv_meter_indicator_type_data_needle_img_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_meter_indicator_type_data_needle_img_t_type()));
    return (lv_meter_indicator_type_data_needle_img_t*)self->data;
}

#define mp_write_lv_meter_indicator_type_data_needle_img_t(struct_obj) *mp_write_ptr_lv_meter_indicator_type_data_needle_img_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_meter_indicator_type_data_needle_img_t(lv_meter_indicator_type_data_needle_img_t *field)
{
    return lv_to_mp_struct(get_mp_lv_meter_indicator_type_data_needle_img_t_type(), (void*)field);
}

#define mp_read_lv_meter_indicator_type_data_needle_img_t(field) mp_read_ptr_lv_meter_indicator_type_data_needle_img_t(copy_buffer(&field, sizeof(lv_meter_indicator_type_data_needle_img_t)))
#define mp_read_byref_lv_meter_indicator_type_data_needle_img_t(field) mp_read_ptr_lv_meter_indicator_type_data_needle_img_t(&field)

STATIC void mp_lv_meter_indicator_type_data_needle_img_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_meter_indicator_type_data_needle_img_t *data = (lv_meter_indicator_type_data_needle_img_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_src: dest[0] = ptr_to_mp((void*)data->src); break; // converting from void *;
            case MP_QSTR_pivot: dest[0] = mp_read_byref_lv_point_t(data->pivot); break; // converting from lv_point_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_src: data->src = (void*)mp_to_ptr(dest[1]); break; // converting to void *;
                case MP_QSTR_pivot: data->pivot = mp_write_lv_point_t(dest[1]); break; // converting to lv_point_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_meter_indicator_type_data_needle_img_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_meter_indicator_type_data_needle_img_t");
}

STATIC const mp_obj_dict_t mp_lv_meter_indicator_type_data_needle_img_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_meter_indicator_type_data_needle_img_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_meter_indicator_type_data_needle_img_t,
    .print = mp_lv_meter_indicator_type_data_needle_img_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_meter_indicator_type_data_needle_img_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_meter_indicator_type_data_needle_img_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_meter_indicator_type_data_needle_img_t_type()
{
    return &mp_lv_meter_indicator_type_data_needle_img_t_type;
}
    
typedef __typeof__( ((lv_meter_indicator_type_data_t*)(0))->needle_line ) lv_meter_indicator_type_data_needle_line_t;

/*
 * Struct lv_meter_indicator_type_data_needle_line_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_meter_indicator_type_data_needle_line_t_type();

STATIC inline lv_meter_indicator_type_data_needle_line_t* mp_write_ptr_lv_meter_indicator_type_data_needle_line_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_meter_indicator_type_data_needle_line_t_type()));
    return (lv_meter_indicator_type_data_needle_line_t*)self->data;
}

#define mp_write_lv_meter_indicator_type_data_needle_line_t(struct_obj) *mp_write_ptr_lv_meter_indicator_type_data_needle_line_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_meter_indicator_type_data_needle_line_t(lv_meter_indicator_type_data_needle_line_t *field)
{
    return lv_to_mp_struct(get_mp_lv_meter_indicator_type_data_needle_line_t_type(), (void*)field);
}

#define mp_read_lv_meter_indicator_type_data_needle_line_t(field) mp_read_ptr_lv_meter_indicator_type_data_needle_line_t(copy_buffer(&field, sizeof(lv_meter_indicator_type_data_needle_line_t)))
#define mp_read_byref_lv_meter_indicator_type_data_needle_line_t(field) mp_read_ptr_lv_meter_indicator_type_data_needle_line_t(&field)

STATIC void mp_lv_meter_indicator_type_data_needle_line_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_meter_indicator_type_data_needle_line_t *data = (lv_meter_indicator_type_data_needle_line_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_width: dest[0] = mp_obj_new_int_from_uint(data->width); break; // converting from uint16_t;
            case MP_QSTR_r_mod: dest[0] = mp_obj_new_int(data->r_mod); break; // converting from int16_t;
            case MP_QSTR_color: dest[0] = mp_read_byref_lv_color16_t(data->color); break; // converting from lv_color_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_width: data->width = (uint16_t)mp_obj_get_int(dest[1]); break; // converting to uint16_t;
                case MP_QSTR_r_mod: data->r_mod = (int16_t)mp_obj_get_int(dest[1]); break; // converting to int16_t;
                case MP_QSTR_color: data->color = mp_write_lv_color16_t(dest[1]); break; // converting to lv_color_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_meter_indicator_type_data_needle_line_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_meter_indicator_type_data_needle_line_t");
}

STATIC const mp_obj_dict_t mp_lv_meter_indicator_type_data_needle_line_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_meter_indicator_type_data_needle_line_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_meter_indicator_type_data_needle_line_t,
    .print = mp_lv_meter_indicator_type_data_needle_line_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_meter_indicator_type_data_needle_line_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_meter_indicator_type_data_needle_line_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_meter_indicator_type_data_needle_line_t_type()
{
    return &mp_lv_meter_indicator_type_data_needle_line_t_type;
}
    
typedef __typeof__( ((lv_meter_indicator_type_data_t*)(0))->arc ) lv_meter_indicator_type_data_arc_t;

/*
 * Struct lv_meter_indicator_type_data_arc_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_meter_indicator_type_data_arc_t_type();

STATIC inline lv_meter_indicator_type_data_arc_t* mp_write_ptr_lv_meter_indicator_type_data_arc_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_meter_indicator_type_data_arc_t_type()));
    return (lv_meter_indicator_type_data_arc_t*)self->data;
}

#define mp_write_lv_meter_indicator_type_data_arc_t(struct_obj) *mp_write_ptr_lv_meter_indicator_type_data_arc_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_meter_indicator_type_data_arc_t(lv_meter_indicator_type_data_arc_t *field)
{
    return lv_to_mp_struct(get_mp_lv_meter_indicator_type_data_arc_t_type(), (void*)field);
}

#define mp_read_lv_meter_indicator_type_data_arc_t(field) mp_read_ptr_lv_meter_indicator_type_data_arc_t(copy_buffer(&field, sizeof(lv_meter_indicator_type_data_arc_t)))
#define mp_read_byref_lv_meter_indicator_type_data_arc_t(field) mp_read_ptr_lv_meter_indicator_type_data_arc_t(&field)

STATIC void mp_lv_meter_indicator_type_data_arc_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_meter_indicator_type_data_arc_t *data = (lv_meter_indicator_type_data_arc_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_width: dest[0] = mp_obj_new_int_from_uint(data->width); break; // converting from uint16_t;
            case MP_QSTR_src: dest[0] = ptr_to_mp((void*)data->src); break; // converting from void *;
            case MP_QSTR_color: dest[0] = mp_read_byref_lv_color16_t(data->color); break; // converting from lv_color_t;
            case MP_QSTR_r_mod: dest[0] = mp_obj_new_int(data->r_mod); break; // converting from int16_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_width: data->width = (uint16_t)mp_obj_get_int(dest[1]); break; // converting to uint16_t;
                case MP_QSTR_src: data->src = (void*)mp_to_ptr(dest[1]); break; // converting to void *;
                case MP_QSTR_color: data->color = mp_write_lv_color16_t(dest[1]); break; // converting to lv_color_t;
                case MP_QSTR_r_mod: data->r_mod = (int16_t)mp_obj_get_int(dest[1]); break; // converting to int16_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_meter_indicator_type_data_arc_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_meter_indicator_type_data_arc_t");
}

STATIC const mp_obj_dict_t mp_lv_meter_indicator_type_data_arc_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_meter_indicator_type_data_arc_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_meter_indicator_type_data_arc_t,
    .print = mp_lv_meter_indicator_type_data_arc_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_meter_indicator_type_data_arc_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_meter_indicator_type_data_arc_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_meter_indicator_type_data_arc_t_type()
{
    return &mp_lv_meter_indicator_type_data_arc_t_type;
}
    
typedef __typeof__( ((lv_meter_indicator_type_data_t*)(0))->scale_lines ) lv_meter_indicator_type_data_scale_lines_t;

/*
 * Struct lv_meter_indicator_type_data_scale_lines_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_meter_indicator_type_data_scale_lines_t_type();

STATIC inline lv_meter_indicator_type_data_scale_lines_t* mp_write_ptr_lv_meter_indicator_type_data_scale_lines_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_meter_indicator_type_data_scale_lines_t_type()));
    return (lv_meter_indicator_type_data_scale_lines_t*)self->data;
}

#define mp_write_lv_meter_indicator_type_data_scale_lines_t(struct_obj) *mp_write_ptr_lv_meter_indicator_type_data_scale_lines_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_meter_indicator_type_data_scale_lines_t(lv_meter_indicator_type_data_scale_lines_t *field)
{
    return lv_to_mp_struct(get_mp_lv_meter_indicator_type_data_scale_lines_t_type(), (void*)field);
}

#define mp_read_lv_meter_indicator_type_data_scale_lines_t(field) mp_read_ptr_lv_meter_indicator_type_data_scale_lines_t(copy_buffer(&field, sizeof(lv_meter_indicator_type_data_scale_lines_t)))
#define mp_read_byref_lv_meter_indicator_type_data_scale_lines_t(field) mp_read_ptr_lv_meter_indicator_type_data_scale_lines_t(&field)

STATIC void mp_lv_meter_indicator_type_data_scale_lines_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_meter_indicator_type_data_scale_lines_t *data = (lv_meter_indicator_type_data_scale_lines_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_width_mod: dest[0] = mp_obj_new_int(data->width_mod); break; // converting from int16_t;
            case MP_QSTR_color_start: dest[0] = mp_read_byref_lv_color16_t(data->color_start); break; // converting from lv_color_t;
            case MP_QSTR_color_end: dest[0] = mp_read_byref_lv_color16_t(data->color_end); break; // converting from lv_color_t;
            case MP_QSTR_local_grad: dest[0] = mp_obj_new_int_from_uint(data->local_grad); break; // converting from uint8_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_width_mod: data->width_mod = (int16_t)mp_obj_get_int(dest[1]); break; // converting to int16_t;
                case MP_QSTR_color_start: data->color_start = mp_write_lv_color16_t(dest[1]); break; // converting to lv_color_t;
                case MP_QSTR_color_end: data->color_end = mp_write_lv_color16_t(dest[1]); break; // converting to lv_color_t;
                case MP_QSTR_local_grad: data->local_grad = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_meter_indicator_type_data_scale_lines_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_meter_indicator_type_data_scale_lines_t");
}

STATIC const mp_obj_dict_t mp_lv_meter_indicator_type_data_scale_lines_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_meter_indicator_type_data_scale_lines_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_meter_indicator_type_data_scale_lines_t,
    .print = mp_lv_meter_indicator_type_data_scale_lines_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_meter_indicator_type_data_scale_lines_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_meter_indicator_type_data_scale_lines_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_meter_indicator_type_data_scale_lines_t_type()
{
    return &mp_lv_meter_indicator_type_data_scale_lines_t_type;
}
    

/*
 * Struct lv_meter_indicator_type_data_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_meter_indicator_type_data_t_type();

STATIC inline lv_meter_indicator_type_data_t* mp_write_ptr_lv_meter_indicator_type_data_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_meter_indicator_type_data_t_type()));
    return (lv_meter_indicator_type_data_t*)self->data;
}

#define mp_write_lv_meter_indicator_type_data_t(struct_obj) *mp_write_ptr_lv_meter_indicator_type_data_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_meter_indicator_type_data_t(lv_meter_indicator_type_data_t *field)
{
    return lv_to_mp_struct(get_mp_lv_meter_indicator_type_data_t_type(), (void*)field);
}

#define mp_read_lv_meter_indicator_type_data_t(field) mp_read_ptr_lv_meter_indicator_type_data_t(copy_buffer(&field, sizeof(lv_meter_indicator_type_data_t)))
#define mp_read_byref_lv_meter_indicator_type_data_t(field) mp_read_ptr_lv_meter_indicator_type_data_t(&field)

STATIC void mp_lv_meter_indicator_type_data_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_meter_indicator_type_data_t *data = (lv_meter_indicator_type_data_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_needle_img: dest[0] = mp_read_byref_lv_meter_indicator_type_data_needle_img_t(data->needle_img); break; // converting from lv_meter_indicator_type_data_needle_img_t;
            case MP_QSTR_needle_line: dest[0] = mp_read_byref_lv_meter_indicator_type_data_needle_line_t(data->needle_line); break; // converting from lv_meter_indicator_type_data_needle_line_t;
            case MP_QSTR_arc: dest[0] = mp_read_byref_lv_meter_indicator_type_data_arc_t(data->arc); break; // converting from lv_meter_indicator_type_data_arc_t;
            case MP_QSTR_scale_lines: dest[0] = mp_read_byref_lv_meter_indicator_type_data_scale_lines_t(data->scale_lines); break; // converting from lv_meter_indicator_type_data_scale_lines_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_needle_img: data->needle_img = mp_write_lv_meter_indicator_type_data_needle_img_t(dest[1]); break; // converting to lv_meter_indicator_type_data_needle_img_t;
                case MP_QSTR_needle_line: data->needle_line = mp_write_lv_meter_indicator_type_data_needle_line_t(dest[1]); break; // converting to lv_meter_indicator_type_data_needle_line_t;
                case MP_QSTR_arc: data->arc = mp_write_lv_meter_indicator_type_data_arc_t(dest[1]); break; // converting to lv_meter_indicator_type_data_arc_t;
                case MP_QSTR_scale_lines: data->scale_lines = mp_write_lv_meter_indicator_type_data_scale_lines_t(dest[1]); break; // converting to lv_meter_indicator_type_data_scale_lines_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_meter_indicator_type_data_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_meter_indicator_type_data_t");
}

STATIC const mp_obj_dict_t mp_lv_meter_indicator_type_data_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_meter_indicator_type_data_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_meter_indicator_type_data_t,
    .print = mp_lv_meter_indicator_type_data_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_meter_indicator_type_data_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_meter_indicator_type_data_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_meter_indicator_type_data_t_type()
{
    return &mp_lv_meter_indicator_type_data_t_type;
}
    

/*
 * Struct lv_meter_indicator_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_meter_indicator_t_type();

STATIC inline lv_meter_indicator_t* mp_write_ptr_lv_meter_indicator_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_meter_indicator_t_type()));
    return (lv_meter_indicator_t*)self->data;
}

#define mp_write_lv_meter_indicator_t(struct_obj) *mp_write_ptr_lv_meter_indicator_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_meter_indicator_t(lv_meter_indicator_t *field)
{
    return lv_to_mp_struct(get_mp_lv_meter_indicator_t_type(), (void*)field);
}

#define mp_read_lv_meter_indicator_t(field) mp_read_ptr_lv_meter_indicator_t(copy_buffer(&field, sizeof(lv_meter_indicator_t)))
#define mp_read_byref_lv_meter_indicator_t(field) mp_read_ptr_lv_meter_indicator_t(&field)

STATIC void mp_lv_meter_indicator_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_meter_indicator_t *data = (lv_meter_indicator_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_scale: dest[0] = mp_read_ptr_lv_meter_scale_t((void*)data->scale); break; // converting from lv_meter_scale_t *;
            case MP_QSTR_type: dest[0] = mp_obj_new_int_from_uint(data->type); break; // converting from lv_meter_indicator_type_t;
            case MP_QSTR_opa: dest[0] = mp_obj_new_int_from_uint(data->opa); break; // converting from lv_opa_t;
            case MP_QSTR_start_value: dest[0] = mp_obj_new_int(data->start_value); break; // converting from int32_t;
            case MP_QSTR_end_value: dest[0] = mp_obj_new_int(data->end_value); break; // converting from int32_t;
            case MP_QSTR_type_data: dest[0] = mp_read_byref_lv_meter_indicator_type_data_t(data->type_data); break; // converting from lv_meter_indicator_type_data_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_scale: data->scale = (void*)mp_write_ptr_lv_meter_scale_t(dest[1]); break; // converting to lv_meter_scale_t *;
                case MP_QSTR_type: data->type = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to lv_meter_indicator_type_t;
                case MP_QSTR_opa: data->opa = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to lv_opa_t;
                case MP_QSTR_start_value: data->start_value = (int32_t)mp_obj_get_int(dest[1]); break; // converting to int32_t;
                case MP_QSTR_end_value: data->end_value = (int32_t)mp_obj_get_int(dest[1]); break; // converting to int32_t;
                case MP_QSTR_type_data: data->type_data = mp_write_lv_meter_indicator_type_data_t(dest[1]); break; // converting to lv_meter_indicator_type_data_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_meter_indicator_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_meter_indicator_t");
}

STATIC const mp_obj_dict_t mp_lv_meter_indicator_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_meter_indicator_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_meter_indicator_t,
    .print = mp_lv_meter_indicator_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_meter_indicator_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_meter_indicator_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_meter_indicator_t_type()
{
    return &mp_lv_meter_indicator_t_type;
}
    

/*
 * lvgl extension definition for:
 * lv_meter_indicator_t *lv_meter_add_needle_line(lv_obj_t *obj, lv_meter_scale_t *scale, uint16_t width, lv_color_t color, int16_t r_mod)
 */
 
STATIC mp_obj_t mp_lv_meter_add_needle_line(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_meter_scale_t *scale = mp_write_ptr_lv_meter_scale_t(mp_args[1]);
    uint16_t width = (uint16_t)mp_obj_get_int(mp_args[2]);
    lv_color_t color = mp_write_lv_color16_t(mp_args[3]);
    int16_t r_mod = (int16_t)mp_obj_get_int(mp_args[4]);
    lv_meter_indicator_t * _res = ((lv_meter_indicator_t *(*)(lv_obj_t *, lv_meter_scale_t *, uint16_t, lv_color_t, int16_t))lv_func_ptr)(obj, scale, width, color, r_mod);
    return mp_read_ptr_lv_meter_indicator_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_meter_add_needle_line_obj, 5, mp_lv_meter_add_needle_line, lv_meter_add_needle_line);
    

/*
 * lvgl extension definition for:
 * lv_meter_indicator_t *lv_meter_add_needle_img(lv_obj_t *obj, lv_meter_scale_t *scale, const void *src, lv_coord_t pivot_x, lv_coord_t pivot_y)
 */
 
STATIC mp_obj_t mp_lv_meter_add_needle_img(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_meter_scale_t *scale = mp_write_ptr_lv_meter_scale_t(mp_args[1]);
    const void *src = mp_to_ptr(mp_args[2]);
    lv_coord_t pivot_x = (int16_t)mp_obj_get_int(mp_args[3]);
    lv_coord_t pivot_y = (int16_t)mp_obj_get_int(mp_args[4]);
    lv_meter_indicator_t * _res = ((lv_meter_indicator_t *(*)(lv_obj_t *, lv_meter_scale_t *, const void *, lv_coord_t, lv_coord_t))lv_func_ptr)(obj, scale, src, pivot_x, pivot_y);
    return mp_read_ptr_lv_meter_indicator_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_meter_add_needle_img_obj, 5, mp_lv_meter_add_needle_img, lv_meter_add_needle_img);
    
/* Reusing lv_meter_add_needle_line for lv_meter_add_arc */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_meter_add_arc_obj, 5, mp_lv_meter_add_needle_line, lv_meter_add_arc);
    

/*
 * lvgl extension definition for:
 * lv_meter_indicator_t *lv_meter_add_scale_lines(lv_obj_t *obj, lv_meter_scale_t *scale, lv_color_t color_start, lv_color_t color_end, bool local, int16_t width_mod)
 */
 
STATIC mp_obj_t mp_lv_meter_add_scale_lines(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_meter_scale_t *scale = mp_write_ptr_lv_meter_scale_t(mp_args[1]);
    lv_color_t color_start = mp_write_lv_color16_t(mp_args[2]);
    lv_color_t color_end = mp_write_lv_color16_t(mp_args[3]);
    bool local = mp_obj_is_true(mp_args[4]);
    int16_t width_mod = (int16_t)mp_obj_get_int(mp_args[5]);
    lv_meter_indicator_t * _res = ((lv_meter_indicator_t *(*)(lv_obj_t *, lv_meter_scale_t *, lv_color_t, lv_color_t, bool, int16_t))lv_func_ptr)(obj, scale, color_start, color_end, local, width_mod);
    return mp_read_ptr_lv_meter_indicator_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_meter_add_scale_lines_obj, 6, mp_lv_meter_add_scale_lines, lv_meter_add_scale_lines);
    

/*
 * lvgl extension definition for:
 * void lv_meter_set_indicator_value(lv_obj_t *obj, lv_meter_indicator_t *indic, int32_t value)
 */
 
STATIC mp_obj_t mp_lv_meter_set_indicator_value(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_meter_indicator_t *indic = mp_write_ptr_lv_meter_indicator_t(mp_args[1]);
    int32_t value = (int32_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_obj_t *, lv_meter_indicator_t *, int32_t))lv_func_ptr)(obj, indic, value);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_meter_set_indicator_value_obj, 3, mp_lv_meter_set_indicator_value, lv_meter_set_indicator_value);
    
/* Reusing lv_meter_set_indicator_value for lv_meter_set_indicator_start_value */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_meter_set_indicator_start_value_obj, 3, mp_lv_meter_set_indicator_value, lv_meter_set_indicator_start_value);
    
/* Reusing lv_meter_set_indicator_value for lv_meter_set_indicator_end_value */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_meter_set_indicator_end_value_obj, 3, mp_lv_meter_set_indicator_value, lv_meter_set_indicator_end_value);
    

/*
 * lvgl meter object definitions
 */
    

STATIC const mp_rom_map_elem_t meter_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_add_scale), MP_ROM_PTR(&mp_lv_meter_add_scale_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_scale_ticks), MP_ROM_PTR(&mp_lv_meter_set_scale_ticks_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_scale_major_ticks), MP_ROM_PTR(&mp_lv_meter_set_scale_major_ticks_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_scale_range), MP_ROM_PTR(&mp_lv_meter_set_scale_range_obj) },
    { MP_ROM_QSTR(MP_QSTR_add_needle_line), MP_ROM_PTR(&mp_lv_meter_add_needle_line_obj) },
    { MP_ROM_QSTR(MP_QSTR_add_needle_img), MP_ROM_PTR(&mp_lv_meter_add_needle_img_obj) },
    { MP_ROM_QSTR(MP_QSTR_add_arc), MP_ROM_PTR(&mp_lv_meter_add_arc_obj) },
    { MP_ROM_QSTR(MP_QSTR_add_scale_lines), MP_ROM_PTR(&mp_lv_meter_add_scale_lines_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_indicator_value), MP_ROM_PTR(&mp_lv_meter_set_indicator_value_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_indicator_start_value), MP_ROM_PTR(&mp_lv_meter_set_indicator_start_value_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_indicator_end_value), MP_ROM_PTR(&mp_lv_meter_set_indicator_end_value_obj) },
    { MP_ROM_QSTR(MP_QSTR_INDICATOR_TYPE), MP_ROM_PTR(&mp_LV_METER_INDICATOR_TYPE_type) },
    { MP_ROM_QSTR(MP_QSTR_DRAW_PART), MP_ROM_PTR(&mp_LV_METER_DRAW_PART_type) }
};

STATIC MP_DEFINE_CONST_DICT(meter_locals_dict, meter_locals_dict_table);

STATIC void meter_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl meter");
}


STATIC mp_obj_t meter_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&lv_meter_create, type, n_args, n_kw, args);           
}


STATIC const mp_obj_type_t mp_meter_type = {
    { &mp_type_type },
    .name = MP_QSTR_meter,
    .print = meter_print,
    .make_new = meter_make_new,
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&meter_locals_dict,
    .buffer_p = { .get_buffer = mp_lv_obj_get_buffer },
    .parent = &mp_obj_type,
};
    
/* Reusing lv_textarea_set_cursor_pos for lv_spinbox_set_value */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_spinbox_set_value_obj, 2, mp_lv_textarea_set_cursor_pos, lv_spinbox_set_value);
    
/* Reusing lv_obj_set_page_glue for lv_spinbox_set_rollover */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_spinbox_set_rollover_obj, 2, mp_lv_obj_set_page_glue, lv_spinbox_set_rollover);
    
/* Reusing lv_chart_set_div_line_count for lv_spinbox_set_digit_format */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_spinbox_set_digit_format_obj, 3, mp_lv_chart_set_div_line_count, lv_spinbox_set_digit_format);
    
/* Reusing lv_label_set_text_sel_start for lv_spinbox_set_step */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_spinbox_set_step_obj, 2, mp_lv_label_set_text_sel_start, lv_spinbox_set_step);
    
/* Reusing lv_bar_set_range for lv_spinbox_set_range */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_spinbox_set_range_obj, 3, mp_lv_bar_set_range, lv_spinbox_set_range);
    
/* Reusing lv_obj_set_flex_grow for lv_spinbox_set_cursor_pos */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_spinbox_set_cursor_pos_obj, 2, mp_lv_obj_set_flex_grow, lv_spinbox_set_cursor_pos);
    
/* Reusing lv_dropdown_set_dir for lv_spinbox_set_digit_step_direction */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_spinbox_set_digit_step_direction_obj, 2, mp_lv_dropdown_set_dir, lv_spinbox_set_digit_step_direction);
    
/* Reusing lv_img_get_antialias for lv_spinbox_get_rollover */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_spinbox_get_rollover_obj, 1, mp_lv_img_get_antialias, lv_spinbox_get_rollover);
    

/*
 * lvgl extension definition for:
 * int32_t lv_spinbox_get_value(lv_obj_t *obj)
 */
 
STATIC mp_obj_t mp_lv_spinbox_get_value(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    int32_t _res = ((int32_t (*)(lv_obj_t *))lv_func_ptr)(obj);
    return mp_obj_new_int(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_spinbox_get_value_obj, 1, mp_lv_spinbox_get_value, lv_spinbox_get_value);
    
/* Reusing lv_spinbox_get_value for lv_spinbox_get_step */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_spinbox_get_step_obj, 1, mp_lv_spinbox_get_value, lv_spinbox_get_step);
    
/* Reusing lv_obj_move_foreground for lv_spinbox_step_next */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_spinbox_step_next_obj, 1, mp_lv_obj_move_foreground, lv_spinbox_step_next);
    
/* Reusing lv_obj_move_foreground for lv_spinbox_step_prev */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_spinbox_step_prev_obj, 1, mp_lv_obj_move_foreground, lv_spinbox_step_prev);
    
/* Reusing lv_obj_move_foreground for lv_spinbox_increment */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_spinbox_increment_obj, 1, mp_lv_obj_move_foreground, lv_spinbox_increment);
    
/* Reusing lv_obj_move_foreground for lv_spinbox_decrement */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_spinbox_decrement_obj, 1, mp_lv_obj_move_foreground, lv_spinbox_decrement);
    

/*
 * lvgl spinbox object definitions
 */
    

STATIC const mp_rom_map_elem_t spinbox_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_set_value), MP_ROM_PTR(&mp_lv_spinbox_set_value_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_rollover), MP_ROM_PTR(&mp_lv_spinbox_set_rollover_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_digit_format), MP_ROM_PTR(&mp_lv_spinbox_set_digit_format_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_step), MP_ROM_PTR(&mp_lv_spinbox_set_step_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_range), MP_ROM_PTR(&mp_lv_spinbox_set_range_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_cursor_pos), MP_ROM_PTR(&mp_lv_spinbox_set_cursor_pos_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_digit_step_direction), MP_ROM_PTR(&mp_lv_spinbox_set_digit_step_direction_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_rollover), MP_ROM_PTR(&mp_lv_spinbox_get_rollover_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_value), MP_ROM_PTR(&mp_lv_spinbox_get_value_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_step), MP_ROM_PTR(&mp_lv_spinbox_get_step_obj) },
    { MP_ROM_QSTR(MP_QSTR_step_next), MP_ROM_PTR(&mp_lv_spinbox_step_next_obj) },
    { MP_ROM_QSTR(MP_QSTR_step_prev), MP_ROM_PTR(&mp_lv_spinbox_step_prev_obj) },
    { MP_ROM_QSTR(MP_QSTR_increment), MP_ROM_PTR(&mp_lv_spinbox_increment_obj) },
    { MP_ROM_QSTR(MP_QSTR_decrement), MP_ROM_PTR(&mp_lv_spinbox_decrement_obj) }
};

STATIC MP_DEFINE_CONST_DICT(spinbox_locals_dict, spinbox_locals_dict_table);

STATIC void spinbox_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl spinbox");
}


STATIC mp_obj_t spinbox_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&lv_spinbox_create, type, n_args, n_kw, args);           
}


STATIC const mp_obj_type_t mp_spinbox_type = {
    { &mp_type_type },
    .name = MP_QSTR_spinbox,
    .print = spinbox_print,
    .make_new = spinbox_make_new,
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&spinbox_locals_dict,
    .buffer_p = { .get_buffer = mp_lv_obj_get_buffer },
    .parent = &mp_obj_type,
};
    

/*
 * lvgl spinner object definitions
 */
    

STATIC const mp_rom_map_elem_t spinner_locals_dict_table[] = {
    
};

STATIC MP_DEFINE_CONST_DICT(spinner_locals_dict, spinner_locals_dict_table);

STATIC void spinner_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl spinner");
}


STATIC mp_obj_t spinner_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&lv_spinner_create, type, n_args, n_kw, args);           
}


STATIC const mp_obj_type_t mp_spinner_type = {
    { &mp_type_type },
    .name = MP_QSTR_spinner,
    .print = spinner_print,
    .make_new = spinner_make_new,
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&spinner_locals_dict,
    .buffer_p = { .get_buffer = mp_lv_obj_get_buffer },
    .parent = &mp_obj_type,
};
    
/* Reusing lv_list_add_text for lv_tabview_add_tab */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_tabview_add_tab_obj, 2, mp_lv_list_add_text, lv_tabview_add_tab);
    
/* Reusing lv_label_ins_text for lv_tabview_rename_tab */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_tabview_rename_tab_obj, 3, mp_lv_label_ins_text, lv_tabview_rename_tab);
    
/* Reusing lv_dropdown_get_list for lv_tabview_get_content */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_tabview_get_content_obj, 1, mp_lv_dropdown_get_list, lv_tabview_get_content);
    
/* Reusing lv_dropdown_get_list for lv_tabview_get_tab_btns */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_tabview_get_tab_btns_obj, 1, mp_lv_dropdown_get_list, lv_tabview_get_tab_btns);
    

/*
 * lvgl extension definition for:
 * void lv_tabview_set_act(lv_obj_t *obj, uint32_t id, lv_anim_enable_t anim_en)
 */
 
STATIC mp_obj_t mp_lv_tabview_set_act(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint32_t id = (uint32_t)mp_obj_get_int(mp_args[1]);
    lv_anim_enable_t anim_en = (int)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_obj_t *, uint32_t, lv_anim_enable_t))lv_func_ptr)(obj, id, anim_en);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_tabview_set_act_obj, 3, mp_lv_tabview_set_act, lv_tabview_set_act);
    
/* Reusing lv_arc_get_angle_start for lv_tabview_get_tab_act */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_tabview_get_tab_act_obj, 1, mp_lv_arc_get_angle_start, lv_tabview_get_tab_act);
    

/*
 * lvgl tabview object definitions
 */
    

STATIC const mp_rom_map_elem_t tabview_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_add_tab), MP_ROM_PTR(&mp_lv_tabview_add_tab_obj) },
    { MP_ROM_QSTR(MP_QSTR_rename_tab), MP_ROM_PTR(&mp_lv_tabview_rename_tab_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_content), MP_ROM_PTR(&mp_lv_tabview_get_content_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_tab_btns), MP_ROM_PTR(&mp_lv_tabview_get_tab_btns_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_act), MP_ROM_PTR(&mp_lv_tabview_set_act_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_tab_act), MP_ROM_PTR(&mp_lv_tabview_get_tab_act_obj) }
};

STATIC MP_DEFINE_CONST_DICT(tabview_locals_dict, tabview_locals_dict_table);

STATIC void tabview_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl tabview");
}


STATIC mp_obj_t tabview_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&lv_tabview_create, type, n_args, n_kw, args);           
}


STATIC const mp_obj_type_t mp_tabview_type = {
    { &mp_type_type },
    .name = MP_QSTR_tabview,
    .print = tabview_print,
    .make_new = tabview_make_new,
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&tabview_locals_dict,
    .buffer_p = { .get_buffer = mp_lv_obj_get_buffer },
    .parent = &mp_obj_type,
};
    

/*
 * lvgl extension definition for:
 * lv_obj_t *lv_tileview_add_tile(lv_obj_t *tv, uint8_t col_id, uint8_t row_id, lv_dir_t dir)
 */
 
STATIC mp_obj_t mp_lv_tileview_add_tile(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *tv = mp_to_lv(mp_args[0]);
    uint8_t col_id = (uint8_t)mp_obj_get_int(mp_args[1]);
    uint8_t row_id = (uint8_t)mp_obj_get_int(mp_args[2]);
    lv_dir_t dir = (uint8_t)mp_obj_get_int(mp_args[3]);
    lv_obj_t * _res = ((lv_obj_t *(*)(lv_obj_t *, uint8_t, uint8_t, lv_dir_t))lv_func_ptr)(tv, col_id, row_id, dir);
    return lv_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_tileview_add_tile_obj, 4, mp_lv_tileview_add_tile, lv_tileview_add_tile);
    
/* Reusing lv_dropdown_get_list for lv_tileview_get_tile_act */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_tileview_get_tile_act_obj, 1, mp_lv_dropdown_get_list, lv_tileview_get_tile_act);
    

/*
 * lvgl tileview object definitions
 */
    

STATIC const mp_rom_map_elem_t tileview_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_add_tile), MP_ROM_PTR(&mp_lv_tileview_add_tile_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_tile_act), MP_ROM_PTR(&mp_lv_tileview_get_tile_act_obj) }
};

STATIC MP_DEFINE_CONST_DICT(tileview_locals_dict, tileview_locals_dict_table);

STATIC void tileview_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl tileview");
}


STATIC mp_obj_t tileview_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&lv_tileview_create, type, n_args, n_kw, args);           
}


STATIC const mp_obj_type_t mp_tileview_type = {
    { &mp_type_type },
    .name = MP_QSTR_tileview,
    .print = tileview_print,
    .make_new = tileview_make_new,
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&tileview_locals_dict,
    .buffer_p = { .get_buffer = mp_lv_obj_get_buffer },
    .parent = &mp_obj_type,
};
    
/* Reusing lv_list_add_text for lv_win_add_title */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_win_add_title_obj, 2, mp_lv_list_add_text, lv_win_add_title);
    

/*
 * lvgl extension definition for:
 * lv_obj_t *lv_win_add_btn(lv_obj_t *win, const void *icon, lv_coord_t btn_w)
 */
 
STATIC mp_obj_t mp_lv_win_add_btn(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *win = mp_to_lv(mp_args[0]);
    const void *icon = mp_to_ptr(mp_args[1]);
    lv_coord_t btn_w = (int16_t)mp_obj_get_int(mp_args[2]);
    lv_obj_t * _res = ((lv_obj_t *(*)(lv_obj_t *, const void *, lv_coord_t))lv_func_ptr)(win, icon, btn_w);
    return lv_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_win_add_btn_obj, 3, mp_lv_win_add_btn, lv_win_add_btn);
    
/* Reusing lv_dropdown_get_list for lv_win_get_header */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_win_get_header_obj, 1, mp_lv_dropdown_get_list, lv_win_get_header);
    
/* Reusing lv_dropdown_get_list for lv_win_get_content */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_win_get_content_obj, 1, mp_lv_dropdown_get_list, lv_win_get_content);
    

/*
 * lvgl win object definitions
 */
    

STATIC const mp_rom_map_elem_t win_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_add_title), MP_ROM_PTR(&mp_lv_win_add_title_obj) },
    { MP_ROM_QSTR(MP_QSTR_add_btn), MP_ROM_PTR(&mp_lv_win_add_btn_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_header), MP_ROM_PTR(&mp_lv_win_get_header_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_content), MP_ROM_PTR(&mp_lv_win_get_content_obj) }
};

STATIC MP_DEFINE_CONST_DICT(win_locals_dict, win_locals_dict_table);

STATIC void win_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl win");
}


STATIC mp_obj_t win_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&lv_win_create, type, n_args, n_kw, args);           
}


STATIC const mp_obj_type_t mp_win_type = {
    { &mp_type_type },
    .name = MP_QSTR_win,
    .print = win_print,
    .make_new = win_make_new,
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&win_locals_dict,
    .buffer_p = { .get_buffer = mp_lv_obj_get_buffer },
    .parent = &mp_obj_type,
};
    

/*
 * Struct lv_color_hsv_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_color_hsv_t_type();

STATIC inline lv_color_hsv_t* mp_write_ptr_lv_color_hsv_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_color_hsv_t_type()));
    return (lv_color_hsv_t*)self->data;
}

#define mp_write_lv_color_hsv_t(struct_obj) *mp_write_ptr_lv_color_hsv_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_color_hsv_t(lv_color_hsv_t *field)
{
    return lv_to_mp_struct(get_mp_lv_color_hsv_t_type(), (void*)field);
}

#define mp_read_lv_color_hsv_t(field) mp_read_ptr_lv_color_hsv_t(copy_buffer(&field, sizeof(lv_color_hsv_t)))
#define mp_read_byref_lv_color_hsv_t(field) mp_read_ptr_lv_color_hsv_t(&field)

STATIC void mp_lv_color_hsv_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_color_hsv_t *data = (lv_color_hsv_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_h: dest[0] = mp_obj_new_int_from_uint(data->h); break; // converting from uint16_t;
            case MP_QSTR_s: dest[0] = mp_obj_new_int_from_uint(data->s); break; // converting from uint8_t;
            case MP_QSTR_v: dest[0] = mp_obj_new_int_from_uint(data->v); break; // converting from uint8_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_h: data->h = (uint16_t)mp_obj_get_int(dest[1]); break; // converting to uint16_t;
                case MP_QSTR_s: data->s = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                case MP_QSTR_v: data->v = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_color_hsv_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_color_hsv_t");
}

STATIC const mp_obj_dict_t mp_lv_color_hsv_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_color_hsv_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_color_hsv_t,
    .print = mp_lv_color_hsv_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_color_hsv_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_color_hsv_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_color_hsv_t_type()
{
    return &mp_lv_color_hsv_t_type;
}
    

/*
 * lvgl extension definition for:
 * bool lv_colorwheel_set_hsv(lv_obj_t *obj, lv_color_hsv_t hsv)
 */
 
STATIC mp_obj_t mp_lv_colorwheel_set_hsv(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_color_hsv_t hsv = mp_write_lv_color_hsv_t(mp_args[1]);
    bool _res = ((bool (*)(lv_obj_t *, lv_color_hsv_t))lv_func_ptr)(obj, hsv);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_colorwheel_set_hsv_obj, 2, mp_lv_colorwheel_set_hsv, lv_colorwheel_set_hsv);
    

/*
 * lvgl extension definition for:
 * bool lv_colorwheel_set_rgb(lv_obj_t *obj, lv_color_t color)
 */
 
STATIC mp_obj_t mp_lv_colorwheel_set_rgb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_color_t color = mp_write_lv_color16_t(mp_args[1]);
    bool _res = ((bool (*)(lv_obj_t *, lv_color_t))lv_func_ptr)(obj, color);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_colorwheel_set_rgb_obj, 2, mp_lv_colorwheel_set_rgb, lv_colorwheel_set_rgb);
    

/*
 * lvgl extension definition for:
 * void lv_colorwheel_set_mode(lv_obj_t *obj, lv_colorwheel_mode_t mode)
 */
 
STATIC mp_obj_t mp_lv_colorwheel_set_mode(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_colorwheel_mode_t mode = (uint8_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_obj_t *, lv_colorwheel_mode_t))lv_func_ptr)(obj, mode);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_colorwheel_set_mode_obj, 2, mp_lv_colorwheel_set_mode, lv_colorwheel_set_mode);
    
/* Reusing lv_obj_set_page_glue for lv_colorwheel_set_mode_fixed */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_colorwheel_set_mode_fixed_obj, 2, mp_lv_obj_set_page_glue, lv_colorwheel_set_mode_fixed);
    

/*
 * lvgl extension definition for:
 * lv_color_hsv_t lv_colorwheel_get_hsv(lv_obj_t *obj)
 */
 
STATIC mp_obj_t mp_lv_colorwheel_get_hsv(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_color_hsv_t _res = ((lv_color_hsv_t (*)(lv_obj_t *))lv_func_ptr)(obj);
    return mp_read_lv_color_hsv_t(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_colorwheel_get_hsv_obj, 1, mp_lv_colorwheel_get_hsv, lv_colorwheel_get_hsv);
    

/*
 * lvgl extension definition for:
 * lv_color_t lv_colorwheel_get_rgb(lv_obj_t *obj)
 */
 
STATIC mp_obj_t mp_lv_colorwheel_get_rgb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_color_t _res = ((lv_color_t (*)(lv_obj_t *))lv_func_ptr)(obj);
    return mp_read_lv_color16_t(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_colorwheel_get_rgb_obj, 1, mp_lv_colorwheel_get_rgb, lv_colorwheel_get_rgb);
    

/*
 * lvgl extension definition for:
 * lv_colorwheel_mode_t lv_colorwheel_get_color_mode(lv_obj_t *obj)
 */
 
STATIC mp_obj_t mp_lv_colorwheel_get_color_mode(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_colorwheel_mode_t _res = ((lv_colorwheel_mode_t (*)(lv_obj_t *))lv_func_ptr)(obj);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_colorwheel_get_color_mode_obj, 1, mp_lv_colorwheel_get_color_mode, lv_colorwheel_get_color_mode);
    
/* Reusing lv_img_get_antialias for lv_colorwheel_get_color_mode_fixed */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_colorwheel_get_color_mode_fixed_obj, 1, mp_lv_img_get_antialias, lv_colorwheel_get_color_mode_fixed);
    

/*
 * lvgl colorwheel object definitions
 */
    

STATIC const mp_rom_map_elem_t colorwheel_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_set_hsv), MP_ROM_PTR(&mp_lv_colorwheel_set_hsv_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_rgb), MP_ROM_PTR(&mp_lv_colorwheel_set_rgb_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_mode), MP_ROM_PTR(&mp_lv_colorwheel_set_mode_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_mode_fixed), MP_ROM_PTR(&mp_lv_colorwheel_set_mode_fixed_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_hsv), MP_ROM_PTR(&mp_lv_colorwheel_get_hsv_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_rgb), MP_ROM_PTR(&mp_lv_colorwheel_get_rgb_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_color_mode), MP_ROM_PTR(&mp_lv_colorwheel_get_color_mode_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_color_mode_fixed), MP_ROM_PTR(&mp_lv_colorwheel_get_color_mode_fixed_obj) },
    { MP_ROM_QSTR(MP_QSTR_MODE), MP_ROM_PTR(&mp_LV_COLORWHEEL_MODE_type) }
};

STATIC MP_DEFINE_CONST_DICT(colorwheel_locals_dict, colorwheel_locals_dict_table);

STATIC void colorwheel_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl colorwheel");
}


STATIC mp_obj_t colorwheel_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&lv_colorwheel_create, type, n_args, n_kw, args);           
}


STATIC const mp_obj_type_t mp_colorwheel_type = {
    { &mp_type_type },
    .name = MP_QSTR_colorwheel,
    .print = colorwheel_print,
    .make_new = colorwheel_make_new,
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&colorwheel_locals_dict,
    .buffer_p = { .get_buffer = mp_lv_obj_get_buffer },
    .parent = &mp_obj_type,
};
    

/*
 * lvgl extension definition for:
 * void lv_led_set_color(lv_obj_t *led, lv_color_t color)
 */
 
STATIC mp_obj_t mp_lv_led_set_color(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *led = mp_to_lv(mp_args[0]);
    lv_color_t color = mp_write_lv_color16_t(mp_args[1]);
    ((void (*)(lv_obj_t *, lv_color_t))lv_func_ptr)(led, color);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_led_set_color_obj, 2, mp_lv_led_set_color, lv_led_set_color);
    
/* Reusing lv_obj_set_flex_grow for lv_led_set_brightness */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_led_set_brightness_obj, 2, mp_lv_obj_set_flex_grow, lv_led_set_brightness);
    
/* Reusing lv_obj_move_foreground for lv_led_on */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_led_on_obj, 1, mp_lv_obj_move_foreground, lv_led_on);
    
/* Reusing lv_obj_move_foreground for lv_led_off */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_led_off_obj, 1, mp_lv_obj_move_foreground, lv_led_off);
    
/* Reusing lv_obj_move_foreground for lv_led_toggle */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_led_toggle_obj, 1, mp_lv_obj_move_foreground, lv_led_toggle);
    

/*
 * lvgl extension definition for:
 * uint8_t lv_led_get_brightness(const lv_obj_t *obj)
 */
 
STATIC mp_obj_t mp_lv_led_get_brightness(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint8_t _res = ((uint8_t (*)(const lv_obj_t *))lv_func_ptr)(obj);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_led_get_brightness_obj, 1, mp_lv_led_get_brightness, lv_led_get_brightness);
    

/*
 * lvgl led object definitions
 */
    

STATIC const mp_rom_map_elem_t led_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_set_color), MP_ROM_PTR(&mp_lv_led_set_color_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_brightness), MP_ROM_PTR(&mp_lv_led_set_brightness_obj) },
    { MP_ROM_QSTR(MP_QSTR_on), MP_ROM_PTR(&mp_lv_led_on_obj) },
    { MP_ROM_QSTR(MP_QSTR_off), MP_ROM_PTR(&mp_lv_led_off_obj) },
    { MP_ROM_QSTR(MP_QSTR_toggle), MP_ROM_PTR(&mp_lv_led_toggle_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_brightness), MP_ROM_PTR(&mp_lv_led_get_brightness_obj) },
    { MP_ROM_QSTR(MP_QSTR_DRAW_PART), MP_ROM_PTR(&mp_LV_LED_DRAW_PART_type) }
};

STATIC MP_DEFINE_CONST_DICT(led_locals_dict, led_locals_dict_table);

STATIC void led_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl led");
}


STATIC mp_obj_t led_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&lv_led_create, type, n_args, n_kw, args);           
}


STATIC const mp_obj_type_t mp_led_type = {
    { &mp_type_type },
    .name = MP_QSTR_led,
    .print = led_print,
    .make_new = led_make_new,
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&led_locals_dict,
    .buffer_p = { .get_buffer = mp_lv_obj_get_buffer },
    .parent = &mp_obj_type,
};
    

/*
 * lvgl extension definition for:
 * void lv_imgbtn_set_src(lv_obj_t *imgbtn, lv_imgbtn_state_t state, const void *src_left, const void *src_mid, const void *src_right)
 */
 
STATIC mp_obj_t mp_lv_imgbtn_set_src(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *imgbtn = mp_to_lv(mp_args[0]);
    lv_imgbtn_state_t state = (int)mp_obj_get_int(mp_args[1]);
    const void *src_left = mp_to_ptr(mp_args[2]);
    const void *src_mid = mp_to_ptr(mp_args[3]);
    const void *src_right = mp_to_ptr(mp_args[4]);
    ((void (*)(lv_obj_t *, lv_imgbtn_state_t, const void *, const void *, const void *))lv_func_ptr)(imgbtn, state, src_left, src_mid, src_right);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_imgbtn_set_src_obj, 5, mp_lv_imgbtn_set_src, lv_imgbtn_set_src);
    

/*
 * lvgl extension definition for:
 * void lv_imgbtn_set_state(lv_obj_t *imgbtn, lv_imgbtn_state_t state)
 */
 
STATIC mp_obj_t mp_lv_imgbtn_set_state(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *imgbtn = mp_to_lv(mp_args[0]);
    lv_imgbtn_state_t state = (int)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_obj_t *, lv_imgbtn_state_t))lv_func_ptr)(imgbtn, state);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_imgbtn_set_state_obj, 2, mp_lv_imgbtn_set_state, lv_imgbtn_set_state);
    

/*
 * lvgl extension definition for:
 * const void *lv_imgbtn_get_src_left(lv_obj_t *imgbtn, lv_imgbtn_state_t state)
 */
 
STATIC mp_obj_t mp_lv_imgbtn_get_src_left(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *imgbtn = mp_to_lv(mp_args[0]);
    lv_imgbtn_state_t state = (int)mp_obj_get_int(mp_args[1]);
    const void * _res = ((const void *(*)(lv_obj_t *, lv_imgbtn_state_t))lv_func_ptr)(imgbtn, state);
    return ptr_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_imgbtn_get_src_left_obj, 2, mp_lv_imgbtn_get_src_left, lv_imgbtn_get_src_left);
    
/* Reusing lv_imgbtn_get_src_left for lv_imgbtn_get_src_middle */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_imgbtn_get_src_middle_obj, 2, mp_lv_imgbtn_get_src_left, lv_imgbtn_get_src_middle);
    
/* Reusing lv_imgbtn_get_src_left for lv_imgbtn_get_src_right */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_imgbtn_get_src_right_obj, 2, mp_lv_imgbtn_get_src_left, lv_imgbtn_get_src_right);
    

/*
 * lvgl imgbtn object definitions
 */
    

STATIC const mp_rom_map_elem_t imgbtn_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_set_src), MP_ROM_PTR(&mp_lv_imgbtn_set_src_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_state), MP_ROM_PTR(&mp_lv_imgbtn_set_state_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_src_left), MP_ROM_PTR(&mp_lv_imgbtn_get_src_left_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_src_middle), MP_ROM_PTR(&mp_lv_imgbtn_get_src_middle_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_src_right), MP_ROM_PTR(&mp_lv_imgbtn_get_src_right_obj) },
    { MP_ROM_QSTR(MP_QSTR_STATE), MP_ROM_PTR(&mp_LV_IMGBTN_STATE_type) }
};

STATIC MP_DEFINE_CONST_DICT(imgbtn_locals_dict, imgbtn_locals_dict_table);

STATIC void imgbtn_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl imgbtn");
}


STATIC mp_obj_t imgbtn_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&lv_imgbtn_create, type, n_args, n_kw, args);           
}


STATIC const mp_obj_type_t mp_imgbtn_type = {
    { &mp_type_type },
    .name = MP_QSTR_imgbtn,
    .print = imgbtn_print,
    .make_new = imgbtn_make_new,
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&imgbtn_locals_dict,
    .buffer_p = { .get_buffer = mp_lv_obj_get_buffer },
    .parent = &mp_obj_type,
};
    

/*
 * Struct lv_span_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_span_t_type();

STATIC inline lv_span_t* mp_write_ptr_lv_span_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_span_t_type()));
    return (lv_span_t*)self->data;
}

#define mp_write_lv_span_t(struct_obj) *mp_write_ptr_lv_span_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_span_t(lv_span_t *field)
{
    return lv_to_mp_struct(get_mp_lv_span_t_type(), (void*)field);
}

#define mp_read_lv_span_t(field) mp_read_ptr_lv_span_t(copy_buffer(&field, sizeof(lv_span_t)))
#define mp_read_byref_lv_span_t(field) mp_read_ptr_lv_span_t(&field)

STATIC void mp_lv_span_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_span_t *data = (lv_span_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_txt: dest[0] = convert_to_str((void*)data->txt); break; // converting from char *;
            case MP_QSTR_spangroup: dest[0] = lv_to_mp((void*)data->spangroup); break; // converting from lv_obj_t *;
            case MP_QSTR_style: dest[0] = mp_read_byref_lv_style_t(data->style); break; // converting from lv_style_t;
            case MP_QSTR_static_flag: dest[0] = mp_obj_new_int_from_uint(data->static_flag); break; // converting from uint8_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_txt: data->txt = (void*)(char*)convert_from_str(dest[1]); break; // converting to char *;
                case MP_QSTR_spangroup: data->spangroup = (void*)mp_to_lv(dest[1]); break; // converting to lv_obj_t *;
                case MP_QSTR_style: data->style = mp_write_lv_style_t(dest[1]); break; // converting to lv_style_t;
                case MP_QSTR_static_flag: data->static_flag = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_span_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_span_t");
}

STATIC const mp_obj_dict_t mp_lv_span_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_span_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_span_t,
    .print = mp_lv_span_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_span_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_span_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_span_t_type()
{
    return &mp_lv_span_t_type;
}
    

/*
 * lvgl extension definition for:
 * lv_span_t *lv_spangroup_new_span(lv_obj_t *obj)
 */
 
STATIC mp_obj_t mp_lv_spangroup_new_span(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_span_t * _res = ((lv_span_t *(*)(lv_obj_t *))lv_func_ptr)(obj);
    return mp_read_ptr_lv_span_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_spangroup_new_span_obj, 1, mp_lv_spangroup_new_span, lv_spangroup_new_span);
    

/*
 * lvgl extension definition for:
 * void lv_spangroup_del_span(lv_obj_t *obj, lv_span_t *span)
 */
 
STATIC mp_obj_t mp_lv_spangroup_del_span(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_span_t *span = mp_write_ptr_lv_span_t(mp_args[1]);
    ((void (*)(lv_obj_t *, lv_span_t *))lv_func_ptr)(obj, span);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_spangroup_del_span_obj, 2, mp_lv_spangroup_del_span, lv_spangroup_del_span);
    
/* Reusing lv_textarea_set_align for lv_spangroup_set_align */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_spangroup_set_align_obj, 2, mp_lv_textarea_set_align, lv_spangroup_set_align);
    

/*
 * lvgl extension definition for:
 * void lv_spangroup_set_overflow(lv_obj_t *obj, lv_span_overflow_t overflow)
 */
 
STATIC mp_obj_t mp_lv_spangroup_set_overflow(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_span_overflow_t overflow = (uint8_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_obj_t *, lv_span_overflow_t))lv_func_ptr)(obj, overflow);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_spangroup_set_overflow_obj, 2, mp_lv_spangroup_set_overflow, lv_spangroup_set_overflow);
    
/* Reusing lv_img_set_offset_x for lv_spangroup_set_indent */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_spangroup_set_indent_obj, 2, mp_lv_img_set_offset_x, lv_spangroup_set_indent);
    

/*
 * lvgl extension definition for:
 * void lv_spangroup_set_mode(lv_obj_t *obj, lv_span_mode_t mode)
 */
 
STATIC mp_obj_t mp_lv_spangroup_set_mode(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_span_mode_t mode = (uint8_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_obj_t *, lv_span_mode_t))lv_func_ptr)(obj, mode);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_spangroup_set_mode_obj, 2, mp_lv_spangroup_set_mode, lv_spangroup_set_mode);
    
/* Reusing lv_textarea_set_cursor_pos for lv_spangroup_set_lines */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_spangroup_set_lines_obj, 2, mp_lv_textarea_set_cursor_pos, lv_spangroup_set_lines);
    

/*
 * lvgl extension definition for:
 * lv_span_t *lv_spangroup_get_child(const lv_obj_t *obj, int32_t id)
 */
 
STATIC mp_obj_t mp_lv_spangroup_get_child(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = mp_to_lv(mp_args[0]);
    int32_t id = (int32_t)mp_obj_get_int(mp_args[1]);
    lv_span_t * _res = ((lv_span_t *(*)(const lv_obj_t *, int32_t))lv_func_ptr)(obj, id);
    return mp_read_ptr_lv_span_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_spangroup_get_child_obj, 2, mp_lv_spangroup_get_child, lv_spangroup_get_child);
    
/* Reusing lv_label_get_text_selection_start for lv_spangroup_get_child_cnt */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_spangroup_get_child_cnt_obj, 1, mp_lv_label_get_text_selection_start, lv_spangroup_get_child_cnt);
    

/*
 * lvgl extension definition for:
 * lv_text_align_t lv_spangroup_get_align(lv_obj_t *obj)
 */
 
STATIC mp_obj_t mp_lv_spangroup_get_align(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_text_align_t _res = ((lv_text_align_t (*)(lv_obj_t *))lv_func_ptr)(obj);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_spangroup_get_align_obj, 1, mp_lv_spangroup_get_align, lv_spangroup_get_align);
    

/*
 * lvgl extension definition for:
 * lv_span_overflow_t lv_spangroup_get_overflow(lv_obj_t *obj)
 */
 
STATIC mp_obj_t mp_lv_spangroup_get_overflow(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_span_overflow_t _res = ((lv_span_overflow_t (*)(lv_obj_t *))lv_func_ptr)(obj);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_spangroup_get_overflow_obj, 1, mp_lv_spangroup_get_overflow, lv_spangroup_get_overflow);
    
/* Reusing lv_img_get_offset_x for lv_spangroup_get_indent */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_spangroup_get_indent_obj, 1, mp_lv_img_get_offset_x, lv_spangroup_get_indent);
    

/*
 * lvgl extension definition for:
 * lv_span_mode_t lv_spangroup_get_mode(lv_obj_t *obj)
 */
 
STATIC mp_obj_t mp_lv_spangroup_get_mode(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_span_mode_t _res = ((lv_span_mode_t (*)(lv_obj_t *))lv_func_ptr)(obj);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_spangroup_get_mode_obj, 1, mp_lv_spangroup_get_mode, lv_spangroup_get_mode);
    
/* Reusing lv_spinbox_get_value for lv_spangroup_get_lines */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_spangroup_get_lines_obj, 1, mp_lv_spinbox_get_value, lv_spangroup_get_lines);
    
/* Reusing lv_img_get_offset_x for lv_spangroup_get_max_line_h */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_spangroup_get_max_line_h_obj, 1, mp_lv_img_get_offset_x, lv_spangroup_get_max_line_h);
    

/*
 * lvgl extension definition for:
 * uint32_t lv_spangroup_get_expand_width(lv_obj_t *obj, uint32_t max_width)
 */
 
STATIC mp_obj_t mp_lv_spangroup_get_expand_width(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint32_t max_width = (uint32_t)mp_obj_get_int(mp_args[1]);
    uint32_t _res = ((uint32_t (*)(lv_obj_t *, uint32_t))lv_func_ptr)(obj, max_width);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_spangroup_get_expand_width_obj, 2, mp_lv_spangroup_get_expand_width, lv_spangroup_get_expand_width);
    

/*
 * lvgl extension definition for:
 * lv_coord_t lv_spangroup_get_expand_height(lv_obj_t *obj, lv_coord_t width)
 */
 
STATIC mp_obj_t mp_lv_spangroup_get_expand_height(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_coord_t width = (int16_t)mp_obj_get_int(mp_args[1]);
    lv_coord_t _res = ((lv_coord_t (*)(lv_obj_t *, lv_coord_t))lv_func_ptr)(obj, width);
    return mp_obj_new_int(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_spangroup_get_expand_height_obj, 2, mp_lv_spangroup_get_expand_height, lv_spangroup_get_expand_height);
    
/* Reusing lv_obj_move_foreground for lv_spangroup_refr_mode */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_spangroup_refr_mode_obj, 1, mp_lv_obj_move_foreground, lv_spangroup_refr_mode);
    

/*
 * lvgl spangroup object definitions
 */
    

STATIC const mp_rom_map_elem_t spangroup_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_new_span), MP_ROM_PTR(&mp_lv_spangroup_new_span_obj) },
    { MP_ROM_QSTR(MP_QSTR_del_span), MP_ROM_PTR(&mp_lv_spangroup_del_span_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_align), MP_ROM_PTR(&mp_lv_spangroup_set_align_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_overflow), MP_ROM_PTR(&mp_lv_spangroup_set_overflow_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_indent), MP_ROM_PTR(&mp_lv_spangroup_set_indent_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_mode), MP_ROM_PTR(&mp_lv_spangroup_set_mode_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_lines), MP_ROM_PTR(&mp_lv_spangroup_set_lines_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_child), MP_ROM_PTR(&mp_lv_spangroup_get_child_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_child_cnt), MP_ROM_PTR(&mp_lv_spangroup_get_child_cnt_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_align), MP_ROM_PTR(&mp_lv_spangroup_get_align_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_overflow), MP_ROM_PTR(&mp_lv_spangroup_get_overflow_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_indent), MP_ROM_PTR(&mp_lv_spangroup_get_indent_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_mode), MP_ROM_PTR(&mp_lv_spangroup_get_mode_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_lines), MP_ROM_PTR(&mp_lv_spangroup_get_lines_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_max_line_h), MP_ROM_PTR(&mp_lv_spangroup_get_max_line_h_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_expand_width), MP_ROM_PTR(&mp_lv_spangroup_get_expand_width_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_expand_height), MP_ROM_PTR(&mp_lv_spangroup_get_expand_height_obj) },
    { MP_ROM_QSTR(MP_QSTR_refr_mode), MP_ROM_PTR(&mp_lv_spangroup_refr_mode_obj) }
};

STATIC MP_DEFINE_CONST_DICT(spangroup_locals_dict, spangroup_locals_dict_table);

STATIC void spangroup_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl spangroup");
}


STATIC mp_obj_t spangroup_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&lv_spangroup_create, type, n_args, n_kw, args);           
}


STATIC const mp_obj_type_t mp_spangroup_type = {
    { &mp_type_type },
    .name = MP_QSTR_spangroup,
    .print = spangroup_print,
    .make_new = spangroup_make_new,
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&spangroup_locals_dict,
    .buffer_p = { .get_buffer = mp_lv_obj_get_buffer },
    .parent = &mp_obj_type,
};
    

/*
 * Callback function lv_obj_t_cb
 * void lv_event_cb_t(lv_event_t *e)
 */

STATIC void lv_obj_t_cb_callback(lv_event_t * arg0)
{
    mp_obj_t mp_args[1];
    mp_args[0] = mp_read_ptr_lv_event_t((void*)arg0);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_obj_t_cb)) , 1, 0, mp_args);
    return;
}


/*
 * lvgl extension definition for:
 * void lv_lvsfheader_back_event_cb(lv_obj_t *hdr, lv_event_cb_t cb)
 */
 
STATIC mp_obj_t mp_lv_lvsfheader_back_event_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *hdr = mp_to_lv(mp_args[0]);
    void *cb = mp_lv_callback(mp_args[1], &lv_obj_t_cb_callback, MP_QSTR_lv_obj_t_cb, &hdr->user_data);
    ((void (*)(lv_obj_t *, lv_event_cb_t))lv_func_ptr)(hdr, cb);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_lvsfheader_back_event_cb_obj, 2, mp_lv_lvsfheader_back_event_cb, lv_lvsfheader_back_event_cb);
    
/* Reusing lv_label_set_text for lv_lvsfheader_set_title */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_lvsfheader_set_title_obj, 2, mp_lv_label_set_text, lv_lvsfheader_set_title);
    

/*
 * lvgl extension definition for:
 * void lv_lvsfheader_set_visible_item(lv_obj_t *hdr, lv_lvsfheader_item_t flag)
 */
 
STATIC mp_obj_t mp_lv_lvsfheader_set_visible_item(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *hdr = mp_to_lv(mp_args[0]);
    lv_lvsfheader_item_t flag = (uint8_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_obj_t *, lv_lvsfheader_item_t))lv_func_ptr)(hdr, flag);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_lvsfheader_set_visible_item_obj, 2, mp_lv_lvsfheader_set_visible_item, lv_lvsfheader_set_visible_item);
    

/*
 * lvgl lvsfheader object definitions
 */
    

STATIC const mp_rom_map_elem_t lvsfheader_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_back_event_cb), MP_ROM_PTR(&mp_lv_lvsfheader_back_event_cb_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_title), MP_ROM_PTR(&mp_lv_lvsfheader_set_title_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_visible_item), MP_ROM_PTR(&mp_lv_lvsfheader_set_visible_item_obj) }
};

STATIC MP_DEFINE_CONST_DICT(lvsfheader_locals_dict, lvsfheader_locals_dict_table);

STATIC void lvsfheader_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl lvsfheader");
}


STATIC mp_obj_t lvsfheader_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&lv_lvsfheader_create, type, n_args, n_kw, args);           
}


STATIC const mp_obj_type_t mp_lvsfheader_type = {
    { &mp_type_type },
    .name = MP_QSTR_lvsfheader,
    .print = lvsfheader_print,
    .make_new = lvsfheader_make_new,
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&lvsfheader_locals_dict,
    .buffer_p = { .get_buffer = mp_lv_obj_get_buffer },
    .parent = &mp_obj_type,
};
    
/* Reusing lv_lvsfheader_back_event_cb for lv_lvsfpopup_event_cb */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_lvsfpopup_event_cb_obj, 2, mp_lv_lvsfheader_back_event_cb, lv_lvsfpopup_event_cb);
    
/* Reusing lv_label_set_text for lv_lvsfpopup_set_title */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_lvsfpopup_set_title_obj, 2, mp_lv_label_set_text, lv_lvsfpopup_set_title);
    
/* Reusing lv_img_set_src for lv_lvsfpopup_set_icon */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_lvsfpopup_set_icon_obj, 2, mp_lv_img_set_src, lv_lvsfpopup_set_icon);
    
/* Reusing lv_label_set_text for lv_lvsfpopup_set_content */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_lvsfpopup_set_content_obj, 2, mp_lv_label_set_text, lv_lvsfpopup_set_content);
    
/* Reusing lv_label_set_text for lv_lvsfpopup_set_confirm_btn_txt */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_lvsfpopup_set_confirm_btn_txt_obj, 2, mp_lv_label_set_text, lv_lvsfpopup_set_confirm_btn_txt);
    
/* Reusing lv_label_set_text for lv_lvsfpopup_set_cancel_btn_txt */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_lvsfpopup_set_cancel_btn_txt_obj, 2, mp_lv_label_set_text, lv_lvsfpopup_set_cancel_btn_txt);
    

/*
 * lvgl lvsfpopup object definitions
 */
    

STATIC const mp_rom_map_elem_t lvsfpopup_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_event_cb), MP_ROM_PTR(&mp_lv_lvsfpopup_event_cb_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_title), MP_ROM_PTR(&mp_lv_lvsfpopup_set_title_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_icon), MP_ROM_PTR(&mp_lv_lvsfpopup_set_icon_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_content), MP_ROM_PTR(&mp_lv_lvsfpopup_set_content_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_confirm_btn_txt), MP_ROM_PTR(&mp_lv_lvsfpopup_set_confirm_btn_txt_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_cancel_btn_txt), MP_ROM_PTR(&mp_lv_lvsfpopup_set_cancel_btn_txt_obj) }
};

STATIC MP_DEFINE_CONST_DICT(lvsfpopup_locals_dict, lvsfpopup_locals_dict_table);

STATIC void lvsfpopup_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl lvsfpopup");
}


STATIC mp_obj_t lvsfpopup_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&lv_lvsfpopup_create, type, n_args, n_kw, args);           
}


STATIC const mp_obj_type_t mp_lvsfpopup_type = {
    { &mp_type_type },
    .name = MP_QSTR_lvsfpopup,
    .print = lvsfpopup_print,
    .make_new = lvsfpopup_make_new,
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&lvsfpopup_locals_dict,
    .buffer_p = { .get_buffer = mp_lv_obj_get_buffer },
    .parent = &mp_obj_type,
};
    

/*
 * lvgl extension definition for:
 * void lv_lvsfcomp_set_type(lv_obj_t *comp, int type)
 */
 
STATIC mp_obj_t mp_lv_lvsfcomp_set_type(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *comp = mp_to_lv(mp_args[0]);
    int type = (int)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_obj_t *, int))lv_func_ptr)(comp, type);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_lvsfcomp_set_type_obj, 2, mp_lv_lvsfcomp_set_type, lv_lvsfcomp_set_type);
    
/* Reusing lv_list_add_text for lv_lvsfcomp_text */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_lvsfcomp_text_obj, 2, mp_lv_list_add_text, lv_lvsfcomp_text);
    

/*
 * lvgl extension definition for:
 * lv_obj_t *lv_lvsfcomp_ring(lv_obj_t *comp, int index, int scale, lv_color_t color, lv_color_t bg_color)
 */
 
STATIC mp_obj_t mp_lv_lvsfcomp_ring(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *comp = mp_to_lv(mp_args[0]);
    int index = (int)mp_obj_get_int(mp_args[1]);
    int scale = (int)mp_obj_get_int(mp_args[2]);
    lv_color_t color = mp_write_lv_color16_t(mp_args[3]);
    lv_color_t bg_color = mp_write_lv_color16_t(mp_args[4]);
    lv_obj_t * _res = ((lv_obj_t *(*)(lv_obj_t *, int, int, lv_color_t, lv_color_t))lv_func_ptr)(comp, index, scale, color, bg_color);
    return lv_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_lvsfcomp_ring_obj, 5, mp_lv_lvsfcomp_ring, lv_lvsfcomp_ring);
    

/*
 * lvgl extension definition for:
 * lv_obj_t *lv_lvsfcomp_arc(lv_obj_t *comp, int scale, lv_color_t color, lv_color_t bg_color)
 */
 
STATIC mp_obj_t mp_lv_lvsfcomp_arc(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *comp = mp_to_lv(mp_args[0]);
    int scale = (int)mp_obj_get_int(mp_args[1]);
    lv_color_t color = mp_write_lv_color16_t(mp_args[2]);
    lv_color_t bg_color = mp_write_lv_color16_t(mp_args[3]);
    lv_obj_t * _res = ((lv_obj_t *(*)(lv_obj_t *, int, lv_color_t, lv_color_t))lv_func_ptr)(comp, scale, color, bg_color);
    return lv_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_lvsfcomp_arc_obj, 4, mp_lv_lvsfcomp_arc, lv_lvsfcomp_arc);
    

/*
 * lvgl extension definition for:
 * void lv_lvsfcomp_set_ring(lv_obj_t *comp, int index, int scale)
 */
 
STATIC mp_obj_t mp_lv_lvsfcomp_set_ring(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *comp = mp_to_lv(mp_args[0]);
    int index = (int)mp_obj_get_int(mp_args[1]);
    int scale = (int)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_obj_t *, int, int))lv_func_ptr)(comp, index, scale);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_lvsfcomp_set_ring_obj, 3, mp_lv_lvsfcomp_set_ring, lv_lvsfcomp_set_ring);
    
/* Reusing lv_lvsfcomp_set_type for lv_lvsfcomp_set_arc */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_lvsfcomp_set_arc_obj, 2, mp_lv_lvsfcomp_set_type, lv_lvsfcomp_set_arc);
    
/* Reusing lv_list_add_text for lv_lvsfcomp_img */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_lvsfcomp_img_obj, 2, mp_lv_list_add_text, lv_lvsfcomp_img);
    

/*
 * lvgl lvsfcomp object definitions
 */
    

STATIC const mp_rom_map_elem_t lvsfcomp_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_set_type), MP_ROM_PTR(&mp_lv_lvsfcomp_set_type_obj) },
    { MP_ROM_QSTR(MP_QSTR_text), MP_ROM_PTR(&mp_lv_lvsfcomp_text_obj) },
    { MP_ROM_QSTR(MP_QSTR_ring), MP_ROM_PTR(&mp_lv_lvsfcomp_ring_obj) },
    { MP_ROM_QSTR(MP_QSTR_arc), MP_ROM_PTR(&mp_lv_lvsfcomp_arc_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_ring), MP_ROM_PTR(&mp_lv_lvsfcomp_set_ring_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_arc), MP_ROM_PTR(&mp_lv_lvsfcomp_set_arc_obj) },
    { MP_ROM_QSTR(MP_QSTR_img), MP_ROM_PTR(&mp_lv_lvsfcomp_img_obj) }
};

STATIC MP_DEFINE_CONST_DICT(lvsfcomp_locals_dict, lvsfcomp_locals_dict_table);

STATIC void lvsfcomp_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl lvsfcomp");
}


STATIC mp_obj_t lvsfcomp_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&lv_lvsfcomp_create, type, n_args, n_kw, args);           
}


STATIC const mp_obj_type_t mp_lvsfcomp_type = {
    { &mp_type_type },
    .name = MP_QSTR_lvsfcomp,
    .print = lvsfcomp_print,
    .make_new = lvsfcomp_make_new,
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&lvsfcomp_locals_dict,
    .buffer_p = { .get_buffer = mp_lv_obj_get_buffer },
    .parent = &mp_obj_type,
};
    

/*
 * lvgl extension definition for:
 * void lv_lvsfcorner_zone(lv_obj_t *corner, uint16_t zone, uint16_t r, uint16_t x, uint16_t y)
 */
 
STATIC mp_obj_t mp_lv_lvsfcorner_zone(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *corner = mp_to_lv(mp_args[0]);
    uint16_t zone = (uint16_t)mp_obj_get_int(mp_args[1]);
    uint16_t r = (uint16_t)mp_obj_get_int(mp_args[2]);
    uint16_t x = (uint16_t)mp_obj_get_int(mp_args[3]);
    uint16_t y = (uint16_t)mp_obj_get_int(mp_args[4]);
    ((void (*)(lv_obj_t *, uint16_t, uint16_t, uint16_t, uint16_t))lv_func_ptr)(corner, zone, r, x, y);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_lvsfcorner_zone_obj, 5, mp_lv_lvsfcorner_zone, lv_lvsfcorner_zone);
    
/* Reusing lv_menu_page_create for lv_lvsfcorner_curve_text */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_lvsfcorner_curve_text_obj, 2, mp_lv_menu_page_create, lv_lvsfcorner_curve_text);
    
/* Reusing lv_list_add_text for lv_lvsfcorner_img */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_lvsfcorner_img_obj, 2, mp_lv_list_add_text, lv_lvsfcorner_img);
    
/* Reusing lv_menu_page_create for lv_lvsfcorner_text */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_lvsfcorner_text_obj, 2, mp_lv_menu_page_create, lv_lvsfcorner_text);
    

/*
 * lvgl extension definition for:
 * lv_obj_t *lv_lvsfcorner_arc(lv_obj_t *corner, int start, int end, lv_color_t color)
 */
 
STATIC mp_obj_t mp_lv_lvsfcorner_arc(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *corner = mp_to_lv(mp_args[0]);
    int start = (int)mp_obj_get_int(mp_args[1]);
    int end = (int)mp_obj_get_int(mp_args[2]);
    lv_color_t color = mp_write_lv_color16_t(mp_args[3]);
    lv_obj_t * _res = ((lv_obj_t *(*)(lv_obj_t *, int, int, lv_color_t))lv_func_ptr)(corner, start, end, color);
    return lv_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_lvsfcorner_arc_obj, 4, mp_lv_lvsfcorner_arc, lv_lvsfcorner_arc);
    
/* Reusing lv_lvsfcomp_set_type for lv_lvsfcorner_arc_scale */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_lvsfcorner_arc_scale_obj, 2, mp_lv_lvsfcomp_set_type, lv_lvsfcorner_arc_scale);
    

/*
 * lvgl lvsfcorner object definitions
 */
    

STATIC const mp_rom_map_elem_t lvsfcorner_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_zone), MP_ROM_PTR(&mp_lv_lvsfcorner_zone_obj) },
    { MP_ROM_QSTR(MP_QSTR_curve_text), MP_ROM_PTR(&mp_lv_lvsfcorner_curve_text_obj) },
    { MP_ROM_QSTR(MP_QSTR_img), MP_ROM_PTR(&mp_lv_lvsfcorner_img_obj) },
    { MP_ROM_QSTR(MP_QSTR_text), MP_ROM_PTR(&mp_lv_lvsfcorner_text_obj) },
    { MP_ROM_QSTR(MP_QSTR_arc), MP_ROM_PTR(&mp_lv_lvsfcorner_arc_obj) },
    { MP_ROM_QSTR(MP_QSTR_arc_scale), MP_ROM_PTR(&mp_lv_lvsfcorner_arc_scale_obj) }
};

STATIC MP_DEFINE_CONST_DICT(lvsfcorner_locals_dict, lvsfcorner_locals_dict_table);

STATIC void lvsfcorner_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl lvsfcorner");
}


STATIC mp_obj_t lvsfcorner_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&lv_lvsfcorner_create, type, n_args, n_kw, args);           
}


STATIC const mp_obj_type_t mp_lvsfcorner_type = {
    { &mp_type_type },
    .name = MP_QSTR_lvsfcorner,
    .print = lvsfcorner_print,
    .make_new = lvsfcorner_make_new,
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&lvsfcorner_locals_dict,
    .buffer_p = { .get_buffer = mp_lv_obj_get_buffer },
    .parent = &mp_obj_type,
};
    
/* Reusing lv_qrcode_set_text for lv_lvsfbarcode_set_text */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_lvsfbarcode_set_text_obj, 2, mp_lv_qrcode_set_text, lv_lvsfbarcode_set_text);
    

/*
 * lvgl lvsfbarcode object definitions
 */
    

STATIC const mp_rom_map_elem_t lvsfbarcode_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_set_text), MP_ROM_PTR(&mp_lv_lvsfbarcode_set_text_obj) }
};

STATIC MP_DEFINE_CONST_DICT(lvsfbarcode_locals_dict, lvsfbarcode_locals_dict_table);

STATIC void lvsfbarcode_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl lvsfbarcode");
}


STATIC mp_obj_t lvsfbarcode_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&lv_lvsfbarcode_create, type, n_args, n_kw, args);           
}


STATIC const mp_obj_type_t mp_lvsfbarcode_type = {
    { &mp_type_type },
    .name = MP_QSTR_lvsfbarcode,
    .print = lvsfbarcode_print,
    .make_new = lvsfbarcode_make_new,
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&lvsfbarcode_locals_dict,
    .buffer_p = { .get_buffer = mp_lv_obj_get_buffer },
    .parent = &mp_obj_type,
};
    

/*
 * lvgl extension definition for:
 * int lv_analogclk_img(lv_obj_t *aclk, const char *bg, const char *hour, const char *min, const char *second)
 */
 
STATIC mp_obj_t mp_lv_analogclk_img(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *aclk = mp_to_lv(mp_args[0]);
    const char *bg = (char*)convert_from_str(mp_args[1]);
    const char *hour = (char*)convert_from_str(mp_args[2]);
    const char *min = (char*)convert_from_str(mp_args[3]);
    const char *second = (char*)convert_from_str(mp_args[4]);
    int _res = ((int (*)(lv_obj_t *, const char *, const char *, const char *, const char *))lv_func_ptr)(aclk, bg, hour, min, second);
    return mp_obj_new_int(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_analogclk_img_obj, 5, mp_lv_analogclk_img, lv_analogclk_img);
    
/* Reusing lv_arc_set_start_angle for lv_analogclk_refr_inteval */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_analogclk_refr_inteval_obj, 2, mp_lv_arc_set_start_angle, lv_analogclk_refr_inteval);
    

/*
 * lvgl extension definition for:
 * void lv_analogclk_pos_off(lv_obj_t *aclk, uint8_t hoff, uint8_t moff, uint8_t soff)
 */
 
STATIC mp_obj_t mp_lv_analogclk_pos_off(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *aclk = mp_to_lv(mp_args[0]);
    uint8_t hoff = (uint8_t)mp_obj_get_int(mp_args[1]);
    uint8_t moff = (uint8_t)mp_obj_get_int(mp_args[2]);
    uint8_t soff = (uint8_t)mp_obj_get_int(mp_args[3]);
    ((void (*)(lv_obj_t *, uint8_t, uint8_t, uint8_t))lv_func_ptr)(aclk, hoff, moff, soff);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_analogclk_pos_off_obj, 4, mp_lv_analogclk_pos_off, lv_analogclk_pos_off);
    

/*
 * lvgl analogclk object definitions
 */
    

STATIC const mp_rom_map_elem_t analogclk_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_img), MP_ROM_PTR(&mp_lv_analogclk_img_obj) },
    { MP_ROM_QSTR(MP_QSTR_refr_inteval), MP_ROM_PTR(&mp_lv_analogclk_refr_inteval_obj) },
    { MP_ROM_QSTR(MP_QSTR_pos_off), MP_ROM_PTR(&mp_lv_analogclk_pos_off_obj) }
};

STATIC MP_DEFINE_CONST_DICT(analogclk_locals_dict, analogclk_locals_dict_table);

STATIC void analogclk_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl analogclk");
}


STATIC mp_obj_t analogclk_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&lv_analogclk_create, type, n_args, n_kw, args);           
}


STATIC const mp_obj_type_t mp_analogclk_type = {
    { &mp_type_type },
    .name = MP_QSTR_analogclk,
    .print = analogclk_print,
    .make_new = analogclk_make_new,
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&analogclk_locals_dict,
    .buffer_p = { .get_buffer = mp_lv_obj_get_buffer },
    .parent = &mp_obj_type,
};
    

/*
 * lvgl extension definition for:
 * void lv_idximg_bind_src_array(lv_obj_t *idximg, const lv_img_dsc_t **dsc_array, uint16_t size)
 */
 
STATIC mp_obj_t mp_lv_idximg_bind_src_array(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *idximg = mp_to_lv(mp_args[0]);
    const lv_img_dsc_t **dsc_array = mp_to_ptr(mp_args[1]);
    uint16_t size = (uint16_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_obj_t *, const lv_img_dsc_t **, uint16_t))lv_func_ptr)(idximg, dsc_array, size);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_idximg_bind_src_array_obj, 3, mp_lv_idximg_bind_src_array, lv_idximg_bind_src_array);
    
/* Reusing lv_arc_set_start_angle for lv_idximg_select */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_idximg_select_obj, 2, mp_lv_arc_set_start_angle, lv_idximg_select);
    
/* Reusing lv_label_set_text for lv_idximg_prefix */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_idximg_prefix_obj, 2, mp_lv_label_set_text, lv_idximg_prefix);
    

/*
 * lvgl idximg object definitions
 */
    

STATIC const mp_rom_map_elem_t idximg_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_bind_src_array), MP_ROM_PTR(&mp_lv_idximg_bind_src_array_obj) },
    { MP_ROM_QSTR(MP_QSTR_select), MP_ROM_PTR(&mp_lv_idximg_select_obj) },
    { MP_ROM_QSTR(MP_QSTR_prefix), MP_ROM_PTR(&mp_lv_idximg_prefix_obj) }
};

STATIC MP_DEFINE_CONST_DICT(idximg_locals_dict, idximg_locals_dict_table);

STATIC void idximg_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl idximg");
}


STATIC mp_obj_t idximg_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&lv_idximg_create, type, n_args, n_kw, args);           
}


STATIC const mp_obj_type_t mp_idximg_type = {
    { &mp_type_type },
    .name = MP_QSTR_idximg,
    .print = idximg_print,
    .make_new = idximg_make_new,
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&idximg_locals_dict,
    .buffer_p = { .get_buffer = mp_lv_obj_get_buffer },
    .parent = &mp_obj_type,
};
    
/* Reusing lv_arc_set_angles for lv_lvsfcurve_set_buf */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_lvsfcurve_set_buf_obj, 3, mp_lv_arc_set_angles, lv_lvsfcurve_set_buf);
    
/* Reusing lv_img_set_pivot for lv_lvsfcurve_set_pivot */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_lvsfcurve_set_pivot_obj, 3, mp_lv_img_set_pivot, lv_lvsfcurve_set_pivot);
    

/*
 * lvgl extension definition for:
 * void lv_lvsfcurve_draw_arc(lv_obj_t *curve, lv_coord_t r, int32_t start_angle, int32_t end_angle, lv_color_t color, lv_coord_t width)
 */
 
STATIC mp_obj_t mp_lv_lvsfcurve_draw_arc(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *curve = mp_to_lv(mp_args[0]);
    lv_coord_t r = (int16_t)mp_obj_get_int(mp_args[1]);
    int32_t start_angle = (int32_t)mp_obj_get_int(mp_args[2]);
    int32_t end_angle = (int32_t)mp_obj_get_int(mp_args[3]);
    lv_color_t color = mp_write_lv_color16_t(mp_args[4]);
    lv_coord_t width = (int16_t)mp_obj_get_int(mp_args[5]);
    ((void (*)(lv_obj_t *, lv_coord_t, int32_t, int32_t, lv_color_t, lv_coord_t))lv_func_ptr)(curve, r, start_angle, end_angle, color, width);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_lvsfcurve_draw_arc_obj, 6, mp_lv_lvsfcurve_draw_arc, lv_lvsfcurve_draw_arc);
    

/*
 * lvgl extension definition for:
 * void lv_lvsfcurve_text(lv_obj_t *curve, char *text, int angle, int r, lv_color_t color, int size)
 */
 
STATIC mp_obj_t mp_lv_lvsfcurve_text(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *curve = mp_to_lv(mp_args[0]);
    char *text = (char*)convert_from_str(mp_args[1]);
    int angle = (int)mp_obj_get_int(mp_args[2]);
    int r = (int)mp_obj_get_int(mp_args[3]);
    lv_color_t color = mp_write_lv_color16_t(mp_args[4]);
    int size = (int)mp_obj_get_int(mp_args[5]);
    ((void (*)(lv_obj_t *, char *, int, int, lv_color_t, int))lv_func_ptr)(curve, text, angle, r, color, size);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_lvsfcurve_text_obj, 6, mp_lv_lvsfcurve_text, lv_lvsfcurve_text);
    

/*
 * lvgl lvsfcurve object definitions
 */
    

STATIC const mp_rom_map_elem_t lvsfcurve_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_set_buf), MP_ROM_PTR(&mp_lv_lvsfcurve_set_buf_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_pivot), MP_ROM_PTR(&mp_lv_lvsfcurve_set_pivot_obj) },
    { MP_ROM_QSTR(MP_QSTR_draw_arc), MP_ROM_PTR(&mp_lv_lvsfcurve_draw_arc_obj) },
    { MP_ROM_QSTR(MP_QSTR_text), MP_ROM_PTR(&mp_lv_lvsfcurve_text_obj) }
};

STATIC MP_DEFINE_CONST_DICT(lvsfcurve_locals_dict, lvsfcurve_locals_dict_table);

STATIC void lvsfcurve_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl lvsfcurve");
}


STATIC mp_obj_t lvsfcurve_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&lv_lvsfcurve_create, type, n_args, n_kw, args);           
}


STATIC const mp_obj_type_t mp_lvsfcurve_type = {
    { &mp_type_type },
    .name = MP_QSTR_lvsfcurve,
    .print = lvsfcurve_print,
    .make_new = lvsfcurve_make_new,
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&lvsfcurve_locals_dict,
    .buffer_p = { .get_buffer = mp_lv_obj_get_buffer },
    .parent = &mp_obj_type,
};
    
/* Reusing lv_label_set_text for lv_lvsfaezip_set_src */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_lvsfaezip_set_src_obj, 2, mp_lv_label_set_text, lv_lvsfaezip_set_src);
    
/* Reusing lv_obj_move_foreground for lv_lvsfaezip_play */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_lvsfaezip_play_obj, 1, mp_lv_obj_move_foreground, lv_lvsfaezip_play);
    
/* Reusing lv_obj_move_foreground for lv_lvsfaezip_stop */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_lvsfaezip_stop_obj, 1, mp_lv_obj_move_foreground, lv_lvsfaezip_stop);
    

/*
 * lvgl lvsfaezip object definitions
 */
    

STATIC const mp_rom_map_elem_t lvsfaezip_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_set_src), MP_ROM_PTR(&mp_lv_lvsfaezip_set_src_obj) },
    { MP_ROM_QSTR(MP_QSTR_play), MP_ROM_PTR(&mp_lv_lvsfaezip_play_obj) },
    { MP_ROM_QSTR(MP_QSTR_stop), MP_ROM_PTR(&mp_lv_lvsfaezip_stop_obj) }
};

STATIC MP_DEFINE_CONST_DICT(lvsfaezip_locals_dict, lvsfaezip_locals_dict_table);

STATIC void lvsfaezip_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl lvsfaezip");
}


STATIC mp_obj_t lvsfaezip_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&lv_lvsfaezip_create, type, n_args, n_kw, args);           
}


STATIC const mp_obj_type_t mp_lvsfaezip_type = {
    { &mp_type_type },
    .name = MP_QSTR_lvsfaezip,
    .print = lvsfaezip_print,
    .make_new = lvsfaezip_make_new,
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&lvsfaezip_locals_dict,
    .buffer_p = { .get_buffer = mp_lv_obj_get_buffer },
    .parent = &mp_obj_type,
};
    

/*
 * lvgl extension definition for:
 * int lv_rlottie_file(lv_obj_t *lottie, const char *path)
 */
 
STATIC mp_obj_t mp_lv_rlottie_file(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *lottie = mp_to_lv(mp_args[0]);
    const char *path = (char*)convert_from_str(mp_args[1]);
    int _res = ((int (*)(lv_obj_t *, const char *))lv_func_ptr)(lottie, path);
    return mp_obj_new_int(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_rlottie_file_obj, 2, mp_lv_rlottie_file, lv_rlottie_file);
    
/* Reusing lv_rlottie_file for lv_rlottie_raw */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_rlottie_raw_obj, 2, mp_lv_rlottie_file, lv_rlottie_raw);
    

/*
 * lvgl extension definition for:
 * int lv_rlottie_play(lv_obj_t *lottie, int enable)
 */
 
STATIC mp_obj_t mp_lv_rlottie_play(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *lottie = mp_to_lv(mp_args[0]);
    int enable = (int)mp_obj_get_int(mp_args[1]);
    int _res = ((int (*)(lv_obj_t *, int))lv_func_ptr)(lottie, enable);
    return mp_obj_new_int(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_rlottie_play_obj, 2, mp_lv_rlottie_play, lv_rlottie_play);
    

/*
 * lvgl rlottie object definitions
 */
    

STATIC const mp_rom_map_elem_t rlottie_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_file), MP_ROM_PTR(&mp_lv_rlottie_file_obj) },
    { MP_ROM_QSTR(MP_QSTR_raw), MP_ROM_PTR(&mp_lv_rlottie_raw_obj) },
    { MP_ROM_QSTR(MP_QSTR_play), MP_ROM_PTR(&mp_lv_rlottie_play_obj) }
};

STATIC MP_DEFINE_CONST_DICT(rlottie_locals_dict, rlottie_locals_dict_table);

STATIC void rlottie_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl rlottie");
}


STATIC mp_obj_t rlottie_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&lv_rlottie_create, type, n_args, n_kw, args);           
}


STATIC const mp_obj_type_t mp_rlottie_type = {
    { &mp_type_type },
    .name = MP_QSTR_rlottie,
    .print = rlottie_print,
    .make_new = rlottie_make_new,
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&rlottie_locals_dict,
    .buffer_p = { .get_buffer = mp_lv_obj_get_buffer },
    .parent = &mp_obj_type,
};
    

/*
 * Struct lv_mem_monitor_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_mem_monitor_t_type();

STATIC inline lv_mem_monitor_t* mp_write_ptr_lv_mem_monitor_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_mem_monitor_t_type()));
    return (lv_mem_monitor_t*)self->data;
}

#define mp_write_lv_mem_monitor_t(struct_obj) *mp_write_ptr_lv_mem_monitor_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_mem_monitor_t(lv_mem_monitor_t *field)
{
    return lv_to_mp_struct(get_mp_lv_mem_monitor_t_type(), (void*)field);
}

#define mp_read_lv_mem_monitor_t(field) mp_read_ptr_lv_mem_monitor_t(copy_buffer(&field, sizeof(lv_mem_monitor_t)))
#define mp_read_byref_lv_mem_monitor_t(field) mp_read_ptr_lv_mem_monitor_t(&field)

STATIC void mp_lv_mem_monitor_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_mem_monitor_t *data = (lv_mem_monitor_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_total_size: dest[0] = mp_obj_new_int_from_uint(data->total_size); break; // converting from uint32_t;
            case MP_QSTR_free_cnt: dest[0] = mp_obj_new_int_from_uint(data->free_cnt); break; // converting from uint32_t;
            case MP_QSTR_free_size: dest[0] = mp_obj_new_int_from_uint(data->free_size); break; // converting from uint32_t;
            case MP_QSTR_free_biggest_size: dest[0] = mp_obj_new_int_from_uint(data->free_biggest_size); break; // converting from uint32_t;
            case MP_QSTR_used_cnt: dest[0] = mp_obj_new_int_from_uint(data->used_cnt); break; // converting from uint32_t;
            case MP_QSTR_max_used: dest[0] = mp_obj_new_int_from_uint(data->max_used); break; // converting from uint32_t;
            case MP_QSTR_used_pct: dest[0] = mp_obj_new_int_from_uint(data->used_pct); break; // converting from uint8_t;
            case MP_QSTR_frag_pct: dest[0] = mp_obj_new_int_from_uint(data->frag_pct); break; // converting from uint8_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_total_size: data->total_size = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_free_cnt: data->free_cnt = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_free_size: data->free_size = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_free_biggest_size: data->free_biggest_size = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_used_cnt: data->used_cnt = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_max_used: data->max_used = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_used_pct: data->used_pct = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                case MP_QSTR_frag_pct: data->frag_pct = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_mem_monitor_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_mem_monitor_t");
}

STATIC const mp_obj_dict_t mp_lv_mem_monitor_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_mem_monitor_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_mem_monitor_t,
    .print = mp_lv_mem_monitor_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_mem_monitor_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_mem_monitor_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_mem_monitor_t_type()
{
    return &mp_lv_mem_monitor_t_type;
}
    
#define funcptr_lv_async_cb_t NULL


/*
 * lvgl extension definition for:
 * void lv_async_cb_t(void *)
 */
 
STATIC mp_obj_t mp_funcptr_lv_async_cb_t(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    void *arg0 = mp_to_ptr(mp_args[0]);
    ((void (*)(void *))lv_func_ptr)(arg0);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_lv_async_cb_t_obj, 1, mp_funcptr_lv_async_cb_t, funcptr_lv_async_cb_t);
    
STATIC inline mp_obj_t mp_lv_funcptr_lv_async_cb_t(void *func){ return mp_lv_funcptr(&mp_funcptr_lv_async_cb_t_obj, func, NULL, MP_QSTR_, NULL); }

#define funcptr_ready_cb NULL


/*
 * lvgl extension definition for:
 * bool ready_cb(struct _lv_fs_drv_t *drv)
 */
 
STATIC mp_obj_t mp_funcptr_ready_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_fs_drv_t *drv = mp_to_ptr(mp_args[0]);
    bool _res = ((bool (*)(struct _lv_fs_drv_t *))lv_func_ptr)(drv);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_ready_cb_obj, 1, mp_funcptr_ready_cb, funcptr_ready_cb);
    
STATIC inline mp_obj_t mp_lv_funcptr_ready_cb(void *func){ return mp_lv_funcptr(&mp_funcptr_ready_cb_obj, func, NULL, MP_QSTR_, NULL); }

STATIC bool lv_fs_drv_t_ready_cb_callback(struct _lv_fs_drv_t *drv);
#define funcptr_open_cb NULL


/*
 * lvgl extension definition for:
 * void *open_cb(struct _lv_fs_drv_t *drv, const char *path, lv_fs_mode_t mode)
 */
 
STATIC mp_obj_t mp_funcptr_open_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_fs_drv_t *drv = mp_to_ptr(mp_args[0]);
    const char *path = (char*)convert_from_str(mp_args[1]);
    lv_fs_mode_t mode = (uint8_t)mp_obj_get_int(mp_args[2]);
    void * _res = ((void *(*)(struct _lv_fs_drv_t *, const char *, lv_fs_mode_t))lv_func_ptr)(drv, path, mode);
    return ptr_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_open_cb_obj, 3, mp_funcptr_open_cb, funcptr_open_cb);
    
STATIC inline mp_obj_t mp_lv_funcptr_open_cb(void *func){ return mp_lv_funcptr(&mp_funcptr_open_cb_obj, func, NULL, MP_QSTR_, NULL); }

STATIC void * lv_fs_drv_t_open_cb_callback(struct _lv_fs_drv_t *drv, const char *path, lv_fs_mode_t mode);
#define funcptr_close_cb NULL


/*
 * lvgl extension definition for:
 * lv_fs_res_t close_cb(struct _lv_fs_drv_t *drv, void *file_p)
 */
 
STATIC mp_obj_t mp_funcptr_close_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_fs_drv_t *drv = mp_to_ptr(mp_args[0]);
    void *file_p = mp_to_ptr(mp_args[1]);
    lv_fs_res_t _res = ((lv_fs_res_t (*)(struct _lv_fs_drv_t *, void *))lv_func_ptr)(drv, file_p);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_close_cb_obj, 2, mp_funcptr_close_cb, funcptr_close_cb);
    
STATIC inline mp_obj_t mp_lv_funcptr_close_cb(void *func){ return mp_lv_funcptr(&mp_funcptr_close_cb_obj, func, NULL, MP_QSTR_, NULL); }

STATIC lv_fs_res_t lv_fs_drv_t_close_cb_callback(struct _lv_fs_drv_t *drv, void *file_p);
#define funcptr_read_cb NULL


/*
 * lvgl extension definition for:
 * lv_fs_res_t read_cb(struct _lv_fs_drv_t *drv, void *file_p, void *buf, uint32_t btr, uint32_t *br)
 */
 
STATIC mp_obj_t mp_funcptr_read_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_fs_drv_t *drv = mp_to_ptr(mp_args[0]);
    void *file_p = mp_to_ptr(mp_args[1]);
    void *buf = mp_to_ptr(mp_args[2]);
    uint32_t btr = (uint32_t)mp_obj_get_int(mp_args[3]);
    uint32_t *br = mp_to_ptr(mp_args[4]);
    lv_fs_res_t _res = ((lv_fs_res_t (*)(struct _lv_fs_drv_t *, void *, void *, uint32_t, uint32_t *))lv_func_ptr)(drv, file_p, buf, btr, br);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_read_cb_obj, 5, mp_funcptr_read_cb, funcptr_read_cb);
    
STATIC inline mp_obj_t mp_lv_funcptr_read_cb(void *func){ return mp_lv_funcptr(&mp_funcptr_read_cb_obj, func, NULL, MP_QSTR_, NULL); }

STATIC lv_fs_res_t lv_fs_drv_t_read_cb_callback(struct _lv_fs_drv_t *drv, void *file_p, void *buf, uint32_t btr, uint32_t *br);
#define funcptr_write_cb NULL


/*
 * lvgl extension definition for:
 * lv_fs_res_t write_cb(struct _lv_fs_drv_t *drv, void *file_p, const void *buf, uint32_t btw, uint32_t *bw)
 */
 
STATIC mp_obj_t mp_funcptr_write_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_fs_drv_t *drv = mp_to_ptr(mp_args[0]);
    void *file_p = mp_to_ptr(mp_args[1]);
    const void *buf = mp_to_ptr(mp_args[2]);
    uint32_t btw = (uint32_t)mp_obj_get_int(mp_args[3]);
    uint32_t *bw = mp_to_ptr(mp_args[4]);
    lv_fs_res_t _res = ((lv_fs_res_t (*)(struct _lv_fs_drv_t *, void *, const void *, uint32_t, uint32_t *))lv_func_ptr)(drv, file_p, buf, btw, bw);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_write_cb_obj, 5, mp_funcptr_write_cb, funcptr_write_cb);
    
STATIC inline mp_obj_t mp_lv_funcptr_write_cb(void *func){ return mp_lv_funcptr(&mp_funcptr_write_cb_obj, func, NULL, MP_QSTR_, NULL); }

STATIC lv_fs_res_t lv_fs_drv_t_write_cb_callback(struct _lv_fs_drv_t *drv, void *file_p, const void *buf, uint32_t btw, uint32_t *bw);
#define funcptr_seek_cb NULL


/*
 * lvgl extension definition for:
 * lv_fs_res_t seek_cb(struct _lv_fs_drv_t *drv, void *file_p, uint32_t pos, lv_fs_whence_t whence)
 */
 
STATIC mp_obj_t mp_funcptr_seek_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_fs_drv_t *drv = mp_to_ptr(mp_args[0]);
    void *file_p = mp_to_ptr(mp_args[1]);
    uint32_t pos = (uint32_t)mp_obj_get_int(mp_args[2]);
    lv_fs_whence_t whence = (int)mp_obj_get_int(mp_args[3]);
    lv_fs_res_t _res = ((lv_fs_res_t (*)(struct _lv_fs_drv_t *, void *, uint32_t, lv_fs_whence_t))lv_func_ptr)(drv, file_p, pos, whence);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_seek_cb_obj, 4, mp_funcptr_seek_cb, funcptr_seek_cb);
    
STATIC inline mp_obj_t mp_lv_funcptr_seek_cb(void *func){ return mp_lv_funcptr(&mp_funcptr_seek_cb_obj, func, NULL, MP_QSTR_, NULL); }

STATIC lv_fs_res_t lv_fs_drv_t_seek_cb_callback(struct _lv_fs_drv_t *drv, void *file_p, uint32_t pos, lv_fs_whence_t whence);
#define funcptr_tell_cb NULL


/*
 * lvgl extension definition for:
 * lv_fs_res_t tell_cb(struct _lv_fs_drv_t *drv, void *file_p, uint32_t *pos_p)
 */
 
STATIC mp_obj_t mp_funcptr_tell_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_fs_drv_t *drv = mp_to_ptr(mp_args[0]);
    void *file_p = mp_to_ptr(mp_args[1]);
    uint32_t *pos_p = mp_to_ptr(mp_args[2]);
    lv_fs_res_t _res = ((lv_fs_res_t (*)(struct _lv_fs_drv_t *, void *, uint32_t *))lv_func_ptr)(drv, file_p, pos_p);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_tell_cb_obj, 3, mp_funcptr_tell_cb, funcptr_tell_cb);
    
STATIC inline mp_obj_t mp_lv_funcptr_tell_cb(void *func){ return mp_lv_funcptr(&mp_funcptr_tell_cb_obj, func, NULL, MP_QSTR_, NULL); }

STATIC lv_fs_res_t lv_fs_drv_t_tell_cb_callback(struct _lv_fs_drv_t *drv, void *file_p, uint32_t *pos_p);
#define funcptr_dir_open_cb NULL


/*
 * lvgl extension definition for:
 * void *dir_open_cb(struct _lv_fs_drv_t *drv, const char *path)
 */
 
STATIC mp_obj_t mp_funcptr_dir_open_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_fs_drv_t *drv = mp_to_ptr(mp_args[0]);
    const char *path = (char*)convert_from_str(mp_args[1]);
    void * _res = ((void *(*)(struct _lv_fs_drv_t *, const char *))lv_func_ptr)(drv, path);
    return ptr_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_dir_open_cb_obj, 2, mp_funcptr_dir_open_cb, funcptr_dir_open_cb);
    
STATIC inline mp_obj_t mp_lv_funcptr_dir_open_cb(void *func){ return mp_lv_funcptr(&mp_funcptr_dir_open_cb_obj, func, NULL, MP_QSTR_, NULL); }

STATIC void * lv_fs_drv_t_dir_open_cb_callback(struct _lv_fs_drv_t *drv, const char *path);
#define funcptr_dir_read_cb NULL


/*
 * lvgl extension definition for:
 * lv_fs_res_t dir_read_cb(struct _lv_fs_drv_t *drv, void *rddir_p, char *fn)
 */
 
STATIC mp_obj_t mp_funcptr_dir_read_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_fs_drv_t *drv = mp_to_ptr(mp_args[0]);
    void *rddir_p = mp_to_ptr(mp_args[1]);
    char *fn = (char*)convert_from_str(mp_args[2]);
    lv_fs_res_t _res = ((lv_fs_res_t (*)(struct _lv_fs_drv_t *, void *, char *))lv_func_ptr)(drv, rddir_p, fn);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_dir_read_cb_obj, 3, mp_funcptr_dir_read_cb, funcptr_dir_read_cb);
    
STATIC inline mp_obj_t mp_lv_funcptr_dir_read_cb(void *func){ return mp_lv_funcptr(&mp_funcptr_dir_read_cb_obj, func, NULL, MP_QSTR_, NULL); }

STATIC lv_fs_res_t lv_fs_drv_t_dir_read_cb_callback(struct _lv_fs_drv_t *drv, void *rddir_p, char *fn);
#define funcptr_dir_close_cb NULL

/* Reusing funcptr_close_cb for funcptr_dir_close_cb */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_dir_close_cb_obj, 2, mp_funcptr_close_cb, funcptr_dir_close_cb);
    
STATIC inline mp_obj_t mp_lv_funcptr_dir_close_cb(void *func){ return mp_lv_funcptr(&mp_funcptr_dir_close_cb_obj, func, NULL, MP_QSTR_, NULL); }

STATIC lv_fs_res_t lv_fs_drv_t_dir_close_cb_callback(struct _lv_fs_drv_t *drv, void *rddir_p);

/*
 * Struct lv_fs_drv_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_fs_drv_t_type();

STATIC inline lv_fs_drv_t* mp_write_ptr_lv_fs_drv_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_fs_drv_t_type()));
    return (lv_fs_drv_t*)self->data;
}

#define mp_write_lv_fs_drv_t(struct_obj) *mp_write_ptr_lv_fs_drv_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_fs_drv_t(lv_fs_drv_t *field)
{
    return lv_to_mp_struct(get_mp_lv_fs_drv_t_type(), (void*)field);
}

#define mp_read_lv_fs_drv_t(field) mp_read_ptr_lv_fs_drv_t(copy_buffer(&field, sizeof(lv_fs_drv_t)))
#define mp_read_byref_lv_fs_drv_t(field) mp_read_ptr_lv_fs_drv_t(&field)

STATIC void mp_lv_fs_drv_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_fs_drv_t *data = (lv_fs_drv_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_letter: dest[0] = mp_obj_new_int(data->letter); break; // converting from char;
            case MP_QSTR_cache_size: dest[0] = mp_obj_new_int_from_uint(data->cache_size); break; // converting from uint16_t;
            case MP_QSTR_ready_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_ready_cb_obj, (void*)data->ready_cb, lv_fs_drv_t_ready_cb_callback ,MP_QSTR_lv_fs_drv_t_ready_cb, data->user_data); break; // converting from callback bool (*)(lv_fs_drv_t *drv);
            case MP_QSTR_open_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_open_cb_obj, (void*)data->open_cb, lv_fs_drv_t_open_cb_callback ,MP_QSTR_lv_fs_drv_t_open_cb, data->user_data); break; // converting from callback void *(*)(lv_fs_drv_t *drv, char *path, lv_fs_mode_t mode);
            case MP_QSTR_close_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_close_cb_obj, (void*)data->close_cb, lv_fs_drv_t_close_cb_callback ,MP_QSTR_lv_fs_drv_t_close_cb, data->user_data); break; // converting from callback lv_fs_res_t (*)(lv_fs_drv_t *drv, void *file_p);
            case MP_QSTR_read_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_read_cb_obj, (void*)data->read_cb, lv_fs_drv_t_read_cb_callback ,MP_QSTR_lv_fs_drv_t_read_cb, data->user_data); break; // converting from callback lv_fs_res_t (*)(lv_fs_drv_t *drv, void *file_p, void *buf, uint32_t btr, uint32_t *br);
            case MP_QSTR_write_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_write_cb_obj, (void*)data->write_cb, lv_fs_drv_t_write_cb_callback ,MP_QSTR_lv_fs_drv_t_write_cb, data->user_data); break; // converting from callback lv_fs_res_t (*)(lv_fs_drv_t *drv, void *file_p, void *buf, uint32_t btw, uint32_t *bw);
            case MP_QSTR_seek_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_seek_cb_obj, (void*)data->seek_cb, lv_fs_drv_t_seek_cb_callback ,MP_QSTR_lv_fs_drv_t_seek_cb, data->user_data); break; // converting from callback lv_fs_res_t (*)(lv_fs_drv_t *drv, void *file_p, uint32_t pos, lv_fs_whence_t whence);
            case MP_QSTR_tell_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_tell_cb_obj, (void*)data->tell_cb, lv_fs_drv_t_tell_cb_callback ,MP_QSTR_lv_fs_drv_t_tell_cb, data->user_data); break; // converting from callback lv_fs_res_t (*)(lv_fs_drv_t *drv, void *file_p, uint32_t *pos_p);
            case MP_QSTR_dir_open_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_dir_open_cb_obj, (void*)data->dir_open_cb, lv_fs_drv_t_dir_open_cb_callback ,MP_QSTR_lv_fs_drv_t_dir_open_cb, data->user_data); break; // converting from callback void *(*)(lv_fs_drv_t *drv, char *path);
            case MP_QSTR_dir_read_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_dir_read_cb_obj, (void*)data->dir_read_cb, lv_fs_drv_t_dir_read_cb_callback ,MP_QSTR_lv_fs_drv_t_dir_read_cb, data->user_data); break; // converting from callback lv_fs_res_t (*)(lv_fs_drv_t *drv, void *rddir_p, char *fn);
            case MP_QSTR_dir_close_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_dir_close_cb_obj, (void*)data->dir_close_cb, lv_fs_drv_t_dir_close_cb_callback ,MP_QSTR_lv_fs_drv_t_dir_close_cb, data->user_data); break; // converting from callback lv_fs_res_t (*)(lv_fs_drv_t *drv, void *rddir_p);
            case MP_QSTR_user_data: dest[0] = ptr_to_mp((void*)data->user_data); break; // converting from void *;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_letter: data->letter = (char)mp_obj_get_int(dest[1]); break; // converting to char;
                case MP_QSTR_cache_size: data->cache_size = (uint16_t)mp_obj_get_int(dest[1]); break; // converting to uint16_t;
                case MP_QSTR_ready_cb: data->ready_cb = (void*)mp_lv_callback(dest[1], lv_fs_drv_t_ready_cb_callback ,MP_QSTR_lv_fs_drv_t_ready_cb, &data->user_data); break; // converting to callback bool (*)(lv_fs_drv_t *drv);
                case MP_QSTR_open_cb: data->open_cb = (void*)mp_lv_callback(dest[1], lv_fs_drv_t_open_cb_callback ,MP_QSTR_lv_fs_drv_t_open_cb, &data->user_data); break; // converting to callback void *(*)(lv_fs_drv_t *drv, char *path, lv_fs_mode_t mode);
                case MP_QSTR_close_cb: data->close_cb = (void*)mp_lv_callback(dest[1], lv_fs_drv_t_close_cb_callback ,MP_QSTR_lv_fs_drv_t_close_cb, &data->user_data); break; // converting to callback lv_fs_res_t (*)(lv_fs_drv_t *drv, void *file_p);
                case MP_QSTR_read_cb: data->read_cb = (void*)mp_lv_callback(dest[1], lv_fs_drv_t_read_cb_callback ,MP_QSTR_lv_fs_drv_t_read_cb, &data->user_data); break; // converting to callback lv_fs_res_t (*)(lv_fs_drv_t *drv, void *file_p, void *buf, uint32_t btr, uint32_t *br);
                case MP_QSTR_write_cb: data->write_cb = (void*)mp_lv_callback(dest[1], lv_fs_drv_t_write_cb_callback ,MP_QSTR_lv_fs_drv_t_write_cb, &data->user_data); break; // converting to callback lv_fs_res_t (*)(lv_fs_drv_t *drv, void *file_p, void *buf, uint32_t btw, uint32_t *bw);
                case MP_QSTR_seek_cb: data->seek_cb = (void*)mp_lv_callback(dest[1], lv_fs_drv_t_seek_cb_callback ,MP_QSTR_lv_fs_drv_t_seek_cb, &data->user_data); break; // converting to callback lv_fs_res_t (*)(lv_fs_drv_t *drv, void *file_p, uint32_t pos, lv_fs_whence_t whence);
                case MP_QSTR_tell_cb: data->tell_cb = (void*)mp_lv_callback(dest[1], lv_fs_drv_t_tell_cb_callback ,MP_QSTR_lv_fs_drv_t_tell_cb, &data->user_data); break; // converting to callback lv_fs_res_t (*)(lv_fs_drv_t *drv, void *file_p, uint32_t *pos_p);
                case MP_QSTR_dir_open_cb: data->dir_open_cb = (void*)mp_lv_callback(dest[1], lv_fs_drv_t_dir_open_cb_callback ,MP_QSTR_lv_fs_drv_t_dir_open_cb, &data->user_data); break; // converting to callback void *(*)(lv_fs_drv_t *drv, char *path);
                case MP_QSTR_dir_read_cb: data->dir_read_cb = (void*)mp_lv_callback(dest[1], lv_fs_drv_t_dir_read_cb_callback ,MP_QSTR_lv_fs_drv_t_dir_read_cb, &data->user_data); break; // converting to callback lv_fs_res_t (*)(lv_fs_drv_t *drv, void *rddir_p, char *fn);
                case MP_QSTR_dir_close_cb: data->dir_close_cb = (void*)mp_lv_callback(dest[1], lv_fs_drv_t_dir_close_cb_callback ,MP_QSTR_lv_fs_drv_t_dir_close_cb, &data->user_data); break; // converting to callback lv_fs_res_t (*)(lv_fs_drv_t *drv, void *rddir_p);
                case MP_QSTR_user_data: data->user_data = (void*)mp_to_ptr(dest[1]); break; // converting to void *;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_fs_drv_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_fs_drv_t");
}

STATIC const mp_obj_dict_t mp_lv_fs_drv_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_fs_drv_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_fs_drv_t,
    .print = mp_lv_fs_drv_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_fs_drv_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_fs_drv_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_fs_drv_t_type()
{
    return &mp_lv_fs_drv_t_type;
}
    

/*
 * Struct lv_fs_file_cache_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_fs_file_cache_t_type();

STATIC inline lv_fs_file_cache_t* mp_write_ptr_lv_fs_file_cache_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_fs_file_cache_t_type()));
    return (lv_fs_file_cache_t*)self->data;
}

#define mp_write_lv_fs_file_cache_t(struct_obj) *mp_write_ptr_lv_fs_file_cache_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_fs_file_cache_t(lv_fs_file_cache_t *field)
{
    return lv_to_mp_struct(get_mp_lv_fs_file_cache_t_type(), (void*)field);
}

#define mp_read_lv_fs_file_cache_t(field) mp_read_ptr_lv_fs_file_cache_t(copy_buffer(&field, sizeof(lv_fs_file_cache_t)))
#define mp_read_byref_lv_fs_file_cache_t(field) mp_read_ptr_lv_fs_file_cache_t(&field)

STATIC void mp_lv_fs_file_cache_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_fs_file_cache_t *data = (lv_fs_file_cache_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_start: dest[0] = mp_obj_new_int_from_uint(data->start); break; // converting from uint32_t;
            case MP_QSTR_end: dest[0] = mp_obj_new_int_from_uint(data->end); break; // converting from uint32_t;
            case MP_QSTR_file_position: dest[0] = mp_obj_new_int_from_uint(data->file_position); break; // converting from uint32_t;
            case MP_QSTR_buffer: dest[0] = ptr_to_mp((void*)data->buffer); break; // converting from void *;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_start: data->start = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_end: data->end = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_file_position: data->file_position = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_buffer: data->buffer = (void*)mp_to_ptr(dest[1]); break; // converting to void *;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_fs_file_cache_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_fs_file_cache_t");
}

STATIC const mp_obj_dict_t mp_lv_fs_file_cache_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_fs_file_cache_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_fs_file_cache_t,
    .print = mp_lv_fs_file_cache_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_fs_file_cache_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_fs_file_cache_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_fs_file_cache_t_type()
{
    return &mp_lv_fs_file_cache_t_type;
}
    

/*
 * Struct lv_fs_file_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_fs_file_t_type();

STATIC inline lv_fs_file_t* mp_write_ptr_lv_fs_file_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_fs_file_t_type()));
    return (lv_fs_file_t*)self->data;
}

#define mp_write_lv_fs_file_t(struct_obj) *mp_write_ptr_lv_fs_file_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_fs_file_t(lv_fs_file_t *field)
{
    return lv_to_mp_struct(get_mp_lv_fs_file_t_type(), (void*)field);
}

#define mp_read_lv_fs_file_t(field) mp_read_ptr_lv_fs_file_t(copy_buffer(&field, sizeof(lv_fs_file_t)))
#define mp_read_byref_lv_fs_file_t(field) mp_read_ptr_lv_fs_file_t(&field)

STATIC void mp_lv_fs_file_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_fs_file_t *data = (lv_fs_file_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_file_d: dest[0] = ptr_to_mp((void*)data->file_d); break; // converting from void *;
            case MP_QSTR_drv: dest[0] = mp_read_ptr_lv_fs_drv_t((void*)data->drv); break; // converting from lv_fs_drv_t *;
            case MP_QSTR_cache: dest[0] = mp_read_ptr_lv_fs_file_cache_t((void*)data->cache); break; // converting from lv_fs_file_cache_t *;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_file_d: data->file_d = (void*)mp_to_ptr(dest[1]); break; // converting to void *;
                case MP_QSTR_drv: data->drv = (void*)mp_write_ptr_lv_fs_drv_t(dest[1]); break; // converting to lv_fs_drv_t *;
                case MP_QSTR_cache: data->cache = (void*)mp_write_ptr_lv_fs_file_cache_t(dest[1]); break; // converting to lv_fs_file_cache_t *;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_fs_file_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_fs_file_t");
}

STATIC const mp_obj_dict_t mp_lv_fs_file_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_fs_file_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_fs_file_t,
    .print = mp_lv_fs_file_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_fs_file_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_fs_file_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_fs_file_t_type()
{
    return &mp_lv_fs_file_t_type;
}
    

/*
 * Struct lv_fs_dir_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_fs_dir_t_type();

STATIC inline lv_fs_dir_t* mp_write_ptr_lv_fs_dir_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_fs_dir_t_type()));
    return (lv_fs_dir_t*)self->data;
}

#define mp_write_lv_fs_dir_t(struct_obj) *mp_write_ptr_lv_fs_dir_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_fs_dir_t(lv_fs_dir_t *field)
{
    return lv_to_mp_struct(get_mp_lv_fs_dir_t_type(), (void*)field);
}

#define mp_read_lv_fs_dir_t(field) mp_read_ptr_lv_fs_dir_t(copy_buffer(&field, sizeof(lv_fs_dir_t)))
#define mp_read_byref_lv_fs_dir_t(field) mp_read_ptr_lv_fs_dir_t(&field)

STATIC void mp_lv_fs_dir_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_fs_dir_t *data = (lv_fs_dir_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_dir_d: dest[0] = ptr_to_mp((void*)data->dir_d); break; // converting from void *;
            case MP_QSTR_drv: dest[0] = mp_read_ptr_lv_fs_drv_t((void*)data->drv); break; // converting from lv_fs_drv_t *;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_dir_d: data->dir_d = (void*)mp_to_ptr(dest[1]); break; // converting to void *;
                case MP_QSTR_drv: data->drv = (void*)mp_write_ptr_lv_fs_drv_t(dest[1]); break; // converting to lv_fs_drv_t *;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_fs_dir_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_fs_dir_t");
}

STATIC const mp_obj_dict_t mp_lv_fs_dir_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_fs_dir_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_fs_dir_t,
    .print = mp_lv_fs_dir_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_fs_dir_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_fs_dir_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_fs_dir_t_type()
{
    return &mp_lv_fs_dir_t_type;
}
    
#define funcptr_lv_layout_update_cb_t NULL


/*
 * lvgl extension definition for:
 * void lv_layout_update_cb_t(struct _lv_obj_t *, void *user_data)
 */
 
STATIC mp_obj_t mp_funcptr_lv_layout_update_cb_t(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    void *user_data = mp_to_ptr(mp_args[1]);
    struct _lv_obj_t *arg0 = mp_to_lv(mp_args[0]);
    ((void (*)(struct _lv_obj_t *, void *))lv_func_ptr)(arg0, user_data);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_funcptr_lv_layout_update_cb_t_obj, 2, mp_funcptr_lv_layout_update_cb_t, funcptr_lv_layout_update_cb_t);
    
STATIC inline mp_obj_t mp_lv_funcptr_lv_layout_update_cb_t(void *func){ return mp_lv_funcptr(&mp_funcptr_lv_layout_update_cb_t_obj, func, NULL, MP_QSTR_, NULL); }


/*
 * Struct lv_grad_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_grad_t_type();

STATIC inline lv_grad_t* mp_write_ptr_lv_grad_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_grad_t_type()));
    return (lv_grad_t*)self->data;
}

#define mp_write_lv_grad_t(struct_obj) *mp_write_ptr_lv_grad_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_grad_t(lv_grad_t *field)
{
    return lv_to_mp_struct(get_mp_lv_grad_t_type(), (void*)field);
}

#define mp_read_lv_grad_t(field) mp_read_ptr_lv_grad_t(copy_buffer(&field, sizeof(lv_grad_t)))
#define mp_read_byref_lv_grad_t(field) mp_read_ptr_lv_grad_t(&field)

STATIC void mp_lv_grad_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_grad_t *data = (lv_grad_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_key: dest[0] = mp_obj_new_int_from_uint(data->key); break; // converting from uint32_t;
            case MP_QSTR_life: dest[0] = mp_obj_new_int_from_uint(data->life); break; // converting from uint32_t;
            case MP_QSTR_filled: dest[0] = mp_obj_new_int_from_uint(data->filled); break; // converting from uint32_t;
            case MP_QSTR_not_cached: dest[0] = mp_obj_new_int_from_uint(data->not_cached); break; // converting from uint32_t;
            case MP_QSTR_map: dest[0] = mp_read_ptr_lv_color16_t((void*)data->map); break; // converting from lv_color_t *;
            case MP_QSTR_alloc_size: dest[0] = mp_obj_new_int(data->alloc_size); break; // converting from lv_coord_t;
            case MP_QSTR_size: dest[0] = mp_obj_new_int(data->size); break; // converting from lv_coord_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_key: data->key = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_life: data->life = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_filled: data->filled = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_not_cached: data->not_cached = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_map: data->map = (void*)mp_write_ptr_lv_color16_t(dest[1]); break; // converting to lv_color_t *;
                case MP_QSTR_alloc_size: data->alloc_size = (int16_t)mp_obj_get_int(dest[1]); break; // converting to lv_coord_t;
                case MP_QSTR_size: data->size = (int16_t)mp_obj_get_int(dest[1]); break; // converting to lv_coord_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_grad_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_grad_t");
}

STATIC const mp_obj_dict_t mp_lv_grad_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_grad_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_grad_t,
    .print = mp_lv_grad_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_grad_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_grad_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_grad_t_type()
{
    return &mp_lv_grad_t_type;
}
    
#define funcptr_lv_draw_mask_xcb_t NULL


/*
 * lvgl extension definition for:
 * lv_draw_mask_res_t lv_draw_mask_xcb_t(lv_opa_t *mask_buf, lv_coord_t abs_x, lv_coord_t abs_y, lv_coord_t len, void *p)
 */
 
STATIC mp_obj_t mp_funcptr_lv_draw_mask_xcb_t(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_opa_t *mask_buf = mp_to_ptr(mp_args[0]);
    lv_coord_t abs_x = (int16_t)mp_obj_get_int(mp_args[1]);
    lv_coord_t abs_y = (int16_t)mp_obj_get_int(mp_args[2]);
    lv_coord_t len = (int16_t)mp_obj_get_int(mp_args[3]);
    void *p = mp_to_ptr(mp_args[4]);
    lv_draw_mask_res_t _res = ((lv_draw_mask_res_t (*)(lv_opa_t *, lv_coord_t, lv_coord_t, lv_coord_t, void *))lv_func_ptr)(mask_buf, abs_x, abs_y, len, p);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_lv_draw_mask_xcb_t_obj, 5, mp_funcptr_lv_draw_mask_xcb_t, funcptr_lv_draw_mask_xcb_t);
    
STATIC inline mp_obj_t mp_lv_funcptr_lv_draw_mask_xcb_t(void *func){ return mp_lv_funcptr(&mp_funcptr_lv_draw_mask_xcb_t_obj, func, NULL, MP_QSTR_, NULL); }


/*
 * Function NOT generated:
 * Missing 'user_data' as a field of the first parameter of the callback function '_lv_draw_mask_common_dsc_t_cb_callback'
 * lv_draw_mask_xcb_t cb
 */
    

/*
 * Struct _lv_draw_mask_common_dsc_t
 */

STATIC inline const mp_obj_type_t *get_mp__lv_draw_mask_common_dsc_t_type();

STATIC inline _lv_draw_mask_common_dsc_t* mp_write_ptr__lv_draw_mask_common_dsc_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp__lv_draw_mask_common_dsc_t_type()));
    return (_lv_draw_mask_common_dsc_t*)self->data;
}

#define mp_write__lv_draw_mask_common_dsc_t(struct_obj) *mp_write_ptr__lv_draw_mask_common_dsc_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr__lv_draw_mask_common_dsc_t(_lv_draw_mask_common_dsc_t *field)
{
    return lv_to_mp_struct(get_mp__lv_draw_mask_common_dsc_t_type(), (void*)field);
}

#define mp_read__lv_draw_mask_common_dsc_t(field) mp_read_ptr__lv_draw_mask_common_dsc_t(copy_buffer(&field, sizeof(_lv_draw_mask_common_dsc_t)))
#define mp_read_byref__lv_draw_mask_common_dsc_t(field) mp_read_ptr__lv_draw_mask_common_dsc_t(&field)

STATIC void mp__lv_draw_mask_common_dsc_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    _lv_draw_mask_common_dsc_t *data = (_lv_draw_mask_common_dsc_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_lv_draw_mask_xcb_t_obj, data->cb, NULL ,MP_QSTR__lv_draw_mask_common_dsc_t_cb, NULL); break; // converting from callback lv_draw_mask_xcb_t;
            case MP_QSTR_type: dest[0] = mp_obj_new_int_from_uint(data->type); break; // converting from lv_draw_mask_type_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_cb: data->cb = mp_lv_callback(dest[1], NULL ,MP_QSTR__lv_draw_mask_common_dsc_t_cb, NULL); break; // converting to callback lv_draw_mask_xcb_t;
                case MP_QSTR_type: data->type = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to lv_draw_mask_type_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp__lv_draw_mask_common_dsc_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct _lv_draw_mask_common_dsc_t");
}

STATIC const mp_obj_dict_t mp__lv_draw_mask_common_dsc_t_locals_dict;

STATIC const mp_obj_type_t mp__lv_draw_mask_common_dsc_t_type = {
    { &mp_type_type },
    .name = MP_QSTR__lv_draw_mask_common_dsc_t,
    .print = mp__lv_draw_mask_common_dsc_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp__lv_draw_mask_common_dsc_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp__lv_draw_mask_common_dsc_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp__lv_draw_mask_common_dsc_t_type()
{
    return &mp__lv_draw_mask_common_dsc_t_type;
}
    
typedef __typeof__( ((lv_draw_mask_line_param_t*)(0))->cfg ) lv_draw_mask_line_param_cfg_t;

/*
 * Struct lv_draw_mask_line_param_cfg_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_draw_mask_line_param_cfg_t_type();

STATIC inline lv_draw_mask_line_param_cfg_t* mp_write_ptr_lv_draw_mask_line_param_cfg_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_draw_mask_line_param_cfg_t_type()));
    return (lv_draw_mask_line_param_cfg_t*)self->data;
}

#define mp_write_lv_draw_mask_line_param_cfg_t(struct_obj) *mp_write_ptr_lv_draw_mask_line_param_cfg_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_draw_mask_line_param_cfg_t(lv_draw_mask_line_param_cfg_t *field)
{
    return lv_to_mp_struct(get_mp_lv_draw_mask_line_param_cfg_t_type(), (void*)field);
}

#define mp_read_lv_draw_mask_line_param_cfg_t(field) mp_read_ptr_lv_draw_mask_line_param_cfg_t(copy_buffer(&field, sizeof(lv_draw_mask_line_param_cfg_t)))
#define mp_read_byref_lv_draw_mask_line_param_cfg_t(field) mp_read_ptr_lv_draw_mask_line_param_cfg_t(&field)

STATIC void mp_lv_draw_mask_line_param_cfg_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_draw_mask_line_param_cfg_t *data = (lv_draw_mask_line_param_cfg_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_p1: dest[0] = mp_read_byref_lv_point_t(data->p1); break; // converting from lv_point_t;
            case MP_QSTR_p2: dest[0] = mp_read_byref_lv_point_t(data->p2); break; // converting from lv_point_t;
            case MP_QSTR_side: dest[0] = mp_obj_new_int_from_uint(data->side); break; // converting from lv_draw_mask_line_side_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_p1: data->p1 = mp_write_lv_point_t(dest[1]); break; // converting to lv_point_t;
                case MP_QSTR_p2: data->p2 = mp_write_lv_point_t(dest[1]); break; // converting to lv_point_t;
                case MP_QSTR_side: data->side = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to lv_draw_mask_line_side_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_draw_mask_line_param_cfg_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_draw_mask_line_param_cfg_t");
}

STATIC const mp_obj_dict_t mp_lv_draw_mask_line_param_cfg_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_draw_mask_line_param_cfg_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_draw_mask_line_param_cfg_t,
    .print = mp_lv_draw_mask_line_param_cfg_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_draw_mask_line_param_cfg_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_draw_mask_line_param_cfg_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_draw_mask_line_param_cfg_t_type()
{
    return &mp_lv_draw_mask_line_param_cfg_t_type;
}
    

/*
 * Struct lv_draw_mask_line_param_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_draw_mask_line_param_t_type();

STATIC inline lv_draw_mask_line_param_t* mp_write_ptr_lv_draw_mask_line_param_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_draw_mask_line_param_t_type()));
    return (lv_draw_mask_line_param_t*)self->data;
}

#define mp_write_lv_draw_mask_line_param_t(struct_obj) *mp_write_ptr_lv_draw_mask_line_param_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_draw_mask_line_param_t(lv_draw_mask_line_param_t *field)
{
    return lv_to_mp_struct(get_mp_lv_draw_mask_line_param_t_type(), (void*)field);
}

#define mp_read_lv_draw_mask_line_param_t(field) mp_read_ptr_lv_draw_mask_line_param_t(copy_buffer(&field, sizeof(lv_draw_mask_line_param_t)))
#define mp_read_byref_lv_draw_mask_line_param_t(field) mp_read_ptr_lv_draw_mask_line_param_t(&field)

STATIC void mp_lv_draw_mask_line_param_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_draw_mask_line_param_t *data = (lv_draw_mask_line_param_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_dsc: dest[0] = mp_read_byref__lv_draw_mask_common_dsc_t(data->dsc); break; // converting from _lv_draw_mask_common_dsc_t;
            case MP_QSTR_cfg: dest[0] = mp_read_byref_lv_draw_mask_line_param_cfg_t(data->cfg); break; // converting from lv_draw_mask_line_param_cfg_t;
            case MP_QSTR_origo: dest[0] = mp_read_byref_lv_point_t(data->origo); break; // converting from lv_point_t;
            case MP_QSTR_xy_steep: dest[0] = mp_obj_new_int(data->xy_steep); break; // converting from int32_t;
            case MP_QSTR_yx_steep: dest[0] = mp_obj_new_int(data->yx_steep); break; // converting from int32_t;
            case MP_QSTR_steep: dest[0] = mp_obj_new_int(data->steep); break; // converting from int32_t;
            case MP_QSTR_spx: dest[0] = mp_obj_new_int(data->spx); break; // converting from int32_t;
            case MP_QSTR_flat: dest[0] = mp_obj_new_int_from_uint(data->flat); break; // converting from uint8_t;
            case MP_QSTR_inv: dest[0] = mp_obj_new_int_from_uint(data->inv); break; // converting from uint8_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_dsc: data->dsc = mp_write__lv_draw_mask_common_dsc_t(dest[1]); break; // converting to _lv_draw_mask_common_dsc_t;
                case MP_QSTR_cfg: data->cfg = mp_write_lv_draw_mask_line_param_cfg_t(dest[1]); break; // converting to lv_draw_mask_line_param_cfg_t;
                case MP_QSTR_origo: data->origo = mp_write_lv_point_t(dest[1]); break; // converting to lv_point_t;
                case MP_QSTR_xy_steep: data->xy_steep = (int32_t)mp_obj_get_int(dest[1]); break; // converting to int32_t;
                case MP_QSTR_yx_steep: data->yx_steep = (int32_t)mp_obj_get_int(dest[1]); break; // converting to int32_t;
                case MP_QSTR_steep: data->steep = (int32_t)mp_obj_get_int(dest[1]); break; // converting to int32_t;
                case MP_QSTR_spx: data->spx = (int32_t)mp_obj_get_int(dest[1]); break; // converting to int32_t;
                case MP_QSTR_flat: data->flat = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                case MP_QSTR_inv: data->inv = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_draw_mask_line_param_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_draw_mask_line_param_t");
}

STATIC const mp_obj_dict_t mp_lv_draw_mask_line_param_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_draw_mask_line_param_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_draw_mask_line_param_t,
    .print = mp_lv_draw_mask_line_param_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_draw_mask_line_param_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_draw_mask_line_param_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_draw_mask_line_param_t_type()
{
    return &mp_lv_draw_mask_line_param_t_type;
}
    
typedef __typeof__( ((lv_draw_mask_angle_param_t*)(0))->cfg ) lv_draw_mask_angle_param_cfg_t;

/*
 * Struct lv_draw_mask_angle_param_cfg_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_draw_mask_angle_param_cfg_t_type();

STATIC inline lv_draw_mask_angle_param_cfg_t* mp_write_ptr_lv_draw_mask_angle_param_cfg_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_draw_mask_angle_param_cfg_t_type()));
    return (lv_draw_mask_angle_param_cfg_t*)self->data;
}

#define mp_write_lv_draw_mask_angle_param_cfg_t(struct_obj) *mp_write_ptr_lv_draw_mask_angle_param_cfg_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_draw_mask_angle_param_cfg_t(lv_draw_mask_angle_param_cfg_t *field)
{
    return lv_to_mp_struct(get_mp_lv_draw_mask_angle_param_cfg_t_type(), (void*)field);
}

#define mp_read_lv_draw_mask_angle_param_cfg_t(field) mp_read_ptr_lv_draw_mask_angle_param_cfg_t(copy_buffer(&field, sizeof(lv_draw_mask_angle_param_cfg_t)))
#define mp_read_byref_lv_draw_mask_angle_param_cfg_t(field) mp_read_ptr_lv_draw_mask_angle_param_cfg_t(&field)

STATIC void mp_lv_draw_mask_angle_param_cfg_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_draw_mask_angle_param_cfg_t *data = (lv_draw_mask_angle_param_cfg_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_vertex_p: dest[0] = mp_read_byref_lv_point_t(data->vertex_p); break; // converting from lv_point_t;
            case MP_QSTR_start_angle: dest[0] = mp_obj_new_int(data->start_angle); break; // converting from lv_coord_t;
            case MP_QSTR_end_angle: dest[0] = mp_obj_new_int(data->end_angle); break; // converting from lv_coord_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_vertex_p: data->vertex_p = mp_write_lv_point_t(dest[1]); break; // converting to lv_point_t;
                case MP_QSTR_start_angle: data->start_angle = (int16_t)mp_obj_get_int(dest[1]); break; // converting to lv_coord_t;
                case MP_QSTR_end_angle: data->end_angle = (int16_t)mp_obj_get_int(dest[1]); break; // converting to lv_coord_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_draw_mask_angle_param_cfg_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_draw_mask_angle_param_cfg_t");
}

STATIC const mp_obj_dict_t mp_lv_draw_mask_angle_param_cfg_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_draw_mask_angle_param_cfg_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_draw_mask_angle_param_cfg_t,
    .print = mp_lv_draw_mask_angle_param_cfg_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_draw_mask_angle_param_cfg_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_draw_mask_angle_param_cfg_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_draw_mask_angle_param_cfg_t_type()
{
    return &mp_lv_draw_mask_angle_param_cfg_t_type;
}
    

/*
 * Struct lv_draw_mask_angle_param_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_draw_mask_angle_param_t_type();

STATIC inline lv_draw_mask_angle_param_t* mp_write_ptr_lv_draw_mask_angle_param_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_draw_mask_angle_param_t_type()));
    return (lv_draw_mask_angle_param_t*)self->data;
}

#define mp_write_lv_draw_mask_angle_param_t(struct_obj) *mp_write_ptr_lv_draw_mask_angle_param_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_draw_mask_angle_param_t(lv_draw_mask_angle_param_t *field)
{
    return lv_to_mp_struct(get_mp_lv_draw_mask_angle_param_t_type(), (void*)field);
}

#define mp_read_lv_draw_mask_angle_param_t(field) mp_read_ptr_lv_draw_mask_angle_param_t(copy_buffer(&field, sizeof(lv_draw_mask_angle_param_t)))
#define mp_read_byref_lv_draw_mask_angle_param_t(field) mp_read_ptr_lv_draw_mask_angle_param_t(&field)

STATIC void mp_lv_draw_mask_angle_param_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_draw_mask_angle_param_t *data = (lv_draw_mask_angle_param_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_dsc: dest[0] = mp_read_byref__lv_draw_mask_common_dsc_t(data->dsc); break; // converting from _lv_draw_mask_common_dsc_t;
            case MP_QSTR_cfg: dest[0] = mp_read_byref_lv_draw_mask_angle_param_cfg_t(data->cfg); break; // converting from lv_draw_mask_angle_param_cfg_t;
            case MP_QSTR_start_line: dest[0] = mp_read_byref_lv_draw_mask_line_param_t(data->start_line); break; // converting from lv_draw_mask_line_param_t;
            case MP_QSTR_end_line: dest[0] = mp_read_byref_lv_draw_mask_line_param_t(data->end_line); break; // converting from lv_draw_mask_line_param_t;
            case MP_QSTR_delta_deg: dest[0] = mp_obj_new_int_from_uint(data->delta_deg); break; // converting from uint16_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_dsc: data->dsc = mp_write__lv_draw_mask_common_dsc_t(dest[1]); break; // converting to _lv_draw_mask_common_dsc_t;
                case MP_QSTR_cfg: data->cfg = mp_write_lv_draw_mask_angle_param_cfg_t(dest[1]); break; // converting to lv_draw_mask_angle_param_cfg_t;
                case MP_QSTR_start_line: data->start_line = mp_write_lv_draw_mask_line_param_t(dest[1]); break; // converting to lv_draw_mask_line_param_t;
                case MP_QSTR_end_line: data->end_line = mp_write_lv_draw_mask_line_param_t(dest[1]); break; // converting to lv_draw_mask_line_param_t;
                case MP_QSTR_delta_deg: data->delta_deg = (uint16_t)mp_obj_get_int(dest[1]); break; // converting to uint16_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_draw_mask_angle_param_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_draw_mask_angle_param_t");
}

STATIC const mp_obj_dict_t mp_lv_draw_mask_angle_param_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_draw_mask_angle_param_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_draw_mask_angle_param_t,
    .print = mp_lv_draw_mask_angle_param_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_draw_mask_angle_param_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_draw_mask_angle_param_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_draw_mask_angle_param_t_type()
{
    return &mp_lv_draw_mask_angle_param_t_type;
}
    
typedef __typeof__( ((lv_draw_mask_radius_param_t*)(0))->cfg ) lv_draw_mask_radius_param_cfg_t;

/*
 * Struct lv_draw_mask_radius_param_cfg_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_draw_mask_radius_param_cfg_t_type();

STATIC inline lv_draw_mask_radius_param_cfg_t* mp_write_ptr_lv_draw_mask_radius_param_cfg_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_draw_mask_radius_param_cfg_t_type()));
    return (lv_draw_mask_radius_param_cfg_t*)self->data;
}

#define mp_write_lv_draw_mask_radius_param_cfg_t(struct_obj) *mp_write_ptr_lv_draw_mask_radius_param_cfg_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_draw_mask_radius_param_cfg_t(lv_draw_mask_radius_param_cfg_t *field)
{
    return lv_to_mp_struct(get_mp_lv_draw_mask_radius_param_cfg_t_type(), (void*)field);
}

#define mp_read_lv_draw_mask_radius_param_cfg_t(field) mp_read_ptr_lv_draw_mask_radius_param_cfg_t(copy_buffer(&field, sizeof(lv_draw_mask_radius_param_cfg_t)))
#define mp_read_byref_lv_draw_mask_radius_param_cfg_t(field) mp_read_ptr_lv_draw_mask_radius_param_cfg_t(&field)

STATIC void mp_lv_draw_mask_radius_param_cfg_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_draw_mask_radius_param_cfg_t *data = (lv_draw_mask_radius_param_cfg_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_rect: dest[0] = mp_read_byref_lv_area_t(data->rect); break; // converting from lv_area_t;
            case MP_QSTR_radius: dest[0] = mp_obj_new_int(data->radius); break; // converting from lv_coord_t;
            case MP_QSTR_outer: dest[0] = mp_obj_new_int_from_uint(data->outer); break; // converting from uint8_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_rect: data->rect = mp_write_lv_area_t(dest[1]); break; // converting to lv_area_t;
                case MP_QSTR_radius: data->radius = (int16_t)mp_obj_get_int(dest[1]); break; // converting to lv_coord_t;
                case MP_QSTR_outer: data->outer = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_draw_mask_radius_param_cfg_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_draw_mask_radius_param_cfg_t");
}

STATIC const mp_obj_dict_t mp_lv_draw_mask_radius_param_cfg_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_draw_mask_radius_param_cfg_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_draw_mask_radius_param_cfg_t,
    .print = mp_lv_draw_mask_radius_param_cfg_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_draw_mask_radius_param_cfg_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_draw_mask_radius_param_cfg_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_draw_mask_radius_param_cfg_t_type()
{
    return &mp_lv_draw_mask_radius_param_cfg_t_type;
}
    

/*
 * Struct _lv_draw_mask_radius_circle_dsc_t
 */

STATIC inline const mp_obj_type_t *get_mp__lv_draw_mask_radius_circle_dsc_t_type();

STATIC inline _lv_draw_mask_radius_circle_dsc_t* mp_write_ptr__lv_draw_mask_radius_circle_dsc_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp__lv_draw_mask_radius_circle_dsc_t_type()));
    return (_lv_draw_mask_radius_circle_dsc_t*)self->data;
}

#define mp_write__lv_draw_mask_radius_circle_dsc_t(struct_obj) *mp_write_ptr__lv_draw_mask_radius_circle_dsc_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr__lv_draw_mask_radius_circle_dsc_t(_lv_draw_mask_radius_circle_dsc_t *field)
{
    return lv_to_mp_struct(get_mp__lv_draw_mask_radius_circle_dsc_t_type(), (void*)field);
}

#define mp_read__lv_draw_mask_radius_circle_dsc_t(field) mp_read_ptr__lv_draw_mask_radius_circle_dsc_t(copy_buffer(&field, sizeof(_lv_draw_mask_radius_circle_dsc_t)))
#define mp_read_byref__lv_draw_mask_radius_circle_dsc_t(field) mp_read_ptr__lv_draw_mask_radius_circle_dsc_t(&field)

STATIC void mp__lv_draw_mask_radius_circle_dsc_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    _lv_draw_mask_radius_circle_dsc_t *data = (_lv_draw_mask_radius_circle_dsc_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_buf: dest[0] = ptr_to_mp((void*)data->buf); break; // converting from uint8_t *;
            case MP_QSTR_cir_opa: dest[0] = ptr_to_mp((void*)data->cir_opa); break; // converting from lv_opa_t *;
            case MP_QSTR_x_start_on_y: dest[0] = ptr_to_mp((void*)data->x_start_on_y); break; // converting from uint16_t *;
            case MP_QSTR_opa_start_on_y: dest[0] = ptr_to_mp((void*)data->opa_start_on_y); break; // converting from uint16_t *;
            case MP_QSTR_life: dest[0] = mp_obj_new_int(data->life); break; // converting from int32_t;
            case MP_QSTR_used_cnt: dest[0] = mp_obj_new_int_from_uint(data->used_cnt); break; // converting from uint32_t;
            case MP_QSTR_radius: dest[0] = mp_obj_new_int(data->radius); break; // converting from lv_coord_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_buf: data->buf = (void*)mp_to_ptr(dest[1]); break; // converting to uint8_t *;
                case MP_QSTR_cir_opa: data->cir_opa = (void*)mp_to_ptr(dest[1]); break; // converting to lv_opa_t *;
                case MP_QSTR_x_start_on_y: data->x_start_on_y = (void*)mp_to_ptr(dest[1]); break; // converting to uint16_t *;
                case MP_QSTR_opa_start_on_y: data->opa_start_on_y = (void*)mp_to_ptr(dest[1]); break; // converting to uint16_t *;
                case MP_QSTR_life: data->life = (int32_t)mp_obj_get_int(dest[1]); break; // converting to int32_t;
                case MP_QSTR_used_cnt: data->used_cnt = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_radius: data->radius = (int16_t)mp_obj_get_int(dest[1]); break; // converting to lv_coord_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp__lv_draw_mask_radius_circle_dsc_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct _lv_draw_mask_radius_circle_dsc_t");
}

STATIC const mp_obj_dict_t mp__lv_draw_mask_radius_circle_dsc_t_locals_dict;

STATIC const mp_obj_type_t mp__lv_draw_mask_radius_circle_dsc_t_type = {
    { &mp_type_type },
    .name = MP_QSTR__lv_draw_mask_radius_circle_dsc_t,
    .print = mp__lv_draw_mask_radius_circle_dsc_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp__lv_draw_mask_radius_circle_dsc_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp__lv_draw_mask_radius_circle_dsc_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp__lv_draw_mask_radius_circle_dsc_t_type()
{
    return &mp__lv_draw_mask_radius_circle_dsc_t_type;
}
    

/*
 * Struct lv_draw_mask_radius_param_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_draw_mask_radius_param_t_type();

STATIC inline lv_draw_mask_radius_param_t* mp_write_ptr_lv_draw_mask_radius_param_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_draw_mask_radius_param_t_type()));
    return (lv_draw_mask_radius_param_t*)self->data;
}

#define mp_write_lv_draw_mask_radius_param_t(struct_obj) *mp_write_ptr_lv_draw_mask_radius_param_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_draw_mask_radius_param_t(lv_draw_mask_radius_param_t *field)
{
    return lv_to_mp_struct(get_mp_lv_draw_mask_radius_param_t_type(), (void*)field);
}

#define mp_read_lv_draw_mask_radius_param_t(field) mp_read_ptr_lv_draw_mask_radius_param_t(copy_buffer(&field, sizeof(lv_draw_mask_radius_param_t)))
#define mp_read_byref_lv_draw_mask_radius_param_t(field) mp_read_ptr_lv_draw_mask_radius_param_t(&field)

STATIC void mp_lv_draw_mask_radius_param_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_draw_mask_radius_param_t *data = (lv_draw_mask_radius_param_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_dsc: dest[0] = mp_read_byref__lv_draw_mask_common_dsc_t(data->dsc); break; // converting from _lv_draw_mask_common_dsc_t;
            case MP_QSTR_cfg: dest[0] = mp_read_byref_lv_draw_mask_radius_param_cfg_t(data->cfg); break; // converting from lv_draw_mask_radius_param_cfg_t;
            case MP_QSTR_circle: dest[0] = mp_read_ptr__lv_draw_mask_radius_circle_dsc_t((void*)data->circle); break; // converting from _lv_draw_mask_radius_circle_dsc_t *;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_dsc: data->dsc = mp_write__lv_draw_mask_common_dsc_t(dest[1]); break; // converting to _lv_draw_mask_common_dsc_t;
                case MP_QSTR_cfg: data->cfg = mp_write_lv_draw_mask_radius_param_cfg_t(dest[1]); break; // converting to lv_draw_mask_radius_param_cfg_t;
                case MP_QSTR_circle: data->circle = (void*)mp_write_ptr__lv_draw_mask_radius_circle_dsc_t(dest[1]); break; // converting to _lv_draw_mask_radius_circle_dsc_t *;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_draw_mask_radius_param_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_draw_mask_radius_param_t");
}

STATIC const mp_obj_dict_t mp_lv_draw_mask_radius_param_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_draw_mask_radius_param_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_draw_mask_radius_param_t,
    .print = mp_lv_draw_mask_radius_param_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_draw_mask_radius_param_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_draw_mask_radius_param_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_draw_mask_radius_param_t_type()
{
    return &mp_lv_draw_mask_radius_param_t_type;
}
    
typedef __typeof__( ((lv_draw_mask_fade_param_t*)(0))->cfg ) lv_draw_mask_fade_param_cfg_t;

/*
 * Struct lv_draw_mask_fade_param_cfg_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_draw_mask_fade_param_cfg_t_type();

STATIC inline lv_draw_mask_fade_param_cfg_t* mp_write_ptr_lv_draw_mask_fade_param_cfg_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_draw_mask_fade_param_cfg_t_type()));
    return (lv_draw_mask_fade_param_cfg_t*)self->data;
}

#define mp_write_lv_draw_mask_fade_param_cfg_t(struct_obj) *mp_write_ptr_lv_draw_mask_fade_param_cfg_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_draw_mask_fade_param_cfg_t(lv_draw_mask_fade_param_cfg_t *field)
{
    return lv_to_mp_struct(get_mp_lv_draw_mask_fade_param_cfg_t_type(), (void*)field);
}

#define mp_read_lv_draw_mask_fade_param_cfg_t(field) mp_read_ptr_lv_draw_mask_fade_param_cfg_t(copy_buffer(&field, sizeof(lv_draw_mask_fade_param_cfg_t)))
#define mp_read_byref_lv_draw_mask_fade_param_cfg_t(field) mp_read_ptr_lv_draw_mask_fade_param_cfg_t(&field)

STATIC void mp_lv_draw_mask_fade_param_cfg_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_draw_mask_fade_param_cfg_t *data = (lv_draw_mask_fade_param_cfg_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_coords: dest[0] = mp_read_byref_lv_area_t(data->coords); break; // converting from lv_area_t;
            case MP_QSTR_y_top: dest[0] = mp_obj_new_int(data->y_top); break; // converting from lv_coord_t;
            case MP_QSTR_y_bottom: dest[0] = mp_obj_new_int(data->y_bottom); break; // converting from lv_coord_t;
            case MP_QSTR_opa_top: dest[0] = mp_obj_new_int_from_uint(data->opa_top); break; // converting from lv_opa_t;
            case MP_QSTR_opa_bottom: dest[0] = mp_obj_new_int_from_uint(data->opa_bottom); break; // converting from lv_opa_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_coords: data->coords = mp_write_lv_area_t(dest[1]); break; // converting to lv_area_t;
                case MP_QSTR_y_top: data->y_top = (int16_t)mp_obj_get_int(dest[1]); break; // converting to lv_coord_t;
                case MP_QSTR_y_bottom: data->y_bottom = (int16_t)mp_obj_get_int(dest[1]); break; // converting to lv_coord_t;
                case MP_QSTR_opa_top: data->opa_top = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to lv_opa_t;
                case MP_QSTR_opa_bottom: data->opa_bottom = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to lv_opa_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_draw_mask_fade_param_cfg_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_draw_mask_fade_param_cfg_t");
}

STATIC const mp_obj_dict_t mp_lv_draw_mask_fade_param_cfg_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_draw_mask_fade_param_cfg_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_draw_mask_fade_param_cfg_t,
    .print = mp_lv_draw_mask_fade_param_cfg_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_draw_mask_fade_param_cfg_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_draw_mask_fade_param_cfg_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_draw_mask_fade_param_cfg_t_type()
{
    return &mp_lv_draw_mask_fade_param_cfg_t_type;
}
    

/*
 * Struct lv_draw_mask_fade_param_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_draw_mask_fade_param_t_type();

STATIC inline lv_draw_mask_fade_param_t* mp_write_ptr_lv_draw_mask_fade_param_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_draw_mask_fade_param_t_type()));
    return (lv_draw_mask_fade_param_t*)self->data;
}

#define mp_write_lv_draw_mask_fade_param_t(struct_obj) *mp_write_ptr_lv_draw_mask_fade_param_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_draw_mask_fade_param_t(lv_draw_mask_fade_param_t *field)
{
    return lv_to_mp_struct(get_mp_lv_draw_mask_fade_param_t_type(), (void*)field);
}

#define mp_read_lv_draw_mask_fade_param_t(field) mp_read_ptr_lv_draw_mask_fade_param_t(copy_buffer(&field, sizeof(lv_draw_mask_fade_param_t)))
#define mp_read_byref_lv_draw_mask_fade_param_t(field) mp_read_ptr_lv_draw_mask_fade_param_t(&field)

STATIC void mp_lv_draw_mask_fade_param_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_draw_mask_fade_param_t *data = (lv_draw_mask_fade_param_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_dsc: dest[0] = mp_read_byref__lv_draw_mask_common_dsc_t(data->dsc); break; // converting from _lv_draw_mask_common_dsc_t;
            case MP_QSTR_cfg: dest[0] = mp_read_byref_lv_draw_mask_fade_param_cfg_t(data->cfg); break; // converting from lv_draw_mask_fade_param_cfg_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_dsc: data->dsc = mp_write__lv_draw_mask_common_dsc_t(dest[1]); break; // converting to _lv_draw_mask_common_dsc_t;
                case MP_QSTR_cfg: data->cfg = mp_write_lv_draw_mask_fade_param_cfg_t(dest[1]); break; // converting to lv_draw_mask_fade_param_cfg_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_draw_mask_fade_param_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_draw_mask_fade_param_t");
}

STATIC const mp_obj_dict_t mp_lv_draw_mask_fade_param_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_draw_mask_fade_param_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_draw_mask_fade_param_t,
    .print = mp_lv_draw_mask_fade_param_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_draw_mask_fade_param_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_draw_mask_fade_param_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_draw_mask_fade_param_t_type()
{
    return &mp_lv_draw_mask_fade_param_t_type;
}
    
typedef __typeof__( ((lv_draw_mask_map_param_t*)(0))->cfg ) lv_draw_mask_map_param_cfg_t;

/*
 * Struct lv_draw_mask_map_param_cfg_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_draw_mask_map_param_cfg_t_type();

STATIC inline lv_draw_mask_map_param_cfg_t* mp_write_ptr_lv_draw_mask_map_param_cfg_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_draw_mask_map_param_cfg_t_type()));
    return (lv_draw_mask_map_param_cfg_t*)self->data;
}

#define mp_write_lv_draw_mask_map_param_cfg_t(struct_obj) *mp_write_ptr_lv_draw_mask_map_param_cfg_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_draw_mask_map_param_cfg_t(lv_draw_mask_map_param_cfg_t *field)
{
    return lv_to_mp_struct(get_mp_lv_draw_mask_map_param_cfg_t_type(), (void*)field);
}

#define mp_read_lv_draw_mask_map_param_cfg_t(field) mp_read_ptr_lv_draw_mask_map_param_cfg_t(copy_buffer(&field, sizeof(lv_draw_mask_map_param_cfg_t)))
#define mp_read_byref_lv_draw_mask_map_param_cfg_t(field) mp_read_ptr_lv_draw_mask_map_param_cfg_t(&field)

STATIC void mp_lv_draw_mask_map_param_cfg_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_draw_mask_map_param_cfg_t *data = (lv_draw_mask_map_param_cfg_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_coords: dest[0] = mp_read_byref_lv_area_t(data->coords); break; // converting from lv_area_t;
            case MP_QSTR_map: dest[0] = ptr_to_mp((void*)data->map); break; // converting from lv_opa_t *;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_coords: data->coords = mp_write_lv_area_t(dest[1]); break; // converting to lv_area_t;
                case MP_QSTR_map: data->map = (void*)mp_to_ptr(dest[1]); break; // converting to lv_opa_t *;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_draw_mask_map_param_cfg_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_draw_mask_map_param_cfg_t");
}

STATIC const mp_obj_dict_t mp_lv_draw_mask_map_param_cfg_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_draw_mask_map_param_cfg_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_draw_mask_map_param_cfg_t,
    .print = mp_lv_draw_mask_map_param_cfg_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_draw_mask_map_param_cfg_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_draw_mask_map_param_cfg_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_draw_mask_map_param_cfg_t_type()
{
    return &mp_lv_draw_mask_map_param_cfg_t_type;
}
    

/*
 * Struct lv_draw_mask_map_param_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_draw_mask_map_param_t_type();

STATIC inline lv_draw_mask_map_param_t* mp_write_ptr_lv_draw_mask_map_param_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_draw_mask_map_param_t_type()));
    return (lv_draw_mask_map_param_t*)self->data;
}

#define mp_write_lv_draw_mask_map_param_t(struct_obj) *mp_write_ptr_lv_draw_mask_map_param_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_draw_mask_map_param_t(lv_draw_mask_map_param_t *field)
{
    return lv_to_mp_struct(get_mp_lv_draw_mask_map_param_t_type(), (void*)field);
}

#define mp_read_lv_draw_mask_map_param_t(field) mp_read_ptr_lv_draw_mask_map_param_t(copy_buffer(&field, sizeof(lv_draw_mask_map_param_t)))
#define mp_read_byref_lv_draw_mask_map_param_t(field) mp_read_ptr_lv_draw_mask_map_param_t(&field)

STATIC void mp_lv_draw_mask_map_param_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_draw_mask_map_param_t *data = (lv_draw_mask_map_param_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_dsc: dest[0] = mp_read_byref__lv_draw_mask_common_dsc_t(data->dsc); break; // converting from _lv_draw_mask_common_dsc_t;
            case MP_QSTR_cfg: dest[0] = mp_read_byref_lv_draw_mask_map_param_cfg_t(data->cfg); break; // converting from lv_draw_mask_map_param_cfg_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_dsc: data->dsc = mp_write__lv_draw_mask_common_dsc_t(dest[1]); break; // converting to _lv_draw_mask_common_dsc_t;
                case MP_QSTR_cfg: data->cfg = mp_write_lv_draw_mask_map_param_cfg_t(dest[1]); break; // converting to lv_draw_mask_map_param_cfg_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_draw_mask_map_param_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_draw_mask_map_param_t");
}

STATIC const mp_obj_dict_t mp_lv_draw_mask_map_param_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_draw_mask_map_param_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_draw_mask_map_param_t,
    .print = mp_lv_draw_mask_map_param_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_draw_mask_map_param_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_draw_mask_map_param_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_draw_mask_map_param_t_type()
{
    return &mp_lv_draw_mask_map_param_t_type;
}
    
typedef __typeof__( ((lv_draw_mask_polygon_param_t*)(0))->cfg ) lv_draw_mask_polygon_param_cfg_t;

/*
 * Struct lv_draw_mask_polygon_param_cfg_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_draw_mask_polygon_param_cfg_t_type();

STATIC inline lv_draw_mask_polygon_param_cfg_t* mp_write_ptr_lv_draw_mask_polygon_param_cfg_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_draw_mask_polygon_param_cfg_t_type()));
    return (lv_draw_mask_polygon_param_cfg_t*)self->data;
}

#define mp_write_lv_draw_mask_polygon_param_cfg_t(struct_obj) *mp_write_ptr_lv_draw_mask_polygon_param_cfg_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_draw_mask_polygon_param_cfg_t(lv_draw_mask_polygon_param_cfg_t *field)
{
    return lv_to_mp_struct(get_mp_lv_draw_mask_polygon_param_cfg_t_type(), (void*)field);
}

#define mp_read_lv_draw_mask_polygon_param_cfg_t(field) mp_read_ptr_lv_draw_mask_polygon_param_cfg_t(copy_buffer(&field, sizeof(lv_draw_mask_polygon_param_cfg_t)))
#define mp_read_byref_lv_draw_mask_polygon_param_cfg_t(field) mp_read_ptr_lv_draw_mask_polygon_param_cfg_t(&field)

STATIC void mp_lv_draw_mask_polygon_param_cfg_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_draw_mask_polygon_param_cfg_t *data = (lv_draw_mask_polygon_param_cfg_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_points: dest[0] = mp_read_ptr_lv_point_t((void*)data->points); break; // converting from lv_point_t *;
            case MP_QSTR_point_cnt: dest[0] = mp_obj_new_int_from_uint(data->point_cnt); break; // converting from uint16_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_points: data->points = (void*)mp_write_ptr_lv_point_t(dest[1]); break; // converting to lv_point_t *;
                case MP_QSTR_point_cnt: data->point_cnt = (uint16_t)mp_obj_get_int(dest[1]); break; // converting to uint16_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_draw_mask_polygon_param_cfg_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_draw_mask_polygon_param_cfg_t");
}

STATIC const mp_obj_dict_t mp_lv_draw_mask_polygon_param_cfg_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_draw_mask_polygon_param_cfg_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_draw_mask_polygon_param_cfg_t,
    .print = mp_lv_draw_mask_polygon_param_cfg_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_draw_mask_polygon_param_cfg_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_draw_mask_polygon_param_cfg_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_draw_mask_polygon_param_cfg_t_type()
{
    return &mp_lv_draw_mask_polygon_param_cfg_t_type;
}
    

/*
 * Struct lv_draw_mask_polygon_param_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_draw_mask_polygon_param_t_type();

STATIC inline lv_draw_mask_polygon_param_t* mp_write_ptr_lv_draw_mask_polygon_param_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_draw_mask_polygon_param_t_type()));
    return (lv_draw_mask_polygon_param_t*)self->data;
}

#define mp_write_lv_draw_mask_polygon_param_t(struct_obj) *mp_write_ptr_lv_draw_mask_polygon_param_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_draw_mask_polygon_param_t(lv_draw_mask_polygon_param_t *field)
{
    return lv_to_mp_struct(get_mp_lv_draw_mask_polygon_param_t_type(), (void*)field);
}

#define mp_read_lv_draw_mask_polygon_param_t(field) mp_read_ptr_lv_draw_mask_polygon_param_t(copy_buffer(&field, sizeof(lv_draw_mask_polygon_param_t)))
#define mp_read_byref_lv_draw_mask_polygon_param_t(field) mp_read_ptr_lv_draw_mask_polygon_param_t(&field)

STATIC void mp_lv_draw_mask_polygon_param_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_draw_mask_polygon_param_t *data = (lv_draw_mask_polygon_param_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_dsc: dest[0] = mp_read_byref__lv_draw_mask_common_dsc_t(data->dsc); break; // converting from _lv_draw_mask_common_dsc_t;
            case MP_QSTR_cfg: dest[0] = mp_read_byref_lv_draw_mask_polygon_param_cfg_t(data->cfg); break; // converting from lv_draw_mask_polygon_param_cfg_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_dsc: data->dsc = mp_write__lv_draw_mask_common_dsc_t(dest[1]); break; // converting to _lv_draw_mask_common_dsc_t;
                case MP_QSTR_cfg: data->cfg = mp_write_lv_draw_mask_polygon_param_cfg_t(dest[1]); break; // converting to lv_draw_mask_polygon_param_cfg_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_draw_mask_polygon_param_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_draw_mask_polygon_param_t");
}

STATIC const mp_obj_dict_t mp_lv_draw_mask_polygon_param_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_draw_mask_polygon_param_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_draw_mask_polygon_param_t,
    .print = mp_lv_draw_mask_polygon_param_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_draw_mask_polygon_param_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_draw_mask_polygon_param_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_draw_mask_polygon_param_t_type()
{
    return &mp_lv_draw_mask_polygon_param_t_type;
}
    
#define funcptr_read_cb_1 NULL


/*
 * Struct lv_indev_data_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_indev_data_t_type();

STATIC inline lv_indev_data_t* mp_write_ptr_lv_indev_data_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_indev_data_t_type()));
    return (lv_indev_data_t*)self->data;
}

#define mp_write_lv_indev_data_t(struct_obj) *mp_write_ptr_lv_indev_data_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_indev_data_t(lv_indev_data_t *field)
{
    return lv_to_mp_struct(get_mp_lv_indev_data_t_type(), (void*)field);
}

#define mp_read_lv_indev_data_t(field) mp_read_ptr_lv_indev_data_t(copy_buffer(&field, sizeof(lv_indev_data_t)))
#define mp_read_byref_lv_indev_data_t(field) mp_read_ptr_lv_indev_data_t(&field)

STATIC void mp_lv_indev_data_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_indev_data_t *data = (lv_indev_data_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_point: dest[0] = mp_read_byref_lv_point_t(data->point); break; // converting from lv_point_t;
            case MP_QSTR_key: dest[0] = mp_obj_new_int_from_uint(data->key); break; // converting from uint32_t;
            case MP_QSTR_btn_id: dest[0] = mp_obj_new_int_from_uint(data->btn_id); break; // converting from uint32_t;
            case MP_QSTR_enc_diff: dest[0] = mp_obj_new_int(data->enc_diff); break; // converting from int16_t;
            case MP_QSTR_state: dest[0] = mp_obj_new_int(data->state); break; // converting from lv_indev_state_t;
            case MP_QSTR_continue_reading: dest[0] = convert_to_bool(data->continue_reading); break; // converting from bool;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_point: data->point = mp_write_lv_point_t(dest[1]); break; // converting to lv_point_t;
                case MP_QSTR_key: data->key = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_btn_id: data->btn_id = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_enc_diff: data->enc_diff = (int16_t)mp_obj_get_int(dest[1]); break; // converting to int16_t;
                case MP_QSTR_state: data->state = (int)mp_obj_get_int(dest[1]); break; // converting to lv_indev_state_t;
                case MP_QSTR_continue_reading: data->continue_reading = mp_obj_is_true(dest[1]); break; // converting to bool;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_indev_data_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_indev_data_t");
}

STATIC const mp_obj_dict_t mp_lv_indev_data_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_indev_data_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_indev_data_t,
    .print = mp_lv_indev_data_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_indev_data_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_indev_data_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_indev_data_t_type()
{
    return &mp_lv_indev_data_t_type;
}
    

/*
 * lvgl extension definition for:
 * void read_cb(struct _lv_indev_drv_t *indev_drv, lv_indev_data_t *data)
 */
 
STATIC mp_obj_t mp_funcptr_read_cb_1(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_indev_drv_t *indev_drv = mp_to_ptr(mp_args[0]);
    lv_indev_data_t *data = mp_write_ptr_lv_indev_data_t(mp_args[1]);
    ((void (*)(struct _lv_indev_drv_t *, lv_indev_data_t *))lv_func_ptr)(indev_drv, data);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_read_cb_1_obj, 2, mp_funcptr_read_cb_1, funcptr_read_cb_1);
    
STATIC inline mp_obj_t mp_lv_funcptr_read_cb_1(void *func){ return mp_lv_funcptr(&mp_funcptr_read_cb_1_obj, func, NULL, MP_QSTR_, NULL); }

STATIC void lv_indev_drv_t_read_cb_callback(struct _lv_indev_drv_t *indev_drv, lv_indev_data_t *data);
#define funcptr_feedback_cb NULL


/*
 * lvgl extension definition for:
 * void feedback_cb(struct _lv_indev_drv_t *, uint8_t)
 */
 
STATIC mp_obj_t mp_funcptr_feedback_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_indev_drv_t *arg0 = mp_to_ptr(mp_args[0]);
    uint8_t arg1 = (uint8_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(struct _lv_indev_drv_t *, uint8_t))lv_func_ptr)(arg0, arg1);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_feedback_cb_obj, 2, mp_funcptr_feedback_cb, funcptr_feedback_cb);
    
STATIC inline mp_obj_t mp_lv_funcptr_feedback_cb(void *func){ return mp_lv_funcptr(&mp_funcptr_feedback_cb_obj, func, NULL, MP_QSTR_, NULL); }

STATIC void lv_indev_drv_t_feedback_cb_callback(struct _lv_indev_drv_t *, uint8_t);

/*
 * Struct lv_indev_drv_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_indev_drv_t_type();

STATIC inline lv_indev_drv_t* mp_write_ptr_lv_indev_drv_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_indev_drv_t_type()));
    return (lv_indev_drv_t*)self->data;
}

#define mp_write_lv_indev_drv_t(struct_obj) *mp_write_ptr_lv_indev_drv_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_indev_drv_t(lv_indev_drv_t *field)
{
    return lv_to_mp_struct(get_mp_lv_indev_drv_t_type(), (void*)field);
}

#define mp_read_lv_indev_drv_t(field) mp_read_ptr_lv_indev_drv_t(copy_buffer(&field, sizeof(lv_indev_drv_t)))
#define mp_read_byref_lv_indev_drv_t(field) mp_read_ptr_lv_indev_drv_t(&field)

STATIC void mp_lv_indev_drv_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_indev_drv_t *data = (lv_indev_drv_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_type: dest[0] = mp_obj_new_int(data->type); break; // converting from lv_indev_type_t;
            case MP_QSTR_read_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_read_cb_1_obj, (void*)data->read_cb, lv_indev_drv_t_read_cb_callback ,MP_QSTR_lv_indev_drv_t_read_cb, data->user_data); break; // converting from callback void (*)(lv_indev_drv_t *indev_drv, lv_indev_data_t *data);
            case MP_QSTR_feedback_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_feedback_cb_obj, (void*)data->feedback_cb, lv_indev_drv_t_feedback_cb_callback ,MP_QSTR_lv_indev_drv_t_feedback_cb, data->user_data); break; // converting from callback void (*)(lv_indev_drv_t *, uint8_t);
            case MP_QSTR_user_data: dest[0] = ptr_to_mp((void*)data->user_data); break; // converting from void *;
            case MP_QSTR_disp: dest[0] = mp_read_ptr_lv_disp_t((void*)data->disp); break; // converting from lv_disp_t *;
            case MP_QSTR_read_timer: dest[0] = mp_read_ptr_lv_timer_t((void*)data->read_timer); break; // converting from lv_timer_t *;
            case MP_QSTR_scroll_limit: dest[0] = mp_obj_new_int_from_uint(data->scroll_limit); break; // converting from uint8_t;
            case MP_QSTR_scroll_throw: dest[0] = mp_obj_new_int_from_uint(data->scroll_throw); break; // converting from uint8_t;
            case MP_QSTR_gesture_min_velocity: dest[0] = mp_obj_new_int_from_uint(data->gesture_min_velocity); break; // converting from uint8_t;
            case MP_QSTR_gesture_limit: dest[0] = mp_obj_new_int_from_uint(data->gesture_limit); break; // converting from uint8_t;
            case MP_QSTR_long_press_time: dest[0] = mp_obj_new_int_from_uint(data->long_press_time); break; // converting from uint16_t;
            case MP_QSTR_long_press_repeat_time: dest[0] = mp_obj_new_int_from_uint(data->long_press_repeat_time); break; // converting from uint16_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_type: data->type = (int)mp_obj_get_int(dest[1]); break; // converting to lv_indev_type_t;
                case MP_QSTR_read_cb: data->read_cb = (void*)mp_lv_callback(dest[1], lv_indev_drv_t_read_cb_callback ,MP_QSTR_lv_indev_drv_t_read_cb, &data->user_data); break; // converting to callback void (*)(lv_indev_drv_t *indev_drv, lv_indev_data_t *data);
                case MP_QSTR_feedback_cb: data->feedback_cb = (void*)mp_lv_callback(dest[1], lv_indev_drv_t_feedback_cb_callback ,MP_QSTR_lv_indev_drv_t_feedback_cb, &data->user_data); break; // converting to callback void (*)(lv_indev_drv_t *, uint8_t);
                case MP_QSTR_user_data: data->user_data = (void*)mp_to_ptr(dest[1]); break; // converting to void *;
                case MP_QSTR_disp: data->disp = (void*)mp_write_ptr_lv_disp_t(dest[1]); break; // converting to lv_disp_t *;
                case MP_QSTR_read_timer: data->read_timer = (void*)mp_write_ptr_lv_timer_t(dest[1]); break; // converting to lv_timer_t *;
                case MP_QSTR_scroll_limit: data->scroll_limit = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                case MP_QSTR_scroll_throw: data->scroll_throw = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                case MP_QSTR_gesture_min_velocity: data->gesture_min_velocity = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                case MP_QSTR_gesture_limit: data->gesture_limit = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                case MP_QSTR_long_press_time: data->long_press_time = (uint16_t)mp_obj_get_int(dest[1]); break; // converting to uint16_t;
                case MP_QSTR_long_press_repeat_time: data->long_press_repeat_time = (uint16_t)mp_obj_get_int(dest[1]); break; // converting to uint16_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_indev_drv_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_indev_drv_t");
}

STATIC const mp_obj_dict_t mp_lv_indev_drv_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_indev_drv_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_indev_drv_t,
    .print = mp_lv_indev_drv_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_indev_drv_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_indev_drv_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_indev_drv_t_type()
{
    return &mp_lv_indev_drv_t_type;
}
    
typedef __typeof__( ((_lv_indev_proc_t*)(0))->types ) _lv_indev_proc_types_t;
typedef __typeof__( ((_lv_indev_proc_types_t*)(0))->pointer ) _lv_indev_proc_types_pointer_t;

/*
 * Struct _lv_indev_proc_types_pointer_t
 */

STATIC inline const mp_obj_type_t *get_mp__lv_indev_proc_types_pointer_t_type();

STATIC inline _lv_indev_proc_types_pointer_t* mp_write_ptr__lv_indev_proc_types_pointer_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp__lv_indev_proc_types_pointer_t_type()));
    return (_lv_indev_proc_types_pointer_t*)self->data;
}

#define mp_write__lv_indev_proc_types_pointer_t(struct_obj) *mp_write_ptr__lv_indev_proc_types_pointer_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr__lv_indev_proc_types_pointer_t(_lv_indev_proc_types_pointer_t *field)
{
    return lv_to_mp_struct(get_mp__lv_indev_proc_types_pointer_t_type(), (void*)field);
}

#define mp_read__lv_indev_proc_types_pointer_t(field) mp_read_ptr__lv_indev_proc_types_pointer_t(copy_buffer(&field, sizeof(_lv_indev_proc_types_pointer_t)))
#define mp_read_byref__lv_indev_proc_types_pointer_t(field) mp_read_ptr__lv_indev_proc_types_pointer_t(&field)

STATIC void mp__lv_indev_proc_types_pointer_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    _lv_indev_proc_types_pointer_t *data = (_lv_indev_proc_types_pointer_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_act_point: dest[0] = mp_read_byref_lv_point_t(data->act_point); break; // converting from lv_point_t;
            case MP_QSTR_last_point: dest[0] = mp_read_byref_lv_point_t(data->last_point); break; // converting from lv_point_t;
            case MP_QSTR_last_raw_point: dest[0] = mp_read_byref_lv_point_t(data->last_raw_point); break; // converting from lv_point_t;
            case MP_QSTR_vect: dest[0] = mp_read_byref_lv_point_t(data->vect); break; // converting from lv_point_t;
            case MP_QSTR_scroll_sum: dest[0] = mp_read_byref_lv_point_t(data->scroll_sum); break; // converting from lv_point_t;
            case MP_QSTR_scroll_throw_vect: dest[0] = mp_read_byref_lv_point_t(data->scroll_throw_vect); break; // converting from lv_point_t;
            case MP_QSTR_scroll_throw_vect_ori: dest[0] = mp_read_byref_lv_point_t(data->scroll_throw_vect_ori); break; // converting from lv_point_t;
            case MP_QSTR_act_obj: dest[0] = lv_to_mp((void*)data->act_obj); break; // converting from lv_obj_t *;
            case MP_QSTR_last_obj: dest[0] = lv_to_mp((void*)data->last_obj); break; // converting from lv_obj_t *;
            case MP_QSTR_scroll_obj: dest[0] = lv_to_mp((void*)data->scroll_obj); break; // converting from lv_obj_t *;
            case MP_QSTR_last_pressed: dest[0] = lv_to_mp((void*)data->last_pressed); break; // converting from lv_obj_t *;
            case MP_QSTR_scroll_area: dest[0] = mp_read_byref_lv_area_t(data->scroll_area); break; // converting from lv_area_t;
            case MP_QSTR_gesture_sum: dest[0] = mp_read_byref_lv_point_t(data->gesture_sum); break; // converting from lv_point_t;
            case MP_QSTR_scroll_dir: dest[0] = mp_obj_new_int_from_uint(data->scroll_dir); break; // converting from lv_dir_t;
            case MP_QSTR_gesture_dir: dest[0] = mp_obj_new_int_from_uint(data->gesture_dir); break; // converting from lv_dir_t;
            case MP_QSTR_gesture_sent: dest[0] = mp_obj_new_int_from_uint(data->gesture_sent); break; // converting from uint8_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_act_point: data->act_point = mp_write_lv_point_t(dest[1]); break; // converting to lv_point_t;
                case MP_QSTR_last_point: data->last_point = mp_write_lv_point_t(dest[1]); break; // converting to lv_point_t;
                case MP_QSTR_last_raw_point: data->last_raw_point = mp_write_lv_point_t(dest[1]); break; // converting to lv_point_t;
                case MP_QSTR_vect: data->vect = mp_write_lv_point_t(dest[1]); break; // converting to lv_point_t;
                case MP_QSTR_scroll_sum: data->scroll_sum = mp_write_lv_point_t(dest[1]); break; // converting to lv_point_t;
                case MP_QSTR_scroll_throw_vect: data->scroll_throw_vect = mp_write_lv_point_t(dest[1]); break; // converting to lv_point_t;
                case MP_QSTR_scroll_throw_vect_ori: data->scroll_throw_vect_ori = mp_write_lv_point_t(dest[1]); break; // converting to lv_point_t;
                case MP_QSTR_act_obj: data->act_obj = (void*)mp_to_lv(dest[1]); break; // converting to lv_obj_t *;
                case MP_QSTR_last_obj: data->last_obj = (void*)mp_to_lv(dest[1]); break; // converting to lv_obj_t *;
                case MP_QSTR_scroll_obj: data->scroll_obj = (void*)mp_to_lv(dest[1]); break; // converting to lv_obj_t *;
                case MP_QSTR_last_pressed: data->last_pressed = (void*)mp_to_lv(dest[1]); break; // converting to lv_obj_t *;
                case MP_QSTR_scroll_area: data->scroll_area = mp_write_lv_area_t(dest[1]); break; // converting to lv_area_t;
                case MP_QSTR_gesture_sum: data->gesture_sum = mp_write_lv_point_t(dest[1]); break; // converting to lv_point_t;
                case MP_QSTR_scroll_dir: data->scroll_dir = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to lv_dir_t;
                case MP_QSTR_gesture_dir: data->gesture_dir = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to lv_dir_t;
                case MP_QSTR_gesture_sent: data->gesture_sent = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp__lv_indev_proc_types_pointer_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct _lv_indev_proc_types_pointer_t");
}

STATIC const mp_obj_dict_t mp__lv_indev_proc_types_pointer_t_locals_dict;

STATIC const mp_obj_type_t mp__lv_indev_proc_types_pointer_t_type = {
    { &mp_type_type },
    .name = MP_QSTR__lv_indev_proc_types_pointer_t,
    .print = mp__lv_indev_proc_types_pointer_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp__lv_indev_proc_types_pointer_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp__lv_indev_proc_types_pointer_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp__lv_indev_proc_types_pointer_t_type()
{
    return &mp__lv_indev_proc_types_pointer_t_type;
}
    
typedef __typeof__( ((_lv_indev_proc_types_t*)(0))->keypad ) _lv_indev_proc_types_keypad_t;

/*
 * Struct _lv_indev_proc_types_keypad_t
 */

STATIC inline const mp_obj_type_t *get_mp__lv_indev_proc_types_keypad_t_type();

STATIC inline _lv_indev_proc_types_keypad_t* mp_write_ptr__lv_indev_proc_types_keypad_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp__lv_indev_proc_types_keypad_t_type()));
    return (_lv_indev_proc_types_keypad_t*)self->data;
}

#define mp_write__lv_indev_proc_types_keypad_t(struct_obj) *mp_write_ptr__lv_indev_proc_types_keypad_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr__lv_indev_proc_types_keypad_t(_lv_indev_proc_types_keypad_t *field)
{
    return lv_to_mp_struct(get_mp__lv_indev_proc_types_keypad_t_type(), (void*)field);
}

#define mp_read__lv_indev_proc_types_keypad_t(field) mp_read_ptr__lv_indev_proc_types_keypad_t(copy_buffer(&field, sizeof(_lv_indev_proc_types_keypad_t)))
#define mp_read_byref__lv_indev_proc_types_keypad_t(field) mp_read_ptr__lv_indev_proc_types_keypad_t(&field)

STATIC void mp__lv_indev_proc_types_keypad_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    _lv_indev_proc_types_keypad_t *data = (_lv_indev_proc_types_keypad_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_last_state: dest[0] = mp_obj_new_int(data->last_state); break; // converting from lv_indev_state_t;
            case MP_QSTR_last_key: dest[0] = mp_obj_new_int_from_uint(data->last_key); break; // converting from uint32_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_last_state: data->last_state = (int)mp_obj_get_int(dest[1]); break; // converting to lv_indev_state_t;
                case MP_QSTR_last_key: data->last_key = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp__lv_indev_proc_types_keypad_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct _lv_indev_proc_types_keypad_t");
}

STATIC const mp_obj_dict_t mp__lv_indev_proc_types_keypad_t_locals_dict;

STATIC const mp_obj_type_t mp__lv_indev_proc_types_keypad_t_type = {
    { &mp_type_type },
    .name = MP_QSTR__lv_indev_proc_types_keypad_t,
    .print = mp__lv_indev_proc_types_keypad_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp__lv_indev_proc_types_keypad_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp__lv_indev_proc_types_keypad_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp__lv_indev_proc_types_keypad_t_type()
{
    return &mp__lv_indev_proc_types_keypad_t_type;
}
    

/*
 * Struct _lv_indev_proc_types_t
 */

STATIC inline const mp_obj_type_t *get_mp__lv_indev_proc_types_t_type();

STATIC inline _lv_indev_proc_types_t* mp_write_ptr__lv_indev_proc_types_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp__lv_indev_proc_types_t_type()));
    return (_lv_indev_proc_types_t*)self->data;
}

#define mp_write__lv_indev_proc_types_t(struct_obj) *mp_write_ptr__lv_indev_proc_types_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr__lv_indev_proc_types_t(_lv_indev_proc_types_t *field)
{
    return lv_to_mp_struct(get_mp__lv_indev_proc_types_t_type(), (void*)field);
}

#define mp_read__lv_indev_proc_types_t(field) mp_read_ptr__lv_indev_proc_types_t(copy_buffer(&field, sizeof(_lv_indev_proc_types_t)))
#define mp_read_byref__lv_indev_proc_types_t(field) mp_read_ptr__lv_indev_proc_types_t(&field)

STATIC void mp__lv_indev_proc_types_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    _lv_indev_proc_types_t *data = (_lv_indev_proc_types_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_pointer: dest[0] = mp_read_byref__lv_indev_proc_types_pointer_t(data->pointer); break; // converting from _lv_indev_proc_types_pointer_t;
            case MP_QSTR_keypad: dest[0] = mp_read_byref__lv_indev_proc_types_keypad_t(data->keypad); break; // converting from _lv_indev_proc_types_keypad_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_pointer: data->pointer = mp_write__lv_indev_proc_types_pointer_t(dest[1]); break; // converting to _lv_indev_proc_types_pointer_t;
                case MP_QSTR_keypad: data->keypad = mp_write__lv_indev_proc_types_keypad_t(dest[1]); break; // converting to _lv_indev_proc_types_keypad_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp__lv_indev_proc_types_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct _lv_indev_proc_types_t");
}

STATIC const mp_obj_dict_t mp__lv_indev_proc_types_t_locals_dict;

STATIC const mp_obj_type_t mp__lv_indev_proc_types_t_type = {
    { &mp_type_type },
    .name = MP_QSTR__lv_indev_proc_types_t,
    .print = mp__lv_indev_proc_types_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp__lv_indev_proc_types_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp__lv_indev_proc_types_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp__lv_indev_proc_types_t_type()
{
    return &mp__lv_indev_proc_types_t_type;
}
    

/*
 * Struct _lv_indev_proc_t
 */

STATIC inline const mp_obj_type_t *get_mp__lv_indev_proc_t_type();

STATIC inline _lv_indev_proc_t* mp_write_ptr__lv_indev_proc_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp__lv_indev_proc_t_type()));
    return (_lv_indev_proc_t*)self->data;
}

#define mp_write__lv_indev_proc_t(struct_obj) *mp_write_ptr__lv_indev_proc_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr__lv_indev_proc_t(_lv_indev_proc_t *field)
{
    return lv_to_mp_struct(get_mp__lv_indev_proc_t_type(), (void*)field);
}

#define mp_read__lv_indev_proc_t(field) mp_read_ptr__lv_indev_proc_t(copy_buffer(&field, sizeof(_lv_indev_proc_t)))
#define mp_read_byref__lv_indev_proc_t(field) mp_read_ptr__lv_indev_proc_t(&field)

STATIC void mp__lv_indev_proc_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    _lv_indev_proc_t *data = (_lv_indev_proc_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_state: dest[0] = mp_obj_new_int(data->state); break; // converting from lv_indev_state_t;
            case MP_QSTR_long_pr_sent: dest[0] = mp_obj_new_int_from_uint(data->long_pr_sent); break; // converting from uint8_t;
            case MP_QSTR_reset_query: dest[0] = mp_obj_new_int_from_uint(data->reset_query); break; // converting from uint8_t;
            case MP_QSTR_disabled: dest[0] = mp_obj_new_int_from_uint(data->disabled); break; // converting from uint8_t;
            case MP_QSTR_wait_until_release: dest[0] = mp_obj_new_int_from_uint(data->wait_until_release); break; // converting from uint8_t;
            case MP_QSTR_types: dest[0] = mp_read_byref__lv_indev_proc_types_t(data->types); break; // converting from _lv_indev_proc_types_t;
            case MP_QSTR_pr_timestamp: dest[0] = mp_obj_new_int_from_uint(data->pr_timestamp); break; // converting from uint32_t;
            case MP_QSTR_longpr_rep_timestamp: dest[0] = mp_obj_new_int_from_uint(data->longpr_rep_timestamp); break; // converting from uint32_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_state: data->state = (int)mp_obj_get_int(dest[1]); break; // converting to lv_indev_state_t;
                case MP_QSTR_long_pr_sent: data->long_pr_sent = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                case MP_QSTR_reset_query: data->reset_query = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                case MP_QSTR_disabled: data->disabled = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                case MP_QSTR_wait_until_release: data->wait_until_release = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                case MP_QSTR_types: data->types = mp_write__lv_indev_proc_types_t(dest[1]); break; // converting to _lv_indev_proc_types_t;
                case MP_QSTR_pr_timestamp: data->pr_timestamp = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_longpr_rep_timestamp: data->longpr_rep_timestamp = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp__lv_indev_proc_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct _lv_indev_proc_t");
}

STATIC const mp_obj_dict_t mp__lv_indev_proc_t_locals_dict;

STATIC const mp_obj_type_t mp__lv_indev_proc_t_type = {
    { &mp_type_type },
    .name = MP_QSTR__lv_indev_proc_t,
    .print = mp__lv_indev_proc_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp__lv_indev_proc_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp__lv_indev_proc_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp__lv_indev_proc_t_type()
{
    return &mp__lv_indev_proc_t_type;
}
    

/*
 * Struct lv_ll_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_ll_t_type();

STATIC inline lv_ll_t* mp_write_ptr_lv_ll_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_ll_t_type()));
    return (lv_ll_t*)self->data;
}

#define mp_write_lv_ll_t(struct_obj) *mp_write_ptr_lv_ll_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_ll_t(lv_ll_t *field)
{
    return lv_to_mp_struct(get_mp_lv_ll_t_type(), (void*)field);
}

#define mp_read_lv_ll_t(field) mp_read_ptr_lv_ll_t(copy_buffer(&field, sizeof(lv_ll_t)))
#define mp_read_byref_lv_ll_t(field) mp_read_ptr_lv_ll_t(&field)

STATIC void mp_lv_ll_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_ll_t *data = (lv_ll_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_n_size: dest[0] = mp_obj_new_int_from_uint(data->n_size); break; // converting from uint32_t;
            case MP_QSTR_head: dest[0] = ptr_to_mp((void*)data->head); break; // converting from lv_ll_node_t *;
            case MP_QSTR_tail: dest[0] = ptr_to_mp((void*)data->tail); break; // converting from lv_ll_node_t *;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_n_size: data->n_size = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_head: data->head = (void*)mp_to_ptr(dest[1]); break; // converting to lv_ll_node_t *;
                case MP_QSTR_tail: data->tail = (void*)mp_to_ptr(dest[1]); break; // converting to lv_ll_node_t *;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_ll_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_ll_t");
}

STATIC const mp_obj_dict_t mp_lv_ll_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_ll_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_ll_t,
    .print = mp_lv_ll_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_ll_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_ll_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_ll_t_type()
{
    return &mp_lv_ll_t_type;
}
    
#define funcptr_lv_group_focus_cb_t NULL


/*
 * lvgl extension definition for:
 * void lv_group_focus_cb_t(struct _lv_group_t *)
 */
 
STATIC mp_obj_t mp_funcptr_lv_group_focus_cb_t(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_group_t *arg0 = mp_to_ptr(mp_args[0]);
    ((void (*)(struct _lv_group_t *))lv_func_ptr)(arg0);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_lv_group_focus_cb_t_obj, 1, mp_funcptr_lv_group_focus_cb_t, funcptr_lv_group_focus_cb_t);
    
STATIC inline mp_obj_t mp_lv_funcptr_lv_group_focus_cb_t(void *func){ return mp_lv_funcptr(&mp_funcptr_lv_group_focus_cb_t_obj, func, NULL, MP_QSTR_, NULL); }

STATIC void lv_group_t_focus_cb_callback(struct _lv_group_t *);
#define funcptr_lv_group_edge_cb_t NULL


/*
 * lvgl extension definition for:
 * void lv_group_edge_cb_t(struct _lv_group_t *, bool)
 */
 
STATIC mp_obj_t mp_funcptr_lv_group_edge_cb_t(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_group_t *arg0 = mp_to_ptr(mp_args[0]);
    bool arg1 = mp_obj_is_true(mp_args[1]);
    ((void (*)(struct _lv_group_t *, bool))lv_func_ptr)(arg0, arg1);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_lv_group_edge_cb_t_obj, 2, mp_funcptr_lv_group_edge_cb_t, funcptr_lv_group_edge_cb_t);
    
STATIC inline mp_obj_t mp_lv_funcptr_lv_group_edge_cb_t(void *func){ return mp_lv_funcptr(&mp_funcptr_lv_group_edge_cb_t_obj, func, NULL, MP_QSTR_, NULL); }

STATIC void lv_group_t_edge_cb_callback(struct _lv_group_t *, bool);

/*
 * Struct lv_group_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_group_t_type();

STATIC inline lv_group_t* mp_write_ptr_lv_group_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_group_t_type()));
    return (lv_group_t*)self->data;
}

#define mp_write_lv_group_t(struct_obj) *mp_write_ptr_lv_group_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_group_t(lv_group_t *field)
{
    return lv_to_mp_struct(get_mp_lv_group_t_type(), (void*)field);
}

#define mp_read_lv_group_t(field) mp_read_ptr_lv_group_t(copy_buffer(&field, sizeof(lv_group_t)))
#define mp_read_byref_lv_group_t(field) mp_read_ptr_lv_group_t(&field)

STATIC void mp_lv_group_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_group_t *data = (lv_group_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_obj_ll: dest[0] = mp_read_byref_lv_ll_t(data->obj_ll); break; // converting from lv_ll_t;
            case MP_QSTR_obj_focus: dest[0] = ptr_to_mp((void*)data->obj_focus); break; // converting from lv_obj_t **;
            case MP_QSTR_focus_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_lv_group_focus_cb_t_obj, data->focus_cb, lv_group_t_focus_cb_callback ,MP_QSTR_lv_group_t_focus_cb, data->user_data); break; // converting from callback lv_group_focus_cb_t;
            case MP_QSTR_edge_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_lv_group_edge_cb_t_obj, data->edge_cb, lv_group_t_edge_cb_callback ,MP_QSTR_lv_group_t_edge_cb, data->user_data); break; // converting from callback lv_group_edge_cb_t;
            case MP_QSTR_user_data: dest[0] = ptr_to_mp((void*)data->user_data); break; // converting from void *;
            case MP_QSTR_frozen: dest[0] = mp_obj_new_int_from_uint(data->frozen); break; // converting from uint8_t;
            case MP_QSTR_editing: dest[0] = mp_obj_new_int_from_uint(data->editing); break; // converting from uint8_t;
            case MP_QSTR_refocus_policy: dest[0] = mp_obj_new_int_from_uint(data->refocus_policy); break; // converting from uint8_t;
            case MP_QSTR_wrap: dest[0] = mp_obj_new_int_from_uint(data->wrap); break; // converting from uint8_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_obj_ll: data->obj_ll = mp_write_lv_ll_t(dest[1]); break; // converting to lv_ll_t;
                case MP_QSTR_obj_focus: data->obj_focus = (void*)mp_to_ptr(dest[1]); break; // converting to lv_obj_t **;
                case MP_QSTR_focus_cb: data->focus_cb = mp_lv_callback(dest[1], lv_group_t_focus_cb_callback ,MP_QSTR_lv_group_t_focus_cb, &data->user_data); break; // converting to callback lv_group_focus_cb_t;
                case MP_QSTR_edge_cb: data->edge_cb = mp_lv_callback(dest[1], lv_group_t_edge_cb_callback ,MP_QSTR_lv_group_t_edge_cb, &data->user_data); break; // converting to callback lv_group_edge_cb_t;
                case MP_QSTR_user_data: data->user_data = (void*)mp_to_ptr(dest[1]); break; // converting to void *;
                case MP_QSTR_frozen: data->frozen = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                case MP_QSTR_editing: data->editing = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                case MP_QSTR_refocus_policy: data->refocus_policy = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                case MP_QSTR_wrap: data->wrap = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_group_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_group_t");
}

STATIC const mp_obj_dict_t mp_lv_group_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_group_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_group_t,
    .print = mp_lv_group_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_group_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_group_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_group_t_type()
{
    return &mp_lv_group_t_type;
}
    

/*
 * Struct lv_indev_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_indev_t_type();

STATIC inline lv_indev_t* mp_write_ptr_lv_indev_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_indev_t_type()));
    return (lv_indev_t*)self->data;
}

#define mp_write_lv_indev_t(struct_obj) *mp_write_ptr_lv_indev_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_indev_t(lv_indev_t *field)
{
    return lv_to_mp_struct(get_mp_lv_indev_t_type(), (void*)field);
}

#define mp_read_lv_indev_t(field) mp_read_ptr_lv_indev_t(copy_buffer(&field, sizeof(lv_indev_t)))
#define mp_read_byref_lv_indev_t(field) mp_read_ptr_lv_indev_t(&field)

STATIC void mp_lv_indev_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_indev_t *data = (lv_indev_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_driver: dest[0] = mp_read_ptr_lv_indev_drv_t((void*)data->driver); break; // converting from lv_indev_drv_t *;
            case MP_QSTR_proc: dest[0] = mp_read_byref__lv_indev_proc_t(data->proc); break; // converting from _lv_indev_proc_t;
            case MP_QSTR_cursor: dest[0] = lv_to_mp((void*)data->cursor); break; // converting from lv_obj_t *;
            case MP_QSTR_group: dest[0] = mp_read_ptr_lv_group_t((void*)data->group); break; // converting from lv_group_t *;
            case MP_QSTR_btn_points: dest[0] = mp_read_ptr_lv_point_t((void*)data->btn_points); break; // converting from lv_point_t *;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_driver: data->driver = (void*)mp_write_ptr_lv_indev_drv_t(dest[1]); break; // converting to lv_indev_drv_t *;
                case MP_QSTR_proc: data->proc = mp_write__lv_indev_proc_t(dest[1]); break; // converting to _lv_indev_proc_t;
                case MP_QSTR_cursor: data->cursor = (void*)mp_to_lv(dest[1]); break; // converting to lv_obj_t *;
                case MP_QSTR_group: data->group = (void*)mp_write_ptr_lv_group_t(dest[1]); break; // converting to lv_group_t *;
                case MP_QSTR_btn_points: data->btn_points = (void*)mp_write_ptr_lv_point_t(dest[1]); break; // converting to lv_point_t *;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_indev_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_indev_t");
}

STATIC const mp_obj_dict_t mp_lv_indev_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_indev_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_indev_t,
    .print = mp_lv_indev_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_indev_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_indev_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_indev_t_type()
{
    return &mp_lv_indev_t_type;
}
    

/*
 * Struct gd_GCE
 */

STATIC inline const mp_obj_type_t *get_mp_gd_GCE_type();

STATIC inline gd_GCE* mp_write_ptr_gd_GCE(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_gd_GCE_type()));
    return (gd_GCE*)self->data;
}

#define mp_write_gd_GCE(struct_obj) *mp_write_ptr_gd_GCE(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_gd_GCE(gd_GCE *field)
{
    return lv_to_mp_struct(get_mp_gd_GCE_type(), (void*)field);
}

#define mp_read_gd_GCE(field) mp_read_ptr_gd_GCE(copy_buffer(&field, sizeof(gd_GCE)))
#define mp_read_byref_gd_GCE(field) mp_read_ptr_gd_GCE(&field)

STATIC void mp_gd_GCE_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    gd_GCE *data = (gd_GCE*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_delay: dest[0] = mp_obj_new_int_from_uint(data->delay); break; // converting from uint16_t;
            case MP_QSTR_tindex: dest[0] = mp_obj_new_int_from_uint(data->tindex); break; // converting from uint8_t;
            case MP_QSTR_disposal: dest[0] = mp_obj_new_int_from_uint(data->disposal); break; // converting from uint8_t;
            case MP_QSTR_input: dest[0] = mp_obj_new_int(data->input); break; // converting from int;
            case MP_QSTR_transparency: dest[0] = mp_obj_new_int(data->transparency); break; // converting from int;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_delay: data->delay = (uint16_t)mp_obj_get_int(dest[1]); break; // converting to uint16_t;
                case MP_QSTR_tindex: data->tindex = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                case MP_QSTR_disposal: data->disposal = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                case MP_QSTR_input: data->input = (int)mp_obj_get_int(dest[1]); break; // converting to int;
                case MP_QSTR_transparency: data->transparency = (int)mp_obj_get_int(dest[1]); break; // converting to int;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_gd_GCE_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct gd_GCE");
}

STATIC const mp_obj_dict_t mp_gd_GCE_locals_dict;

STATIC const mp_obj_type_t mp_gd_GCE_type = {
    { &mp_type_type },
    .name = MP_QSTR_gd_GCE,
    .print = mp_gd_GCE_print,
    .make_new = make_new_lv_struct,
    .attr = mp_gd_GCE_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_gd_GCE_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_gd_GCE_type()
{
    return &mp_gd_GCE_type;
}
    

/*
 * Array convertors for uint8_t [0x100 * 3]
 */

STATIC uint8_t *mp_arr_to_uint8_t___0x100_ptr_3__(mp_obj_t mp_arr)
{
    mp_obj_t mp_len = mp_obj_len_maybe(mp_arr);
    if (mp_len == MP_OBJ_NULL) return mp_to_ptr(mp_arr);
    mp_int_t len = mp_obj_get_int(mp_len);
    //TODO check dim!
    uint8_t *lv_arr = (uint8_t*)m_malloc(len * sizeof(uint8_t));
    mp_obj_t iter = mp_getiter(mp_arr, NULL);
    mp_obj_t item;
    size_t i = 0;
    while ((item = mp_iternext(iter)) != MP_OBJ_STOP_ITERATION) {
        lv_arr[i++] = (uint8_t)mp_obj_get_int(item);
    }
    return (uint8_t *)lv_arr;
}
    
STATIC mp_obj_t mp_arr_from_uint8_t___0x100_ptr_3__(uint8_t *arr)
{
    mp_obj_t obj_arr[0x100 * 3];
    for (size_t i=0; i<0x100 * 3; i++){
        obj_arr[i] = mp_obj_new_int_from_uint(arr[i]);
    }
    return mp_obj_new_list(0x100 * 3, obj_arr); // TODO: return custom iterable object!
}
    

/*
 * Struct gd_Palette
 */

STATIC inline const mp_obj_type_t *get_mp_gd_Palette_type();

STATIC inline gd_Palette* mp_write_ptr_gd_Palette(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_gd_Palette_type()));
    return (gd_Palette*)self->data;
}

#define mp_write_gd_Palette(struct_obj) *mp_write_ptr_gd_Palette(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_gd_Palette(gd_Palette *field)
{
    return lv_to_mp_struct(get_mp_gd_Palette_type(), (void*)field);
}

#define mp_read_gd_Palette(field) mp_read_ptr_gd_Palette(copy_buffer(&field, sizeof(gd_Palette)))
#define mp_read_byref_gd_Palette(field) mp_read_ptr_gd_Palette(&field)

STATIC void mp_gd_Palette_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    gd_Palette *data = (gd_Palette*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_size: dest[0] = mp_obj_new_int(data->size); break; // converting from int;
            case MP_QSTR_colors: dest[0] = mp_arr_from_uint8_t___0x100_ptr_3__(data->colors); break; // converting from uint8_t [0x100 * 3];
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_size: data->size = (int)mp_obj_get_int(dest[1]); break; // converting to int;
                case MP_QSTR_colors: memcpy((void*)&data->colors, mp_arr_to_uint8_t___0x100_ptr_3__(dest[1]), sizeof(uint8_t)*0x100 * 3); break; // converting to uint8_t [0x100 * 3];
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_gd_Palette_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct gd_Palette");
}

STATIC const mp_obj_dict_t mp_gd_Palette_locals_dict;

STATIC const mp_obj_type_t mp_gd_Palette_type = {
    { &mp_type_type },
    .name = MP_QSTR_gd_Palette,
    .print = mp_gd_Palette_print,
    .make_new = make_new_lv_struct,
    .attr = mp_gd_Palette_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_gd_Palette_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_gd_Palette_type()
{
    return &mp_gd_Palette_type;
}
    
#define funcptr_plain_text NULL


/*
 * lvgl extension definition for:
 * void plain_text(struct gd_GIF *gif, uint16_t tx, uint16_t ty, uint16_t tw, uint16_t th, uint8_t cw, uint8_t ch, uint8_t fg, uint8_t bg)
 */
 
STATIC mp_obj_t mp_funcptr_plain_text(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct gd_GIF *gif = mp_to_ptr(mp_args[0]);
    uint16_t tx = (uint16_t)mp_obj_get_int(mp_args[1]);
    uint16_t ty = (uint16_t)mp_obj_get_int(mp_args[2]);
    uint16_t tw = (uint16_t)mp_obj_get_int(mp_args[3]);
    uint16_t th = (uint16_t)mp_obj_get_int(mp_args[4]);
    uint8_t cw = (uint8_t)mp_obj_get_int(mp_args[5]);
    uint8_t ch = (uint8_t)mp_obj_get_int(mp_args[6]);
    uint8_t fg = (uint8_t)mp_obj_get_int(mp_args[7]);
    uint8_t bg = (uint8_t)mp_obj_get_int(mp_args[8]);
    ((void (*)(struct gd_GIF *, uint16_t, uint16_t, uint16_t, uint16_t, uint8_t, uint8_t, uint8_t, uint8_t))lv_func_ptr)(gif, tx, ty, tw, th, cw, ch, fg, bg);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_plain_text_obj, 9, mp_funcptr_plain_text, funcptr_plain_text);
    
STATIC inline mp_obj_t mp_lv_funcptr_plain_text(void *func){ return mp_lv_funcptr(&mp_funcptr_plain_text_obj, func, NULL, MP_QSTR_, NULL); }


/*
 * Function NOT generated:
 * Missing 'user_data' as a field of the first parameter of the callback function 'gd_GIF_plain_text_callback'
 * void (*plain_text)(struct gd_GIF *gif, uint16_t tx, uint16_t ty, uint16_t tw, uint16_t th, uint8_t cw, uint8_t ch, uint8_t fg, uint8_t bg)
 */
    
#define funcptr_comment NULL


/*
 * lvgl extension definition for:
 * void comment(struct gd_GIF *gif)
 */
 
STATIC mp_obj_t mp_funcptr_comment(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct gd_GIF *gif = mp_to_ptr(mp_args[0]);
    ((void (*)(struct gd_GIF *))lv_func_ptr)(gif);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_comment_obj, 1, mp_funcptr_comment, funcptr_comment);
    
STATIC inline mp_obj_t mp_lv_funcptr_comment(void *func){ return mp_lv_funcptr(&mp_funcptr_comment_obj, func, NULL, MP_QSTR_, NULL); }


/*
 * Function NOT generated:
 * Missing 'user_data' as a field of the first parameter of the callback function 'gd_GIF_comment_callback'
 * void (*comment)(struct gd_GIF *gif)
 */
    
#define funcptr_application NULL


/*
 * Array convertors for char [8]
 */

STATIC char *mp_arr_to_char___8__(mp_obj_t mp_arr)
{
    mp_obj_t mp_len = mp_obj_len_maybe(mp_arr);
    if (mp_len == MP_OBJ_NULL) return mp_to_ptr(mp_arr);
    mp_int_t len = mp_obj_get_int(mp_len);
    //TODO check dim!
    char *lv_arr = (char*)m_malloc(len * sizeof(char));
    mp_obj_t iter = mp_getiter(mp_arr, NULL);
    mp_obj_t item;
    size_t i = 0;
    while ((item = mp_iternext(iter)) != MP_OBJ_STOP_ITERATION) {
        lv_arr[i++] = (char)mp_obj_get_int(item);
    }
    return (char *)lv_arr;
}
    
STATIC mp_obj_t mp_arr_from_char___8__(char *arr)
{
    mp_obj_t obj_arr[8];
    for (size_t i=0; i<8; i++){
        obj_arr[i] = mp_obj_new_int(arr[i]);
    }
    return mp_obj_new_list(8, obj_arr); // TODO: return custom iterable object!
}
    

/*
 * Array convertors for char [3]
 */

STATIC char *mp_arr_to_char___3__(mp_obj_t mp_arr)
{
    mp_obj_t mp_len = mp_obj_len_maybe(mp_arr);
    if (mp_len == MP_OBJ_NULL) return mp_to_ptr(mp_arr);
    mp_int_t len = mp_obj_get_int(mp_len);
    //TODO check dim!
    char *lv_arr = (char*)m_malloc(len * sizeof(char));
    mp_obj_t iter = mp_getiter(mp_arr, NULL);
    mp_obj_t item;
    size_t i = 0;
    while ((item = mp_iternext(iter)) != MP_OBJ_STOP_ITERATION) {
        lv_arr[i++] = (char)mp_obj_get_int(item);
    }
    return (char *)lv_arr;
}
    
STATIC mp_obj_t mp_arr_from_char___3__(char *arr)
{
    mp_obj_t obj_arr[3];
    for (size_t i=0; i<3; i++){
        obj_arr[i] = mp_obj_new_int(arr[i]);
    }
    return mp_obj_new_list(3, obj_arr); // TODO: return custom iterable object!
}
    

/*
 * lvgl extension definition for:
 * void application(struct gd_GIF *gif, char id[8], char auth[3])
 */
 
STATIC mp_obj_t mp_funcptr_application(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct gd_GIF *gif = mp_to_ptr(mp_args[0]);
    char *id = mp_arr_to_char___8__(mp_args[1]);
    char *auth = mp_arr_to_char___3__(mp_args[2]);
    ((void (*)(struct gd_GIF *, char [8], char [3]))lv_func_ptr)(gif, id, auth);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_application_obj, 3, mp_funcptr_application, funcptr_application);
    
STATIC inline mp_obj_t mp_lv_funcptr_application(void *func){ return mp_lv_funcptr(&mp_funcptr_application_obj, func, NULL, MP_QSTR_, NULL); }


/*
 * Function NOT generated:
 * Missing 'user_data' as a field of the first parameter of the callback function 'gd_GIF_application_callback'
 * void (*application)(struct gd_GIF *gif, char id[8], char auth[3])
 */
    

/*
 * Struct gd_GIF
 */

STATIC inline const mp_obj_type_t *get_mp_gd_GIF_type();

STATIC inline gd_GIF* mp_write_ptr_gd_GIF(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_gd_GIF_type()));
    return (gd_GIF*)self->data;
}

#define mp_write_gd_GIF(struct_obj) *mp_write_ptr_gd_GIF(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_gd_GIF(gd_GIF *field)
{
    return lv_to_mp_struct(get_mp_gd_GIF_type(), (void*)field);
}

#define mp_read_gd_GIF(field) mp_read_ptr_gd_GIF(copy_buffer(&field, sizeof(gd_GIF)))
#define mp_read_byref_gd_GIF(field) mp_read_ptr_gd_GIF(&field)

STATIC void mp_gd_GIF_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    gd_GIF *data = (gd_GIF*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_fd: dest[0] = mp_read_byref_lv_fs_file_t(data->fd); break; // converting from lv_fs_file_t;
            case MP_QSTR_data: dest[0] = convert_to_str((void*)data->data); break; // converting from char *;
            case MP_QSTR_is_file: dest[0] = mp_obj_new_int_from_uint(data->is_file); break; // converting from uint8_t;
            case MP_QSTR_f_rw_p: dest[0] = mp_obj_new_int_from_uint(data->f_rw_p); break; // converting from uint32_t;
            case MP_QSTR_anim_start: dest[0] = mp_obj_new_int(data->anim_start); break; // converting from int32_t;
            case MP_QSTR_width: dest[0] = mp_obj_new_int_from_uint(data->width); break; // converting from uint16_t;
            case MP_QSTR_height: dest[0] = mp_obj_new_int_from_uint(data->height); break; // converting from uint16_t;
            case MP_QSTR_depth: dest[0] = mp_obj_new_int_from_uint(data->depth); break; // converting from uint16_t;
            case MP_QSTR_loop_count: dest[0] = mp_obj_new_int_from_uint(data->loop_count); break; // converting from uint16_t;
            case MP_QSTR_gce: dest[0] = mp_read_byref_gd_GCE(data->gce); break; // converting from gd_GCE;
            case MP_QSTR_palette: dest[0] = mp_read_ptr_gd_Palette((void*)data->palette); break; // converting from gd_Palette *;
            case MP_QSTR_lct: dest[0] = mp_read_byref_gd_Palette(data->lct); break; // converting from gd_Palette;
            case MP_QSTR_gct: dest[0] = mp_read_byref_gd_Palette(data->gct); break; // converting from gd_Palette;
            case MP_QSTR_plain_text: dest[0] = mp_lv_funcptr(&mp_funcptr_plain_text_obj, (void*)data->plain_text, NULL ,MP_QSTR_gd_GIF_plain_text, NULL); break; // converting from callback void (*)(gd_GIF *gif, uint16_t tx, uint16_t ty, uint16_t tw, uint16_t th, uint8_t cw, uint8_t ch, uint8_t fg, uint8_t bg);
            case MP_QSTR_comment: dest[0] = mp_lv_funcptr(&mp_funcptr_comment_obj, (void*)data->comment, NULL ,MP_QSTR_gd_GIF_comment, NULL); break; // converting from callback void (*)(gd_GIF *gif);
            case MP_QSTR_application: dest[0] = mp_lv_funcptr(&mp_funcptr_application_obj, (void*)data->application, NULL ,MP_QSTR_gd_GIF_application, NULL); break; // converting from callback void (*)(gd_GIF *gif, char id[8], char auth[3]);
            case MP_QSTR_fx: dest[0] = mp_obj_new_int_from_uint(data->fx); break; // converting from uint16_t;
            case MP_QSTR_fy: dest[0] = mp_obj_new_int_from_uint(data->fy); break; // converting from uint16_t;
            case MP_QSTR_fw: dest[0] = mp_obj_new_int_from_uint(data->fw); break; // converting from uint16_t;
            case MP_QSTR_fh: dest[0] = mp_obj_new_int_from_uint(data->fh); break; // converting from uint16_t;
            case MP_QSTR_bgindex: dest[0] = mp_obj_new_int_from_uint(data->bgindex); break; // converting from uint8_t;
            case MP_QSTR_canvas: dest[0] = ptr_to_mp((void*)data->canvas); break; // converting from uint8_t *;
            case MP_QSTR_frame: dest[0] = ptr_to_mp((void*)data->frame); break; // converting from uint8_t *;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_fd: data->fd = mp_write_lv_fs_file_t(dest[1]); break; // converting to lv_fs_file_t;
                case MP_QSTR_data: data->data = (void*)(char*)convert_from_str(dest[1]); break; // converting to char *;
                case MP_QSTR_is_file: data->is_file = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                case MP_QSTR_f_rw_p: data->f_rw_p = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_anim_start: data->anim_start = (int32_t)mp_obj_get_int(dest[1]); break; // converting to int32_t;
                case MP_QSTR_width: data->width = (uint16_t)mp_obj_get_int(dest[1]); break; // converting to uint16_t;
                case MP_QSTR_height: data->height = (uint16_t)mp_obj_get_int(dest[1]); break; // converting to uint16_t;
                case MP_QSTR_depth: data->depth = (uint16_t)mp_obj_get_int(dest[1]); break; // converting to uint16_t;
                case MP_QSTR_loop_count: data->loop_count = (uint16_t)mp_obj_get_int(dest[1]); break; // converting to uint16_t;
                case MP_QSTR_gce: data->gce = mp_write_gd_GCE(dest[1]); break; // converting to gd_GCE;
                case MP_QSTR_palette: data->palette = (void*)mp_write_ptr_gd_Palette(dest[1]); break; // converting to gd_Palette *;
                case MP_QSTR_lct: data->lct = mp_write_gd_Palette(dest[1]); break; // converting to gd_Palette;
                case MP_QSTR_gct: data->gct = mp_write_gd_Palette(dest[1]); break; // converting to gd_Palette;
                case MP_QSTR_plain_text: data->plain_text = (void*)mp_lv_callback(dest[1], NULL ,MP_QSTR_gd_GIF_plain_text, NULL); break; // converting to callback void (*)(gd_GIF *gif, uint16_t tx, uint16_t ty, uint16_t tw, uint16_t th, uint8_t cw, uint8_t ch, uint8_t fg, uint8_t bg);
                case MP_QSTR_comment: data->comment = (void*)mp_lv_callback(dest[1], NULL ,MP_QSTR_gd_GIF_comment, NULL); break; // converting to callback void (*)(gd_GIF *gif);
                case MP_QSTR_application: data->application = (void*)mp_lv_callback(dest[1], NULL ,MP_QSTR_gd_GIF_application, NULL); break; // converting to callback void (*)(gd_GIF *gif, char id[8], char auth[3]);
                case MP_QSTR_fx: data->fx = (uint16_t)mp_obj_get_int(dest[1]); break; // converting to uint16_t;
                case MP_QSTR_fy: data->fy = (uint16_t)mp_obj_get_int(dest[1]); break; // converting to uint16_t;
                case MP_QSTR_fw: data->fw = (uint16_t)mp_obj_get_int(dest[1]); break; // converting to uint16_t;
                case MP_QSTR_fh: data->fh = (uint16_t)mp_obj_get_int(dest[1]); break; // converting to uint16_t;
                case MP_QSTR_bgindex: data->bgindex = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                case MP_QSTR_canvas: data->canvas = (void*)mp_to_ptr(dest[1]); break; // converting to uint8_t *;
                case MP_QSTR_frame: data->frame = (void*)mp_to_ptr(dest[1]); break; // converting to uint8_t *;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_gd_GIF_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct gd_GIF");
}

STATIC const mp_obj_dict_t mp_gd_GIF_locals_dict;

STATIC const mp_obj_type_t mp_gd_GIF_type = {
    { &mp_type_type },
    .name = MP_QSTR_gd_GIF,
    .print = mp_gd_GIF_print,
    .make_new = make_new_lv_struct,
    .attr = mp_gd_GIF_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_gd_GIF_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_gd_GIF_type()
{
    return &mp_gd_GIF_type;
}
    

/*
 * Array convertors for char [32]
 */

STATIC char *mp_arr_to_char___32__(mp_obj_t mp_arr)
{
    mp_obj_t mp_len = mp_obj_len_maybe(mp_arr);
    if (mp_len == MP_OBJ_NULL) return mp_to_ptr(mp_arr);
    mp_int_t len = mp_obj_get_int(mp_len);
    //TODO check dim!
    char *lv_arr = (char*)m_malloc(len * sizeof(char));
    mp_obj_t iter = mp_getiter(mp_arr, NULL);
    mp_obj_t item;
    size_t i = 0;
    while ((item = mp_iternext(iter)) != MP_OBJ_STOP_ITERATION) {
        lv_arr[i++] = (char)mp_obj_get_int(item);
    }
    return (char *)lv_arr;
}
    
STATIC mp_obj_t mp_arr_from_char___32__(char *arr)
{
    mp_obj_t obj_arr[32];
    for (size_t i=0; i<32; i++){
        obj_arr[i] = mp_obj_new_int(arr[i]);
    }
    return mp_obj_new_list(32, obj_arr); // TODO: return custom iterable object!
}
    

/*
 * Struct lv_ex_data_value_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_ex_data_value_t_type();

STATIC inline lv_ex_data_value_t* mp_write_ptr_lv_ex_data_value_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_ex_data_value_t_type()));
    return (lv_ex_data_value_t*)self->data;
}

#define mp_write_lv_ex_data_value_t(struct_obj) *mp_write_ptr_lv_ex_data_value_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_ex_data_value_t(lv_ex_data_value_t *field)
{
    return lv_to_mp_struct(get_mp_lv_ex_data_value_t_type(), (void*)field);
}

#define mp_read_lv_ex_data_value_t(field) mp_read_ptr_lv_ex_data_value_t(copy_buffer(&field, sizeof(lv_ex_data_value_t)))
#define mp_read_byref_lv_ex_data_value_t(field) mp_read_ptr_lv_ex_data_value_t(&field)

STATIC void mp_lv_ex_data_value_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_ex_data_value_t *data = (lv_ex_data_value_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_i: dest[0] = mp_obj_new_int(data->i); break; // converting from int32_t;
            case MP_QSTR_ui: dest[0] = mp_obj_new_int_from_uint(data->ui); break; // converting from uint32_t;
            case MP_QSTR_f: dest[0] = mp_obj_new_float(data->f); break; // converting from float;
            case MP_QSTR_s: dest[0] = convert_to_str((void*)data->s); break; // converting from char *;
            case MP_QSTR_ptr: dest[0] = ptr_to_mp((void*)data->ptr); break; // converting from void *;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_i: data->i = (int32_t)mp_obj_get_int(dest[1]); break; // converting to int32_t;
                case MP_QSTR_ui: data->ui = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_f: data->f = mp_obj_get_float(dest[1]); break; // converting to float;
                case MP_QSTR_s: data->s = (void*)(char*)convert_from_str(dest[1]); break; // converting to char *;
                case MP_QSTR_ptr: data->ptr = (void*)mp_to_ptr(dest[1]); break; // converting to void *;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_ex_data_value_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_ex_data_value_t");
}

STATIC const mp_obj_dict_t mp_lv_ex_data_value_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_ex_data_value_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_ex_data_value_t,
    .print = mp_lv_ex_data_value_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_ex_data_value_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_ex_data_value_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_ex_data_value_t_type()
{
    return &mp_lv_ex_data_value_t_type;
}
    

/*
 * Struct lv_ex_data_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_ex_data_t_type();

STATIC inline lv_ex_data_t* mp_write_ptr_lv_ex_data_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_ex_data_t_type()));
    return (lv_ex_data_t*)self->data;
}

#define mp_write_lv_ex_data_t(struct_obj) *mp_write_ptr_lv_ex_data_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_ex_data_t(lv_ex_data_t *field)
{
    return lv_to_mp_struct(get_mp_lv_ex_data_t_type(), (void*)field);
}

#define mp_read_lv_ex_data_t(field) mp_read_ptr_lv_ex_data_t(copy_buffer(&field, sizeof(lv_ex_data_t)))
#define mp_read_byref_lv_ex_data_t(field) mp_read_ptr_lv_ex_data_t(&field)

STATIC void mp_lv_ex_data_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_ex_data_t *data = (lv_ex_data_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_name: dest[0] = mp_arr_from_char___32__(data->name); break; // converting from char [32];
            case MP_QSTR_value: dest[0] = mp_read_byref_lv_ex_data_value_t(data->value); break; // converting from lv_ex_data_value_t;
            case MP_QSTR_type: dest[0] = mp_obj_new_int(data->type); break; // converting from lv_ex_data_type_t;
            case MP_QSTR_listener: dest[0] = mp_read_byref_lv_ll_t(data->listener); break; // converting from lv_ll_t;
            case MP_QSTR_updated: dest[0] = convert_to_bool(data->updated); break; // converting from bool;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_name: memcpy((void*)&data->name, mp_arr_to_char___32__(dest[1]), sizeof(char)*32); break; // converting to char [32];
                case MP_QSTR_value: data->value = mp_write_lv_ex_data_value_t(dest[1]); break; // converting to lv_ex_data_value_t;
                case MP_QSTR_type: data->type = (int)mp_obj_get_int(dest[1]); break; // converting to lv_ex_data_type_t;
                case MP_QSTR_listener: data->listener = mp_write_lv_ll_t(dest[1]); break; // converting to lv_ll_t;
                case MP_QSTR_updated: data->updated = mp_obj_is_true(dest[1]); break; // converting to bool;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_ex_data_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_ex_data_t");
}

STATIC const mp_obj_dict_t mp_lv_ex_data_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_ex_data_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_ex_data_t,
    .print = mp_lv_ex_data_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_ex_data_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_ex_data_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_ex_data_t_type()
{
    return &mp_lv_ex_data_t_type;
}
    
#define funcptr_lv_key_handler_t NULL


/*
 * lvgl extension definition for:
 * int32_t lv_key_handler_t(lv_key_t key, lv_indev_state_t event)
 */
 
STATIC mp_obj_t mp_funcptr_lv_key_handler_t(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_key_t key = (uint8_t)mp_obj_get_int(mp_args[0]);
    lv_indev_state_t event = (int)mp_obj_get_int(mp_args[1]);
    int32_t _res = ((int32_t (*)(lv_key_t, lv_indev_state_t))lv_func_ptr)(key, event);
    return mp_obj_new_int(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_lv_key_handler_t_obj, 2, mp_funcptr_lv_key_handler_t, funcptr_lv_key_handler_t);
    
STATIC inline mp_obj_t mp_lv_funcptr_lv_key_handler_t(void *func){ return mp_lv_funcptr(&mp_funcptr_lv_key_handler_t_obj, func, NULL, MP_QSTR_, NULL); }

#define funcptr_lv_defaultwheel_handler_t NULL


/*
 * lvgl extension definition for:
 * int32_t lv_defaultwheel_handler_t(int16_t diff, lv_indev_state_t event, void *user_data)
 */
 
STATIC mp_obj_t mp_funcptr_lv_defaultwheel_handler_t(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    void *user_data = mp_to_ptr(mp_args[2]);
    lv_indev_state_t event = (int)mp_obj_get_int(mp_args[1]);
    int16_t diff = (int16_t)mp_obj_get_int(mp_args[0]);
    int32_t _res = ((int32_t (*)(int16_t, lv_indev_state_t, void *))lv_func_ptr)(diff, event, user_data);
    return mp_obj_new_int(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_lv_defaultwheel_handler_t_obj, 3, mp_funcptr_lv_defaultwheel_handler_t, funcptr_lv_defaultwheel_handler_t);
    
STATIC inline mp_obj_t mp_lv_funcptr_lv_defaultwheel_handler_t(void *func){ return mp_lv_funcptr(&mp_funcptr_lv_defaultwheel_handler_t_obj, func, NULL, MP_QSTR_, NULL); }


STATIC const mp_rom_map_elem_t mp_C_Pointer_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(C_Pointer))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_C_Pointer_locals_dict, mp_C_Pointer_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * inline static uint8_t lv_color_to1(lv_color_t color)
 */
 
STATIC mp_obj_t mp_lv_color_to1(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_color_t color = mp_write_lv_color16_t(mp_args[0]);
    uint8_t _res = ((uint8_t (*)(lv_color_t))lv_func_ptr)(color);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_color_to1_obj, 1, mp_lv_color_to1, lv_color_to1);
    
/* Reusing lv_color_to1 for lv_color_to8 */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_color_to8_obj, 1, mp_lv_color_to1, lv_color_to8);
    

/*
 * lvgl extension definition for:
 * inline static uint16_t lv_color_to16(lv_color_t color)
 */
 
STATIC mp_obj_t mp_lv_color_to16(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_color_t color = mp_write_lv_color16_t(mp_args[0]);
    uint16_t _res = ((uint16_t (*)(lv_color_t))lv_func_ptr)(color);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_color_to16_obj, 1, mp_lv_color_to16, lv_color_to16);
    

/*
 * lvgl extension definition for:
 * inline static uint32_t lv_color_to32(lv_color_t color)
 */
 
STATIC mp_obj_t mp_lv_color_to32(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_color_t color = mp_write_lv_color16_t(mp_args[0]);
    uint32_t _res = ((uint32_t (*)(lv_color_t))lv_func_ptr)(color);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_color_to32_obj, 1, mp_lv_color_to32, lv_color_to32);
    

/*
 * lvgl extension definition for:
 * inline static bool lv_color_eq(lv_color_t c1, lv_color_t c2)
 */
 
STATIC mp_obj_t mp_lv_color_eq(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_color_t c1 = mp_write_lv_color16_t(mp_args[0]);
    lv_color_t c2 = mp_write_lv_color16_t(mp_args[1]);
    bool _res = ((bool (*)(lv_color_t, lv_color_t))lv_func_ptr)(c1, c2);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_color_eq_obj, 2, mp_lv_color_eq, lv_color_eq);
    

/*
 * lvgl extension definition for:
 * inline static lv_color_t lv_color_mix(lv_color_t c1, lv_color_t c2, uint8_t mix)
 */
 
STATIC mp_obj_t mp_lv_color_mix(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_color_t c1 = mp_write_lv_color16_t(mp_args[0]);
    lv_color_t c2 = mp_write_lv_color16_t(mp_args[1]);
    uint8_t mix = (uint8_t)mp_obj_get_int(mp_args[2]);
    lv_color_t _res = ((lv_color_t (*)(lv_color_t, lv_color_t, uint8_t))lv_func_ptr)(c1, c2, mix);
    return mp_read_lv_color16_t(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_color_mix_obj, 3, mp_lv_color_mix, lv_color_mix);
    

/*
 * lvgl extension definition for:
 * inline static void lv_color_premult(lv_color_t c, uint8_t mix, uint16_t *out)
 */
 
STATIC mp_obj_t mp_lv_color_premult(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_color_t c = mp_write_lv_color16_t(mp_args[0]);
    uint8_t mix = (uint8_t)mp_obj_get_int(mp_args[1]);
    uint16_t *out = mp_to_ptr(mp_args[2]);
    ((void (*)(lv_color_t, uint8_t, uint16_t *))lv_func_ptr)(c, mix, out);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_color_premult_obj, 3, mp_lv_color_premult, lv_color_premult);
    

/*
 * lvgl extension definition for:
 * inline static void lv_color_mix_with_alpha(lv_color_t bg_color, lv_opa_t bg_opa, lv_color_t fg_color, lv_opa_t fg_opa, lv_color_t *res_color, lv_opa_t *res_opa)
 */
 
STATIC mp_obj_t mp_lv_color_mix_with_alpha(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_color_t bg_color = mp_write_lv_color16_t(mp_args[0]);
    lv_opa_t bg_opa = (uint8_t)mp_obj_get_int(mp_args[1]);
    lv_color_t fg_color = mp_write_lv_color16_t(mp_args[2]);
    lv_opa_t fg_opa = (uint8_t)mp_obj_get_int(mp_args[3]);
    lv_color_t *res_color = mp_write_ptr_lv_color16_t(mp_args[4]);
    lv_opa_t *res_opa = mp_to_ptr(mp_args[5]);
    ((void (*)(lv_color_t, lv_opa_t, lv_color_t, lv_opa_t, lv_color_t *, lv_opa_t *))lv_func_ptr)(bg_color, bg_opa, fg_color, fg_opa, res_color, res_opa);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_color_mix_with_alpha_obj, 6, mp_lv_color_mix_with_alpha, lv_color_mix_with_alpha);
    
/* Reusing lv_color_to1 for lv_color_brightness */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_color_brightness_obj, 1, mp_lv_color_to1, lv_color_brightness);
    

/*
 * lvgl extension definition for:
 * void lv_color_fill(lv_color_t *buf, lv_color_t color, uint32_t px_num)
 */
 
STATIC mp_obj_t mp_lv_color_fill(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_color_t *buf = mp_write_ptr_lv_color16_t(mp_args[0]);
    lv_color_t color = mp_write_lv_color16_t(mp_args[1]);
    uint32_t px_num = (uint32_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_color_t *, lv_color_t, uint32_t))lv_func_ptr)(buf, color, px_num);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_color_fill_obj, 3, mp_lv_color_fill, lv_color_fill);
    

/*
 * lvgl extension definition for:
 * lv_color_t lv_color_lighten(lv_color_t c, lv_opa_t lvl)
 */
 
STATIC mp_obj_t mp_lv_color_lighten(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_color_t c = mp_write_lv_color16_t(mp_args[0]);
    lv_opa_t lvl = (uint8_t)mp_obj_get_int(mp_args[1]);
    lv_color_t _res = ((lv_color_t (*)(lv_color_t, lv_opa_t))lv_func_ptr)(c, lvl);
    return mp_read_lv_color16_t(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_color_lighten_obj, 2, mp_lv_color_lighten, lv_color_lighten);
    
/* Reusing lv_color_lighten for lv_color_darken */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_color_darken_obj, 2, mp_lv_color_lighten, lv_color_darken);
    
/* Reusing lv_color_lighten for lv_color_change_lightness */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_color_change_lightness_obj, 2, mp_lv_color_lighten, lv_color_change_lightness);
    

/*
 * lvgl extension definition for:
 * lv_color_hsv_t lv_color_to_hsv(lv_color_t color)
 */
 
STATIC mp_obj_t mp_lv_color_to_hsv(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_color_t color = mp_write_lv_color16_t(mp_args[0]);
    lv_color_hsv_t _res = ((lv_color_hsv_t (*)(lv_color_t))lv_func_ptr)(color);
    return mp_read_lv_color_hsv_t(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_color_to_hsv_obj, 1, mp_lv_color_to_hsv, lv_color_to_hsv);
    

STATIC const mp_rom_map_elem_t mp_lv_color16_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_color16_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    { MP_ROM_QSTR(MP_QSTR_color_to1), MP_ROM_PTR(&mp_lv_color_to1_obj) },
    { MP_ROM_QSTR(MP_QSTR_color_to8), MP_ROM_PTR(&mp_lv_color_to8_obj) },
    { MP_ROM_QSTR(MP_QSTR_color_to16), MP_ROM_PTR(&mp_lv_color_to16_obj) },
    { MP_ROM_QSTR(MP_QSTR_color_to32), MP_ROM_PTR(&mp_lv_color_to32_obj) },
    { MP_ROM_QSTR(MP_QSTR_color_eq), MP_ROM_PTR(&mp_lv_color_eq_obj) },
    { MP_ROM_QSTR(MP_QSTR_color_mix), MP_ROM_PTR(&mp_lv_color_mix_obj) },
    { MP_ROM_QSTR(MP_QSTR_color_premult), MP_ROM_PTR(&mp_lv_color_premult_obj) },
    { MP_ROM_QSTR(MP_QSTR_color_mix_with_alpha), MP_ROM_PTR(&mp_lv_color_mix_with_alpha_obj) },
    { MP_ROM_QSTR(MP_QSTR_color_brightness), MP_ROM_PTR(&mp_lv_color_brightness_obj) },
    { MP_ROM_QSTR(MP_QSTR_color_fill), MP_ROM_PTR(&mp_lv_color_fill_obj) },
    { MP_ROM_QSTR(MP_QSTR_color_lighten), MP_ROM_PTR(&mp_lv_color_lighten_obj) },
    { MP_ROM_QSTR(MP_QSTR_color_darken), MP_ROM_PTR(&mp_lv_color_darken_obj) },
    { MP_ROM_QSTR(MP_QSTR_color_change_lightness), MP_ROM_PTR(&mp_lv_color_change_lightness_obj) },
    { MP_ROM_QSTR(MP_QSTR_color_to_hsv), MP_ROM_PTR(&mp_lv_color_to_hsv_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_color16_t_locals_dict, mp_lv_color16_t_locals_dict_table);
        

STATIC const mp_rom_map_elem_t mp_lv_color16_ch_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_color16_ch_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_color16_ch_t_locals_dict, mp_lv_color16_ch_t_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * lv_grad_color_t lv_gradient_calculate(const lv_grad_dsc_t *dsc, lv_coord_t range, lv_coord_t frac)
 */
 
STATIC mp_obj_t mp_lv_gradient_calculate(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_grad_dsc_t *dsc = mp_write_ptr_lv_grad_dsc_t(mp_args[0]);
    lv_coord_t range = (int16_t)mp_obj_get_int(mp_args[1]);
    lv_coord_t frac = (int16_t)mp_obj_get_int(mp_args[2]);
    lv_grad_color_t _res = ((lv_grad_color_t (*)(const lv_grad_dsc_t *, lv_coord_t, lv_coord_t))lv_func_ptr)(dsc, range, frac);
    return mp_read_lv_color16_t(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_gradient_calculate_obj, 3, mp_lv_gradient_calculate, lv_gradient_calculate);
    

/*
 * lvgl extension definition for:
 * lv_grad_t *lv_gradient_get(const lv_grad_dsc_t *gradient, lv_coord_t w, lv_coord_t h)
 */
 
STATIC mp_obj_t mp_lv_gradient_get(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_grad_dsc_t *gradient = mp_write_ptr_lv_grad_dsc_t(mp_args[0]);
    lv_coord_t w = (int16_t)mp_obj_get_int(mp_args[1]);
    lv_coord_t h = (int16_t)mp_obj_get_int(mp_args[2]);
    lv_grad_t * _res = ((lv_grad_t *(*)(const lv_grad_dsc_t *, lv_coord_t, lv_coord_t))lv_func_ptr)(gradient, w, h);
    return mp_read_ptr_lv_grad_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_gradient_get_obj, 3, mp_lv_gradient_get, lv_gradient_get);
    

STATIC const mp_rom_map_elem_t mp_lv_grad_dsc_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_grad_dsc_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    { MP_ROM_QSTR(MP_QSTR_gradient_calculate), MP_ROM_PTR(&mp_lv_gradient_calculate_obj) },
    { MP_ROM_QSTR(MP_QSTR_gradient_get), MP_ROM_PTR(&mp_lv_gradient_get_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_grad_dsc_t_locals_dict, mp_lv_grad_dsc_t_locals_dict_table);
        

STATIC const mp_rom_map_elem_t mp_lv_gradient_stop_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_gradient_stop_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_gradient_stop_t_locals_dict, mp_lv_gradient_stop_t_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * inline static lv_coord_t lv_font_get_line_height(const lv_font_t *font_p)
 */
 
STATIC mp_obj_t mp_lv_font_get_line_height(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_font_t *font_p = mp_write_ptr_lv_font_t(mp_args[0]);
    lv_coord_t _res = ((lv_coord_t (*)(const lv_font_t *))lv_func_ptr)(font_p);
    return mp_obj_new_int(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_font_get_line_height_obj, 1, mp_lv_font_get_line_height, lv_font_get_line_height);
    

/*
 * lvgl extension definition for:
 * const uint8_t *lv_font_get_glyph_bitmap(const lv_font_t *font_p, uint32_t letter)
 */
 
STATIC mp_obj_t mp_lv_font_get_glyph_bitmap(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_font_t *font_p = mp_write_ptr_lv_font_t(mp_args[0]);
    uint32_t letter = (uint32_t)mp_obj_get_int(mp_args[1]);
    const uint8_t * _res = ((const uint8_t *(*)(const lv_font_t *, uint32_t))lv_func_ptr)(font_p, letter);
    return ptr_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_font_get_glyph_bitmap_obj, 2, mp_lv_font_get_glyph_bitmap, lv_font_get_glyph_bitmap);
    

/*
 * lvgl extension definition for:
 * bool lv_font_get_glyph_dsc(const lv_font_t *font_p, lv_font_glyph_dsc_t *dsc_out, uint32_t letter, uint32_t letter_next)
 */
 
STATIC mp_obj_t mp_lv_font_get_glyph_dsc(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_font_t *font_p = mp_write_ptr_lv_font_t(mp_args[0]);
    lv_font_glyph_dsc_t *dsc_out = mp_write_ptr_lv_font_glyph_dsc_t(mp_args[1]);
    uint32_t letter = (uint32_t)mp_obj_get_int(mp_args[2]);
    uint32_t letter_next = (uint32_t)mp_obj_get_int(mp_args[3]);
    bool _res = ((bool (*)(const lv_font_t *, lv_font_glyph_dsc_t *, uint32_t, uint32_t))lv_func_ptr)(font_p, dsc_out, letter, letter_next);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_font_get_glyph_dsc_obj, 4, mp_lv_font_get_glyph_dsc, lv_font_get_glyph_dsc);
    

/*
 * lvgl extension definition for:
 * uint16_t lv_font_get_glyph_width(const lv_font_t *font, uint32_t letter, uint32_t letter_next)
 */
 
STATIC mp_obj_t mp_lv_font_get_glyph_width(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_font_t *font = mp_write_ptr_lv_font_t(mp_args[0]);
    uint32_t letter = (uint32_t)mp_obj_get_int(mp_args[1]);
    uint32_t letter_next = (uint32_t)mp_obj_get_int(mp_args[2]);
    uint16_t _res = ((uint16_t (*)(const lv_font_t *, uint32_t, uint32_t))lv_func_ptr)(font, letter, letter_next);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_font_get_glyph_width_obj, 3, mp_lv_font_get_glyph_width, lv_font_get_glyph_width);
    

/*
 * lvgl extension definition for:
 * void lv_font_free(lv_font_t *font)
 */
 
STATIC mp_obj_t mp_lv_font_free(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_font_t *font = mp_write_ptr_lv_font_t(mp_args[0]);
    ((void (*)(lv_font_t *))lv_func_ptr)(font);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_font_free_obj, 1, mp_lv_font_free, lv_font_free);
    
/* Reusing lv_font_get_glyph_bitmap for lv_font_get_bitmap_fmt_txt */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_font_get_bitmap_fmt_txt_obj, 2, mp_lv_font_get_glyph_bitmap, lv_font_get_bitmap_fmt_txt);
    
/* Reusing lv_font_get_glyph_dsc for lv_font_get_glyph_dsc_fmt_txt */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_font_get_glyph_dsc_fmt_txt_obj, 4, mp_lv_font_get_glyph_dsc, lv_font_get_glyph_dsc_fmt_txt);
    

STATIC const mp_rom_map_elem_t mp_lv_font_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_font_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_line_height), MP_ROM_PTR(&mp_lv_font_get_line_height_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_glyph_bitmap), MP_ROM_PTR(&mp_lv_font_get_glyph_bitmap_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_glyph_dsc), MP_ROM_PTR(&mp_lv_font_get_glyph_dsc_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_glyph_width), MP_ROM_PTR(&mp_lv_font_get_glyph_width_obj) },
    { MP_ROM_QSTR(MP_QSTR_free), MP_ROM_PTR(&mp_lv_font_free_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_bitmap_fmt_txt), MP_ROM_PTR(&mp_lv_font_get_bitmap_fmt_txt_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_glyph_dsc_fmt_txt), MP_ROM_PTR(&mp_lv_font_get_glyph_dsc_fmt_txt_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_font_t_locals_dict, mp_lv_font_t_locals_dict_table);
        

STATIC const mp_rom_map_elem_t mp_lv_font_glyph_dsc_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_font_glyph_dsc_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_font_glyph_dsc_t_locals_dict, mp_lv_font_glyph_dsc_t_locals_dict_table);
        

/*
 * Callback function lv_color_filter_dsc_t_cb
 * lv_color_t lv_color_filter_cb_t(const struct _lv_color_filter_dsc_t *, lv_color_t, lv_opa_t)
 */

STATIC lv_color_t lv_color_filter_dsc_t_cb_callback(const struct _lv_color_filter_dsc_t * arg0, lv_color_t arg1, lv_opa_t arg2)
{
    mp_obj_t mp_args[3];
    mp_args[0] = mp_read_ptr_lv_color_filter_dsc_t((void*)arg0);
    mp_args[1] = mp_read_lv_color16_t(arg1);
    mp_args[2] = mp_obj_new_int_from_uint(arg2);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    mp_obj_t callback_result = mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_color_filter_dsc_t_cb)) , 3, 0, mp_args);
    return mp_write_lv_color16_t(callback_result);
}


/*
 * lvgl extension definition for:
 * inline static void lv_color_filter_dsc_init(lv_color_filter_dsc_t *dsc, lv_color_filter_cb_t cb)
 */
 
STATIC mp_obj_t mp_lv_color_filter_dsc_init(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_color_filter_dsc_t *dsc = mp_write_ptr_lv_color_filter_dsc_t(mp_args[0]);
    void *cb = mp_lv_callback(mp_args[1], &lv_color_filter_dsc_t_cb_callback, MP_QSTR_lv_color_filter_dsc_t_cb, &dsc->user_data);
    ((void (*)(lv_color_filter_dsc_t *, lv_color_filter_cb_t))lv_func_ptr)(dsc, cb);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_color_filter_dsc_init_obj, 2, mp_lv_color_filter_dsc_init, lv_color_filter_dsc_init);
    

STATIC const mp_rom_map_elem_t mp_lv_color_filter_dsc_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_color_filter_dsc_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    { MP_ROM_QSTR(MP_QSTR_init), MP_ROM_PTR(&mp_lv_color_filter_dsc_init_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_color_filter_dsc_t_locals_dict, mp_lv_color_filter_dsc_t_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * inline static void lv_anim_set_var(lv_anim_t *a, void *var)
 */
 
STATIC mp_obj_t mp_lv_anim_set_var(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_anim_t *a = mp_write_ptr_lv_anim_t(mp_args[0]);
    void *var = mp_to_ptr(mp_args[1]);
    ((void (*)(lv_anim_t *, void *))lv_func_ptr)(a, var);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_anim_set_var_obj, 2, mp_lv_anim_set_var, lv_anim_set_var);
    

/*
 * Function NOT generated:
 * Callback function 'lv_anim_exec_xcb_t exec_cb' must receive a struct pointer with user_data member as its first argument!
 * lv_anim_exec_xcb_t exec_cb
 */
    

/*
 * lvgl extension definition for:
 * inline static void lv_anim_set_exec_cb(lv_anim_t *a, lv_anim_exec_xcb_t exec_cb)
 */
 
STATIC mp_obj_t mp_lv_anim_set_exec_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_anim_t *a = mp_write_ptr_lv_anim_t(mp_args[0]);
    lv_anim_exec_xcb_t exec_cb = mp_to_ptr(mp_args[1]);
    ((void (*)(lv_anim_t *, lv_anim_exec_xcb_t))lv_func_ptr)(a, exec_cb);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_anim_set_exec_cb_obj, 2, mp_lv_anim_set_exec_cb, lv_anim_set_exec_cb);
    

/*
 * lvgl extension definition for:
 * inline static void lv_anim_set_time(lv_anim_t *a, uint32_t duration)
 */
 
STATIC mp_obj_t mp_lv_anim_set_time(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_anim_t *a = mp_write_ptr_lv_anim_t(mp_args[0]);
    uint32_t duration = (uint32_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_anim_t *, uint32_t))lv_func_ptr)(a, duration);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_anim_set_time_obj, 2, mp_lv_anim_set_time, lv_anim_set_time);
    
/* Reusing lv_anim_set_time for lv_anim_set_delay */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_anim_set_delay_obj, 2, mp_lv_anim_set_time, lv_anim_set_delay);
    

/*
 * lvgl extension definition for:
 * inline static void lv_anim_set_values(lv_anim_t *a, int32_t start, int32_t end)
 */
 
STATIC mp_obj_t mp_lv_anim_set_values(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_anim_t *a = mp_write_ptr_lv_anim_t(mp_args[0]);
    int32_t start = (int32_t)mp_obj_get_int(mp_args[1]);
    int32_t end = (int32_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_anim_t *, int32_t, int32_t))lv_func_ptr)(a, start, end);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_anim_set_values_obj, 3, mp_lv_anim_set_values, lv_anim_set_values);
    

/*
 * Callback function lv_anim_t_exec_cb
 * void lv_anim_custom_exec_cb_t(struct _lv_anim_t *, int32_t)
 */

STATIC void lv_anim_t_exec_cb_callback(struct _lv_anim_t * arg0, int32_t arg1)
{
    mp_obj_t mp_args[2];
    mp_args[0] = mp_read_ptr_lv_anim_t((void*)arg0);
    mp_args[1] = mp_obj_new_int(arg1);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_anim_t_exec_cb)) , 2, 0, mp_args);
    return;
}


/*
 * lvgl extension definition for:
 * inline static void lv_anim_set_custom_exec_cb(lv_anim_t *a, lv_anim_custom_exec_cb_t exec_cb)
 */
 
STATIC mp_obj_t mp_lv_anim_set_custom_exec_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_anim_t *a = mp_write_ptr_lv_anim_t(mp_args[0]);
    void *exec_cb = mp_lv_callback(mp_args[1], &lv_anim_t_exec_cb_callback, MP_QSTR_lv_anim_t_exec_cb, &a->user_data);
    ((void (*)(lv_anim_t *, lv_anim_custom_exec_cb_t))lv_func_ptr)(a, exec_cb);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_anim_set_custom_exec_cb_obj, 2, mp_lv_anim_set_custom_exec_cb, lv_anim_set_custom_exec_cb);
    

/*
 * Callback function lv_anim_t_path_cb
 * int32_t lv_anim_path_cb_t(const struct _lv_anim_t *)
 */

STATIC int32_t lv_anim_t_path_cb_callback(const struct _lv_anim_t * arg0)
{
    mp_obj_t mp_args[1];
    mp_args[0] = mp_read_ptr_lv_anim_t((void*)arg0);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    mp_obj_t callback_result = mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_anim_t_path_cb)) , 1, 0, mp_args);
    return (int32_t)mp_obj_get_int(callback_result);
}


/*
 * lvgl extension definition for:
 * inline static void lv_anim_set_path_cb(lv_anim_t *a, lv_anim_path_cb_t path_cb)
 */
 
STATIC mp_obj_t mp_lv_anim_set_path_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_anim_t *a = mp_write_ptr_lv_anim_t(mp_args[0]);
    void *path_cb = mp_lv_callback(mp_args[1], &lv_anim_t_path_cb_callback, MP_QSTR_lv_anim_t_path_cb, &a->user_data);
    ((void (*)(lv_anim_t *, lv_anim_path_cb_t))lv_func_ptr)(a, path_cb);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_anim_set_path_cb_obj, 2, mp_lv_anim_set_path_cb, lv_anim_set_path_cb);
    

/*
 * Callback function lv_anim_t_start_cb
 * void lv_anim_start_cb_t(struct _lv_anim_t *)
 */

STATIC void lv_anim_t_start_cb_callback(struct _lv_anim_t * arg0)
{
    mp_obj_t mp_args[1];
    mp_args[0] = mp_read_ptr_lv_anim_t((void*)arg0);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_anim_t_start_cb)) , 1, 0, mp_args);
    return;
}


/*
 * lvgl extension definition for:
 * inline static void lv_anim_set_start_cb(lv_anim_t *a, lv_anim_start_cb_t start_cb)
 */
 
STATIC mp_obj_t mp_lv_anim_set_start_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_anim_t *a = mp_write_ptr_lv_anim_t(mp_args[0]);
    void *start_cb = mp_lv_callback(mp_args[1], &lv_anim_t_start_cb_callback, MP_QSTR_lv_anim_t_start_cb, &a->user_data);
    ((void (*)(lv_anim_t *, lv_anim_start_cb_t))lv_func_ptr)(a, start_cb);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_anim_set_start_cb_obj, 2, mp_lv_anim_set_start_cb, lv_anim_set_start_cb);
    

/*
 * Callback function lv_anim_t_get_value_cb
 * int32_t lv_anim_get_value_cb_t(struct _lv_anim_t *)
 */

STATIC int32_t lv_anim_t_get_value_cb_callback(struct _lv_anim_t * arg0)
{
    mp_obj_t mp_args[1];
    mp_args[0] = mp_read_ptr_lv_anim_t((void*)arg0);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    mp_obj_t callback_result = mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_anim_t_get_value_cb)) , 1, 0, mp_args);
    return (int32_t)mp_obj_get_int(callback_result);
}


/*
 * lvgl extension definition for:
 * inline static void lv_anim_set_get_value_cb(lv_anim_t *a, lv_anim_get_value_cb_t get_value_cb)
 */
 
STATIC mp_obj_t mp_lv_anim_set_get_value_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_anim_t *a = mp_write_ptr_lv_anim_t(mp_args[0]);
    void *get_value_cb = mp_lv_callback(mp_args[1], &lv_anim_t_get_value_cb_callback, MP_QSTR_lv_anim_t_get_value_cb, &a->user_data);
    ((void (*)(lv_anim_t *, lv_anim_get_value_cb_t))lv_func_ptr)(a, get_value_cb);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_anim_set_get_value_cb_obj, 2, mp_lv_anim_set_get_value_cb, lv_anim_set_get_value_cb);
    

/*
 * Callback function lv_anim_t_ready_cb
 * void lv_anim_ready_cb_t(struct _lv_anim_t *)
 */

STATIC void lv_anim_t_ready_cb_callback(struct _lv_anim_t * arg0)
{
    mp_obj_t mp_args[1];
    mp_args[0] = mp_read_ptr_lv_anim_t((void*)arg0);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_anim_t_ready_cb)) , 1, 0, mp_args);
    return;
}


/*
 * lvgl extension definition for:
 * inline static void lv_anim_set_ready_cb(lv_anim_t *a, lv_anim_ready_cb_t ready_cb)
 */
 
STATIC mp_obj_t mp_lv_anim_set_ready_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_anim_t *a = mp_write_ptr_lv_anim_t(mp_args[0]);
    void *ready_cb = mp_lv_callback(mp_args[1], &lv_anim_t_ready_cb_callback, MP_QSTR_lv_anim_t_ready_cb, &a->user_data);
    ((void (*)(lv_anim_t *, lv_anim_ready_cb_t))lv_func_ptr)(a, ready_cb);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_anim_set_ready_cb_obj, 2, mp_lv_anim_set_ready_cb, lv_anim_set_ready_cb);
    

/*
 * Callback function lv_anim_t_deleted_cb
 * void lv_anim_deleted_cb_t(struct _lv_anim_t *)
 */

STATIC void lv_anim_t_deleted_cb_callback(struct _lv_anim_t * arg0)
{
    mp_obj_t mp_args[1];
    mp_args[0] = mp_read_ptr_lv_anim_t((void*)arg0);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_anim_t_deleted_cb)) , 1, 0, mp_args);
    return;
}


/*
 * lvgl extension definition for:
 * inline static void lv_anim_set_deleted_cb(lv_anim_t *a, lv_anim_deleted_cb_t deleted_cb)
 */
 
STATIC mp_obj_t mp_lv_anim_set_deleted_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_anim_t *a = mp_write_ptr_lv_anim_t(mp_args[0]);
    void *deleted_cb = mp_lv_callback(mp_args[1], &lv_anim_t_deleted_cb_callback, MP_QSTR_lv_anim_t_deleted_cb, &a->user_data);
    ((void (*)(lv_anim_t *, lv_anim_deleted_cb_t))lv_func_ptr)(a, deleted_cb);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_anim_set_deleted_cb_obj, 2, mp_lv_anim_set_deleted_cb, lv_anim_set_deleted_cb);
    
/* Reusing lv_anim_set_time for lv_anim_set_playback_time */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_anim_set_playback_time_obj, 2, mp_lv_anim_set_time, lv_anim_set_playback_time);
    
/* Reusing lv_anim_set_time for lv_anim_set_playback_delay */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_anim_set_playback_delay_obj, 2, mp_lv_anim_set_time, lv_anim_set_playback_delay);
    

/*
 * lvgl extension definition for:
 * inline static void lv_anim_set_repeat_count(lv_anim_t *a, uint16_t cnt)
 */
 
STATIC mp_obj_t mp_lv_anim_set_repeat_count(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_anim_t *a = mp_write_ptr_lv_anim_t(mp_args[0]);
    uint16_t cnt = (uint16_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_anim_t *, uint16_t))lv_func_ptr)(a, cnt);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_anim_set_repeat_count_obj, 2, mp_lv_anim_set_repeat_count, lv_anim_set_repeat_count);
    
/* Reusing lv_anim_set_time for lv_anim_set_repeat_delay */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_anim_set_repeat_delay_obj, 2, mp_lv_anim_set_time, lv_anim_set_repeat_delay);
    

/*
 * lvgl extension definition for:
 * inline static void lv_anim_set_early_apply(lv_anim_t *a, bool en)
 */
 
STATIC mp_obj_t mp_lv_anim_set_early_apply(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_anim_t *a = mp_write_ptr_lv_anim_t(mp_args[0]);
    bool en = mp_obj_is_true(mp_args[1]);
    ((void (*)(lv_anim_t *, bool))lv_func_ptr)(a, en);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_anim_set_early_apply_obj, 2, mp_lv_anim_set_early_apply, lv_anim_set_early_apply);
    
/* Reusing lv_anim_set_var for lv_anim_set_user_data */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_anim_set_user_data_obj, 2, mp_lv_anim_set_var, lv_anim_set_user_data);
    

/*
 * lvgl extension definition for:
 * inline static uint32_t lv_anim_get_delay(lv_anim_t *a)
 */
 
STATIC mp_obj_t mp_lv_anim_get_delay(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_anim_t *a = mp_write_ptr_lv_anim_t(mp_args[0]);
    uint32_t _res = ((uint32_t (*)(lv_anim_t *))lv_func_ptr)(a);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_anim_get_delay_obj, 1, mp_lv_anim_get_delay, lv_anim_get_delay);
    

/*
 * lvgl extension definition for:
 * inline static void *lv_anim_get_user_data(lv_anim_t *a)
 */
 
STATIC mp_obj_t mp_lv_anim_get_user_data(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_anim_t *a = mp_write_ptr_lv_anim_t(mp_args[0]);
    void * _res = ((void *(*)(lv_anim_t *))lv_func_ptr)(a);
    return ptr_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_anim_get_user_data_obj, 1, mp_lv_anim_get_user_data, lv_anim_get_user_data);
    

/*
 * lvgl extension definition for:
 * inline static bool lv_anim_custom_del(lv_anim_t *a, lv_anim_custom_exec_cb_t exec_cb)
 */
 
STATIC mp_obj_t mp_lv_anim_custom_del(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_anim_t *a = mp_write_ptr_lv_anim_t(mp_args[0]);
    void *exec_cb = mp_lv_callback(mp_args[1], &lv_anim_t_exec_cb_callback, MP_QSTR_lv_anim_t_exec_cb, &a->user_data);
    bool _res = ((bool (*)(lv_anim_t *, lv_anim_custom_exec_cb_t))lv_func_ptr)(a, exec_cb);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_anim_custom_del_obj, 2, mp_lv_anim_custom_del, lv_anim_custom_del);
    

/*
 * lvgl extension definition for:
 * inline static lv_anim_t *lv_anim_custom_get(lv_anim_t *a, lv_anim_custom_exec_cb_t exec_cb)
 */
 
STATIC mp_obj_t mp_lv_anim_custom_get(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_anim_t *a = mp_write_ptr_lv_anim_t(mp_args[0]);
    void *exec_cb = mp_lv_callback(mp_args[1], &lv_anim_t_exec_cb_callback, MP_QSTR_lv_anim_t_exec_cb, &a->user_data);
    lv_anim_t * _res = ((lv_anim_t *(*)(lv_anim_t *, lv_anim_custom_exec_cb_t))lv_func_ptr)(a, exec_cb);
    return mp_read_ptr_lv_anim_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_anim_custom_get_obj, 2, mp_lv_anim_custom_get, lv_anim_custom_get);
    
/* Reusing lv_obj_del_anim_ready_cb for lv_anim_init */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_anim_init_obj, 1, mp_lv_obj_del_anim_ready_cb, lv_anim_init);
    

/*
 * lvgl extension definition for:
 * lv_anim_t *lv_anim_start(const lv_anim_t *a)
 */
 
STATIC mp_obj_t mp_lv_anim_start(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_anim_t *a = mp_write_ptr_lv_anim_t(mp_args[0]);
    lv_anim_t * _res = ((lv_anim_t *(*)(const lv_anim_t *))lv_func_ptr)(a);
    return mp_read_ptr_lv_anim_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_anim_start_obj, 1, mp_lv_anim_start, lv_anim_start);
    
/* Reusing lv_anim_get_delay for lv_anim_get_playtime */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_anim_get_playtime_obj, 1, mp_lv_anim_get_delay, lv_anim_get_playtime);
    

/*
 * lvgl extension definition for:
 * int32_t lv_anim_path_linear(const lv_anim_t *a)
 */
 
STATIC mp_obj_t mp_lv_anim_path_linear(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_anim_t *a = mp_write_ptr_lv_anim_t(mp_args[0]);
    int32_t _res = ((int32_t (*)(const lv_anim_t *))lv_func_ptr)(a);
    return mp_obj_new_int(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_anim_path_linear_obj, 1, mp_lv_anim_path_linear, lv_anim_path_linear);
    
/* Reusing lv_anim_path_linear for lv_anim_path_ease_in */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_anim_path_ease_in_obj, 1, mp_lv_anim_path_linear, lv_anim_path_ease_in);
    
/* Reusing lv_anim_path_linear for lv_anim_path_ease_out */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_anim_path_ease_out_obj, 1, mp_lv_anim_path_linear, lv_anim_path_ease_out);
    
/* Reusing lv_anim_path_linear for lv_anim_path_ease_in_out */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_anim_path_ease_in_out_obj, 1, mp_lv_anim_path_linear, lv_anim_path_ease_in_out);
    
/* Reusing lv_anim_path_linear for lv_anim_path_overshoot */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_anim_path_overshoot_obj, 1, mp_lv_anim_path_linear, lv_anim_path_overshoot);
    
/* Reusing lv_anim_path_linear for lv_anim_path_bounce */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_anim_path_bounce_obj, 1, mp_lv_anim_path_linear, lv_anim_path_bounce);
    
/* Reusing lv_anim_path_linear for lv_anim_path_step */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_anim_path_step_obj, 1, mp_lv_anim_path_linear, lv_anim_path_step);
    

STATIC const mp_rom_map_elem_t mp_lv_anim_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_anim_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_var), MP_ROM_PTR(&mp_lv_anim_set_var_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_exec_cb), MP_ROM_PTR(&mp_lv_anim_set_exec_cb_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_time), MP_ROM_PTR(&mp_lv_anim_set_time_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_delay), MP_ROM_PTR(&mp_lv_anim_set_delay_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_values), MP_ROM_PTR(&mp_lv_anim_set_values_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_custom_exec_cb), MP_ROM_PTR(&mp_lv_anim_set_custom_exec_cb_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_path_cb), MP_ROM_PTR(&mp_lv_anim_set_path_cb_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_start_cb), MP_ROM_PTR(&mp_lv_anim_set_start_cb_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_get_value_cb), MP_ROM_PTR(&mp_lv_anim_set_get_value_cb_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_ready_cb), MP_ROM_PTR(&mp_lv_anim_set_ready_cb_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_deleted_cb), MP_ROM_PTR(&mp_lv_anim_set_deleted_cb_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_playback_time), MP_ROM_PTR(&mp_lv_anim_set_playback_time_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_playback_delay), MP_ROM_PTR(&mp_lv_anim_set_playback_delay_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_repeat_count), MP_ROM_PTR(&mp_lv_anim_set_repeat_count_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_repeat_delay), MP_ROM_PTR(&mp_lv_anim_set_repeat_delay_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_early_apply), MP_ROM_PTR(&mp_lv_anim_set_early_apply_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_user_data), MP_ROM_PTR(&mp_lv_anim_set_user_data_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_delay), MP_ROM_PTR(&mp_lv_anim_get_delay_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_user_data), MP_ROM_PTR(&mp_lv_anim_get_user_data_obj) },
    { MP_ROM_QSTR(MP_QSTR_custom_del), MP_ROM_PTR(&mp_lv_anim_custom_del_obj) },
    { MP_ROM_QSTR(MP_QSTR_custom_get), MP_ROM_PTR(&mp_lv_anim_custom_get_obj) },
    { MP_ROM_QSTR(MP_QSTR_init), MP_ROM_PTR(&mp_lv_anim_init_obj) },
    { MP_ROM_QSTR(MP_QSTR_start), MP_ROM_PTR(&mp_lv_anim_start_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_playtime), MP_ROM_PTR(&mp_lv_anim_get_playtime_obj) },
    { MP_ROM_QSTR(MP_QSTR_path_linear), MP_ROM_PTR(&mp_lv_anim_path_linear_obj) },
    { MP_ROM_QSTR(MP_QSTR_path_ease_in), MP_ROM_PTR(&mp_lv_anim_path_ease_in_obj) },
    { MP_ROM_QSTR(MP_QSTR_path_ease_out), MP_ROM_PTR(&mp_lv_anim_path_ease_out_obj) },
    { MP_ROM_QSTR(MP_QSTR_path_ease_in_out), MP_ROM_PTR(&mp_lv_anim_path_ease_in_out_obj) },
    { MP_ROM_QSTR(MP_QSTR_path_overshoot), MP_ROM_PTR(&mp_lv_anim_path_overshoot_obj) },
    { MP_ROM_QSTR(MP_QSTR_path_bounce), MP_ROM_PTR(&mp_lv_anim_path_bounce_obj) },
    { MP_ROM_QSTR(MP_QSTR_path_step), MP_ROM_PTR(&mp_lv_anim_path_step_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_anim_t_locals_dict, mp_lv_anim_t_locals_dict_table);
        

/*
 * Array convertors for lv_style_prop_t []
 */

STATIC const lv_style_prop_t *mp_arr_to_lv_style_prop_t_____(mp_obj_t mp_arr)
{
    mp_obj_t mp_len = mp_obj_len_maybe(mp_arr);
    if (mp_len == MP_OBJ_NULL) return mp_to_ptr(mp_arr);
    mp_int_t len = mp_obj_get_int(mp_len);
    
    lv_style_prop_t *lv_arr = (lv_style_prop_t*)m_malloc(len * sizeof(lv_style_prop_t));
    mp_obj_t iter = mp_getiter(mp_arr, NULL);
    mp_obj_t item;
    size_t i = 0;
    while ((item = mp_iternext(iter)) != MP_OBJ_STOP_ITERATION) {
        lv_arr[i++] = (int)mp_obj_get_int(item);
    }
    return (const lv_style_prop_t *)lv_arr;
}
    
STATIC mp_obj_t mp_arr_from_lv_style_prop_t_____(const lv_style_prop_t *arr)
{
    mp_obj_t obj_arr[1];
    for (size_t i=0; i<1; i++){
        obj_arr[i] = mp_obj_new_int(arr[i]);
    }
    return mp_obj_new_list(1, obj_arr); // TODO: return custom iterable object!
}
    

/*
 * Callback function path_cb
 * int32_t lv_anim_path_cb_t(const struct _lv_anim_t *)
 */

STATIC int32_t path_cb_callback(const struct _lv_anim_t * arg0)
{
    mp_obj_t mp_args[1];
    mp_args[0] = mp_read_ptr_lv_anim_t((void*)arg0);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    mp_obj_t callback_result = mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_path_cb)) , 1, 0, mp_args);
    return (int32_t)mp_obj_get_int(callback_result);
}


/*
 * lvgl extension definition for:
 * void lv_style_transition_dsc_init(lv_style_transition_dsc_t *tr, const lv_style_prop_t props[], lv_anim_path_cb_t path_cb, uint32_t time, uint32_t delay, void *user_data)
 */
 
STATIC mp_obj_t mp_lv_style_transition_dsc_init(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    void *user_data = mp_to_ptr(mp_args[5]);
    const lv_style_prop_t *props = mp_arr_to_lv_style_prop_t_____(mp_args[1]);
    void *path_cb = mp_lv_callback(mp_args[2], &path_cb_callback, MP_QSTR_path_cb, &user_data);
    uint32_t time = (uint32_t)mp_obj_get_int(mp_args[3]);
    uint32_t delay = (uint32_t)mp_obj_get_int(mp_args[4]);
    lv_style_transition_dsc_t *tr = mp_write_ptr_lv_style_transition_dsc_t(mp_args[0]);
    ((void (*)(lv_style_transition_dsc_t *, const lv_style_prop_t [], lv_anim_path_cb_t, uint32_t, uint32_t, void *))lv_func_ptr)(tr, props, path_cb, time, delay, user_data);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_transition_dsc_init_obj, 6, mp_lv_style_transition_dsc_init, lv_style_transition_dsc_init);
    

STATIC const mp_rom_map_elem_t mp_lv_style_transition_dsc_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_style_transition_dsc_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    { MP_ROM_QSTR(MP_QSTR_init), MP_ROM_PTR(&mp_lv_style_transition_dsc_init_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_style_transition_dsc_t_locals_dict, mp_lv_style_transition_dsc_t_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * inline static void lv_area_copy(lv_area_t *dest, const lv_area_t *src)
 */
 
STATIC mp_obj_t mp_lv_area_copy(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_area_t *dest = mp_write_ptr_lv_area_t(mp_args[0]);
    const lv_area_t *src = mp_write_ptr_lv_area_t(mp_args[1]);
    ((void (*)(lv_area_t *, const lv_area_t *))lv_func_ptr)(dest, src);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_area_copy_obj, 2, mp_lv_area_copy, lv_area_copy);
    

/*
 * lvgl extension definition for:
 * inline static lv_coord_t lv_area_get_width(const lv_area_t *area_p)
 */
 
STATIC mp_obj_t mp_lv_area_get_width(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_area_t *area_p = mp_write_ptr_lv_area_t(mp_args[0]);
    lv_coord_t _res = ((lv_coord_t (*)(const lv_area_t *))lv_func_ptr)(area_p);
    return mp_obj_new_int(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_area_get_width_obj, 1, mp_lv_area_get_width, lv_area_get_width);
    
/* Reusing lv_area_get_width for lv_area_get_height */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_area_get_height_obj, 1, mp_lv_area_get_width, lv_area_get_height);
    

/*
 * lvgl extension definition for:
 * void lv_area_set(lv_area_t *area_p, lv_coord_t x1, lv_coord_t y1, lv_coord_t x2, lv_coord_t y2)
 */
 
STATIC mp_obj_t mp_lv_area_set(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_area_t *area_p = mp_write_ptr_lv_area_t(mp_args[0]);
    lv_coord_t x1 = (int16_t)mp_obj_get_int(mp_args[1]);
    lv_coord_t y1 = (int16_t)mp_obj_get_int(mp_args[2]);
    lv_coord_t x2 = (int16_t)mp_obj_get_int(mp_args[3]);
    lv_coord_t y2 = (int16_t)mp_obj_get_int(mp_args[4]);
    ((void (*)(lv_area_t *, lv_coord_t, lv_coord_t, lv_coord_t, lv_coord_t))lv_func_ptr)(area_p, x1, y1, x2, y2);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_area_set_obj, 5, mp_lv_area_set, lv_area_set);
    

/*
 * lvgl extension definition for:
 * void lv_area_set_width(lv_area_t *area_p, lv_coord_t w)
 */
 
STATIC mp_obj_t mp_lv_area_set_width(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_area_t *area_p = mp_write_ptr_lv_area_t(mp_args[0]);
    lv_coord_t w = (int16_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_area_t *, lv_coord_t))lv_func_ptr)(area_p, w);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_area_set_width_obj, 2, mp_lv_area_set_width, lv_area_set_width);
    
/* Reusing lv_area_set_width for lv_area_set_height */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_area_set_height_obj, 2, mp_lv_area_set_width, lv_area_set_height);
    

/*
 * lvgl extension definition for:
 * uint32_t lv_area_get_size(const lv_area_t *area_p)
 */
 
STATIC mp_obj_t mp_lv_area_get_size(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_area_t *area_p = mp_write_ptr_lv_area_t(mp_args[0]);
    uint32_t _res = ((uint32_t (*)(const lv_area_t *))lv_func_ptr)(area_p);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_area_get_size_obj, 1, mp_lv_area_get_size, lv_area_get_size);
    

/*
 * lvgl extension definition for:
 * void lv_area_increase(lv_area_t *area, lv_coord_t w_extra, lv_coord_t h_extra)
 */
 
STATIC mp_obj_t mp_lv_area_increase(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_area_t *area = mp_write_ptr_lv_area_t(mp_args[0]);
    lv_coord_t w_extra = (int16_t)mp_obj_get_int(mp_args[1]);
    lv_coord_t h_extra = (int16_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_area_t *, lv_coord_t, lv_coord_t))lv_func_ptr)(area, w_extra, h_extra);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_area_increase_obj, 3, mp_lv_area_increase, lv_area_increase);
    
/* Reusing lv_area_increase for lv_area_move */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_area_move_obj, 3, mp_lv_area_increase, lv_area_move);
    

/*
 * lvgl extension definition for:
 * void lv_area_align(const lv_area_t *base, lv_area_t *to_align, lv_align_t align, lv_coord_t ofs_x, lv_coord_t ofs_y)
 */
 
STATIC mp_obj_t mp_lv_area_align(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_area_t *base = mp_write_ptr_lv_area_t(mp_args[0]);
    lv_area_t *to_align = mp_write_ptr_lv_area_t(mp_args[1]);
    lv_align_t align = (uint8_t)mp_obj_get_int(mp_args[2]);
    lv_coord_t ofs_x = (int16_t)mp_obj_get_int(mp_args[3]);
    lv_coord_t ofs_y = (int16_t)mp_obj_get_int(mp_args[4]);
    ((void (*)(const lv_area_t *, lv_area_t *, lv_align_t, lv_coord_t, lv_coord_t))lv_func_ptr)(base, to_align, align, ofs_x, ofs_y);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_area_align_obj, 5, mp_lv_area_align, lv_area_align);
    

STATIC const mp_rom_map_elem_t mp_lv_area_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_area_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    { MP_ROM_QSTR(MP_QSTR_copy), MP_ROM_PTR(&mp_lv_area_copy_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_width), MP_ROM_PTR(&mp_lv_area_get_width_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_height), MP_ROM_PTR(&mp_lv_area_get_height_obj) },
    { MP_ROM_QSTR(MP_QSTR_set), MP_ROM_PTR(&mp_lv_area_set_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_width), MP_ROM_PTR(&mp_lv_area_set_width_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_height), MP_ROM_PTR(&mp_lv_area_set_height_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_size), MP_ROM_PTR(&mp_lv_area_get_size_obj) },
    { MP_ROM_QSTR(MP_QSTR_increase), MP_ROM_PTR(&mp_lv_area_increase_obj) },
    { MP_ROM_QSTR(MP_QSTR_move), MP_ROM_PTR(&mp_lv_area_move_obj) },
    { MP_ROM_QSTR(MP_QSTR_align), MP_ROM_PTR(&mp_lv_area_align_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_area_t_locals_dict, mp_lv_area_t_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * void lv_point_transform(lv_point_t *p, int32_t angle, int32_t zoom, const lv_point_t *pivot)
 */
 
STATIC mp_obj_t mp_lv_point_transform(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_point_t *p = mp_write_ptr_lv_point_t(mp_args[0]);
    int32_t angle = (int32_t)mp_obj_get_int(mp_args[1]);
    int32_t zoom = (int32_t)mp_obj_get_int(mp_args[2]);
    const lv_point_t *pivot = mp_write_ptr_lv_point_t(mp_args[3]);
    ((void (*)(lv_point_t *, int32_t, int32_t, const lv_point_t *))lv_func_ptr)(p, angle, zoom, pivot);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_point_transform_obj, 4, mp_lv_point_transform, lv_point_transform);
    

STATIC const mp_rom_map_elem_t mp_lv_point_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_point_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    { MP_ROM_QSTR(MP_QSTR_transform), MP_ROM_PTR(&mp_lv_point_transform_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_point_t_locals_dict, mp_lv_point_t_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * inline static lv_coord_t lv_disp_dpx(const lv_disp_t *disp, lv_coord_t n)
 */
 
STATIC mp_obj_t mp_lv_disp_dpx(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_disp_t *disp = mp_write_ptr_lv_disp_t(mp_args[0]);
    lv_coord_t n = (int16_t)mp_obj_get_int(mp_args[1]);
    lv_coord_t _res = ((lv_coord_t (*)(const lv_disp_t *, lv_coord_t))lv_func_ptr)(disp, n);
    return mp_obj_new_int(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_disp_dpx_obj, 2, mp_lv_disp_dpx, lv_disp_dpx);
    

/*
 * lvgl extension definition for:
 * void lv_disp_drv_update(lv_disp_t *disp, lv_disp_drv_t *new_drv)
 */
 
STATIC mp_obj_t mp_lv_disp_drv_update(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_disp_t *disp = mp_write_ptr_lv_disp_t(mp_args[0]);
    lv_disp_drv_t *new_drv = mp_write_ptr_lv_disp_drv_t(mp_args[1]);
    ((void (*)(lv_disp_t *, lv_disp_drv_t *))lv_func_ptr)(disp, new_drv);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_disp_drv_update_obj, 2, mp_lv_disp_drv_update, lv_disp_drv_update);
    

/*
 * lvgl extension definition for:
 * void lv_disp_remove(lv_disp_t *disp)
 */
 
STATIC mp_obj_t mp_lv_disp_remove(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_disp_t *disp = mp_write_ptr_lv_disp_t(mp_args[0]);
    ((void (*)(lv_disp_t *))lv_func_ptr)(disp);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_disp_remove_obj, 1, mp_lv_disp_remove, lv_disp_remove);
    
/* Reusing lv_disp_remove for lv_disp_set_default */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_disp_set_default_obj, 1, mp_lv_disp_remove, lv_disp_set_default);
    

/*
 * lvgl extension definition for:
 * lv_coord_t lv_disp_get_hor_res(lv_disp_t *disp)
 */
 
STATIC mp_obj_t mp_lv_disp_get_hor_res(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_disp_t *disp = mp_write_ptr_lv_disp_t(mp_args[0]);
    lv_coord_t _res = ((lv_coord_t (*)(lv_disp_t *))lv_func_ptr)(disp);
    return mp_obj_new_int(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_disp_get_hor_res_obj, 1, mp_lv_disp_get_hor_res, lv_disp_get_hor_res);
    
/* Reusing lv_disp_get_hor_res for lv_disp_get_ver_res */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_disp_get_ver_res_obj, 1, mp_lv_disp_get_hor_res, lv_disp_get_ver_res);
    
/* Reusing lv_disp_get_hor_res for lv_disp_get_physical_hor_res */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_disp_get_physical_hor_res_obj, 1, mp_lv_disp_get_hor_res, lv_disp_get_physical_hor_res);
    
/* Reusing lv_disp_get_hor_res for lv_disp_get_physical_ver_res */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_disp_get_physical_ver_res_obj, 1, mp_lv_disp_get_hor_res, lv_disp_get_physical_ver_res);
    
/* Reusing lv_disp_get_hor_res for lv_disp_get_offset_x */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_disp_get_offset_x_obj, 1, mp_lv_disp_get_hor_res, lv_disp_get_offset_x);
    
/* Reusing lv_disp_get_hor_res for lv_disp_get_offset_y */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_disp_get_offset_y_obj, 1, mp_lv_disp_get_hor_res, lv_disp_get_offset_y);
    

/*
 * lvgl extension definition for:
 * bool lv_disp_get_antialiasing(lv_disp_t *disp)
 */
 
STATIC mp_obj_t mp_lv_disp_get_antialiasing(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_disp_t *disp = mp_write_ptr_lv_disp_t(mp_args[0]);
    bool _res = ((bool (*)(lv_disp_t *))lv_func_ptr)(disp);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_disp_get_antialiasing_obj, 1, mp_lv_disp_get_antialiasing, lv_disp_get_antialiasing);
    

/*
 * lvgl extension definition for:
 * lv_coord_t lv_disp_get_dpi(const lv_disp_t *disp)
 */
 
STATIC mp_obj_t mp_lv_disp_get_dpi(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_disp_t *disp = mp_write_ptr_lv_disp_t(mp_args[0]);
    lv_coord_t _res = ((lv_coord_t (*)(const lv_disp_t *))lv_func_ptr)(disp);
    return mp_obj_new_int(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_disp_get_dpi_obj, 1, mp_lv_disp_get_dpi, lv_disp_get_dpi);
    

/*
 * lvgl extension definition for:
 * void lv_disp_set_rotation(lv_disp_t *disp, lv_disp_rot_t rotation)
 */
 
STATIC mp_obj_t mp_lv_disp_set_rotation(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_disp_t *disp = mp_write_ptr_lv_disp_t(mp_args[0]);
    lv_disp_rot_t rotation = (int)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_disp_t *, lv_disp_rot_t))lv_func_ptr)(disp, rotation);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_disp_set_rotation_obj, 2, mp_lv_disp_set_rotation, lv_disp_set_rotation);
    

/*
 * lvgl extension definition for:
 * lv_disp_rot_t lv_disp_get_rotation(lv_disp_t *disp)
 */
 
STATIC mp_obj_t mp_lv_disp_get_rotation(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_disp_t *disp = mp_write_ptr_lv_disp_t(mp_args[0]);
    lv_disp_rot_t _res = ((lv_disp_rot_t (*)(lv_disp_t *))lv_func_ptr)(disp);
    return mp_obj_new_int(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_disp_get_rotation_obj, 1, mp_lv_disp_get_rotation, lv_disp_get_rotation);
    

/*
 * lvgl extension definition for:
 * lv_disp_t *lv_disp_get_next(lv_disp_t *disp)
 */
 
STATIC mp_obj_t mp_lv_disp_get_next(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_disp_t *disp = mp_write_ptr_lv_disp_t(mp_args[0]);
    lv_disp_t * _res = ((lv_disp_t *(*)(lv_disp_t *))lv_func_ptr)(disp);
    return mp_read_ptr_lv_disp_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_disp_get_next_obj, 1, mp_lv_disp_get_next, lv_disp_get_next);
    

/*
 * lvgl extension definition for:
 * lv_disp_draw_buf_t *lv_disp_get_draw_buf(lv_disp_t *disp)
 */
 
STATIC mp_obj_t mp_lv_disp_get_draw_buf(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_disp_t *disp = mp_write_ptr_lv_disp_t(mp_args[0]);
    lv_disp_draw_buf_t * _res = ((lv_disp_draw_buf_t *(*)(lv_disp_t *))lv_func_ptr)(disp);
    return mp_read_ptr_lv_disp_draw_buf_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_disp_get_draw_buf_obj, 1, mp_lv_disp_get_draw_buf, lv_disp_get_draw_buf);
    

/*
 * lvgl extension definition for:
 * lv_obj_t *lv_disp_get_scr_act(lv_disp_t *disp)
 */
 
STATIC mp_obj_t mp_lv_disp_get_scr_act(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_disp_t *disp = mp_write_ptr_lv_disp_t(mp_args[0]);
    lv_obj_t * _res = ((lv_obj_t *(*)(lv_disp_t *))lv_func_ptr)(disp);
    return lv_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_disp_get_scr_act_obj, 1, mp_lv_disp_get_scr_act, lv_disp_get_scr_act);
    
/* Reusing lv_disp_get_scr_act for lv_disp_get_scr_prev */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_disp_get_scr_prev_obj, 1, mp_lv_disp_get_scr_act, lv_disp_get_scr_prev);
    
/* Reusing lv_disp_get_scr_act for lv_disp_get_layer_top */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_disp_get_layer_top_obj, 1, mp_lv_disp_get_scr_act, lv_disp_get_layer_top);
    
/* Reusing lv_disp_get_scr_act for lv_disp_get_layer_sys */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_disp_get_layer_sys_obj, 1, mp_lv_disp_get_scr_act, lv_disp_get_layer_sys);
    

/*
 * lvgl extension definition for:
 * void lv_disp_set_theme(lv_disp_t *disp, lv_theme_t *th)
 */
 
STATIC mp_obj_t mp_lv_disp_set_theme(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_disp_t *disp = mp_write_ptr_lv_disp_t(mp_args[0]);
    lv_theme_t *th = mp_write_ptr_lv_theme_t(mp_args[1]);
    ((void (*)(lv_disp_t *, lv_theme_t *))lv_func_ptr)(disp, th);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_disp_set_theme_obj, 2, mp_lv_disp_set_theme, lv_disp_set_theme);
    

/*
 * lvgl extension definition for:
 * lv_theme_t *lv_disp_get_theme(lv_disp_t *disp)
 */
 
STATIC mp_obj_t mp_lv_disp_get_theme(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_disp_t *disp = mp_write_ptr_lv_disp_t(mp_args[0]);
    lv_theme_t * _res = ((lv_theme_t *(*)(lv_disp_t *))lv_func_ptr)(disp);
    return mp_read_ptr_lv_theme_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_disp_get_theme_obj, 1, mp_lv_disp_get_theme, lv_disp_get_theme);
    

/*
 * lvgl extension definition for:
 * void lv_disp_set_bg_color(lv_disp_t *disp, lv_color_t color)
 */
 
STATIC mp_obj_t mp_lv_disp_set_bg_color(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_disp_t *disp = mp_write_ptr_lv_disp_t(mp_args[0]);
    lv_color_t color = mp_write_lv_color16_t(mp_args[1]);
    ((void (*)(lv_disp_t *, lv_color_t))lv_func_ptr)(disp, color);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_disp_set_bg_color_obj, 2, mp_lv_disp_set_bg_color, lv_disp_set_bg_color);
    

/*
 * lvgl extension definition for:
 * void lv_disp_set_bg_image(lv_disp_t *disp, const void *img_src)
 */
 
STATIC mp_obj_t mp_lv_disp_set_bg_image(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_disp_t *disp = mp_write_ptr_lv_disp_t(mp_args[0]);
    const void *img_src = mp_to_ptr(mp_args[1]);
    ((void (*)(lv_disp_t *, const void *))lv_func_ptr)(disp, img_src);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_disp_set_bg_image_obj, 2, mp_lv_disp_set_bg_image, lv_disp_set_bg_image);
    

/*
 * lvgl extension definition for:
 * void lv_disp_set_bg_opa(lv_disp_t *disp, lv_opa_t opa)
 */
 
STATIC mp_obj_t mp_lv_disp_set_bg_opa(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_disp_t *disp = mp_write_ptr_lv_disp_t(mp_args[0]);
    lv_opa_t opa = (uint8_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_disp_t *, lv_opa_t))lv_func_ptr)(disp, opa);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_disp_set_bg_opa_obj, 2, mp_lv_disp_set_bg_opa, lv_disp_set_bg_opa);
    

/*
 * lvgl extension definition for:
 * uint32_t lv_disp_get_inactive_time(const lv_disp_t *disp)
 */
 
STATIC mp_obj_t mp_lv_disp_get_inactive_time(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_disp_t *disp = mp_write_ptr_lv_disp_t(mp_args[0]);
    uint32_t _res = ((uint32_t (*)(const lv_disp_t *))lv_func_ptr)(disp);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_disp_get_inactive_time_obj, 1, mp_lv_disp_get_inactive_time, lv_disp_get_inactive_time);
    
/* Reusing lv_disp_remove for lv_disp_trig_activity */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_disp_trig_activity_obj, 1, mp_lv_disp_remove, lv_disp_trig_activity);
    
/* Reusing lv_disp_remove for lv_disp_clean_dcache */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_disp_clean_dcache_obj, 1, mp_lv_disp_remove, lv_disp_clean_dcache);
    

/*
 * lvgl extension definition for:
 * void lv_disp_enable_invalidation(lv_disp_t *disp, bool en)
 */
 
STATIC mp_obj_t mp_lv_disp_enable_invalidation(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_disp_t *disp = mp_write_ptr_lv_disp_t(mp_args[0]);
    bool en = mp_obj_is_true(mp_args[1]);
    ((void (*)(lv_disp_t *, bool))lv_func_ptr)(disp, en);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_disp_enable_invalidation_obj, 2, mp_lv_disp_enable_invalidation, lv_disp_enable_invalidation);
    
/* Reusing lv_disp_get_antialiasing for lv_disp_is_invalidation_enabled */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_disp_is_invalidation_enabled_obj, 1, mp_lv_disp_get_antialiasing, lv_disp_is_invalidation_enabled);
    

STATIC const mp_rom_map_elem_t mp_lv_disp_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_disp_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    { MP_ROM_QSTR(MP_QSTR_dpx), MP_ROM_PTR(&mp_lv_disp_dpx_obj) },
    { MP_ROM_QSTR(MP_QSTR_drv_update), MP_ROM_PTR(&mp_lv_disp_drv_update_obj) },
    { MP_ROM_QSTR(MP_QSTR_remove), MP_ROM_PTR(&mp_lv_disp_remove_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_default), MP_ROM_PTR(&mp_lv_disp_set_default_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_hor_res), MP_ROM_PTR(&mp_lv_disp_get_hor_res_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_ver_res), MP_ROM_PTR(&mp_lv_disp_get_ver_res_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_physical_hor_res), MP_ROM_PTR(&mp_lv_disp_get_physical_hor_res_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_physical_ver_res), MP_ROM_PTR(&mp_lv_disp_get_physical_ver_res_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_offset_x), MP_ROM_PTR(&mp_lv_disp_get_offset_x_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_offset_y), MP_ROM_PTR(&mp_lv_disp_get_offset_y_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_antialiasing), MP_ROM_PTR(&mp_lv_disp_get_antialiasing_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_dpi), MP_ROM_PTR(&mp_lv_disp_get_dpi_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_rotation), MP_ROM_PTR(&mp_lv_disp_set_rotation_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_rotation), MP_ROM_PTR(&mp_lv_disp_get_rotation_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_next), MP_ROM_PTR(&mp_lv_disp_get_next_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_draw_buf), MP_ROM_PTR(&mp_lv_disp_get_draw_buf_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_scr_act), MP_ROM_PTR(&mp_lv_disp_get_scr_act_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_scr_prev), MP_ROM_PTR(&mp_lv_disp_get_scr_prev_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_layer_top), MP_ROM_PTR(&mp_lv_disp_get_layer_top_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_layer_sys), MP_ROM_PTR(&mp_lv_disp_get_layer_sys_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_theme), MP_ROM_PTR(&mp_lv_disp_set_theme_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_theme), MP_ROM_PTR(&mp_lv_disp_get_theme_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_bg_color), MP_ROM_PTR(&mp_lv_disp_set_bg_color_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_bg_image), MP_ROM_PTR(&mp_lv_disp_set_bg_image_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_bg_opa), MP_ROM_PTR(&mp_lv_disp_set_bg_opa_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_inactive_time), MP_ROM_PTR(&mp_lv_disp_get_inactive_time_obj) },
    { MP_ROM_QSTR(MP_QSTR_trig_activity), MP_ROM_PTR(&mp_lv_disp_trig_activity_obj) },
    { MP_ROM_QSTR(MP_QSTR_clean_dcache), MP_ROM_PTR(&mp_lv_disp_clean_dcache_obj) },
    { MP_ROM_QSTR(MP_QSTR_enable_invalidation), MP_ROM_PTR(&mp_lv_disp_enable_invalidation_obj) },
    { MP_ROM_QSTR(MP_QSTR_is_invalidation_enabled), MP_ROM_PTR(&mp_lv_disp_is_invalidation_enabled_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_disp_t_locals_dict, mp_lv_disp_t_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * void lv_disp_drv_init(lv_disp_drv_t *driver)
 */
 
STATIC mp_obj_t mp_lv_disp_drv_init(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_disp_drv_t *driver = mp_write_ptr_lv_disp_drv_t(mp_args[0]);
    ((void (*)(lv_disp_drv_t *))lv_func_ptr)(driver);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_disp_drv_init_obj, 1, mp_lv_disp_drv_init, lv_disp_drv_init);
    

/*
 * lvgl extension definition for:
 * lv_disp_t *lv_disp_drv_register(lv_disp_drv_t *driver)
 */
 
STATIC mp_obj_t mp_lv_disp_drv_register(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_disp_drv_t *driver = mp_write_ptr_lv_disp_drv_t(mp_args[0]);
    lv_disp_t * _res = ((lv_disp_t *(*)(lv_disp_drv_t *))lv_func_ptr)(driver);
    return mp_read_ptr_lv_disp_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_disp_drv_register_obj, 1, mp_lv_disp_drv_register, lv_disp_drv_register);
    
/* Reusing lv_disp_drv_init for lv_disp_flush_ready */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_disp_flush_ready_obj, 1, mp_lv_disp_drv_init, lv_disp_flush_ready);
    

/*
 * lvgl extension definition for:
 * bool lv_disp_flush_is_last(lv_disp_drv_t *disp_drv)
 */
 
STATIC mp_obj_t mp_lv_disp_flush_is_last(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_disp_drv_t *disp_drv = mp_write_ptr_lv_disp_drv_t(mp_args[0]);
    bool _res = ((bool (*)(lv_disp_drv_t *))lv_func_ptr)(disp_drv);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_disp_flush_is_last_obj, 1, mp_lv_disp_flush_is_last, lv_disp_flush_is_last);
    

/*
 * lvgl extension definition for:
 * void lv_disp_drv_use_generic_set_px_cb(lv_disp_drv_t *disp_drv, lv_img_cf_t cf)
 */
 
STATIC mp_obj_t mp_lv_disp_drv_use_generic_set_px_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_disp_drv_t *disp_drv = mp_write_ptr_lv_disp_drv_t(mp_args[0]);
    lv_img_cf_t cf = (uint8_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_disp_drv_t *, lv_img_cf_t))lv_func_ptr)(disp_drv, cf);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_disp_drv_use_generic_set_px_cb_obj, 2, mp_lv_disp_drv_use_generic_set_px_cb, lv_disp_drv_use_generic_set_px_cb);
    

STATIC const mp_rom_map_elem_t mp_lv_disp_drv_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_disp_drv_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    { MP_ROM_QSTR(MP_QSTR_init), MP_ROM_PTR(&mp_lv_disp_drv_init_obj) },
    { MP_ROM_QSTR(MP_QSTR_register), MP_ROM_PTR(&mp_lv_disp_drv_register_obj) },
    { MP_ROM_QSTR(MP_QSTR_flush_ready), MP_ROM_PTR(&mp_lv_disp_flush_ready_obj) },
    { MP_ROM_QSTR(MP_QSTR_flush_is_last), MP_ROM_PTR(&mp_lv_disp_flush_is_last_obj) },
    { MP_ROM_QSTR(MP_QSTR_use_generic_set_px_cb), MP_ROM_PTR(&mp_lv_disp_drv_use_generic_set_px_cb_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_disp_drv_t_locals_dict, mp_lv_disp_drv_t_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * void lv_disp_draw_buf_init(lv_disp_draw_buf_t *draw_buf, void *buf1, void *buf2, uint32_t size_in_px_cnt)
 */
 
STATIC mp_obj_t mp_lv_disp_draw_buf_init(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_disp_draw_buf_t *draw_buf = mp_write_ptr_lv_disp_draw_buf_t(mp_args[0]);
    void *buf1 = mp_to_ptr(mp_args[1]);
    void *buf2 = mp_to_ptr(mp_args[2]);
    uint32_t size_in_px_cnt = (uint32_t)mp_obj_get_int(mp_args[3]);
    ((void (*)(lv_disp_draw_buf_t *, void *, void *, uint32_t))lv_func_ptr)(draw_buf, buf1, buf2, size_in_px_cnt);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_disp_draw_buf_init_obj, 4, mp_lv_disp_draw_buf_init, lv_disp_draw_buf_init);
    

STATIC const mp_rom_map_elem_t mp_lv_disp_draw_buf_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_disp_draw_buf_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    { MP_ROM_QSTR(MP_QSTR_init), MP_ROM_PTR(&mp_lv_disp_draw_buf_init_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_disp_draw_buf_t_locals_dict, mp_lv_disp_draw_buf_t_locals_dict_table);
        
/* Reusing funcptr_draw_rect for lv_draw_rect */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_draw_rect_obj, 3, mp_funcptr_draw_rect, lv_draw_rect);
    

/*
 * Struct lv_draw_label_hint_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_draw_label_hint_t_type();

STATIC inline lv_draw_label_hint_t* mp_write_ptr_lv_draw_label_hint_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_draw_label_hint_t_type()));
    return (lv_draw_label_hint_t*)self->data;
}

#define mp_write_lv_draw_label_hint_t(struct_obj) *mp_write_ptr_lv_draw_label_hint_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_draw_label_hint_t(lv_draw_label_hint_t *field)
{
    return lv_to_mp_struct(get_mp_lv_draw_label_hint_t_type(), (void*)field);
}

#define mp_read_lv_draw_label_hint_t(field) mp_read_ptr_lv_draw_label_hint_t(copy_buffer(&field, sizeof(lv_draw_label_hint_t)))
#define mp_read_byref_lv_draw_label_hint_t(field) mp_read_ptr_lv_draw_label_hint_t(&field)

STATIC void mp_lv_draw_label_hint_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_draw_label_hint_t *data = (lv_draw_label_hint_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_line_start: dest[0] = mp_obj_new_int(data->line_start); break; // converting from int32_t;
            case MP_QSTR_y: dest[0] = mp_obj_new_int(data->y); break; // converting from int32_t;
            case MP_QSTR_coord_y: dest[0] = mp_obj_new_int(data->coord_y); break; // converting from int32_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_line_start: data->line_start = (int32_t)mp_obj_get_int(dest[1]); break; // converting to int32_t;
                case MP_QSTR_y: data->y = (int32_t)mp_obj_get_int(dest[1]); break; // converting to int32_t;
                case MP_QSTR_coord_y: data->coord_y = (int32_t)mp_obj_get_int(dest[1]); break; // converting to int32_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_draw_label_hint_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_draw_label_hint_t");
}

STATIC const mp_obj_dict_t mp_lv_draw_label_hint_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_draw_label_hint_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_draw_label_hint_t,
    .print = mp_lv_draw_label_hint_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_draw_label_hint_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_draw_label_hint_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_draw_label_hint_t_type()
{
    return &mp_lv_draw_label_hint_t_type;
}
    

/*
 * lvgl extension definition for:
 * void lv_draw_label(struct _lv_draw_ctx_t *draw_ctx, const lv_draw_label_dsc_t *dsc, const lv_area_t *coords, const char *txt, lv_draw_label_hint_t *hint)
 */
 
STATIC mp_obj_t mp_lv_draw_label(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_draw_ctx_t *draw_ctx = mp_write_ptr_lv_draw_ctx_t(mp_args[0]);
    const lv_draw_label_dsc_t *dsc = mp_write_ptr_lv_draw_label_dsc_t(mp_args[1]);
    const lv_area_t *coords = mp_write_ptr_lv_area_t(mp_args[2]);
    const char *txt = (char*)convert_from_str(mp_args[3]);
    lv_draw_label_hint_t *hint = mp_write_ptr_lv_draw_label_hint_t(mp_args[4]);
    ((void (*)(struct _lv_draw_ctx_t *, const lv_draw_label_dsc_t *, const lv_area_t *, const char *, lv_draw_label_hint_t *))lv_func_ptr)(draw_ctx, dsc, coords, txt, hint);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_draw_label_obj, 5, mp_lv_draw_label, lv_draw_label);
    
/* Reusing funcptr_draw_letter for lv_draw_letter */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_draw_letter_obj, 4, mp_funcptr_draw_letter, lv_draw_letter);
    

/*
 * lvgl extension definition for:
 * void lv_draw_img(struct _lv_draw_ctx_t *draw_ctx, const lv_draw_img_dsc_t *dsc, const lv_area_t *coords, const void *src)
 */
 
STATIC mp_obj_t mp_lv_draw_img(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_draw_ctx_t *draw_ctx = mp_write_ptr_lv_draw_ctx_t(mp_args[0]);
    const lv_draw_img_dsc_t *dsc = mp_write_ptr_lv_draw_img_dsc_t(mp_args[1]);
    const lv_area_t *coords = mp_write_ptr_lv_area_t(mp_args[2]);
    const void *src = mp_to_ptr(mp_args[3]);
    ((void (*)(struct _lv_draw_ctx_t *, const lv_draw_img_dsc_t *, const lv_area_t *, const void *))lv_func_ptr)(draw_ctx, dsc, coords, src);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_draw_img_obj, 4, mp_lv_draw_img, lv_draw_img);
    
/* Reusing funcptr_draw_img_decoded for lv_draw_img_decoded */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_draw_img_decoded_obj, 5, mp_funcptr_draw_img_decoded, lv_draw_img_decoded);
    
/* Reusing funcptr_draw_line for lv_draw_line */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_draw_line_obj, 4, mp_funcptr_draw_line, lv_draw_line);
    

/*
 * lvgl extension definition for:
 * void lv_draw_polygon(struct _lv_draw_ctx_t *draw_ctx, const lv_draw_rect_dsc_t *draw_dsc, const lv_point_t points[], uint16_t point_cnt)
 */
 
STATIC mp_obj_t mp_lv_draw_polygon(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_draw_ctx_t *draw_ctx = mp_write_ptr_lv_draw_ctx_t(mp_args[0]);
    const lv_draw_rect_dsc_t *draw_dsc = mp_write_ptr_lv_draw_rect_dsc_t(mp_args[1]);
    const lv_point_t *points = mp_arr_to_lv_point_t_____(mp_args[2]);
    uint16_t point_cnt = (uint16_t)mp_obj_get_int(mp_args[3]);
    ((void (*)(struct _lv_draw_ctx_t *, const lv_draw_rect_dsc_t *, const lv_point_t [], uint16_t))lv_func_ptr)(draw_ctx, draw_dsc, points, point_cnt);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_draw_polygon_obj, 4, mp_lv_draw_polygon, lv_draw_polygon);
    

/*
 * lvgl extension definition for:
 * void lv_draw_triangle(struct _lv_draw_ctx_t *draw_ctx, const lv_draw_rect_dsc_t *draw_dsc, const lv_point_t points[])
 */
 
STATIC mp_obj_t mp_lv_draw_triangle(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_draw_ctx_t *draw_ctx = mp_write_ptr_lv_draw_ctx_t(mp_args[0]);
    const lv_draw_rect_dsc_t *draw_dsc = mp_write_ptr_lv_draw_rect_dsc_t(mp_args[1]);
    const lv_point_t *points = mp_arr_to_lv_point_t_____(mp_args[2]);
    ((void (*)(struct _lv_draw_ctx_t *, const lv_draw_rect_dsc_t *, const lv_point_t []))lv_func_ptr)(draw_ctx, draw_dsc, points);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_draw_triangle_obj, 3, mp_lv_draw_triangle, lv_draw_triangle);
    
/* Reusing funcptr_draw_arc for lv_draw_arc */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_draw_arc_obj, 6, mp_funcptr_draw_arc, lv_draw_arc);
    
/* Reusing funcptr_draw_transform for lv_draw_transform */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_draw_transform_obj, 10, mp_funcptr_draw_transform, lv_draw_transform);
    

/*
 * lvgl extension definition for:
 * struct _lv_draw_layer_ctx_t *lv_draw_layer_create(struct _lv_draw_ctx_t *draw_ctx, const lv_area_t *layer_area, lv_draw_layer_flags_t flags)
 */
 
STATIC mp_obj_t mp_lv_draw_layer_create(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_draw_ctx_t *draw_ctx = mp_write_ptr_lv_draw_ctx_t(mp_args[0]);
    const lv_area_t *layer_area = mp_write_ptr_lv_area_t(mp_args[1]);
    lv_draw_layer_flags_t flags = (int)mp_obj_get_int(mp_args[2]);
    lv_draw_layer_ctx_t * _res = ((struct _lv_draw_layer_ctx_t *(*)(struct _lv_draw_ctx_t *, const lv_area_t *, lv_draw_layer_flags_t))lv_func_ptr)(draw_ctx, layer_area, flags);
    return mp_read_ptr_lv_draw_layer_ctx_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_draw_layer_create_obj, 3, mp_lv_draw_layer_create, lv_draw_layer_create);
    
/* Reusing funcptr_layer_adjust for lv_draw_layer_adjust */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_draw_layer_adjust_obj, 3, mp_funcptr_layer_adjust, lv_draw_layer_adjust);
    

/*
 * lvgl extension definition for:
 * void lv_draw_layer_blend(struct _lv_draw_ctx_t *draw_ctx, struct _lv_draw_layer_ctx_t *layer_ctx, lv_draw_img_dsc_t *draw_dsc)
 */
 
STATIC mp_obj_t mp_lv_draw_layer_blend(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_draw_ctx_t *draw_ctx = mp_write_ptr_lv_draw_ctx_t(mp_args[0]);
    struct _lv_draw_layer_ctx_t *layer_ctx = mp_write_ptr_lv_draw_layer_ctx_t(mp_args[1]);
    lv_draw_img_dsc_t *draw_dsc = mp_write_ptr_lv_draw_img_dsc_t(mp_args[2]);
    ((void (*)(struct _lv_draw_ctx_t *, struct _lv_draw_layer_ctx_t *, lv_draw_img_dsc_t *))lv_func_ptr)(draw_ctx, layer_ctx, draw_dsc);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_draw_layer_blend_obj, 3, mp_lv_draw_layer_blend, lv_draw_layer_blend);
    

/*
 * lvgl extension definition for:
 * void lv_draw_layer_destroy(struct _lv_draw_ctx_t *draw_ctx, struct _lv_draw_layer_ctx_t *layer_ctx)
 */
 
STATIC mp_obj_t mp_lv_draw_layer_destroy(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_draw_ctx_t *draw_ctx = mp_write_ptr_lv_draw_ctx_t(mp_args[0]);
    struct _lv_draw_layer_ctx_t *layer_ctx = mp_write_ptr_lv_draw_layer_ctx_t(mp_args[1]);
    ((void (*)(struct _lv_draw_ctx_t *, struct _lv_draw_layer_ctx_t *))lv_func_ptr)(draw_ctx, layer_ctx);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_draw_layer_destroy_obj, 2, mp_lv_draw_layer_destroy, lv_draw_layer_destroy);
    

/*
 * lvgl extension definition for:
 * void lv_draw_wait_for_finish(lv_draw_ctx_t *draw_ctx)
 */
 
STATIC mp_obj_t mp_lv_draw_wait_for_finish(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_draw_ctx_t *draw_ctx = mp_write_ptr_lv_draw_ctx_t(mp_args[0]);
    ((void (*)(lv_draw_ctx_t *))lv_func_ptr)(draw_ctx);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_draw_wait_for_finish_obj, 1, mp_lv_draw_wait_for_finish, lv_draw_wait_for_finish);
    

STATIC const mp_rom_map_elem_t mp_lv_draw_ctx_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_draw_ctx_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    { MP_ROM_QSTR(MP_QSTR_rect), MP_ROM_PTR(&mp_lv_draw_rect_obj) },
    { MP_ROM_QSTR(MP_QSTR_label), MP_ROM_PTR(&mp_lv_draw_label_obj) },
    { MP_ROM_QSTR(MP_QSTR_letter), MP_ROM_PTR(&mp_lv_draw_letter_obj) },
    { MP_ROM_QSTR(MP_QSTR_img), MP_ROM_PTR(&mp_lv_draw_img_obj) },
    { MP_ROM_QSTR(MP_QSTR_img_decoded), MP_ROM_PTR(&mp_lv_draw_img_decoded_obj) },
    { MP_ROM_QSTR(MP_QSTR_line), MP_ROM_PTR(&mp_lv_draw_line_obj) },
    { MP_ROM_QSTR(MP_QSTR_polygon), MP_ROM_PTR(&mp_lv_draw_polygon_obj) },
    { MP_ROM_QSTR(MP_QSTR_triangle), MP_ROM_PTR(&mp_lv_draw_triangle_obj) },
    { MP_ROM_QSTR(MP_QSTR_arc), MP_ROM_PTR(&mp_lv_draw_arc_obj) },
    { MP_ROM_QSTR(MP_QSTR_transform), MP_ROM_PTR(&mp_lv_draw_transform_obj) },
    { MP_ROM_QSTR(MP_QSTR_layer_create), MP_ROM_PTR(&mp_lv_draw_layer_create_obj) },
    { MP_ROM_QSTR(MP_QSTR_layer_adjust), MP_ROM_PTR(&mp_lv_draw_layer_adjust_obj) },
    { MP_ROM_QSTR(MP_QSTR_layer_blend), MP_ROM_PTR(&mp_lv_draw_layer_blend_obj) },
    { MP_ROM_QSTR(MP_QSTR_layer_destroy), MP_ROM_PTR(&mp_lv_draw_layer_destroy_obj) },
    { MP_ROM_QSTR(MP_QSTR_wait_for_finish), MP_ROM_PTR(&mp_lv_draw_wait_for_finish_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_draw_ctx_t_locals_dict, mp_lv_draw_ctx_t_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * void lv_draw_rect_dsc_init(lv_draw_rect_dsc_t *dsc)
 */
 
STATIC mp_obj_t mp_lv_draw_rect_dsc_init(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_draw_rect_dsc_t *dsc = mp_write_ptr_lv_draw_rect_dsc_t(mp_args[0]);
    ((void (*)(lv_draw_rect_dsc_t *))lv_func_ptr)(dsc);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_draw_rect_dsc_init_obj, 1, mp_lv_draw_rect_dsc_init, lv_draw_rect_dsc_init);
    

STATIC const mp_rom_map_elem_t mp_lv_draw_rect_dsc_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_draw_rect_dsc_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    { MP_ROM_QSTR(MP_QSTR_init), MP_ROM_PTR(&mp_lv_draw_rect_dsc_init_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_draw_rect_dsc_t_locals_dict, mp_lv_draw_rect_dsc_t_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * void lv_draw_arc_dsc_init(lv_draw_arc_dsc_t *dsc)
 */
 
STATIC mp_obj_t mp_lv_draw_arc_dsc_init(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_draw_arc_dsc_t *dsc = mp_write_ptr_lv_draw_arc_dsc_t(mp_args[0]);
    ((void (*)(lv_draw_arc_dsc_t *))lv_func_ptr)(dsc);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_draw_arc_dsc_init_obj, 1, mp_lv_draw_arc_dsc_init, lv_draw_arc_dsc_init);
    

STATIC const mp_rom_map_elem_t mp_lv_draw_arc_dsc_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_draw_arc_dsc_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    { MP_ROM_QSTR(MP_QSTR_init), MP_ROM_PTR(&mp_lv_draw_arc_dsc_init_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_draw_arc_dsc_t_locals_dict, mp_lv_draw_arc_dsc_t_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * void lv_draw_img_dsc_init(lv_draw_img_dsc_t *dsc)
 */
 
STATIC mp_obj_t mp_lv_draw_img_dsc_init(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_draw_img_dsc_t *dsc = mp_write_ptr_lv_draw_img_dsc_t(mp_args[0]);
    ((void (*)(lv_draw_img_dsc_t *))lv_func_ptr)(dsc);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_draw_img_dsc_init_obj, 1, mp_lv_draw_img_dsc_init, lv_draw_img_dsc_init);
    

STATIC const mp_rom_map_elem_t mp_lv_draw_img_dsc_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_draw_img_dsc_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    { MP_ROM_QSTR(MP_QSTR_init), MP_ROM_PTR(&mp_lv_draw_img_dsc_init_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_draw_img_dsc_t_locals_dict, mp_lv_draw_img_dsc_t_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * void lv_draw_label_dsc_init(lv_draw_label_dsc_t *dsc)
 */
 
STATIC mp_obj_t mp_lv_draw_label_dsc_init(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_draw_label_dsc_t *dsc = mp_write_ptr_lv_draw_label_dsc_t(mp_args[0]);
    ((void (*)(lv_draw_label_dsc_t *))lv_func_ptr)(dsc);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_draw_label_dsc_init_obj, 1, mp_lv_draw_label_dsc_init, lv_draw_label_dsc_init);
    

STATIC const mp_rom_map_elem_t mp_lv_draw_label_dsc_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_draw_label_dsc_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    { MP_ROM_QSTR(MP_QSTR_init), MP_ROM_PTR(&mp_lv_draw_label_dsc_init_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_draw_label_dsc_t_locals_dict, mp_lv_draw_label_dsc_t_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * void lv_draw_line_dsc_init(lv_draw_line_dsc_t *dsc)
 */
 
STATIC mp_obj_t mp_lv_draw_line_dsc_init(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_draw_line_dsc_t *dsc = mp_write_ptr_lv_draw_line_dsc_t(mp_args[0]);
    ((void (*)(lv_draw_line_dsc_t *))lv_func_ptr)(dsc);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_draw_line_dsc_init_obj, 1, mp_lv_draw_line_dsc_init, lv_draw_line_dsc_init);
    

STATIC const mp_rom_map_elem_t mp_lv_draw_line_dsc_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_draw_line_dsc_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    { MP_ROM_QSTR(MP_QSTR_init), MP_ROM_PTR(&mp_lv_draw_line_dsc_init_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_draw_line_dsc_t_locals_dict, mp_lv_draw_line_dsc_t_locals_dict_table);
        

STATIC const mp_rom_map_elem_t mp_lv_draw_layer_ctx_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_draw_layer_ctx_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_draw_layer_ctx_t_locals_dict, mp_lv_draw_layer_ctx_t_locals_dict_table);
        

STATIC const mp_rom_map_elem_t mp_lv_draw_layer_ctx_original_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_draw_layer_ctx_original_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_draw_layer_ctx_original_t_locals_dict, mp_lv_draw_layer_ctx_original_t_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * void lv_timer_del(lv_timer_t *timer)
 */
 
STATIC mp_obj_t mp_lv_timer_del(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_timer_t *timer = mp_write_ptr_lv_timer_t(mp_args[0]);
    ((void (*)(lv_timer_t *))lv_func_ptr)(timer);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_timer_del_obj, 1, mp_lv_timer_del, lv_timer_del);
    
/* Reusing lv_timer_del for lv_timer_pause */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_timer_pause_obj, 1, mp_lv_timer_del, lv_timer_pause);
    
/* Reusing lv_timer_del for lv_timer_resume */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_timer_resume_obj, 1, mp_lv_timer_del, lv_timer_resume);
    

/*
 * Callback function lv_timer_t_timer_cb
 * void lv_timer_cb_t(struct _lv_timer_t *)
 */

STATIC void lv_timer_t_timer_cb_callback(struct _lv_timer_t * arg0)
{
    mp_obj_t mp_args[1];
    mp_args[0] = mp_read_ptr_lv_timer_t((void*)arg0);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_timer_t_timer_cb)) , 1, 0, mp_args);
    return;
}


/*
 * lvgl extension definition for:
 * void lv_timer_set_cb(lv_timer_t *timer, lv_timer_cb_t timer_cb)
 */
 
STATIC mp_obj_t mp_lv_timer_set_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_timer_t *timer = mp_write_ptr_lv_timer_t(mp_args[0]);
    void *timer_cb = mp_lv_callback(mp_args[1], &lv_timer_t_timer_cb_callback, MP_QSTR_lv_timer_t_timer_cb, &timer->user_data);
    ((void (*)(lv_timer_t *, lv_timer_cb_t))lv_func_ptr)(timer, timer_cb);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_timer_set_cb_obj, 2, mp_lv_timer_set_cb, lv_timer_set_cb);
    

/*
 * lvgl extension definition for:
 * void lv_timer_set_period(lv_timer_t *timer, uint32_t period)
 */
 
STATIC mp_obj_t mp_lv_timer_set_period(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_timer_t *timer = mp_write_ptr_lv_timer_t(mp_args[0]);
    uint32_t period = (uint32_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_timer_t *, uint32_t))lv_func_ptr)(timer, period);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_timer_set_period_obj, 2, mp_lv_timer_set_period, lv_timer_set_period);
    
/* Reusing lv_timer_del for lv_timer_ready */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_timer_ready_obj, 1, mp_lv_timer_del, lv_timer_ready);
    

/*
 * lvgl extension definition for:
 * void lv_timer_set_repeat_count(lv_timer_t *timer, int32_t repeat_count)
 */
 
STATIC mp_obj_t mp_lv_timer_set_repeat_count(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_timer_t *timer = mp_write_ptr_lv_timer_t(mp_args[0]);
    int32_t repeat_count = (int32_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_timer_t *, int32_t))lv_func_ptr)(timer, repeat_count);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_timer_set_repeat_count_obj, 2, mp_lv_timer_set_repeat_count, lv_timer_set_repeat_count);
    
/* Reusing lv_timer_del for lv_timer_reset */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_timer_reset_obj, 1, mp_lv_timer_del, lv_timer_reset);
    

/*
 * lvgl extension definition for:
 * lv_timer_t *lv_timer_get_next(lv_timer_t *timer)
 */
 
STATIC mp_obj_t mp_lv_timer_get_next(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_timer_t *timer = mp_write_ptr_lv_timer_t(mp_args[0]);
    lv_timer_t * _res = ((lv_timer_t *(*)(lv_timer_t *))lv_func_ptr)(timer);
    return mp_read_ptr_lv_timer_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_timer_get_next_obj, 1, mp_lv_timer_get_next, lv_timer_get_next);
    

STATIC const mp_rom_map_elem_t mp_lv_timer_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_timer_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    { MP_ROM_QSTR(MP_QSTR__del), MP_ROM_PTR(&mp_lv_timer_del_obj) },
    { MP_ROM_QSTR(MP_QSTR_pause), MP_ROM_PTR(&mp_lv_timer_pause_obj) },
    { MP_ROM_QSTR(MP_QSTR_resume), MP_ROM_PTR(&mp_lv_timer_resume_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_cb), MP_ROM_PTR(&mp_lv_timer_set_cb_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_period), MP_ROM_PTR(&mp_lv_timer_set_period_obj) },
    { MP_ROM_QSTR(MP_QSTR_ready), MP_ROM_PTR(&mp_lv_timer_ready_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_repeat_count), MP_ROM_PTR(&mp_lv_timer_set_repeat_count_obj) },
    { MP_ROM_QSTR(MP_QSTR_reset), MP_ROM_PTR(&mp_lv_timer_reset_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_next), MP_ROM_PTR(&mp_lv_timer_get_next_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_timer_t_locals_dict, mp_lv_timer_t_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * void lv_theme_set_parent(lv_theme_t *new_theme, lv_theme_t *parent)
 */
 
STATIC mp_obj_t mp_lv_theme_set_parent(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_theme_t *new_theme = mp_write_ptr_lv_theme_t(mp_args[0]);
    lv_theme_t *parent = mp_write_ptr_lv_theme_t(mp_args[1]);
    ((void (*)(lv_theme_t *, lv_theme_t *))lv_func_ptr)(new_theme, parent);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_theme_set_parent_obj, 2, mp_lv_theme_set_parent, lv_theme_set_parent);
    

/*
 * Callback function lv_theme_t_apply_cb
 * void lv_theme_apply_cb_t(struct _lv_theme_t *, lv_obj_t *)
 */

STATIC void lv_theme_t_apply_cb_callback(struct _lv_theme_t * arg0, lv_obj_t * arg1)
{
    mp_obj_t mp_args[2];
    mp_args[0] = mp_read_ptr_lv_theme_t((void*)arg0);
    mp_args[1] = lv_to_mp((void*)arg1);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_theme_t_apply_cb)) , 2, 0, mp_args);
    return;
}


/*
 * lvgl extension definition for:
 * void lv_theme_set_apply_cb(lv_theme_t *theme, lv_theme_apply_cb_t apply_cb)
 */
 
STATIC mp_obj_t mp_lv_theme_set_apply_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_theme_t *theme = mp_write_ptr_lv_theme_t(mp_args[0]);
    void *apply_cb = mp_lv_callback(mp_args[1], &lv_theme_t_apply_cb_callback, MP_QSTR_lv_theme_t_apply_cb, &theme->user_data);
    ((void (*)(lv_theme_t *, lv_theme_apply_cb_t))lv_func_ptr)(theme, apply_cb);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_theme_set_apply_cb_obj, 2, mp_lv_theme_set_apply_cb, lv_theme_set_apply_cb);
    

STATIC const mp_rom_map_elem_t mp_lv_theme_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_theme_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_parent), MP_ROM_PTR(&mp_lv_theme_set_parent_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_apply_cb), MP_ROM_PTR(&mp_lv_theme_set_apply_cb_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_theme_t_locals_dict, mp_lv_theme_t_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * inline static lv_style_res_t lv_style_get_prop_inlined(const lv_style_t *style, lv_style_prop_t prop, lv_style_value_t *value)
 */
 
STATIC mp_obj_t mp_lv_style_get_prop_inlined(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_style_t *style = mp_write_ptr_lv_style_t(mp_args[0]);
    lv_style_prop_t prop = (int)mp_obj_get_int(mp_args[1]);
    lv_style_value_t *value = mp_write_ptr_lv_style_value_t(mp_args[2]);
    lv_style_res_t _res = ((lv_style_res_t (*)(const lv_style_t *, lv_style_prop_t, lv_style_value_t *))lv_func_ptr)(style, prop, value);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_get_prop_inlined_obj, 3, mp_lv_style_get_prop_inlined, lv_style_get_prop_inlined);
    

/*
 * lvgl extension definition for:
 * inline static void lv_style_set_size(lv_style_t *style, lv_coord_t value)
 */
 
STATIC mp_obj_t mp_lv_style_set_size(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_style_t *style = mp_write_ptr_lv_style_t(mp_args[0]);
    lv_coord_t value = (int16_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_style_t *, lv_coord_t))lv_func_ptr)(style, value);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_size_obj, 2, mp_lv_style_set_size, lv_style_set_size);
    
/* Reusing lv_style_set_size for lv_style_set_pad_all */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_pad_all_obj, 2, mp_lv_style_set_size, lv_style_set_pad_all);
    
/* Reusing lv_style_set_size for lv_style_set_pad_hor */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_pad_hor_obj, 2, mp_lv_style_set_size, lv_style_set_pad_hor);
    
/* Reusing lv_style_set_size for lv_style_set_pad_ver */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_pad_ver_obj, 2, mp_lv_style_set_size, lv_style_set_pad_ver);
    
/* Reusing lv_style_set_size for lv_style_set_pad_gap */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_pad_gap_obj, 2, mp_lv_style_set_size, lv_style_set_pad_gap);
    
/* Reusing lv_obj_report_style_change for lv_style_init */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_init_obj, 1, mp_lv_obj_report_style_change, lv_style_init);
    
/* Reusing lv_obj_report_style_change for lv_style_reset */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_reset_obj, 1, mp_lv_obj_report_style_change, lv_style_reset);
    

/*
 * lvgl extension definition for:
 * bool lv_style_remove_prop(lv_style_t *style, lv_style_prop_t prop)
 */
 
STATIC mp_obj_t mp_lv_style_remove_prop(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_style_t *style = mp_write_ptr_lv_style_t(mp_args[0]);
    lv_style_prop_t prop = (int)mp_obj_get_int(mp_args[1]);
    bool _res = ((bool (*)(lv_style_t *, lv_style_prop_t))lv_func_ptr)(style, prop);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_remove_prop_obj, 2, mp_lv_style_remove_prop, lv_style_remove_prop);
    

/*
 * lvgl extension definition for:
 * void lv_style_set_prop(lv_style_t *style, lv_style_prop_t prop, lv_style_value_t value)
 */
 
STATIC mp_obj_t mp_lv_style_set_prop(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_style_t *style = mp_write_ptr_lv_style_t(mp_args[0]);
    lv_style_prop_t prop = (int)mp_obj_get_int(mp_args[1]);
    lv_style_value_t value = mp_write_lv_style_value_t(mp_args[2]);
    ((void (*)(lv_style_t *, lv_style_prop_t, lv_style_value_t))lv_func_ptr)(style, prop, value);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_prop_obj, 3, mp_lv_style_set_prop, lv_style_set_prop);
    

/*
 * lvgl extension definition for:
 * void lv_style_set_prop_meta(lv_style_t *style, lv_style_prop_t prop, uint16_t meta)
 */
 
STATIC mp_obj_t mp_lv_style_set_prop_meta(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_style_t *style = mp_write_ptr_lv_style_t(mp_args[0]);
    lv_style_prop_t prop = (int)mp_obj_get_int(mp_args[1]);
    uint16_t meta = (uint16_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_style_t *, lv_style_prop_t, uint16_t))lv_func_ptr)(style, prop, meta);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_prop_meta_obj, 3, mp_lv_style_set_prop_meta, lv_style_set_prop_meta);
    
/* Reusing lv_style_get_prop_inlined for lv_style_get_prop */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_get_prop_obj, 3, mp_lv_style_get_prop_inlined, lv_style_get_prop);
    

/*
 * lvgl extension definition for:
 * bool lv_style_is_empty(const lv_style_t *style)
 */
 
STATIC mp_obj_t mp_lv_style_is_empty(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_style_t *style = mp_write_ptr_lv_style_t(mp_args[0]);
    bool _res = ((bool (*)(const lv_style_t *))lv_func_ptr)(style);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_is_empty_obj, 1, mp_lv_style_is_empty, lv_style_is_empty);
    
/* Reusing lv_style_set_size for lv_style_set_width */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_width_obj, 2, mp_lv_style_set_size, lv_style_set_width);
    
/* Reusing lv_style_set_size for lv_style_set_min_width */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_min_width_obj, 2, mp_lv_style_set_size, lv_style_set_min_width);
    
/* Reusing lv_style_set_size for lv_style_set_max_width */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_max_width_obj, 2, mp_lv_style_set_size, lv_style_set_max_width);
    
/* Reusing lv_style_set_size for lv_style_set_height */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_height_obj, 2, mp_lv_style_set_size, lv_style_set_height);
    
/* Reusing lv_style_set_size for lv_style_set_min_height */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_min_height_obj, 2, mp_lv_style_set_size, lv_style_set_min_height);
    
/* Reusing lv_style_set_size for lv_style_set_max_height */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_max_height_obj, 2, mp_lv_style_set_size, lv_style_set_max_height);
    
/* Reusing lv_style_set_size for lv_style_set_x */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_x_obj, 2, mp_lv_style_set_size, lv_style_set_x);
    
/* Reusing lv_style_set_size for lv_style_set_y */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_y_obj, 2, mp_lv_style_set_size, lv_style_set_y);
    

/*
 * lvgl extension definition for:
 * void lv_style_set_align(lv_style_t *style, lv_align_t value)
 */
 
STATIC mp_obj_t mp_lv_style_set_align(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_style_t *style = mp_write_ptr_lv_style_t(mp_args[0]);
    lv_align_t value = (uint8_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_style_t *, lv_align_t))lv_func_ptr)(style, value);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_align_obj, 2, mp_lv_style_set_align, lv_style_set_align);
    
/* Reusing lv_style_set_size for lv_style_set_transform_width */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_transform_width_obj, 2, mp_lv_style_set_size, lv_style_set_transform_width);
    
/* Reusing lv_style_set_size for lv_style_set_transform_height */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_transform_height_obj, 2, mp_lv_style_set_size, lv_style_set_transform_height);
    
/* Reusing lv_style_set_size for lv_style_set_translate_x */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_translate_x_obj, 2, mp_lv_style_set_size, lv_style_set_translate_x);
    
/* Reusing lv_style_set_size for lv_style_set_translate_y */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_translate_y_obj, 2, mp_lv_style_set_size, lv_style_set_translate_y);
    
/* Reusing lv_style_set_size for lv_style_set_transform_zoom */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_transform_zoom_obj, 2, mp_lv_style_set_size, lv_style_set_transform_zoom);
    
/* Reusing lv_style_set_size for lv_style_set_transform_angle */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_transform_angle_obj, 2, mp_lv_style_set_size, lv_style_set_transform_angle);
    
/* Reusing lv_style_set_size for lv_style_set_transform_pivot_x */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_transform_pivot_x_obj, 2, mp_lv_style_set_size, lv_style_set_transform_pivot_x);
    
/* Reusing lv_style_set_size for lv_style_set_transform_pivot_y */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_transform_pivot_y_obj, 2, mp_lv_style_set_size, lv_style_set_transform_pivot_y);
    
/* Reusing lv_style_set_size for lv_style_set_pad_top */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_pad_top_obj, 2, mp_lv_style_set_size, lv_style_set_pad_top);
    
/* Reusing lv_style_set_size for lv_style_set_pad_bottom */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_pad_bottom_obj, 2, mp_lv_style_set_size, lv_style_set_pad_bottom);
    
/* Reusing lv_style_set_size for lv_style_set_pad_left */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_pad_left_obj, 2, mp_lv_style_set_size, lv_style_set_pad_left);
    
/* Reusing lv_style_set_size for lv_style_set_pad_right */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_pad_right_obj, 2, mp_lv_style_set_size, lv_style_set_pad_right);
    
/* Reusing lv_style_set_size for lv_style_set_pad_row */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_pad_row_obj, 2, mp_lv_style_set_size, lv_style_set_pad_row);
    
/* Reusing lv_style_set_size for lv_style_set_pad_column */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_pad_column_obj, 2, mp_lv_style_set_size, lv_style_set_pad_column);
    

/*
 * lvgl extension definition for:
 * void lv_style_set_bg_color(lv_style_t *style, lv_color_t value)
 */
 
STATIC mp_obj_t mp_lv_style_set_bg_color(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_style_t *style = mp_write_ptr_lv_style_t(mp_args[0]);
    lv_color_t value = mp_write_lv_color16_t(mp_args[1]);
    ((void (*)(lv_style_t *, lv_color_t))lv_func_ptr)(style, value);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_bg_color_obj, 2, mp_lv_style_set_bg_color, lv_style_set_bg_color);
    

/*
 * lvgl extension definition for:
 * void lv_style_set_bg_opa(lv_style_t *style, lv_opa_t value)
 */
 
STATIC mp_obj_t mp_lv_style_set_bg_opa(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_style_t *style = mp_write_ptr_lv_style_t(mp_args[0]);
    lv_opa_t value = (uint8_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_style_t *, lv_opa_t))lv_func_ptr)(style, value);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_bg_opa_obj, 2, mp_lv_style_set_bg_opa, lv_style_set_bg_opa);
    
/* Reusing lv_style_set_bg_color for lv_style_set_bg_grad_color */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_bg_grad_color_obj, 2, mp_lv_style_set_bg_color, lv_style_set_bg_grad_color);
    

/*
 * lvgl extension definition for:
 * void lv_style_set_bg_grad_dir(lv_style_t *style, lv_grad_dir_t value)
 */
 
STATIC mp_obj_t mp_lv_style_set_bg_grad_dir(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_style_t *style = mp_write_ptr_lv_style_t(mp_args[0]);
    lv_grad_dir_t value = (uint8_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_style_t *, lv_grad_dir_t))lv_func_ptr)(style, value);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_bg_grad_dir_obj, 2, mp_lv_style_set_bg_grad_dir, lv_style_set_bg_grad_dir);
    
/* Reusing lv_style_set_size for lv_style_set_bg_main_stop */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_bg_main_stop_obj, 2, mp_lv_style_set_size, lv_style_set_bg_main_stop);
    
/* Reusing lv_style_set_size for lv_style_set_bg_grad_stop */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_bg_grad_stop_obj, 2, mp_lv_style_set_size, lv_style_set_bg_grad_stop);
    

/*
 * lvgl extension definition for:
 * void lv_style_set_bg_grad(lv_style_t *style, const lv_grad_dsc_t *value)
 */
 
STATIC mp_obj_t mp_lv_style_set_bg_grad(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_style_t *style = mp_write_ptr_lv_style_t(mp_args[0]);
    const lv_grad_dsc_t *value = mp_write_ptr_lv_grad_dsc_t(mp_args[1]);
    ((void (*)(lv_style_t *, const lv_grad_dsc_t *))lv_func_ptr)(style, value);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_bg_grad_obj, 2, mp_lv_style_set_bg_grad, lv_style_set_bg_grad);
    

/*
 * lvgl extension definition for:
 * void lv_style_set_bg_dither_mode(lv_style_t *style, lv_dither_mode_t value)
 */
 
STATIC mp_obj_t mp_lv_style_set_bg_dither_mode(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_style_t *style = mp_write_ptr_lv_style_t(mp_args[0]);
    lv_dither_mode_t value = (uint8_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_style_t *, lv_dither_mode_t))lv_func_ptr)(style, value);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_bg_dither_mode_obj, 2, mp_lv_style_set_bg_dither_mode, lv_style_set_bg_dither_mode);
    

/*
 * lvgl extension definition for:
 * void lv_style_set_bg_img_src(lv_style_t *style, const void *value)
 */
 
STATIC mp_obj_t mp_lv_style_set_bg_img_src(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_style_t *style = mp_write_ptr_lv_style_t(mp_args[0]);
    const void *value = mp_to_ptr(mp_args[1]);
    ((void (*)(lv_style_t *, const void *))lv_func_ptr)(style, value);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_bg_img_src_obj, 2, mp_lv_style_set_bg_img_src, lv_style_set_bg_img_src);
    
/* Reusing lv_style_set_bg_opa for lv_style_set_bg_img_opa */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_bg_img_opa_obj, 2, mp_lv_style_set_bg_opa, lv_style_set_bg_img_opa);
    
/* Reusing lv_style_set_bg_color for lv_style_set_bg_img_recolor */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_bg_img_recolor_obj, 2, mp_lv_style_set_bg_color, lv_style_set_bg_img_recolor);
    
/* Reusing lv_style_set_bg_opa for lv_style_set_bg_img_recolor_opa */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_bg_img_recolor_opa_obj, 2, mp_lv_style_set_bg_opa, lv_style_set_bg_img_recolor_opa);
    

/*
 * lvgl extension definition for:
 * void lv_style_set_bg_img_tiled(lv_style_t *style, bool value)
 */
 
STATIC mp_obj_t mp_lv_style_set_bg_img_tiled(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_style_t *style = mp_write_ptr_lv_style_t(mp_args[0]);
    bool value = mp_obj_is_true(mp_args[1]);
    ((void (*)(lv_style_t *, bool))lv_func_ptr)(style, value);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_bg_img_tiled_obj, 2, mp_lv_style_set_bg_img_tiled, lv_style_set_bg_img_tiled);
    
/* Reusing lv_style_set_bg_color for lv_style_set_border_color */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_border_color_obj, 2, mp_lv_style_set_bg_color, lv_style_set_border_color);
    
/* Reusing lv_style_set_bg_opa for lv_style_set_border_opa */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_border_opa_obj, 2, mp_lv_style_set_bg_opa, lv_style_set_border_opa);
    
/* Reusing lv_style_set_size for lv_style_set_border_width */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_border_width_obj, 2, mp_lv_style_set_size, lv_style_set_border_width);
    

/*
 * lvgl extension definition for:
 * void lv_style_set_border_side(lv_style_t *style, lv_border_side_t value)
 */
 
STATIC mp_obj_t mp_lv_style_set_border_side(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_style_t *style = mp_write_ptr_lv_style_t(mp_args[0]);
    lv_border_side_t value = (uint8_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_style_t *, lv_border_side_t))lv_func_ptr)(style, value);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_border_side_obj, 2, mp_lv_style_set_border_side, lv_style_set_border_side);
    
/* Reusing lv_style_set_bg_img_tiled for lv_style_set_border_post */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_border_post_obj, 2, mp_lv_style_set_bg_img_tiled, lv_style_set_border_post);
    
/* Reusing lv_style_set_size for lv_style_set_outline_width */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_outline_width_obj, 2, mp_lv_style_set_size, lv_style_set_outline_width);
    
/* Reusing lv_style_set_bg_color for lv_style_set_outline_color */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_outline_color_obj, 2, mp_lv_style_set_bg_color, lv_style_set_outline_color);
    
/* Reusing lv_style_set_bg_opa for lv_style_set_outline_opa */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_outline_opa_obj, 2, mp_lv_style_set_bg_opa, lv_style_set_outline_opa);
    
/* Reusing lv_style_set_size for lv_style_set_outline_pad */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_outline_pad_obj, 2, mp_lv_style_set_size, lv_style_set_outline_pad);
    
/* Reusing lv_style_set_size for lv_style_set_shadow_width */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_shadow_width_obj, 2, mp_lv_style_set_size, lv_style_set_shadow_width);
    
/* Reusing lv_style_set_size for lv_style_set_shadow_ofs_x */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_shadow_ofs_x_obj, 2, mp_lv_style_set_size, lv_style_set_shadow_ofs_x);
    
/* Reusing lv_style_set_size for lv_style_set_shadow_ofs_y */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_shadow_ofs_y_obj, 2, mp_lv_style_set_size, lv_style_set_shadow_ofs_y);
    
/* Reusing lv_style_set_size for lv_style_set_shadow_spread */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_shadow_spread_obj, 2, mp_lv_style_set_size, lv_style_set_shadow_spread);
    
/* Reusing lv_style_set_bg_color for lv_style_set_shadow_color */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_shadow_color_obj, 2, mp_lv_style_set_bg_color, lv_style_set_shadow_color);
    
/* Reusing lv_style_set_bg_opa for lv_style_set_shadow_opa */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_shadow_opa_obj, 2, mp_lv_style_set_bg_opa, lv_style_set_shadow_opa);
    
/* Reusing lv_style_set_bg_opa for lv_style_set_img_opa */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_img_opa_obj, 2, mp_lv_style_set_bg_opa, lv_style_set_img_opa);
    
/* Reusing lv_style_set_bg_color for lv_style_set_img_recolor */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_img_recolor_obj, 2, mp_lv_style_set_bg_color, lv_style_set_img_recolor);
    
/* Reusing lv_style_set_bg_opa for lv_style_set_img_recolor_opa */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_img_recolor_opa_obj, 2, mp_lv_style_set_bg_opa, lv_style_set_img_recolor_opa);
    
/* Reusing lv_style_set_size for lv_style_set_line_width */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_line_width_obj, 2, mp_lv_style_set_size, lv_style_set_line_width);
    
/* Reusing lv_style_set_size for lv_style_set_line_dash_width */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_line_dash_width_obj, 2, mp_lv_style_set_size, lv_style_set_line_dash_width);
    
/* Reusing lv_style_set_size for lv_style_set_line_dash_gap */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_line_dash_gap_obj, 2, mp_lv_style_set_size, lv_style_set_line_dash_gap);
    
/* Reusing lv_style_set_bg_img_tiled for lv_style_set_line_rounded */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_line_rounded_obj, 2, mp_lv_style_set_bg_img_tiled, lv_style_set_line_rounded);
    
/* Reusing lv_style_set_bg_color for lv_style_set_line_color */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_line_color_obj, 2, mp_lv_style_set_bg_color, lv_style_set_line_color);
    
/* Reusing lv_style_set_bg_opa for lv_style_set_line_opa */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_line_opa_obj, 2, mp_lv_style_set_bg_opa, lv_style_set_line_opa);
    
/* Reusing lv_style_set_size for lv_style_set_arc_width */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_arc_width_obj, 2, mp_lv_style_set_size, lv_style_set_arc_width);
    
/* Reusing lv_style_set_bg_img_tiled for lv_style_set_arc_rounded */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_arc_rounded_obj, 2, mp_lv_style_set_bg_img_tiled, lv_style_set_arc_rounded);
    
/* Reusing lv_style_set_bg_color for lv_style_set_arc_color */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_arc_color_obj, 2, mp_lv_style_set_bg_color, lv_style_set_arc_color);
    
/* Reusing lv_style_set_bg_opa for lv_style_set_arc_opa */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_arc_opa_obj, 2, mp_lv_style_set_bg_opa, lv_style_set_arc_opa);
    
/* Reusing lv_style_set_bg_img_src for lv_style_set_arc_img_src */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_arc_img_src_obj, 2, mp_lv_style_set_bg_img_src, lv_style_set_arc_img_src);
    
/* Reusing lv_style_set_bg_color for lv_style_set_text_color */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_text_color_obj, 2, mp_lv_style_set_bg_color, lv_style_set_text_color);
    
/* Reusing lv_style_set_bg_opa for lv_style_set_text_opa */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_text_opa_obj, 2, mp_lv_style_set_bg_opa, lv_style_set_text_opa);
    

/*
 * lvgl extension definition for:
 * void lv_style_set_text_font(lv_style_t *style, const lv_font_t *value)
 */
 
STATIC mp_obj_t mp_lv_style_set_text_font(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_style_t *style = mp_write_ptr_lv_style_t(mp_args[0]);
    const lv_font_t *value = mp_write_ptr_lv_font_t(mp_args[1]);
    ((void (*)(lv_style_t *, const lv_font_t *))lv_func_ptr)(style, value);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_text_font_obj, 2, mp_lv_style_set_text_font, lv_style_set_text_font);
    
/* Reusing lv_style_set_size for lv_style_set_text_letter_space */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_text_letter_space_obj, 2, mp_lv_style_set_size, lv_style_set_text_letter_space);
    
/* Reusing lv_style_set_size for lv_style_set_text_line_space */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_text_line_space_obj, 2, mp_lv_style_set_size, lv_style_set_text_line_space);
    

/*
 * lvgl extension definition for:
 * void lv_style_set_text_decor(lv_style_t *style, lv_text_decor_t value)
 */
 
STATIC mp_obj_t mp_lv_style_set_text_decor(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_style_t *style = mp_write_ptr_lv_style_t(mp_args[0]);
    lv_text_decor_t value = (uint8_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_style_t *, lv_text_decor_t))lv_func_ptr)(style, value);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_text_decor_obj, 2, mp_lv_style_set_text_decor, lv_style_set_text_decor);
    

/*
 * lvgl extension definition for:
 * void lv_style_set_text_align(lv_style_t *style, lv_text_align_t value)
 */
 
STATIC mp_obj_t mp_lv_style_set_text_align(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_style_t *style = mp_write_ptr_lv_style_t(mp_args[0]);
    lv_text_align_t value = (uint8_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_style_t *, lv_text_align_t))lv_func_ptr)(style, value);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_text_align_obj, 2, mp_lv_style_set_text_align, lv_style_set_text_align);
    
/* Reusing lv_style_set_size for lv_style_set_radius */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_radius_obj, 2, mp_lv_style_set_size, lv_style_set_radius);
    
/* Reusing lv_style_set_bg_img_tiled for lv_style_set_clip_corner */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_clip_corner_obj, 2, mp_lv_style_set_bg_img_tiled, lv_style_set_clip_corner);
    
/* Reusing lv_style_set_bg_opa for lv_style_set_opa */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_opa_obj, 2, mp_lv_style_set_bg_opa, lv_style_set_opa);
    

/*
 * lvgl extension definition for:
 * void lv_style_set_color_filter_dsc(lv_style_t *style, const lv_color_filter_dsc_t *value)
 */
 
STATIC mp_obj_t mp_lv_style_set_color_filter_dsc(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_style_t *style = mp_write_ptr_lv_style_t(mp_args[0]);
    const lv_color_filter_dsc_t *value = mp_write_ptr_lv_color_filter_dsc_t(mp_args[1]);
    ((void (*)(lv_style_t *, const lv_color_filter_dsc_t *))lv_func_ptr)(style, value);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_color_filter_dsc_obj, 2, mp_lv_style_set_color_filter_dsc, lv_style_set_color_filter_dsc);
    
/* Reusing lv_style_set_bg_opa for lv_style_set_color_filter_opa */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_color_filter_opa_obj, 2, mp_lv_style_set_bg_opa, lv_style_set_color_filter_opa);
    

/*
 * lvgl extension definition for:
 * void lv_style_set_anim(lv_style_t *style, const lv_anim_t *value)
 */
 
STATIC mp_obj_t mp_lv_style_set_anim(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_style_t *style = mp_write_ptr_lv_style_t(mp_args[0]);
    const lv_anim_t *value = mp_write_ptr_lv_anim_t(mp_args[1]);
    ((void (*)(lv_style_t *, const lv_anim_t *))lv_func_ptr)(style, value);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_anim_obj, 2, mp_lv_style_set_anim, lv_style_set_anim);
    

/*
 * lvgl extension definition for:
 * void lv_style_set_anim_time(lv_style_t *style, uint32_t value)
 */
 
STATIC mp_obj_t mp_lv_style_set_anim_time(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_style_t *style = mp_write_ptr_lv_style_t(mp_args[0]);
    uint32_t value = (uint32_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_style_t *, uint32_t))lv_func_ptr)(style, value);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_anim_time_obj, 2, mp_lv_style_set_anim_time, lv_style_set_anim_time);
    
/* Reusing lv_style_set_anim_time for lv_style_set_anim_speed */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_anim_speed_obj, 2, mp_lv_style_set_anim_time, lv_style_set_anim_speed);
    

/*
 * lvgl extension definition for:
 * void lv_style_set_transition(lv_style_t *style, const lv_style_transition_dsc_t *value)
 */
 
STATIC mp_obj_t mp_lv_style_set_transition(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_style_t *style = mp_write_ptr_lv_style_t(mp_args[0]);
    const lv_style_transition_dsc_t *value = mp_write_ptr_lv_style_transition_dsc_t(mp_args[1]);
    ((void (*)(lv_style_t *, const lv_style_transition_dsc_t *))lv_func_ptr)(style, value);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_transition_obj, 2, mp_lv_style_set_transition, lv_style_set_transition);
    

/*
 * lvgl extension definition for:
 * void lv_style_set_blend_mode(lv_style_t *style, lv_blend_mode_t value)
 */
 
STATIC mp_obj_t mp_lv_style_set_blend_mode(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_style_t *style = mp_write_ptr_lv_style_t(mp_args[0]);
    lv_blend_mode_t value = (uint8_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_style_t *, lv_blend_mode_t))lv_func_ptr)(style, value);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_blend_mode_obj, 2, mp_lv_style_set_blend_mode, lv_style_set_blend_mode);
    

/*
 * lvgl extension definition for:
 * void lv_style_set_layout(lv_style_t *style, uint16_t value)
 */
 
STATIC mp_obj_t mp_lv_style_set_layout(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_style_t *style = mp_write_ptr_lv_style_t(mp_args[0]);
    uint16_t value = (uint16_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_style_t *, uint16_t))lv_func_ptr)(style, value);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_layout_obj, 2, mp_lv_style_set_layout, lv_style_set_layout);
    

/*
 * lvgl extension definition for:
 * void lv_style_set_base_dir(lv_style_t *style, lv_base_dir_t value)
 */
 
STATIC mp_obj_t mp_lv_style_set_base_dir(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_style_t *style = mp_write_ptr_lv_style_t(mp_args[0]);
    lv_base_dir_t value = (uint8_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_style_t *, lv_base_dir_t))lv_func_ptr)(style, value);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_base_dir_obj, 2, mp_lv_style_set_base_dir, lv_style_set_base_dir);
    

/*
 * lvgl extension definition for:
 * void lv_style_set_flex_flow(lv_style_t *style, lv_flex_flow_t value)
 */
 
STATIC mp_obj_t mp_lv_style_set_flex_flow(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_style_t *style = mp_write_ptr_lv_style_t(mp_args[0]);
    lv_flex_flow_t value = (int)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_style_t *, lv_flex_flow_t))lv_func_ptr)(style, value);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_flex_flow_obj, 2, mp_lv_style_set_flex_flow, lv_style_set_flex_flow);
    

/*
 * lvgl extension definition for:
 * void lv_style_set_flex_main_place(lv_style_t *style, lv_flex_align_t value)
 */
 
STATIC mp_obj_t mp_lv_style_set_flex_main_place(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_style_t *style = mp_write_ptr_lv_style_t(mp_args[0]);
    lv_flex_align_t value = (int)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_style_t *, lv_flex_align_t))lv_func_ptr)(style, value);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_flex_main_place_obj, 2, mp_lv_style_set_flex_main_place, lv_style_set_flex_main_place);
    
/* Reusing lv_style_set_flex_main_place for lv_style_set_flex_cross_place */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_flex_cross_place_obj, 2, mp_lv_style_set_flex_main_place, lv_style_set_flex_cross_place);
    
/* Reusing lv_style_set_flex_main_place for lv_style_set_flex_track_place */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_flex_track_place_obj, 2, mp_lv_style_set_flex_main_place, lv_style_set_flex_track_place);
    

/*
 * lvgl extension definition for:
 * void lv_style_set_flex_grow(lv_style_t *style, uint8_t value)
 */
 
STATIC mp_obj_t mp_lv_style_set_flex_grow(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_style_t *style = mp_write_ptr_lv_style_t(mp_args[0]);
    uint8_t value = (uint8_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_style_t *, uint8_t))lv_func_ptr)(style, value);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_flex_grow_obj, 2, mp_lv_style_set_flex_grow, lv_style_set_flex_grow);
    

/*
 * lvgl extension definition for:
 * void lv_style_set_grid_row_dsc_array(lv_style_t *style, const lv_coord_t value[])
 */
 
STATIC mp_obj_t mp_lv_style_set_grid_row_dsc_array(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_style_t *style = mp_write_ptr_lv_style_t(mp_args[0]);
    const lv_coord_t *value = mp_arr_to_lv_coord_t_____(mp_args[1]);
    ((void (*)(lv_style_t *, const lv_coord_t []))lv_func_ptr)(style, value);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_grid_row_dsc_array_obj, 2, mp_lv_style_set_grid_row_dsc_array, lv_style_set_grid_row_dsc_array);
    
/* Reusing lv_style_set_grid_row_dsc_array for lv_style_set_grid_column_dsc_array */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_grid_column_dsc_array_obj, 2, mp_lv_style_set_grid_row_dsc_array, lv_style_set_grid_column_dsc_array);
    

/*
 * lvgl extension definition for:
 * void lv_style_set_grid_row_align(lv_style_t *style, lv_grid_align_t value)
 */
 
STATIC mp_obj_t mp_lv_style_set_grid_row_align(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_style_t *style = mp_write_ptr_lv_style_t(mp_args[0]);
    lv_grid_align_t value = (int)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_style_t *, lv_grid_align_t))lv_func_ptr)(style, value);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_grid_row_align_obj, 2, mp_lv_style_set_grid_row_align, lv_style_set_grid_row_align);
    
/* Reusing lv_style_set_grid_row_align for lv_style_set_grid_column_align */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_grid_column_align_obj, 2, mp_lv_style_set_grid_row_align, lv_style_set_grid_column_align);
    
/* Reusing lv_style_set_size for lv_style_set_grid_cell_column_pos */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_grid_cell_column_pos_obj, 2, mp_lv_style_set_size, lv_style_set_grid_cell_column_pos);
    
/* Reusing lv_style_set_size for lv_style_set_grid_cell_column_span */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_grid_cell_column_span_obj, 2, mp_lv_style_set_size, lv_style_set_grid_cell_column_span);
    
/* Reusing lv_style_set_size for lv_style_set_grid_cell_row_pos */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_grid_cell_row_pos_obj, 2, mp_lv_style_set_size, lv_style_set_grid_cell_row_pos);
    
/* Reusing lv_style_set_size for lv_style_set_grid_cell_row_span */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_grid_cell_row_span_obj, 2, mp_lv_style_set_size, lv_style_set_grid_cell_row_span);
    
/* Reusing lv_style_set_size for lv_style_set_grid_cell_x_align */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_grid_cell_x_align_obj, 2, mp_lv_style_set_size, lv_style_set_grid_cell_x_align);
    
/* Reusing lv_style_set_size for lv_style_set_grid_cell_y_align */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_grid_cell_y_align_obj, 2, mp_lv_style_set_size, lv_style_set_grid_cell_y_align);
    

STATIC const mp_rom_map_elem_t mp_lv_style_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_style_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_prop_inlined), MP_ROM_PTR(&mp_lv_style_get_prop_inlined_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_size), MP_ROM_PTR(&mp_lv_style_set_size_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_pad_all), MP_ROM_PTR(&mp_lv_style_set_pad_all_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_pad_hor), MP_ROM_PTR(&mp_lv_style_set_pad_hor_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_pad_ver), MP_ROM_PTR(&mp_lv_style_set_pad_ver_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_pad_gap), MP_ROM_PTR(&mp_lv_style_set_pad_gap_obj) },
    { MP_ROM_QSTR(MP_QSTR_init), MP_ROM_PTR(&mp_lv_style_init_obj) },
    { MP_ROM_QSTR(MP_QSTR_reset), MP_ROM_PTR(&mp_lv_style_reset_obj) },
    { MP_ROM_QSTR(MP_QSTR_remove_prop), MP_ROM_PTR(&mp_lv_style_remove_prop_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_prop), MP_ROM_PTR(&mp_lv_style_set_prop_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_prop_meta), MP_ROM_PTR(&mp_lv_style_set_prop_meta_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_prop), MP_ROM_PTR(&mp_lv_style_get_prop_obj) },
    { MP_ROM_QSTR(MP_QSTR_is_empty), MP_ROM_PTR(&mp_lv_style_is_empty_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_width), MP_ROM_PTR(&mp_lv_style_set_width_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_min_width), MP_ROM_PTR(&mp_lv_style_set_min_width_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_max_width), MP_ROM_PTR(&mp_lv_style_set_max_width_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_height), MP_ROM_PTR(&mp_lv_style_set_height_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_min_height), MP_ROM_PTR(&mp_lv_style_set_min_height_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_max_height), MP_ROM_PTR(&mp_lv_style_set_max_height_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_x), MP_ROM_PTR(&mp_lv_style_set_x_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_y), MP_ROM_PTR(&mp_lv_style_set_y_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_align), MP_ROM_PTR(&mp_lv_style_set_align_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_transform_width), MP_ROM_PTR(&mp_lv_style_set_transform_width_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_transform_height), MP_ROM_PTR(&mp_lv_style_set_transform_height_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_translate_x), MP_ROM_PTR(&mp_lv_style_set_translate_x_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_translate_y), MP_ROM_PTR(&mp_lv_style_set_translate_y_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_transform_zoom), MP_ROM_PTR(&mp_lv_style_set_transform_zoom_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_transform_angle), MP_ROM_PTR(&mp_lv_style_set_transform_angle_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_transform_pivot_x), MP_ROM_PTR(&mp_lv_style_set_transform_pivot_x_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_transform_pivot_y), MP_ROM_PTR(&mp_lv_style_set_transform_pivot_y_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_pad_top), MP_ROM_PTR(&mp_lv_style_set_pad_top_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_pad_bottom), MP_ROM_PTR(&mp_lv_style_set_pad_bottom_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_pad_left), MP_ROM_PTR(&mp_lv_style_set_pad_left_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_pad_right), MP_ROM_PTR(&mp_lv_style_set_pad_right_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_pad_row), MP_ROM_PTR(&mp_lv_style_set_pad_row_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_pad_column), MP_ROM_PTR(&mp_lv_style_set_pad_column_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_bg_color), MP_ROM_PTR(&mp_lv_style_set_bg_color_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_bg_opa), MP_ROM_PTR(&mp_lv_style_set_bg_opa_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_bg_grad_color), MP_ROM_PTR(&mp_lv_style_set_bg_grad_color_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_bg_grad_dir), MP_ROM_PTR(&mp_lv_style_set_bg_grad_dir_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_bg_main_stop), MP_ROM_PTR(&mp_lv_style_set_bg_main_stop_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_bg_grad_stop), MP_ROM_PTR(&mp_lv_style_set_bg_grad_stop_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_bg_grad), MP_ROM_PTR(&mp_lv_style_set_bg_grad_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_bg_dither_mode), MP_ROM_PTR(&mp_lv_style_set_bg_dither_mode_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_bg_img_src), MP_ROM_PTR(&mp_lv_style_set_bg_img_src_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_bg_img_opa), MP_ROM_PTR(&mp_lv_style_set_bg_img_opa_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_bg_img_recolor), MP_ROM_PTR(&mp_lv_style_set_bg_img_recolor_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_bg_img_recolor_opa), MP_ROM_PTR(&mp_lv_style_set_bg_img_recolor_opa_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_bg_img_tiled), MP_ROM_PTR(&mp_lv_style_set_bg_img_tiled_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_border_color), MP_ROM_PTR(&mp_lv_style_set_border_color_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_border_opa), MP_ROM_PTR(&mp_lv_style_set_border_opa_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_border_width), MP_ROM_PTR(&mp_lv_style_set_border_width_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_border_side), MP_ROM_PTR(&mp_lv_style_set_border_side_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_border_post), MP_ROM_PTR(&mp_lv_style_set_border_post_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_outline_width), MP_ROM_PTR(&mp_lv_style_set_outline_width_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_outline_color), MP_ROM_PTR(&mp_lv_style_set_outline_color_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_outline_opa), MP_ROM_PTR(&mp_lv_style_set_outline_opa_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_outline_pad), MP_ROM_PTR(&mp_lv_style_set_outline_pad_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_shadow_width), MP_ROM_PTR(&mp_lv_style_set_shadow_width_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_shadow_ofs_x), MP_ROM_PTR(&mp_lv_style_set_shadow_ofs_x_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_shadow_ofs_y), MP_ROM_PTR(&mp_lv_style_set_shadow_ofs_y_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_shadow_spread), MP_ROM_PTR(&mp_lv_style_set_shadow_spread_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_shadow_color), MP_ROM_PTR(&mp_lv_style_set_shadow_color_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_shadow_opa), MP_ROM_PTR(&mp_lv_style_set_shadow_opa_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_img_opa), MP_ROM_PTR(&mp_lv_style_set_img_opa_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_img_recolor), MP_ROM_PTR(&mp_lv_style_set_img_recolor_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_img_recolor_opa), MP_ROM_PTR(&mp_lv_style_set_img_recolor_opa_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_line_width), MP_ROM_PTR(&mp_lv_style_set_line_width_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_line_dash_width), MP_ROM_PTR(&mp_lv_style_set_line_dash_width_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_line_dash_gap), MP_ROM_PTR(&mp_lv_style_set_line_dash_gap_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_line_rounded), MP_ROM_PTR(&mp_lv_style_set_line_rounded_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_line_color), MP_ROM_PTR(&mp_lv_style_set_line_color_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_line_opa), MP_ROM_PTR(&mp_lv_style_set_line_opa_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_arc_width), MP_ROM_PTR(&mp_lv_style_set_arc_width_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_arc_rounded), MP_ROM_PTR(&mp_lv_style_set_arc_rounded_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_arc_color), MP_ROM_PTR(&mp_lv_style_set_arc_color_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_arc_opa), MP_ROM_PTR(&mp_lv_style_set_arc_opa_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_arc_img_src), MP_ROM_PTR(&mp_lv_style_set_arc_img_src_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_text_color), MP_ROM_PTR(&mp_lv_style_set_text_color_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_text_opa), MP_ROM_PTR(&mp_lv_style_set_text_opa_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_text_font), MP_ROM_PTR(&mp_lv_style_set_text_font_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_text_letter_space), MP_ROM_PTR(&mp_lv_style_set_text_letter_space_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_text_line_space), MP_ROM_PTR(&mp_lv_style_set_text_line_space_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_text_decor), MP_ROM_PTR(&mp_lv_style_set_text_decor_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_text_align), MP_ROM_PTR(&mp_lv_style_set_text_align_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_radius), MP_ROM_PTR(&mp_lv_style_set_radius_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_clip_corner), MP_ROM_PTR(&mp_lv_style_set_clip_corner_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_opa), MP_ROM_PTR(&mp_lv_style_set_opa_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_color_filter_dsc), MP_ROM_PTR(&mp_lv_style_set_color_filter_dsc_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_color_filter_opa), MP_ROM_PTR(&mp_lv_style_set_color_filter_opa_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_anim), MP_ROM_PTR(&mp_lv_style_set_anim_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_anim_time), MP_ROM_PTR(&mp_lv_style_set_anim_time_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_anim_speed), MP_ROM_PTR(&mp_lv_style_set_anim_speed_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_transition), MP_ROM_PTR(&mp_lv_style_set_transition_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_blend_mode), MP_ROM_PTR(&mp_lv_style_set_blend_mode_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_layout), MP_ROM_PTR(&mp_lv_style_set_layout_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_base_dir), MP_ROM_PTR(&mp_lv_style_set_base_dir_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_flex_flow), MP_ROM_PTR(&mp_lv_style_set_flex_flow_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_flex_main_place), MP_ROM_PTR(&mp_lv_style_set_flex_main_place_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_flex_cross_place), MP_ROM_PTR(&mp_lv_style_set_flex_cross_place_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_flex_track_place), MP_ROM_PTR(&mp_lv_style_set_flex_track_place_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_flex_grow), MP_ROM_PTR(&mp_lv_style_set_flex_grow_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_grid_row_dsc_array), MP_ROM_PTR(&mp_lv_style_set_grid_row_dsc_array_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_grid_column_dsc_array), MP_ROM_PTR(&mp_lv_style_set_grid_column_dsc_array_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_grid_row_align), MP_ROM_PTR(&mp_lv_style_set_grid_row_align_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_grid_column_align), MP_ROM_PTR(&mp_lv_style_set_grid_column_align_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_grid_cell_column_pos), MP_ROM_PTR(&mp_lv_style_set_grid_cell_column_pos_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_grid_cell_column_span), MP_ROM_PTR(&mp_lv_style_set_grid_cell_column_span_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_grid_cell_row_pos), MP_ROM_PTR(&mp_lv_style_set_grid_cell_row_pos_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_grid_cell_row_span), MP_ROM_PTR(&mp_lv_style_set_grid_cell_row_span_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_grid_cell_x_align), MP_ROM_PTR(&mp_lv_style_set_grid_cell_x_align_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_grid_cell_y_align), MP_ROM_PTR(&mp_lv_style_set_grid_cell_y_align_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_style_t_locals_dict, mp_lv_style_t_locals_dict_table);
        

STATIC const mp_rom_map_elem_t mp_lv_style_v_p_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_style_v_p_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_style_v_p_t_locals_dict, mp_lv_style_v_p_t_locals_dict_table);
        

STATIC const mp_rom_map_elem_t mp_lv_style_value_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_style_value_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_style_value_t_locals_dict, mp_lv_style_value_t_locals_dict_table);
        

STATIC const mp_rom_map_elem_t mp_lv_style_const_prop_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_style_const_prop_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_style_const_prop_t_locals_dict, mp_lv_style_const_prop_t_locals_dict_table);
        

STATIC const mp_rom_map_elem_t mp_lv_obj_draw_part_dsc_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_obj_draw_part_dsc_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    { MP_ROM_QSTR(MP_QSTR_dsc_init), MP_ROM_PTR(&mp_lv_obj_draw_dsc_init_obj) },
    { MP_ROM_QSTR(MP_QSTR_check_type), MP_ROM_PTR(&mp_lv_obj_draw_part_check_type_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_obj_draw_part_dsc_t_locals_dict, mp_lv_obj_draw_part_dsc_t_locals_dict_table);
        

STATIC const mp_rom_map_elem_t mp_lv_obj_class_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_obj_class_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    { MP_ROM_QSTR(MP_QSTR_create_obj), MP_ROM_PTR(&mp_lv_obj_class_create_obj_obj) },
    { MP_ROM_QSTR(MP_QSTR_event_base), MP_ROM_PTR(&mp_lv_obj_event_base_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_obj_class_t_locals_dict, mp_lv_obj_class_t_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * struct _lv_obj_t *lv_event_get_target(lv_event_t *e)
 */
 
STATIC mp_obj_t mp_lv_event_get_target(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_event_t *e = mp_write_ptr_lv_event_t(mp_args[0]);
    lv_obj_t * _res = ((struct _lv_obj_t *(*)(lv_event_t *))lv_func_ptr)(e);
    return lv_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_event_get_target_obj, 1, mp_lv_event_get_target, lv_event_get_target);
    
/* Reusing lv_event_get_target for lv_event_get_current_target */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_event_get_current_target_obj, 1, mp_lv_event_get_target, lv_event_get_current_target);
    

/*
 * lvgl extension definition for:
 * lv_event_code_t lv_event_get_code(lv_event_t *e)
 */
 
STATIC mp_obj_t mp_lv_event_get_code(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_event_t *e = mp_write_ptr_lv_event_t(mp_args[0]);
    lv_event_code_t _res = ((lv_event_code_t (*)(lv_event_t *))lv_func_ptr)(e);
    return mp_obj_new_int(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_event_get_code_obj, 1, mp_lv_event_get_code, lv_event_get_code);
    

/*
 * lvgl extension definition for:
 * void *lv_event_get_param(lv_event_t *e)
 */
 
STATIC mp_obj_t mp_lv_event_get_param(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_event_t *e = mp_write_ptr_lv_event_t(mp_args[0]);
    void * _res = ((void *(*)(lv_event_t *))lv_func_ptr)(e);
    return ptr_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_event_get_param_obj, 1, mp_lv_event_get_param, lv_event_get_param);
    
/* Reusing lv_event_get_param for lv_event_get_user_data */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_event_get_user_data_obj, 1, mp_lv_event_get_param, lv_event_get_user_data);
    
/* Reusing lv_keyboard_def_event_cb for lv_event_stop_bubbling */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_event_stop_bubbling_obj, 1, mp_lv_keyboard_def_event_cb, lv_event_stop_bubbling);
    
/* Reusing lv_keyboard_def_event_cb for lv_event_stop_processing */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_event_stop_processing_obj, 1, mp_lv_keyboard_def_event_cb, lv_event_stop_processing);
    

/*
 * lvgl extension definition for:
 * lv_indev_t *lv_event_get_indev(lv_event_t *e)
 */
 
STATIC mp_obj_t mp_lv_event_get_indev(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_event_t *e = mp_write_ptr_lv_event_t(mp_args[0]);
    lv_indev_t * _res = ((lv_indev_t *(*)(lv_event_t *))lv_func_ptr)(e);
    return mp_read_ptr_lv_indev_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_event_get_indev_obj, 1, mp_lv_event_get_indev, lv_event_get_indev);
    

/*
 * lvgl extension definition for:
 * lv_obj_draw_part_dsc_t *lv_event_get_draw_part_dsc(lv_event_t *e)
 */
 
STATIC mp_obj_t mp_lv_event_get_draw_part_dsc(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_event_t *e = mp_write_ptr_lv_event_t(mp_args[0]);
    lv_obj_draw_part_dsc_t * _res = ((lv_obj_draw_part_dsc_t *(*)(lv_event_t *))lv_func_ptr)(e);
    return mp_read_ptr_lv_obj_draw_part_dsc_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_event_get_draw_part_dsc_obj, 1, mp_lv_event_get_draw_part_dsc, lv_event_get_draw_part_dsc);
    

/*
 * lvgl extension definition for:
 * lv_draw_ctx_t *lv_event_get_draw_ctx(lv_event_t *e)
 */
 
STATIC mp_obj_t mp_lv_event_get_draw_ctx(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_event_t *e = mp_write_ptr_lv_event_t(mp_args[0]);
    lv_draw_ctx_t * _res = ((lv_draw_ctx_t *(*)(lv_event_t *))lv_func_ptr)(e);
    return mp_read_ptr_lv_draw_ctx_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_event_get_draw_ctx_obj, 1, mp_lv_event_get_draw_ctx, lv_event_get_draw_ctx);
    

/*
 * lvgl extension definition for:
 * const lv_area_t *lv_event_get_old_size(lv_event_t *e)
 */
 
STATIC mp_obj_t mp_lv_event_get_old_size(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_event_t *e = mp_write_ptr_lv_event_t(mp_args[0]);
    const lv_area_t * _res = ((const lv_area_t *(*)(lv_event_t *))lv_func_ptr)(e);
    return mp_read_ptr_lv_area_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_event_get_old_size_obj, 1, mp_lv_event_get_old_size, lv_event_get_old_size);
    

/*
 * lvgl extension definition for:
 * uint32_t lv_event_get_key(lv_event_t *e)
 */
 
STATIC mp_obj_t mp_lv_event_get_key(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_event_t *e = mp_write_ptr_lv_event_t(mp_args[0]);
    uint32_t _res = ((uint32_t (*)(lv_event_t *))lv_func_ptr)(e);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_event_get_key_obj, 1, mp_lv_event_get_key, lv_event_get_key);
    

/*
 * lvgl extension definition for:
 * lv_anim_t *lv_event_get_scroll_anim(lv_event_t *e)
 */
 
STATIC mp_obj_t mp_lv_event_get_scroll_anim(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_event_t *e = mp_write_ptr_lv_event_t(mp_args[0]);
    lv_anim_t * _res = ((lv_anim_t *(*)(lv_event_t *))lv_func_ptr)(e);
    return mp_read_ptr_lv_anim_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_event_get_scroll_anim_obj, 1, mp_lv_event_get_scroll_anim, lv_event_get_scroll_anim);
    

/*
 * lvgl extension definition for:
 * void lv_event_set_ext_draw_size(lv_event_t *e, lv_coord_t size)
 */
 
STATIC mp_obj_t mp_lv_event_set_ext_draw_size(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_event_t *e = mp_write_ptr_lv_event_t(mp_args[0]);
    lv_coord_t size = (int16_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_event_t *, lv_coord_t))lv_func_ptr)(e, size);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_event_set_ext_draw_size_obj, 2, mp_lv_event_set_ext_draw_size, lv_event_set_ext_draw_size);
    

/*
 * lvgl extension definition for:
 * lv_point_t *lv_event_get_self_size_info(lv_event_t *e)
 */
 
STATIC mp_obj_t mp_lv_event_get_self_size_info(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_event_t *e = mp_write_ptr_lv_event_t(mp_args[0]);
    lv_point_t * _res = ((lv_point_t *(*)(lv_event_t *))lv_func_ptr)(e);
    return mp_read_ptr_lv_point_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_event_get_self_size_info_obj, 1, mp_lv_event_get_self_size_info, lv_event_get_self_size_info);
    

/*
 * Struct lv_hit_test_info_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_hit_test_info_t_type();

STATIC inline lv_hit_test_info_t* mp_write_ptr_lv_hit_test_info_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_hit_test_info_t_type()));
    return (lv_hit_test_info_t*)self->data;
}

#define mp_write_lv_hit_test_info_t(struct_obj) *mp_write_ptr_lv_hit_test_info_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_hit_test_info_t(lv_hit_test_info_t *field)
{
    return lv_to_mp_struct(get_mp_lv_hit_test_info_t_type(), (void*)field);
}

#define mp_read_lv_hit_test_info_t(field) mp_read_ptr_lv_hit_test_info_t(copy_buffer(&field, sizeof(lv_hit_test_info_t)))
#define mp_read_byref_lv_hit_test_info_t(field) mp_read_ptr_lv_hit_test_info_t(&field)

STATIC void mp_lv_hit_test_info_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_hit_test_info_t *data = (lv_hit_test_info_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_point: dest[0] = mp_read_ptr_lv_point_t((void*)data->point); break; // converting from lv_point_t *;
            case MP_QSTR_res: dest[0] = convert_to_bool(data->res); break; // converting from bool;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_point: data->point = (void*)mp_write_ptr_lv_point_t(dest[1]); break; // converting to lv_point_t *;
                case MP_QSTR_res: data->res = mp_obj_is_true(dest[1]); break; // converting to bool;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_hit_test_info_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_hit_test_info_t");
}

STATIC const mp_obj_dict_t mp_lv_hit_test_info_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_hit_test_info_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_hit_test_info_t,
    .print = mp_lv_hit_test_info_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_hit_test_info_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_hit_test_info_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_hit_test_info_t_type()
{
    return &mp_lv_hit_test_info_t_type;
}
    

/*
 * lvgl extension definition for:
 * lv_hit_test_info_t *lv_event_get_hit_test_info(lv_event_t *e)
 */
 
STATIC mp_obj_t mp_lv_event_get_hit_test_info(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_event_t *e = mp_write_ptr_lv_event_t(mp_args[0]);
    lv_hit_test_info_t * _res = ((lv_hit_test_info_t *(*)(lv_event_t *))lv_func_ptr)(e);
    return mp_read_ptr_lv_hit_test_info_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_event_get_hit_test_info_obj, 1, mp_lv_event_get_hit_test_info, lv_event_get_hit_test_info);
    
/* Reusing lv_event_get_old_size for lv_event_get_cover_area */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_event_get_cover_area_obj, 1, mp_lv_event_get_old_size, lv_event_get_cover_area);
    

/*
 * lvgl extension definition for:
 * void lv_event_set_cover_res(lv_event_t *e, lv_cover_res_t res)
 */
 
STATIC mp_obj_t mp_lv_event_set_cover_res(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_event_t *e = mp_write_ptr_lv_event_t(mp_args[0]);
    lv_cover_res_t res = (int)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_event_t *, lv_cover_res_t))lv_func_ptr)(e, res);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_event_set_cover_res_obj, 2, mp_lv_event_set_cover_res, lv_event_set_cover_res);
    

STATIC const mp_rom_map_elem_t mp_lv_event_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_event_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_target), MP_ROM_PTR(&mp_lv_event_get_target_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_current_target), MP_ROM_PTR(&mp_lv_event_get_current_target_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_code), MP_ROM_PTR(&mp_lv_event_get_code_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_param), MP_ROM_PTR(&mp_lv_event_get_param_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_user_data), MP_ROM_PTR(&mp_lv_event_get_user_data_obj) },
    { MP_ROM_QSTR(MP_QSTR_stop_bubbling), MP_ROM_PTR(&mp_lv_event_stop_bubbling_obj) },
    { MP_ROM_QSTR(MP_QSTR_stop_processing), MP_ROM_PTR(&mp_lv_event_stop_processing_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_indev), MP_ROM_PTR(&mp_lv_event_get_indev_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_draw_part_dsc), MP_ROM_PTR(&mp_lv_event_get_draw_part_dsc_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_draw_ctx), MP_ROM_PTR(&mp_lv_event_get_draw_ctx_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_old_size), MP_ROM_PTR(&mp_lv_event_get_old_size_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_key), MP_ROM_PTR(&mp_lv_event_get_key_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_scroll_anim), MP_ROM_PTR(&mp_lv_event_get_scroll_anim_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_ext_draw_size), MP_ROM_PTR(&mp_lv_event_set_ext_draw_size_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_self_size_info), MP_ROM_PTR(&mp_lv_event_get_self_size_info_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_hit_test_info), MP_ROM_PTR(&mp_lv_event_get_hit_test_info_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_cover_area), MP_ROM_PTR(&mp_lv_event_get_cover_area_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_cover_res), MP_ROM_PTR(&mp_lv_event_set_cover_res_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_event_t_locals_dict, mp_lv_event_t_locals_dict_table);
        

STATIC const mp_rom_map_elem_t mp_lv_img_dsc_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_img_dsc_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    { MP_ROM_QSTR(MP_QSTR_buf_get_px_color), MP_ROM_PTR(&mp_lv_img_buf_get_px_color_obj) },
    { MP_ROM_QSTR(MP_QSTR_buf_get_px_alpha), MP_ROM_PTR(&mp_lv_img_buf_get_px_alpha_obj) },
    { MP_ROM_QSTR(MP_QSTR_buf_set_px_color), MP_ROM_PTR(&mp_lv_img_buf_set_px_color_obj) },
    { MP_ROM_QSTR(MP_QSTR_buf_set_px_alpha), MP_ROM_PTR(&mp_lv_img_buf_set_px_alpha_obj) },
    { MP_ROM_QSTR(MP_QSTR_buf_set_palette), MP_ROM_PTR(&mp_lv_img_buf_set_palette_obj) },
    { MP_ROM_QSTR(MP_QSTR_buf_free), MP_ROM_PTR(&mp_lv_img_buf_free_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_img_dsc_t_locals_dict, mp_lv_img_dsc_t_locals_dict_table);
        

STATIC const mp_rom_map_elem_t mp_lv_img_header_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_img_header_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_img_header_t_locals_dict, mp_lv_img_header_t_locals_dict_table);
        

STATIC const mp_rom_map_elem_t mp_lv_img_decoder_dsc_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_img_decoder_dsc_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    { MP_ROM_QSTR(MP_QSTR_open), MP_ROM_PTR(&mp_lv_img_decoder_open_obj) },
    { MP_ROM_QSTR(MP_QSTR_read_line), MP_ROM_PTR(&mp_lv_img_decoder_read_line_obj) },
    { MP_ROM_QSTR(MP_QSTR_close), MP_ROM_PTR(&mp_lv_img_decoder_close_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_img_decoder_dsc_t_locals_dict, mp_lv_img_decoder_dsc_t_locals_dict_table);
        

STATIC const mp_rom_map_elem_t mp_lv_img_decoder_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_img_decoder_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    { MP_ROM_QSTR(MP_QSTR_delete), MP_ROM_PTR(&mp_lv_img_decoder_delete_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_info_cb), MP_ROM_PTR(&mp_lv_img_decoder_set_info_cb_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_open_cb), MP_ROM_PTR(&mp_lv_img_decoder_set_open_cb_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_read_line_cb), MP_ROM_PTR(&mp_lv_img_decoder_set_read_line_cb_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_close_cb), MP_ROM_PTR(&mp_lv_img_decoder_set_close_cb_obj) },
    { MP_ROM_QSTR(MP_QSTR_built_in_info), MP_ROM_PTR(&mp_lv_img_decoder_built_in_info_obj) },
    { MP_ROM_QSTR(MP_QSTR_built_in_open), MP_ROM_PTR(&mp_lv_img_decoder_built_in_open_obj) },
    { MP_ROM_QSTR(MP_QSTR_built_in_read_line), MP_ROM_PTR(&mp_lv_img_decoder_built_in_read_line_obj) },
    { MP_ROM_QSTR(MP_QSTR_built_in_close), MP_ROM_PTR(&mp_lv_img_decoder_built_in_close_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_img_decoder_t_locals_dict, mp_lv_img_decoder_t_locals_dict_table);
        

STATIC const mp_rom_map_elem_t mp_lv_calendar_date_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_calendar_date_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_calendar_date_t_locals_dict, mp_lv_calendar_date_t_locals_dict_table);
        

STATIC const mp_rom_map_elem_t mp_lv_chart_series_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_chart_series_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_chart_series_t_locals_dict, mp_lv_chart_series_t_locals_dict_table);
        

STATIC const mp_rom_map_elem_t mp_lv_chart_cursor_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_chart_cursor_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_chart_cursor_t_locals_dict, mp_lv_chart_cursor_t_locals_dict_table);
        

STATIC const mp_rom_map_elem_t mp_lv_meter_scale_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_meter_scale_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_meter_scale_t_locals_dict, mp_lv_meter_scale_t_locals_dict_table);
        

STATIC const mp_rom_map_elem_t mp_lv_meter_indicator_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_meter_indicator_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_meter_indicator_t_locals_dict, mp_lv_meter_indicator_t_locals_dict_table);
        

STATIC const mp_rom_map_elem_t mp_lv_meter_indicator_type_data_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_meter_indicator_type_data_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_meter_indicator_type_data_t_locals_dict, mp_lv_meter_indicator_type_data_t_locals_dict_table);
        

STATIC const mp_rom_map_elem_t mp_lv_meter_indicator_type_data_needle_img_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_meter_indicator_type_data_needle_img_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_meter_indicator_type_data_needle_img_t_locals_dict, mp_lv_meter_indicator_type_data_needle_img_t_locals_dict_table);
        

STATIC const mp_rom_map_elem_t mp_lv_meter_indicator_type_data_needle_line_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_meter_indicator_type_data_needle_line_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_meter_indicator_type_data_needle_line_t_locals_dict, mp_lv_meter_indicator_type_data_needle_line_t_locals_dict_table);
        

STATIC const mp_rom_map_elem_t mp_lv_meter_indicator_type_data_arc_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_meter_indicator_type_data_arc_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_meter_indicator_type_data_arc_t_locals_dict, mp_lv_meter_indicator_type_data_arc_t_locals_dict_table);
        

STATIC const mp_rom_map_elem_t mp_lv_meter_indicator_type_data_scale_lines_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_meter_indicator_type_data_scale_lines_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_meter_indicator_type_data_scale_lines_t_locals_dict, mp_lv_meter_indicator_type_data_scale_lines_t_locals_dict_table);
        

STATIC const mp_rom_map_elem_t mp_lv_color_hsv_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_color_hsv_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_color_hsv_t_locals_dict, mp_lv_color_hsv_t_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * void lv_span_set_text(lv_span_t *span, const char *text)
 */
 
STATIC mp_obj_t mp_lv_span_set_text(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_span_t *span = mp_write_ptr_lv_span_t(mp_args[0]);
    const char *text = (char*)convert_from_str(mp_args[1]);
    ((void (*)(lv_span_t *, const char *))lv_func_ptr)(span, text);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_span_set_text_obj, 2, mp_lv_span_set_text, lv_span_set_text);
    
/* Reusing lv_span_set_text for lv_span_set_text_static */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_span_set_text_static_obj, 2, mp_lv_span_set_text, lv_span_set_text_static);
    

STATIC const mp_rom_map_elem_t mp_lv_span_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_span_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_text), MP_ROM_PTR(&mp_lv_span_set_text_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_text_static), MP_ROM_PTR(&mp_lv_span_set_text_static_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_span_t_locals_dict, mp_lv_span_t_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * void lv_mem_monitor(lv_mem_monitor_t *mon_p)
 */
 
STATIC mp_obj_t mp_lv_mem_monitor(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_mem_monitor_t *mon_p = mp_write_ptr_lv_mem_monitor_t(mp_args[0]);
    ((void (*)(lv_mem_monitor_t *))lv_func_ptr)(mon_p);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_mem_monitor_obj, 1, mp_lv_mem_monitor, lv_mem_monitor);
    

STATIC const mp_rom_map_elem_t mp_lv_mem_monitor_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_mem_monitor_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    { MP_ROM_QSTR(MP_QSTR_monitor), MP_ROM_PTR(&mp_lv_mem_monitor_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_mem_monitor_t_locals_dict, mp_lv_mem_monitor_t_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * void lv_fs_drv_init(lv_fs_drv_t *drv)
 */
 
STATIC mp_obj_t mp_lv_fs_drv_init(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_fs_drv_t *drv = mp_write_ptr_lv_fs_drv_t(mp_args[0]);
    ((void (*)(lv_fs_drv_t *))lv_func_ptr)(drv);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_fs_drv_init_obj, 1, mp_lv_fs_drv_init, lv_fs_drv_init);
    
/* Reusing lv_fs_drv_init for lv_fs_drv_register */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_fs_drv_register_obj, 1, mp_lv_fs_drv_init, lv_fs_drv_register);
    

STATIC const mp_rom_map_elem_t mp_lv_fs_drv_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_fs_drv_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    { MP_ROM_QSTR(MP_QSTR_init), MP_ROM_PTR(&mp_lv_fs_drv_init_obj) },
    { MP_ROM_QSTR(MP_QSTR_register), MP_ROM_PTR(&mp_lv_fs_drv_register_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_fs_drv_t_locals_dict, mp_lv_fs_drv_t_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * lv_fs_res_t lv_fs_open(lv_fs_file_t *file_p, const char *path, lv_fs_mode_t mode)
 */
 
STATIC mp_obj_t mp_lv_fs_open(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_fs_file_t *file_p = mp_write_ptr_lv_fs_file_t(mp_args[0]);
    const char *path = (char*)convert_from_str(mp_args[1]);
    lv_fs_mode_t mode = (uint8_t)mp_obj_get_int(mp_args[2]);
    lv_fs_res_t _res = ((lv_fs_res_t (*)(lv_fs_file_t *, const char *, lv_fs_mode_t))lv_func_ptr)(file_p, path, mode);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_fs_open_obj, 3, mp_lv_fs_open, lv_fs_open);
    

/*
 * lvgl extension definition for:
 * lv_fs_res_t lv_fs_close(lv_fs_file_t *file_p)
 */
 
STATIC mp_obj_t mp_lv_fs_close(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_fs_file_t *file_p = mp_write_ptr_lv_fs_file_t(mp_args[0]);
    lv_fs_res_t _res = ((lv_fs_res_t (*)(lv_fs_file_t *))lv_func_ptr)(file_p);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_fs_close_obj, 1, mp_lv_fs_close, lv_fs_close);
    

/*
 * lvgl extension definition for:
 * lv_fs_res_t lv_fs_read(lv_fs_file_t *file_p, void *buf, uint32_t btr, uint32_t *br)
 */
 
STATIC mp_obj_t mp_lv_fs_read(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_fs_file_t *file_p = mp_write_ptr_lv_fs_file_t(mp_args[0]);
    void *buf = mp_to_ptr(mp_args[1]);
    uint32_t btr = (uint32_t)mp_obj_get_int(mp_args[2]);
    uint32_t *br = mp_to_ptr(mp_args[3]);
    lv_fs_res_t _res = ((lv_fs_res_t (*)(lv_fs_file_t *, void *, uint32_t, uint32_t *))lv_func_ptr)(file_p, buf, btr, br);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_fs_read_obj, 4, mp_lv_fs_read, lv_fs_read);
    

/*
 * lvgl extension definition for:
 * lv_fs_res_t lv_fs_write(lv_fs_file_t *file_p, const void *buf, uint32_t btw, uint32_t *bw)
 */
 
STATIC mp_obj_t mp_lv_fs_write(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_fs_file_t *file_p = mp_write_ptr_lv_fs_file_t(mp_args[0]);
    const void *buf = mp_to_ptr(mp_args[1]);
    uint32_t btw = (uint32_t)mp_obj_get_int(mp_args[2]);
    uint32_t *bw = mp_to_ptr(mp_args[3]);
    lv_fs_res_t _res = ((lv_fs_res_t (*)(lv_fs_file_t *, const void *, uint32_t, uint32_t *))lv_func_ptr)(file_p, buf, btw, bw);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_fs_write_obj, 4, mp_lv_fs_write, lv_fs_write);
    

/*
 * lvgl extension definition for:
 * lv_fs_res_t lv_fs_seek(lv_fs_file_t *file_p, uint32_t pos, lv_fs_whence_t whence)
 */
 
STATIC mp_obj_t mp_lv_fs_seek(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_fs_file_t *file_p = mp_write_ptr_lv_fs_file_t(mp_args[0]);
    uint32_t pos = (uint32_t)mp_obj_get_int(mp_args[1]);
    lv_fs_whence_t whence = (int)mp_obj_get_int(mp_args[2]);
    lv_fs_res_t _res = ((lv_fs_res_t (*)(lv_fs_file_t *, uint32_t, lv_fs_whence_t))lv_func_ptr)(file_p, pos, whence);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_fs_seek_obj, 3, mp_lv_fs_seek, lv_fs_seek);
    

/*
 * lvgl extension definition for:
 * lv_fs_res_t lv_fs_tell(lv_fs_file_t *file_p, uint32_t *pos)
 */
 
STATIC mp_obj_t mp_lv_fs_tell(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_fs_file_t *file_p = mp_write_ptr_lv_fs_file_t(mp_args[0]);
    uint32_t *pos = mp_to_ptr(mp_args[1]);
    lv_fs_res_t _res = ((lv_fs_res_t (*)(lv_fs_file_t *, uint32_t *))lv_func_ptr)(file_p, pos);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_fs_tell_obj, 2, mp_lv_fs_tell, lv_fs_tell);
    

STATIC const mp_rom_map_elem_t mp_lv_fs_file_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_fs_file_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    { MP_ROM_QSTR(MP_QSTR_open), MP_ROM_PTR(&mp_lv_fs_open_obj) },
    { MP_ROM_QSTR(MP_QSTR_close), MP_ROM_PTR(&mp_lv_fs_close_obj) },
    { MP_ROM_QSTR(MP_QSTR_read), MP_ROM_PTR(&mp_lv_fs_read_obj) },
    { MP_ROM_QSTR(MP_QSTR_write), MP_ROM_PTR(&mp_lv_fs_write_obj) },
    { MP_ROM_QSTR(MP_QSTR_seek), MP_ROM_PTR(&mp_lv_fs_seek_obj) },
    { MP_ROM_QSTR(MP_QSTR_tell), MP_ROM_PTR(&mp_lv_fs_tell_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_fs_file_t_locals_dict, mp_lv_fs_file_t_locals_dict_table);
        

STATIC const mp_rom_map_elem_t mp_lv_fs_file_cache_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_fs_file_cache_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_fs_file_cache_t_locals_dict, mp_lv_fs_file_cache_t_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * lv_fs_res_t lv_fs_dir_open(lv_fs_dir_t *rddir_p, const char *path)
 */
 
STATIC mp_obj_t mp_lv_fs_dir_open(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_fs_dir_t *rddir_p = mp_write_ptr_lv_fs_dir_t(mp_args[0]);
    const char *path = (char*)convert_from_str(mp_args[1]);
    lv_fs_res_t _res = ((lv_fs_res_t (*)(lv_fs_dir_t *, const char *))lv_func_ptr)(rddir_p, path);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_fs_dir_open_obj, 2, mp_lv_fs_dir_open, lv_fs_dir_open);
    

/*
 * lvgl extension definition for:
 * lv_fs_res_t lv_fs_dir_read(lv_fs_dir_t *rddir_p, char *fn)
 */
 
STATIC mp_obj_t mp_lv_fs_dir_read(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_fs_dir_t *rddir_p = mp_write_ptr_lv_fs_dir_t(mp_args[0]);
    char *fn = (char*)convert_from_str(mp_args[1]);
    lv_fs_res_t _res = ((lv_fs_res_t (*)(lv_fs_dir_t *, char *))lv_func_ptr)(rddir_p, fn);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_fs_dir_read_obj, 2, mp_lv_fs_dir_read, lv_fs_dir_read);
    

/*
 * lvgl extension definition for:
 * lv_fs_res_t lv_fs_dir_close(lv_fs_dir_t *rddir_p)
 */
 
STATIC mp_obj_t mp_lv_fs_dir_close(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_fs_dir_t *rddir_p = mp_write_ptr_lv_fs_dir_t(mp_args[0]);
    lv_fs_res_t _res = ((lv_fs_res_t (*)(lv_fs_dir_t *))lv_func_ptr)(rddir_p);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_fs_dir_close_obj, 1, mp_lv_fs_dir_close, lv_fs_dir_close);
    

STATIC const mp_rom_map_elem_t mp_lv_fs_dir_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_fs_dir_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    { MP_ROM_QSTR(MP_QSTR_open), MP_ROM_PTR(&mp_lv_fs_dir_open_obj) },
    { MP_ROM_QSTR(MP_QSTR_read), MP_ROM_PTR(&mp_lv_fs_dir_read_obj) },
    { MP_ROM_QSTR(MP_QSTR_close), MP_ROM_PTR(&mp_lv_fs_dir_close_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_fs_dir_t_locals_dict, mp_lv_fs_dir_t_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * void lv_gradient_cleanup(lv_grad_t *grad)
 */
 
STATIC mp_obj_t mp_lv_gradient_cleanup(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_grad_t *grad = mp_write_ptr_lv_grad_t(mp_args[0]);
    ((void (*)(lv_grad_t *))lv_func_ptr)(grad);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_gradient_cleanup_obj, 1, mp_lv_gradient_cleanup, lv_gradient_cleanup);
    

STATIC const mp_rom_map_elem_t mp_lv_grad_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_grad_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    { MP_ROM_QSTR(MP_QSTR_gradient_cleanup), MP_ROM_PTR(&mp_lv_gradient_cleanup_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_grad_t_locals_dict, mp_lv_grad_t_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * void lv_draw_mask_line_points_init(lv_draw_mask_line_param_t *param, lv_coord_t p1x, lv_coord_t p1y, lv_coord_t p2x, lv_coord_t p2y, lv_draw_mask_line_side_t side)
 */
 
STATIC mp_obj_t mp_lv_draw_mask_line_points_init(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_draw_mask_line_param_t *param = mp_write_ptr_lv_draw_mask_line_param_t(mp_args[0]);
    lv_coord_t p1x = (int16_t)mp_obj_get_int(mp_args[1]);
    lv_coord_t p1y = (int16_t)mp_obj_get_int(mp_args[2]);
    lv_coord_t p2x = (int16_t)mp_obj_get_int(mp_args[3]);
    lv_coord_t p2y = (int16_t)mp_obj_get_int(mp_args[4]);
    lv_draw_mask_line_side_t side = (uint8_t)mp_obj_get_int(mp_args[5]);
    ((void (*)(lv_draw_mask_line_param_t *, lv_coord_t, lv_coord_t, lv_coord_t, lv_coord_t, lv_draw_mask_line_side_t))lv_func_ptr)(param, p1x, p1y, p2x, p2y, side);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_draw_mask_line_points_init_obj, 6, mp_lv_draw_mask_line_points_init, lv_draw_mask_line_points_init);
    

/*
 * lvgl extension definition for:
 * void lv_draw_mask_line_angle_init(lv_draw_mask_line_param_t *param, lv_coord_t p1x, lv_coord_t py, int16_t angle, lv_draw_mask_line_side_t side)
 */
 
STATIC mp_obj_t mp_lv_draw_mask_line_angle_init(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_draw_mask_line_param_t *param = mp_write_ptr_lv_draw_mask_line_param_t(mp_args[0]);
    lv_coord_t p1x = (int16_t)mp_obj_get_int(mp_args[1]);
    lv_coord_t py = (int16_t)mp_obj_get_int(mp_args[2]);
    int16_t angle = (int16_t)mp_obj_get_int(mp_args[3]);
    lv_draw_mask_line_side_t side = (uint8_t)mp_obj_get_int(mp_args[4]);
    ((void (*)(lv_draw_mask_line_param_t *, lv_coord_t, lv_coord_t, int16_t, lv_draw_mask_line_side_t))lv_func_ptr)(param, p1x, py, angle, side);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_draw_mask_line_angle_init_obj, 5, mp_lv_draw_mask_line_angle_init, lv_draw_mask_line_angle_init);
    

STATIC const mp_rom_map_elem_t mp_lv_draw_mask_line_param_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_draw_mask_line_param_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    { MP_ROM_QSTR(MP_QSTR_points_init), MP_ROM_PTR(&mp_lv_draw_mask_line_points_init_obj) },
    { MP_ROM_QSTR(MP_QSTR_angle_init), MP_ROM_PTR(&mp_lv_draw_mask_line_angle_init_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_draw_mask_line_param_t_locals_dict, mp_lv_draw_mask_line_param_t_locals_dict_table);
        

STATIC const mp_rom_map_elem_t mp__lv_draw_mask_common_dsc_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(_lv_draw_mask_common_dsc_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp__lv_draw_mask_common_dsc_t_locals_dict, mp__lv_draw_mask_common_dsc_t_locals_dict_table);
        

STATIC const mp_rom_map_elem_t mp_lv_draw_mask_line_param_cfg_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_draw_mask_line_param_cfg_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_draw_mask_line_param_cfg_t_locals_dict, mp_lv_draw_mask_line_param_cfg_t_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * void lv_draw_mask_angle_init(lv_draw_mask_angle_param_t *param, lv_coord_t vertex_x, lv_coord_t vertex_y, lv_coord_t start_angle, lv_coord_t end_angle)
 */
 
STATIC mp_obj_t mp_lv_draw_mask_angle_init(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_draw_mask_angle_param_t *param = mp_write_ptr_lv_draw_mask_angle_param_t(mp_args[0]);
    lv_coord_t vertex_x = (int16_t)mp_obj_get_int(mp_args[1]);
    lv_coord_t vertex_y = (int16_t)mp_obj_get_int(mp_args[2]);
    lv_coord_t start_angle = (int16_t)mp_obj_get_int(mp_args[3]);
    lv_coord_t end_angle = (int16_t)mp_obj_get_int(mp_args[4]);
    ((void (*)(lv_draw_mask_angle_param_t *, lv_coord_t, lv_coord_t, lv_coord_t, lv_coord_t))lv_func_ptr)(param, vertex_x, vertex_y, start_angle, end_angle);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_draw_mask_angle_init_obj, 5, mp_lv_draw_mask_angle_init, lv_draw_mask_angle_init);
    

STATIC const mp_rom_map_elem_t mp_lv_draw_mask_angle_param_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_draw_mask_angle_param_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    { MP_ROM_QSTR(MP_QSTR_init), MP_ROM_PTR(&mp_lv_draw_mask_angle_init_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_draw_mask_angle_param_t_locals_dict, mp_lv_draw_mask_angle_param_t_locals_dict_table);
        

STATIC const mp_rom_map_elem_t mp_lv_draw_mask_angle_param_cfg_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_draw_mask_angle_param_cfg_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_draw_mask_angle_param_cfg_t_locals_dict, mp_lv_draw_mask_angle_param_cfg_t_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * void lv_draw_mask_radius_init(lv_draw_mask_radius_param_t *param, const lv_area_t *rect, lv_coord_t radius, bool inv)
 */
 
STATIC mp_obj_t mp_lv_draw_mask_radius_init(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_draw_mask_radius_param_t *param = mp_write_ptr_lv_draw_mask_radius_param_t(mp_args[0]);
    const lv_area_t *rect = mp_write_ptr_lv_area_t(mp_args[1]);
    lv_coord_t radius = (int16_t)mp_obj_get_int(mp_args[2]);
    bool inv = mp_obj_is_true(mp_args[3]);
    ((void (*)(lv_draw_mask_radius_param_t *, const lv_area_t *, lv_coord_t, bool))lv_func_ptr)(param, rect, radius, inv);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_draw_mask_radius_init_obj, 4, mp_lv_draw_mask_radius_init, lv_draw_mask_radius_init);
    

STATIC const mp_rom_map_elem_t mp_lv_draw_mask_radius_param_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_draw_mask_radius_param_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    { MP_ROM_QSTR(MP_QSTR_init), MP_ROM_PTR(&mp_lv_draw_mask_radius_init_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_draw_mask_radius_param_t_locals_dict, mp_lv_draw_mask_radius_param_t_locals_dict_table);
        

STATIC const mp_rom_map_elem_t mp_lv_draw_mask_radius_param_cfg_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_draw_mask_radius_param_cfg_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_draw_mask_radius_param_cfg_t_locals_dict, mp_lv_draw_mask_radius_param_cfg_t_locals_dict_table);
        

STATIC const mp_rom_map_elem_t mp__lv_draw_mask_radius_circle_dsc_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(_lv_draw_mask_radius_circle_dsc_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp__lv_draw_mask_radius_circle_dsc_t_locals_dict, mp__lv_draw_mask_radius_circle_dsc_t_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * void lv_draw_mask_fade_init(lv_draw_mask_fade_param_t *param, const lv_area_t *coords, lv_opa_t opa_top, lv_coord_t y_top, lv_opa_t opa_bottom, lv_coord_t y_bottom)
 */
 
STATIC mp_obj_t mp_lv_draw_mask_fade_init(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_draw_mask_fade_param_t *param = mp_write_ptr_lv_draw_mask_fade_param_t(mp_args[0]);
    const lv_area_t *coords = mp_write_ptr_lv_area_t(mp_args[1]);
    lv_opa_t opa_top = (uint8_t)mp_obj_get_int(mp_args[2]);
    lv_coord_t y_top = (int16_t)mp_obj_get_int(mp_args[3]);
    lv_opa_t opa_bottom = (uint8_t)mp_obj_get_int(mp_args[4]);
    lv_coord_t y_bottom = (int16_t)mp_obj_get_int(mp_args[5]);
    ((void (*)(lv_draw_mask_fade_param_t *, const lv_area_t *, lv_opa_t, lv_coord_t, lv_opa_t, lv_coord_t))lv_func_ptr)(param, coords, opa_top, y_top, opa_bottom, y_bottom);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_draw_mask_fade_init_obj, 6, mp_lv_draw_mask_fade_init, lv_draw_mask_fade_init);
    

STATIC const mp_rom_map_elem_t mp_lv_draw_mask_fade_param_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_draw_mask_fade_param_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    { MP_ROM_QSTR(MP_QSTR_init), MP_ROM_PTR(&mp_lv_draw_mask_fade_init_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_draw_mask_fade_param_t_locals_dict, mp_lv_draw_mask_fade_param_t_locals_dict_table);
        

STATIC const mp_rom_map_elem_t mp_lv_draw_mask_fade_param_cfg_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_draw_mask_fade_param_cfg_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_draw_mask_fade_param_cfg_t_locals_dict, mp_lv_draw_mask_fade_param_cfg_t_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * void lv_draw_mask_map_init(lv_draw_mask_map_param_t *param, const lv_area_t *coords, const lv_opa_t *map)
 */
 
STATIC mp_obj_t mp_lv_draw_mask_map_init(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_draw_mask_map_param_t *param = mp_write_ptr_lv_draw_mask_map_param_t(mp_args[0]);
    const lv_area_t *coords = mp_write_ptr_lv_area_t(mp_args[1]);
    const lv_opa_t *map = mp_to_ptr(mp_args[2]);
    ((void (*)(lv_draw_mask_map_param_t *, const lv_area_t *, const lv_opa_t *))lv_func_ptr)(param, coords, map);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_draw_mask_map_init_obj, 3, mp_lv_draw_mask_map_init, lv_draw_mask_map_init);
    

STATIC const mp_rom_map_elem_t mp_lv_draw_mask_map_param_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_draw_mask_map_param_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    { MP_ROM_QSTR(MP_QSTR_init), MP_ROM_PTR(&mp_lv_draw_mask_map_init_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_draw_mask_map_param_t_locals_dict, mp_lv_draw_mask_map_param_t_locals_dict_table);
        

STATIC const mp_rom_map_elem_t mp_lv_draw_mask_map_param_cfg_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_draw_mask_map_param_cfg_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_draw_mask_map_param_cfg_t_locals_dict, mp_lv_draw_mask_map_param_cfg_t_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * void lv_draw_mask_polygon_init(lv_draw_mask_polygon_param_t *param, const lv_point_t *points, uint16_t point_cnt)
 */
 
STATIC mp_obj_t mp_lv_draw_mask_polygon_init(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_draw_mask_polygon_param_t *param = mp_write_ptr_lv_draw_mask_polygon_param_t(mp_args[0]);
    const lv_point_t *points = mp_write_ptr_lv_point_t(mp_args[1]);
    uint16_t point_cnt = (uint16_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_draw_mask_polygon_param_t *, const lv_point_t *, uint16_t))lv_func_ptr)(param, points, point_cnt);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_draw_mask_polygon_init_obj, 3, mp_lv_draw_mask_polygon_init, lv_draw_mask_polygon_init);
    

STATIC const mp_rom_map_elem_t mp_lv_draw_mask_polygon_param_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_draw_mask_polygon_param_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    { MP_ROM_QSTR(MP_QSTR_init), MP_ROM_PTR(&mp_lv_draw_mask_polygon_init_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_draw_mask_polygon_param_t_locals_dict, mp_lv_draw_mask_polygon_param_t_locals_dict_table);
        

STATIC const mp_rom_map_elem_t mp_lv_draw_mask_polygon_param_cfg_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_draw_mask_polygon_param_cfg_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_draw_mask_polygon_param_cfg_t_locals_dict, mp_lv_draw_mask_polygon_param_cfg_t_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * void lv_indev_drv_init(struct _lv_indev_drv_t *driver)
 */
 
STATIC mp_obj_t mp_lv_indev_drv_init(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_indev_drv_t *driver = mp_write_ptr_lv_indev_drv_t(mp_args[0]);
    ((void (*)(struct _lv_indev_drv_t *))lv_func_ptr)(driver);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_indev_drv_init_obj, 1, mp_lv_indev_drv_init, lv_indev_drv_init);
    

/*
 * lvgl extension definition for:
 * lv_indev_t *lv_indev_drv_register(struct _lv_indev_drv_t *driver)
 */
 
STATIC mp_obj_t mp_lv_indev_drv_register(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_indev_drv_t *driver = mp_write_ptr_lv_indev_drv_t(mp_args[0]);
    lv_indev_t * _res = ((lv_indev_t *(*)(struct _lv_indev_drv_t *))lv_func_ptr)(driver);
    return mp_read_ptr_lv_indev_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_indev_drv_register_obj, 1, mp_lv_indev_drv_register, lv_indev_drv_register);
    

STATIC const mp_rom_map_elem_t mp_lv_indev_drv_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_indev_drv_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    { MP_ROM_QSTR(MP_QSTR_init), MP_ROM_PTR(&mp_lv_indev_drv_init_obj) },
    { MP_ROM_QSTR(MP_QSTR_register), MP_ROM_PTR(&mp_lv_indev_drv_register_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_indev_drv_t_locals_dict, mp_lv_indev_drv_t_locals_dict_table);
        

STATIC const mp_rom_map_elem_t mp_lv_indev_data_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_indev_data_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_indev_data_t_locals_dict, mp_lv_indev_data_t_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * void lv_indev_drv_update(lv_indev_t *indev, struct _lv_indev_drv_t *new_drv)
 */
 
STATIC mp_obj_t mp_lv_indev_drv_update(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_indev_t *indev = mp_write_ptr_lv_indev_t(mp_args[0]);
    struct _lv_indev_drv_t *new_drv = mp_write_ptr_lv_indev_drv_t(mp_args[1]);
    ((void (*)(lv_indev_t *, struct _lv_indev_drv_t *))lv_func_ptr)(indev, new_drv);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_indev_drv_update_obj, 2, mp_lv_indev_drv_update, lv_indev_drv_update);
    

/*
 * lvgl extension definition for:
 * void lv_indev_delete(lv_indev_t *indev)
 */
 
STATIC mp_obj_t mp_lv_indev_delete(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_indev_t *indev = mp_write_ptr_lv_indev_t(mp_args[0]);
    ((void (*)(lv_indev_t *))lv_func_ptr)(indev);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_indev_delete_obj, 1, mp_lv_indev_delete, lv_indev_delete);
    

/*
 * lvgl extension definition for:
 * lv_indev_t *lv_indev_get_next(lv_indev_t *indev)
 */
 
STATIC mp_obj_t mp_lv_indev_get_next(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_indev_t *indev = mp_write_ptr_lv_indev_t(mp_args[0]);
    lv_indev_t * _res = ((lv_indev_t *(*)(lv_indev_t *))lv_func_ptr)(indev);
    return mp_read_ptr_lv_indev_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_indev_get_next_obj, 1, mp_lv_indev_get_next, lv_indev_get_next);
    

/*
 * lvgl extension definition for:
 * void lv_indev_enable(lv_indev_t *indev, bool en)
 */
 
STATIC mp_obj_t mp_lv_indev_enable(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_indev_t *indev = mp_write_ptr_lv_indev_t(mp_args[0]);
    bool en = mp_obj_is_true(mp_args[1]);
    ((void (*)(lv_indev_t *, bool))lv_func_ptr)(indev, en);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_indev_enable_obj, 2, mp_lv_indev_enable, lv_indev_enable);
    

/*
 * lvgl extension definition for:
 * lv_indev_type_t lv_indev_get_type(const lv_indev_t *indev)
 */
 
STATIC mp_obj_t mp_lv_indev_get_type(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_indev_t *indev = mp_write_ptr_lv_indev_t(mp_args[0]);
    lv_indev_type_t _res = ((lv_indev_type_t (*)(const lv_indev_t *))lv_func_ptr)(indev);
    return mp_obj_new_int(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_indev_get_type_obj, 1, mp_lv_indev_get_type, lv_indev_get_type);
    

/*
 * lvgl extension definition for:
 * void lv_indev_reset(lv_indev_t *indev, lv_obj_t *obj)
 */
 
STATIC mp_obj_t mp_lv_indev_reset(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_indev_t *indev = mp_write_ptr_lv_indev_t(mp_args[0]);
    lv_obj_t *obj = mp_to_lv(mp_args[1]);
    ((void (*)(lv_indev_t *, lv_obj_t *))lv_func_ptr)(indev, obj);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_indev_reset_obj, 2, mp_lv_indev_reset, lv_indev_reset);
    
/* Reusing lv_indev_delete for lv_indev_reset_long_press */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_indev_reset_long_press_obj, 1, mp_lv_indev_delete, lv_indev_reset_long_press);
    
/* Reusing lv_indev_reset for lv_indev_set_cursor */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_indev_set_cursor_obj, 2, mp_lv_indev_reset, lv_indev_set_cursor);
    

/*
 * lvgl extension definition for:
 * void lv_indev_set_group(lv_indev_t *indev, lv_group_t *group)
 */
 
STATIC mp_obj_t mp_lv_indev_set_group(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_indev_t *indev = mp_write_ptr_lv_indev_t(mp_args[0]);
    lv_group_t *group = mp_write_ptr_lv_group_t(mp_args[1]);
    ((void (*)(lv_indev_t *, lv_group_t *))lv_func_ptr)(indev, group);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_indev_set_group_obj, 2, mp_lv_indev_set_group, lv_indev_set_group);
    

/*
 * lvgl extension definition for:
 * void lv_indev_set_button_points(lv_indev_t *indev, const lv_point_t points[])
 */
 
STATIC mp_obj_t mp_lv_indev_set_button_points(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_indev_t *indev = mp_write_ptr_lv_indev_t(mp_args[0]);
    const lv_point_t *points = mp_arr_to_lv_point_t_____(mp_args[1]);
    ((void (*)(lv_indev_t *, const lv_point_t []))lv_func_ptr)(indev, points);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_indev_set_button_points_obj, 2, mp_lv_indev_set_button_points, lv_indev_set_button_points);
    

/*
 * lvgl extension definition for:
 * void lv_indev_get_point(const lv_indev_t *indev, lv_point_t *point)
 */
 
STATIC mp_obj_t mp_lv_indev_get_point(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_indev_t *indev = mp_write_ptr_lv_indev_t(mp_args[0]);
    lv_point_t *point = mp_write_ptr_lv_point_t(mp_args[1]);
    ((void (*)(const lv_indev_t *, lv_point_t *))lv_func_ptr)(indev, point);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_indev_get_point_obj, 2, mp_lv_indev_get_point, lv_indev_get_point);
    

/*
 * lvgl extension definition for:
 * lv_dir_t lv_indev_get_gesture_dir(const lv_indev_t *indev)
 */
 
STATIC mp_obj_t mp_lv_indev_get_gesture_dir(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_indev_t *indev = mp_write_ptr_lv_indev_t(mp_args[0]);
    lv_dir_t _res = ((lv_dir_t (*)(const lv_indev_t *))lv_func_ptr)(indev);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_indev_get_gesture_dir_obj, 1, mp_lv_indev_get_gesture_dir, lv_indev_get_gesture_dir);
    

/*
 * lvgl extension definition for:
 * uint32_t lv_indev_get_key(const lv_indev_t *indev)
 */
 
STATIC mp_obj_t mp_lv_indev_get_key(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_indev_t *indev = mp_write_ptr_lv_indev_t(mp_args[0]);
    uint32_t _res = ((uint32_t (*)(const lv_indev_t *))lv_func_ptr)(indev);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_indev_get_key_obj, 1, mp_lv_indev_get_key, lv_indev_get_key);
    
/* Reusing lv_indev_get_gesture_dir for lv_indev_get_scroll_dir */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_indev_get_scroll_dir_obj, 1, mp_lv_indev_get_gesture_dir, lv_indev_get_scroll_dir);
    

/*
 * lvgl extension definition for:
 * lv_obj_t *lv_indev_get_scroll_obj(const lv_indev_t *indev)
 */
 
STATIC mp_obj_t mp_lv_indev_get_scroll_obj(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_indev_t *indev = mp_write_ptr_lv_indev_t(mp_args[0]);
    lv_obj_t * _res = ((lv_obj_t *(*)(const lv_indev_t *))lv_func_ptr)(indev);
    return lv_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_indev_get_scroll_obj_obj, 1, mp_lv_indev_get_scroll_obj, lv_indev_get_scroll_obj);
    
/* Reusing lv_indev_get_point for lv_indev_get_vect */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_indev_get_vect_obj, 2, mp_lv_indev_get_point, lv_indev_get_vect);
    
/* Reusing lv_indev_delete for lv_indev_wait_release */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_indev_wait_release_obj, 1, mp_lv_indev_delete, lv_indev_wait_release);
    

STATIC const mp_rom_map_elem_t mp_lv_indev_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_indev_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    { MP_ROM_QSTR(MP_QSTR_drv_update), MP_ROM_PTR(&mp_lv_indev_drv_update_obj) },
    { MP_ROM_QSTR(MP_QSTR_delete), MP_ROM_PTR(&mp_lv_indev_delete_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_next), MP_ROM_PTR(&mp_lv_indev_get_next_obj) },
    { MP_ROM_QSTR(MP_QSTR_enable), MP_ROM_PTR(&mp_lv_indev_enable_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_type), MP_ROM_PTR(&mp_lv_indev_get_type_obj) },
    { MP_ROM_QSTR(MP_QSTR_reset), MP_ROM_PTR(&mp_lv_indev_reset_obj) },
    { MP_ROM_QSTR(MP_QSTR_reset_long_press), MP_ROM_PTR(&mp_lv_indev_reset_long_press_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_cursor), MP_ROM_PTR(&mp_lv_indev_set_cursor_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_group), MP_ROM_PTR(&mp_lv_indev_set_group_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_button_points), MP_ROM_PTR(&mp_lv_indev_set_button_points_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_point), MP_ROM_PTR(&mp_lv_indev_get_point_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_gesture_dir), MP_ROM_PTR(&mp_lv_indev_get_gesture_dir_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_key), MP_ROM_PTR(&mp_lv_indev_get_key_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_scroll_dir), MP_ROM_PTR(&mp_lv_indev_get_scroll_dir_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_scroll_obj), MP_ROM_PTR(&mp_lv_indev_get_scroll_obj_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_vect), MP_ROM_PTR(&mp_lv_indev_get_vect_obj) },
    { MP_ROM_QSTR(MP_QSTR_wait_release), MP_ROM_PTR(&mp_lv_indev_wait_release_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_indev_t_locals_dict, mp_lv_indev_t_locals_dict_table);
        

STATIC const mp_rom_map_elem_t mp__lv_indev_proc_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(_lv_indev_proc_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp__lv_indev_proc_t_locals_dict, mp__lv_indev_proc_t_locals_dict_table);
        

STATIC const mp_rom_map_elem_t mp__lv_indev_proc_types_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(_lv_indev_proc_types_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp__lv_indev_proc_types_t_locals_dict, mp__lv_indev_proc_types_t_locals_dict_table);
        

STATIC const mp_rom_map_elem_t mp__lv_indev_proc_types_pointer_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(_lv_indev_proc_types_pointer_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp__lv_indev_proc_types_pointer_t_locals_dict, mp__lv_indev_proc_types_pointer_t_locals_dict_table);
        

STATIC const mp_rom_map_elem_t mp__lv_indev_proc_types_keypad_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(_lv_indev_proc_types_keypad_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp__lv_indev_proc_types_keypad_t_locals_dict, mp__lv_indev_proc_types_keypad_t_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * void lv_group_del(lv_group_t *group)
 */
 
STATIC mp_obj_t mp_lv_group_del(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_group_t *group = mp_write_ptr_lv_group_t(mp_args[0]);
    ((void (*)(lv_group_t *))lv_func_ptr)(group);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_group_del_obj, 1, mp_lv_group_del, lv_group_del);
    
/* Reusing lv_group_del for lv_group_set_default */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_group_set_default_obj, 1, mp_lv_group_del, lv_group_set_default);
    

/*
 * lvgl extension definition for:
 * void lv_group_add_obj(lv_group_t *group, struct _lv_obj_t *obj)
 */
 
STATIC mp_obj_t mp_lv_group_add_obj(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_group_t *group = mp_write_ptr_lv_group_t(mp_args[0]);
    struct _lv_obj_t *obj = mp_to_lv(mp_args[1]);
    ((void (*)(lv_group_t *, struct _lv_obj_t *))lv_func_ptr)(group, obj);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_group_add_obj_obj, 2, mp_lv_group_add_obj, lv_group_add_obj);
    
/* Reusing lv_group_del for lv_group_remove_all_objs */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_group_remove_all_objs_obj, 1, mp_lv_group_del, lv_group_remove_all_objs);
    
/* Reusing lv_group_del for lv_group_focus_next */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_group_focus_next_obj, 1, mp_lv_group_del, lv_group_focus_next);
    
/* Reusing lv_group_del for lv_group_focus_prev */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_group_focus_prev_obj, 1, mp_lv_group_del, lv_group_focus_prev);
    

/*
 * lvgl extension definition for:
 * void lv_group_focus_freeze(lv_group_t *group, bool en)
 */
 
STATIC mp_obj_t mp_lv_group_focus_freeze(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_group_t *group = mp_write_ptr_lv_group_t(mp_args[0]);
    bool en = mp_obj_is_true(mp_args[1]);
    ((void (*)(lv_group_t *, bool))lv_func_ptr)(group, en);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_group_focus_freeze_obj, 2, mp_lv_group_focus_freeze, lv_group_focus_freeze);
    

/*
 * lvgl extension definition for:
 * lv_res_t lv_group_send_data(lv_group_t *group, uint32_t c)
 */
 
STATIC mp_obj_t mp_lv_group_send_data(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_group_t *group = mp_write_ptr_lv_group_t(mp_args[0]);
    uint32_t c = (uint32_t)mp_obj_get_int(mp_args[1]);
    lv_res_t _res = ((lv_res_t (*)(lv_group_t *, uint32_t))lv_func_ptr)(group, c);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_group_send_data_obj, 2, mp_lv_group_send_data, lv_group_send_data);
    

/*
 * Callback function lv_group_t_focus_cb
 * void lv_group_focus_cb_t(struct _lv_group_t *)
 */

STATIC void lv_group_t_focus_cb_callback(struct _lv_group_t * arg0)
{
    mp_obj_t mp_args[1];
    mp_args[0] = mp_read_ptr_lv_group_t((void*)arg0);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_group_t_focus_cb)) , 1, 0, mp_args);
    return;
}


/*
 * lvgl extension definition for:
 * void lv_group_set_focus_cb(lv_group_t *group, lv_group_focus_cb_t focus_cb)
 */
 
STATIC mp_obj_t mp_lv_group_set_focus_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_group_t *group = mp_write_ptr_lv_group_t(mp_args[0]);
    void *focus_cb = mp_lv_callback(mp_args[1], &lv_group_t_focus_cb_callback, MP_QSTR_lv_group_t_focus_cb, &group->user_data);
    ((void (*)(lv_group_t *, lv_group_focus_cb_t))lv_func_ptr)(group, focus_cb);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_group_set_focus_cb_obj, 2, mp_lv_group_set_focus_cb, lv_group_set_focus_cb);
    

/*
 * Callback function lv_group_t_edge_cb
 * void lv_group_edge_cb_t(struct _lv_group_t *, bool)
 */

STATIC void lv_group_t_edge_cb_callback(struct _lv_group_t * arg0, bool arg1)
{
    mp_obj_t mp_args[2];
    mp_args[0] = mp_read_ptr_lv_group_t((void*)arg0);
    mp_args[1] = convert_to_bool(arg1);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_group_t_edge_cb)) , 2, 0, mp_args);
    return;
}


/*
 * lvgl extension definition for:
 * void lv_group_set_edge_cb(lv_group_t *group, lv_group_edge_cb_t edge_cb)
 */
 
STATIC mp_obj_t mp_lv_group_set_edge_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_group_t *group = mp_write_ptr_lv_group_t(mp_args[0]);
    void *edge_cb = mp_lv_callback(mp_args[1], &lv_group_t_edge_cb_callback, MP_QSTR_lv_group_t_edge_cb, &group->user_data);
    ((void (*)(lv_group_t *, lv_group_edge_cb_t))lv_func_ptr)(group, edge_cb);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_group_set_edge_cb_obj, 2, mp_lv_group_set_edge_cb, lv_group_set_edge_cb);
    

/*
 * lvgl extension definition for:
 * void lv_group_set_refocus_policy(lv_group_t *group, lv_group_refocus_policy_t policy)
 */
 
STATIC mp_obj_t mp_lv_group_set_refocus_policy(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_group_t *group = mp_write_ptr_lv_group_t(mp_args[0]);
    lv_group_refocus_policy_t policy = (int)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_group_t *, lv_group_refocus_policy_t))lv_func_ptr)(group, policy);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_group_set_refocus_policy_obj, 2, mp_lv_group_set_refocus_policy, lv_group_set_refocus_policy);
    
/* Reusing lv_group_focus_freeze for lv_group_set_editing */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_group_set_editing_obj, 2, mp_lv_group_focus_freeze, lv_group_set_editing);
    
/* Reusing lv_group_focus_freeze for lv_group_set_wrap */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_group_set_wrap_obj, 2, mp_lv_group_focus_freeze, lv_group_set_wrap);
    

/*
 * lvgl extension definition for:
 * struct _lv_obj_t *lv_group_get_focused(const lv_group_t *group)
 */
 
STATIC mp_obj_t mp_lv_group_get_focused(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_group_t *group = mp_write_ptr_lv_group_t(mp_args[0]);
    lv_obj_t * _res = ((struct _lv_obj_t *(*)(const lv_group_t *))lv_func_ptr)(group);
    return lv_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_group_get_focused_obj, 1, mp_lv_group_get_focused, lv_group_get_focused);
    

/*
 * lvgl extension definition for:
 * lv_group_focus_cb_t lv_group_get_focus_cb(const lv_group_t *group)
 */
 
STATIC mp_obj_t mp_lv_group_get_focus_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_group_t *group = mp_write_ptr_lv_group_t(mp_args[0]);
    lv_group_focus_cb_t _res = ((lv_group_focus_cb_t (*)(const lv_group_t *))lv_func_ptr)(group);
    return mp_lv_funcptr_lv_group_focus_cb_t(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_group_get_focus_cb_obj, 1, mp_lv_group_get_focus_cb, lv_group_get_focus_cb);
    

/*
 * lvgl extension definition for:
 * lv_group_edge_cb_t lv_group_get_edge_cb(const lv_group_t *group)
 */
 
STATIC mp_obj_t mp_lv_group_get_edge_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_group_t *group = mp_write_ptr_lv_group_t(mp_args[0]);
    lv_group_edge_cb_t _res = ((lv_group_edge_cb_t (*)(const lv_group_t *))lv_func_ptr)(group);
    return mp_lv_funcptr_lv_group_edge_cb_t(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_group_get_edge_cb_obj, 1, mp_lv_group_get_edge_cb, lv_group_get_edge_cb);
    

/*
 * lvgl extension definition for:
 * bool lv_group_get_editing(const lv_group_t *group)
 */
 
STATIC mp_obj_t mp_lv_group_get_editing(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_group_t *group = mp_write_ptr_lv_group_t(mp_args[0]);
    bool _res = ((bool (*)(const lv_group_t *))lv_func_ptr)(group);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_group_get_editing_obj, 1, mp_lv_group_get_editing, lv_group_get_editing);
    

/*
 * lvgl extension definition for:
 * bool lv_group_get_wrap(lv_group_t *group)
 */
 
STATIC mp_obj_t mp_lv_group_get_wrap(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_group_t *group = mp_write_ptr_lv_group_t(mp_args[0]);
    bool _res = ((bool (*)(lv_group_t *))lv_func_ptr)(group);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_group_get_wrap_obj, 1, mp_lv_group_get_wrap, lv_group_get_wrap);
    

/*
 * lvgl extension definition for:
 * uint32_t lv_group_get_obj_count(lv_group_t *group)
 */
 
STATIC mp_obj_t mp_lv_group_get_obj_count(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_group_t *group = mp_write_ptr_lv_group_t(mp_args[0]);
    uint32_t _res = ((uint32_t (*)(lv_group_t *))lv_func_ptr)(group);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_group_get_obj_count_obj, 1, mp_lv_group_get_obj_count, lv_group_get_obj_count);
    

STATIC const mp_rom_map_elem_t mp_lv_group_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_group_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    { MP_ROM_QSTR(MP_QSTR__del), MP_ROM_PTR(&mp_lv_group_del_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_default), MP_ROM_PTR(&mp_lv_group_set_default_obj) },
    { MP_ROM_QSTR(MP_QSTR_add_obj), MP_ROM_PTR(&mp_lv_group_add_obj_obj) },
    { MP_ROM_QSTR(MP_QSTR_remove_all_objs), MP_ROM_PTR(&mp_lv_group_remove_all_objs_obj) },
    { MP_ROM_QSTR(MP_QSTR_focus_next), MP_ROM_PTR(&mp_lv_group_focus_next_obj) },
    { MP_ROM_QSTR(MP_QSTR_focus_prev), MP_ROM_PTR(&mp_lv_group_focus_prev_obj) },
    { MP_ROM_QSTR(MP_QSTR_focus_freeze), MP_ROM_PTR(&mp_lv_group_focus_freeze_obj) },
    { MP_ROM_QSTR(MP_QSTR_send_data), MP_ROM_PTR(&mp_lv_group_send_data_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_focus_cb), MP_ROM_PTR(&mp_lv_group_set_focus_cb_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_edge_cb), MP_ROM_PTR(&mp_lv_group_set_edge_cb_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_refocus_policy), MP_ROM_PTR(&mp_lv_group_set_refocus_policy_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_editing), MP_ROM_PTR(&mp_lv_group_set_editing_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_wrap), MP_ROM_PTR(&mp_lv_group_set_wrap_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_focused), MP_ROM_PTR(&mp_lv_group_get_focused_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_focus_cb), MP_ROM_PTR(&mp_lv_group_get_focus_cb_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_edge_cb), MP_ROM_PTR(&mp_lv_group_get_edge_cb_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_editing), MP_ROM_PTR(&mp_lv_group_get_editing_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_wrap), MP_ROM_PTR(&mp_lv_group_get_wrap_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_obj_count), MP_ROM_PTR(&mp_lv_group_get_obj_count_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_group_t_locals_dict, mp_lv_group_t_locals_dict_table);
        

STATIC const mp_rom_map_elem_t mp_lv_ll_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_ll_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_ll_t_locals_dict, mp_lv_ll_t_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * void gd_render_frame(gd_GIF *gif, uint8_t *buffer)
 */
 
STATIC mp_obj_t mp_gd_render_frame(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    gd_GIF *gif = mp_write_ptr_gd_GIF(mp_args[0]);
    uint8_t *buffer = mp_to_ptr(mp_args[1]);
    ((void (*)(gd_GIF *, uint8_t *))lv_func_ptr)(gif, buffer);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_gd_render_frame_obj, 2, mp_gd_render_frame, gd_render_frame);
    

/*
 * lvgl extension definition for:
 * int gd_get_frame(gd_GIF *gif)
 */
 
STATIC mp_obj_t mp_gd_get_frame(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    gd_GIF *gif = mp_write_ptr_gd_GIF(mp_args[0]);
    int _res = ((int (*)(gd_GIF *))lv_func_ptr)(gif);
    return mp_obj_new_int(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_gd_get_frame_obj, 1, mp_gd_get_frame, gd_get_frame);
    

/*
 * lvgl extension definition for:
 * void gd_rewind(gd_GIF *gif)
 */
 
STATIC mp_obj_t mp_gd_rewind(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    gd_GIF *gif = mp_write_ptr_gd_GIF(mp_args[0]);
    ((void (*)(gd_GIF *))lv_func_ptr)(gif);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_gd_rewind_obj, 1, mp_gd_rewind, gd_rewind);
    
/* Reusing gd_rewind for gd_close_gif */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_gd_close_gif_obj, 1, mp_gd_rewind, gd_close_gif);
    

STATIC const mp_rom_map_elem_t mp_gd_GIF_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(gd_GIF))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    { MP_ROM_QSTR(MP_QSTR_render_frame), MP_ROM_PTR(&mp_gd_render_frame_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_frame), MP_ROM_PTR(&mp_gd_get_frame_obj) },
    { MP_ROM_QSTR(MP_QSTR_rewind), MP_ROM_PTR(&mp_gd_rewind_obj) },
    { MP_ROM_QSTR(MP_QSTR_close_gif), MP_ROM_PTR(&mp_gd_close_gif_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_gd_GIF_locals_dict, mp_gd_GIF_locals_dict_table);
        

STATIC const mp_rom_map_elem_t mp_gd_GCE_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(gd_GCE))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_gd_GCE_locals_dict, mp_gd_GCE_locals_dict_table);
        

STATIC const mp_rom_map_elem_t mp_gd_Palette_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(gd_Palette))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_gd_Palette_locals_dict, mp_gd_Palette_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * lv_res_t lv_ex_data_delete(lv_ex_data_t *data)
 */
 
STATIC mp_obj_t mp_lv_ex_data_delete(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_ex_data_t *data = mp_write_ptr_lv_ex_data_t(mp_args[0]);
    lv_res_t _res = ((lv_res_t (*)(lv_ex_data_t *))lv_func_ptr)(data);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_ex_data_delete_obj, 1, mp_lv_ex_data_delete, lv_ex_data_delete);
    

/*
 * Struct lv_ex_binding_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_ex_binding_t_type();

STATIC inline lv_ex_binding_t* mp_write_ptr_lv_ex_binding_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_ex_binding_t_type()));
    return (lv_ex_binding_t*)self->data;
}

#define mp_write_lv_ex_binding_t(struct_obj) *mp_write_ptr_lv_ex_binding_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_ex_binding_t(lv_ex_binding_t *field)
{
    return lv_to_mp_struct(get_mp_lv_ex_binding_t_type(), (void*)field);
}

#define mp_read_lv_ex_binding_t(field) mp_read_ptr_lv_ex_binding_t(copy_buffer(&field, sizeof(lv_ex_binding_t)))
#define mp_read_byref_lv_ex_binding_t(field) mp_read_ptr_lv_ex_binding_t(&field)

STATIC void mp_lv_ex_binding_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_ex_binding_t *data = (lv_ex_binding_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_target: dest[0] = lv_to_mp((void*)data->target); break; // converting from lv_obj_t *;
            case MP_QSTR_setter: dest[0] = ptr_to_mp((void*)data->setter); break; // converting from void *;
            case MP_QSTR_arg_type: dest[0] = mp_obj_new_int(data->arg_type); break; // converting from lv_ex_data_type_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_target: data->target = (void*)mp_to_lv(dest[1]); break; // converting to lv_obj_t *;
                case MP_QSTR_setter: data->setter = (void*)mp_to_ptr(dest[1]); break; // converting to void *;
                case MP_QSTR_arg_type: data->arg_type = (int)mp_obj_get_int(dest[1]); break; // converting to lv_ex_data_type_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_ex_binding_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_ex_binding_t");
}

STATIC const mp_obj_dict_t mp_lv_ex_binding_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_ex_binding_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_ex_binding_t,
    .print = mp_lv_ex_binding_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_ex_binding_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_ex_binding_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_ex_binding_t_type()
{
    return &mp_lv_ex_binding_t_type;
}
    

/*
 * lvgl extension definition for:
 * void *lv_ex_bind_data(lv_ex_data_t *data, lv_ex_binding_t *binding)
 */
 
STATIC mp_obj_t mp_lv_ex_bind_data(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_ex_data_t *data = mp_write_ptr_lv_ex_data_t(mp_args[0]);
    lv_ex_binding_t *binding = mp_write_ptr_lv_ex_binding_t(mp_args[1]);
    void * _res = ((void *(*)(lv_ex_data_t *, lv_ex_binding_t *))lv_func_ptr)(data, binding);
    return ptr_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_ex_bind_data_obj, 2, mp_lv_ex_bind_data, lv_ex_bind_data);
    

/*
 * lvgl extension definition for:
 * lv_res_t lv_ex_unbind_data(lv_ex_data_t *data, void *handle)
 */
 
STATIC mp_obj_t mp_lv_ex_unbind_data(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_ex_data_t *data = mp_write_ptr_lv_ex_data_t(mp_args[0]);
    void *handle = mp_to_ptr(mp_args[1]);
    lv_res_t _res = ((lv_res_t (*)(lv_ex_data_t *, void *))lv_func_ptr)(data, handle);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_ex_unbind_data_obj, 2, mp_lv_ex_unbind_data, lv_ex_unbind_data);
    
/* Reusing lv_ex_unbind_data for lv_ex_data_set_value */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_ex_data_set_value_obj, 2, mp_lv_ex_unbind_data, lv_ex_data_set_value);
    

STATIC const mp_rom_map_elem_t mp_lv_ex_data_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_ex_data_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    { MP_ROM_QSTR(MP_QSTR_delete), MP_ROM_PTR(&mp_lv_ex_data_delete_obj) },
    { MP_ROM_QSTR(MP_QSTR_bind_data), MP_ROM_PTR(&mp_lv_ex_bind_data_obj) },
    { MP_ROM_QSTR(MP_QSTR_unbind_data), MP_ROM_PTR(&mp_lv_ex_unbind_data_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_value), MP_ROM_PTR(&mp_lv_ex_data_set_value_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_ex_data_t_locals_dict, mp_lv_ex_data_t_locals_dict_table);
        

STATIC const mp_rom_map_elem_t mp_lv_ex_data_value_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_ex_data_value_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_ex_data_value_t_locals_dict, mp_lv_ex_data_value_t_locals_dict_table);
        

/* 
 *
 * Global Module Functions
 *
 */


/*
 * lvgl extension definition for:
 * inline static uint32_t lv_timer_handler_run_in_period(uint32_t ms)
 */
 
STATIC mp_obj_t mp_lv_timer_handler_run_in_period(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    uint32_t ms = (uint32_t)mp_obj_get_int(mp_args[0]);
    uint32_t _res = ((uint32_t (*)(uint32_t))lv_func_ptr)(ms);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_timer_handler_run_in_period_obj, 1, mp_lv_timer_handler_run_in_period, lv_timer_handler_run_in_period);
    

STATIC const mp_rom_map_elem_t mp_lv_draw_label_hint_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_draw_label_hint_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_draw_label_hint_t_locals_dict, mp_lv_draw_label_hint_t_locals_dict_table);
        

STATIC const mp_rom_map_elem_t mp_lv_hit_test_info_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_hit_test_info_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_hit_test_info_t_locals_dict, mp_lv_hit_test_info_t_locals_dict_table);
        

STATIC const mp_rom_map_elem_t mp_lv_ex_binding_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_ex_binding_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_ex_binding_t_locals_dict, mp_lv_ex_binding_t_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * inline static int16_t lv_trigo_cos(int16_t angle)
 */
 
STATIC mp_obj_t mp_lv_trigo_cos(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    int16_t angle = (int16_t)mp_obj_get_int(mp_args[0]);
    int16_t _res = ((int16_t (*)(int16_t))lv_func_ptr)(angle);
    return mp_obj_new_int(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_trigo_cos_obj, 1, mp_lv_trigo_cos, lv_trigo_cos);
    

/*
 * lvgl extension definition for:
 * inline static void *lv_memcpy_small(void *dst, const void *src, size_t len)
 */
 
STATIC mp_obj_t mp_lv_memcpy_small(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    void *dst = mp_to_ptr(mp_args[0]);
    const void *src = mp_to_ptr(mp_args[1]);
    size_t len = (size_t)mp_obj_get_int(mp_args[2]);
    void * _res = ((void *(*)(void *, const void *, size_t))lv_func_ptr)(dst, src, len);
    return ptr_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_memcpy_small_obj, 3, mp_lv_memcpy_small, lv_memcpy_small);
    

/*
 * lvgl extension definition for:
 * inline static lv_coord_t lv_pct(lv_coord_t x)
 */
 
STATIC mp_obj_t mp_lv_pct(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_coord_t x = (int16_t)mp_obj_get_int(mp_args[0]);
    lv_coord_t _res = ((lv_coord_t (*)(lv_coord_t))lv_func_ptr)(x);
    return mp_obj_new_int(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_pct_obj, 1, mp_lv_pct, lv_pct);
    

/*
 * lvgl extension definition for:
 * inline static const lv_font_t *lv_font_default(void)
 */
 
STATIC mp_obj_t mp_lv_font_default(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    
    const lv_font_t * _res = ((const lv_font_t *(*)(void))lv_func_ptr)();
    return mp_read_ptr_lv_font_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_font_default_obj, 0, mp_lv_font_default, lv_font_default);
    

/*
 * lvgl extension definition for:
 * inline static lv_color_t lv_color_mix_premult(uint16_t *premult_c1, lv_color_t c2, uint8_t mix)
 */
 
STATIC mp_obj_t mp_lv_color_mix_premult(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    uint16_t *premult_c1 = mp_to_ptr(mp_args[0]);
    lv_color_t c2 = mp_write_lv_color16_t(mp_args[1]);
    uint8_t mix = (uint8_t)mp_obj_get_int(mp_args[2]);
    lv_color_t _res = ((lv_color_t (*)(uint16_t *, lv_color_t, uint8_t))lv_func_ptr)(premult_c1, c2, mix);
    return mp_read_lv_color16_t(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_color_mix_premult_obj, 3, mp_lv_color_mix_premult, lv_color_mix_premult);
    

/*
 * lvgl extension definition for:
 * inline static lv_color_t lv_color_make(uint8_t r, uint8_t g, uint8_t b)
 */
 
STATIC mp_obj_t mp_lv_color_make(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    uint8_t r = (uint8_t)mp_obj_get_int(mp_args[0]);
    uint8_t g = (uint8_t)mp_obj_get_int(mp_args[1]);
    uint8_t b = (uint8_t)mp_obj_get_int(mp_args[2]);
    lv_color_t _res = ((lv_color_t (*)(uint8_t, uint8_t, uint8_t))lv_func_ptr)(r, g, b);
    return mp_read_lv_color16_t(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_color_make_obj, 3, mp_lv_color_make, lv_color_make);
    

/*
 * lvgl extension definition for:
 * inline static lv_color_t lv_color_hex(uint32_t c)
 */
 
STATIC mp_obj_t mp_lv_color_hex(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    uint32_t c = (uint32_t)mp_obj_get_int(mp_args[0]);
    lv_color_t _res = ((lv_color_t (*)(uint32_t))lv_func_ptr)(c);
    return mp_read_lv_color16_t(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_color_hex_obj, 1, mp_lv_color_hex, lv_color_hex);
    
/* Reusing lv_color_hex for lv_color_hex3 */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_color_hex3_obj, 1, mp_lv_color_hex, lv_color_hex3);
    

/*
 * lvgl extension definition for:
 * inline static lv_color_t lv_color_chroma_key(void)
 */
 
STATIC mp_obj_t mp_lv_color_chroma_key(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    
    lv_color_t _res = ((lv_color_t (*)(void))lv_func_ptr)();
    return mp_read_lv_color16_t(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_color_chroma_key_obj, 0, mp_lv_color_chroma_key, lv_color_chroma_key);
    
/* Reusing lv_color_chroma_key for lv_color_white */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_color_white_obj, 0, mp_lv_color_chroma_key, lv_color_white);
    
/* Reusing lv_color_chroma_key for lv_color_black */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_color_black_obj, 0, mp_lv_color_chroma_key, lv_color_black);
    

/*
 * lvgl extension definition for:
 * inline static void lv_bidi_calculate_align(lv_text_align_t *align, lv_base_dir_t *base_dir, const char *txt)
 */
 
STATIC mp_obj_t mp_lv_bidi_calculate_align(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_text_align_t *align = mp_to_ptr(mp_args[0]);
    lv_base_dir_t *base_dir = mp_to_ptr(mp_args[1]);
    const char *txt = (char*)convert_from_str(mp_args[2]);
    ((void (*)(lv_text_align_t *, lv_base_dir_t *, const char *))lv_func_ptr)(align, base_dir, txt);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_bidi_calculate_align_obj, 3, mp_lv_bidi_calculate_align, lv_bidi_calculate_align);
    

/*
 * lvgl extension definition for:
 * inline static bool lv_style_prop_has_flag(lv_style_prop_t prop, uint8_t flag)
 */
 
STATIC mp_obj_t mp_lv_style_prop_has_flag(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_style_prop_t prop = (int)mp_obj_get_int(mp_args[0]);
    uint8_t flag = (uint8_t)mp_obj_get_int(mp_args[1]);
    bool _res = ((bool (*)(lv_style_prop_t, uint8_t))lv_func_ptr)(prop, flag);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_style_prop_has_flag_obj, 2, mp_lv_style_prop_has_flag, lv_style_prop_has_flag);
    

/*
 * lvgl extension definition for:
 * inline static lv_obj_t *lv_scr_act(void)
 */
 
STATIC mp_obj_t mp_lv_scr_act(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    
    lv_obj_t * _res = ((lv_obj_t *(*)(void))lv_func_ptr)();
    return lv_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_scr_act_obj, 0, mp_lv_scr_act, lv_scr_act);
    
/* Reusing lv_scr_act for lv_layer_top */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_layer_top_obj, 0, mp_lv_scr_act, lv_layer_top);
    
/* Reusing lv_scr_act for lv_layer_sys */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_layer_sys_obj, 0, mp_lv_scr_act, lv_layer_sys);
    
/* Reusing lv_obj_move_foreground for lv_scr_load */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_scr_load_obj, 1, mp_lv_obj_move_foreground, lv_scr_load);
    
/* Reusing lv_pct for lv_dpx */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_dpx_obj, 1, mp_lv_pct, lv_dpx);
    

/*
 * lvgl extension definition for:
 * inline static uint32_t lv_task_handler(void)
 */
 
STATIC mp_obj_t mp_lv_task_handler(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    
    uint32_t _res = ((uint32_t (*)(void))lv_func_ptr)();
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_task_handler_obj, 0, mp_lv_task_handler, lv_task_handler);
    

/*
 * lvgl extension definition for:
 * inline static lv_coord_t lv_grid_fr(uint8_t x)
 */
 
STATIC mp_obj_t mp_lv_grid_fr(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    uint8_t x = (uint8_t)mp_obj_get_int(mp_args[0]);
    lv_coord_t _res = ((lv_coord_t (*)(uint8_t))lv_func_ptr)(x);
    return mp_obj_new_int(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_grid_fr_obj, 1, mp_lv_grid_fr, lv_grid_fr);
    

/*
 * lvgl extension definition for:
 * inline static int lv_version_major(void)
 */
 
STATIC mp_obj_t mp_lv_version_major(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    
    int _res = ((int (*)(void))lv_func_ptr)();
    return mp_obj_new_int(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_version_major_obj, 0, mp_lv_version_major, lv_version_major);
    
/* Reusing lv_version_major for lv_version_minor */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_version_minor_obj, 0, mp_lv_version_major, lv_version_minor);
    
/* Reusing lv_version_major for lv_version_patch */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_version_patch_obj, 0, mp_lv_version_major, lv_version_patch);
    

/*
 * lvgl extension definition for:
 * inline static const char *lv_version_info(void)
 */
 
STATIC mp_obj_t mp_lv_version_info(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    
    const char * _res = ((const char *(*)(void))lv_func_ptr)();
    return convert_to_str((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_version_info_obj, 0, mp_lv_version_info, lv_version_info);
    

/*
 * lvgl extension definition for:
 * void lv_tick_inc(uint32_t tick_period)
 */
 
STATIC mp_obj_t mp_lv_tick_inc(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    uint32_t tick_period = (uint32_t)mp_obj_get_int(mp_args[0]);
    ((void (*)(uint32_t))lv_func_ptr)(tick_period);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_tick_inc_obj, 1, mp_lv_tick_inc, lv_tick_inc);
    
/* Reusing lv_task_handler for lv_tick_get */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_tick_get_obj, 0, mp_lv_task_handler, lv_tick_get);
    
/* Reusing lv_timer_handler_run_in_period for lv_tick_elaps */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_tick_elaps_obj, 1, mp_lv_timer_handler_run_in_period, lv_tick_elaps);
    
/* Reusing lv_task_handler for lv_timer_handler */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_timer_handler_obj, 0, mp_lv_task_handler, lv_timer_handler);
    

/*
 * lvgl extension definition for:
 * lv_timer_t *lv_timer_create_basic(void)
 */
 
STATIC mp_obj_t mp_lv_timer_create_basic(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    
    lv_timer_t * _res = ((lv_timer_t *(*)(void))lv_func_ptr)();
    return mp_read_ptr_lv_timer_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_timer_create_basic_obj, 0, mp_lv_timer_create_basic, lv_timer_create_basic);
    

/*
 * Callback function timer_xcb
 * void lv_timer_cb_t(struct _lv_timer_t *)
 */

STATIC void timer_xcb_callback(struct _lv_timer_t * arg0)
{
    mp_obj_t mp_args[1];
    mp_args[0] = mp_read_ptr_lv_timer_t((void*)arg0);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_timer_xcb)) , 1, 0, mp_args);
    return;
}


/*
 * lvgl extension definition for:
 * lv_timer_t *lv_timer_create(lv_timer_cb_t timer_xcb, uint32_t period, void *user_data)
 */
 
STATIC mp_obj_t mp_lv_timer_create(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    void *user_data = mp_to_ptr(mp_args[2]);
    uint32_t period = (uint32_t)mp_obj_get_int(mp_args[1]);
    void *timer_xcb = mp_lv_callback(mp_args[0], &timer_xcb_callback, MP_QSTR_timer_xcb, &user_data);
    lv_timer_t * _res = ((lv_timer_t *(*)(lv_timer_cb_t, uint32_t, void *))lv_func_ptr)(timer_xcb, period, user_data);
    return mp_read_ptr_lv_timer_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_timer_create_obj, 3, mp_lv_timer_create, lv_timer_create);
    
/* Reusing lv_obj_enable_style_refresh for lv_timer_enable */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_timer_enable_obj, 1, mp_lv_obj_enable_style_refresh, lv_timer_enable);
    

/*
 * lvgl extension definition for:
 * uint8_t lv_timer_get_idle(void)
 */
 
STATIC mp_obj_t mp_lv_timer_get_idle(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    
    uint8_t _res = ((uint8_t (*)(void))lv_func_ptr)();
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_timer_get_idle_obj, 0, mp_lv_timer_get_idle, lv_timer_get_idle);
    
/* Reusing lv_trigo_cos for lv_trigo_sin */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_trigo_sin_obj, 1, mp_lv_trigo_cos, lv_trigo_sin);
    

/*
 * lvgl extension definition for:
 * uint32_t lv_bezier3(uint32_t t, uint32_t u0, uint32_t u1, uint32_t u2, uint32_t u3)
 */
 
STATIC mp_obj_t mp_lv_bezier3(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    uint32_t t = (uint32_t)mp_obj_get_int(mp_args[0]);
    uint32_t u0 = (uint32_t)mp_obj_get_int(mp_args[1]);
    uint32_t u1 = (uint32_t)mp_obj_get_int(mp_args[2]);
    uint32_t u2 = (uint32_t)mp_obj_get_int(mp_args[3]);
    uint32_t u3 = (uint32_t)mp_obj_get_int(mp_args[4]);
    uint32_t _res = ((uint32_t (*)(uint32_t, uint32_t, uint32_t, uint32_t, uint32_t))lv_func_ptr)(t, u0, u1, u2, u3);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_bezier3_obj, 5, mp_lv_bezier3, lv_bezier3);
    

/*
 * lvgl extension definition for:
 * uint16_t lv_atan2(int x, int y)
 */
 
STATIC mp_obj_t mp_lv_atan2(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    int x = (int)mp_obj_get_int(mp_args[0]);
    int y = (int)mp_obj_get_int(mp_args[1]);
    uint16_t _res = ((uint16_t (*)(int, int))lv_func_ptr)(x, y);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_atan2_obj, 2, mp_lv_atan2, lv_atan2);
    

/*
 * Struct lv_sqrt_res_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_sqrt_res_t_type();

STATIC inline lv_sqrt_res_t* mp_write_ptr_lv_sqrt_res_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_sqrt_res_t_type()));
    return (lv_sqrt_res_t*)self->data;
}

#define mp_write_lv_sqrt_res_t(struct_obj) *mp_write_ptr_lv_sqrt_res_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_sqrt_res_t(lv_sqrt_res_t *field)
{
    return lv_to_mp_struct(get_mp_lv_sqrt_res_t_type(), (void*)field);
}

#define mp_read_lv_sqrt_res_t(field) mp_read_ptr_lv_sqrt_res_t(copy_buffer(&field, sizeof(lv_sqrt_res_t)))
#define mp_read_byref_lv_sqrt_res_t(field) mp_read_ptr_lv_sqrt_res_t(&field)

STATIC void mp_lv_sqrt_res_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_sqrt_res_t *data = (lv_sqrt_res_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_i: dest[0] = mp_obj_new_int_from_uint(data->i); break; // converting from uint16_t;
            case MP_QSTR_f: dest[0] = mp_obj_new_int_from_uint(data->f); break; // converting from uint16_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_i: data->i = (uint16_t)mp_obj_get_int(dest[1]); break; // converting to uint16_t;
                case MP_QSTR_f: data->f = (uint16_t)mp_obj_get_int(dest[1]); break; // converting to uint16_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_sqrt_res_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_sqrt_res_t");
}

STATIC const mp_obj_dict_t mp_lv_sqrt_res_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_sqrt_res_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_sqrt_res_t,
    .print = mp_lv_sqrt_res_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_sqrt_res_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_sqrt_res_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_sqrt_res_t_type()
{
    return &mp_lv_sqrt_res_t_type;
}
    

/*
 * lvgl extension definition for:
 * void lv_sqrt(uint32_t x, lv_sqrt_res_t *q, uint32_t mask)
 */
 
STATIC mp_obj_t mp_lv_sqrt(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    uint32_t x = (uint32_t)mp_obj_get_int(mp_args[0]);
    lv_sqrt_res_t *q = mp_write_ptr_lv_sqrt_res_t(mp_args[1]);
    uint32_t mask = (uint32_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(uint32_t, lv_sqrt_res_t *, uint32_t))lv_func_ptr)(x, q, mask);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_sqrt_obj, 3, mp_lv_sqrt, lv_sqrt);
    

STATIC const mp_rom_map_elem_t mp_lv_sqrt_res_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_sqrt_res_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_sqrt_res_t_locals_dict, mp_lv_sqrt_res_t_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * int64_t lv_pow(int64_t base, int8_t exp)
 */
 
STATIC mp_obj_t mp_lv_pow(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    int64_t base = (int64_t)mp_obj_get_ull(mp_args[0]);
    int8_t exp = (int8_t)mp_obj_get_int(mp_args[1]);
    int64_t _res = ((int64_t (*)(int64_t, int8_t))lv_func_ptr)(base, exp);
    return mp_obj_new_int_from_ll(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_pow_obj, 2, mp_lv_pow, lv_pow);
    

/*
 * lvgl extension definition for:
 * int32_t lv_map(int32_t x, int32_t min_in, int32_t max_in, int32_t min_out, int32_t max_out)
 */
 
STATIC mp_obj_t mp_lv_map(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    int32_t x = (int32_t)mp_obj_get_int(mp_args[0]);
    int32_t min_in = (int32_t)mp_obj_get_int(mp_args[1]);
    int32_t max_in = (int32_t)mp_obj_get_int(mp_args[2]);
    int32_t min_out = (int32_t)mp_obj_get_int(mp_args[3]);
    int32_t max_out = (int32_t)mp_obj_get_int(mp_args[4]);
    int32_t _res = ((int32_t (*)(int32_t, int32_t, int32_t, int32_t, int32_t))lv_func_ptr)(x, min_in, max_in, min_out, max_out);
    return mp_obj_new_int(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_map_obj, 5, mp_lv_map, lv_map);
    

/*
 * lvgl extension definition for:
 * uint32_t lv_rand(uint32_t min, uint32_t max)
 */
 
STATIC mp_obj_t mp_lv_rand(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    uint32_t min = (uint32_t)mp_obj_get_int(mp_args[0]);
    uint32_t max = (uint32_t)mp_obj_get_int(mp_args[1]);
    uint32_t _res = ((uint32_t (*)(uint32_t, uint32_t))lv_func_ptr)(min, max);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_rand_obj, 2, mp_lv_rand, lv_rand);
    

/*
 * lvgl extension definition for:
 * void lv_mem_init(void)
 */
 
STATIC mp_obj_t mp_lv_mem_init(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    
    ((void (*)(void))lv_func_ptr)();
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_mem_init_obj, 0, mp_lv_mem_init, lv_mem_init);
    
/* Reusing lv_mem_init for lv_mem_deinit */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_mem_deinit_obj, 0, mp_lv_mem_init, lv_mem_deinit);
    

/*
 * lvgl extension definition for:
 * void *lv_mem_alloc(size_t size)
 */
 
STATIC mp_obj_t mp_lv_mem_alloc(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    size_t size = (size_t)mp_obj_get_int(mp_args[0]);
    void * _res = ((void *(*)(size_t))lv_func_ptr)(size);
    return ptr_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_mem_alloc_obj, 1, mp_lv_mem_alloc, lv_mem_alloc);
    
/* Reusing funcptr_lv_async_cb_t for lv_mem_free */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_mem_free_obj, 1, mp_funcptr_lv_async_cb_t, lv_mem_free);
    

/*
 * lvgl extension definition for:
 * void *lv_mem_realloc(void *data_p, size_t new_size)
 */
 
STATIC mp_obj_t mp_lv_mem_realloc(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    void *data_p = mp_to_ptr(mp_args[0]);
    size_t new_size = (size_t)mp_obj_get_int(mp_args[1]);
    void * _res = ((void *(*)(void *, size_t))lv_func_ptr)(data_p, new_size);
    return ptr_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_mem_realloc_obj, 2, mp_lv_mem_realloc, lv_mem_realloc);
    

/*
 * lvgl extension definition for:
 * lv_res_t lv_mem_test(void)
 */
 
STATIC mp_obj_t mp_lv_mem_test(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    
    lv_res_t _res = ((lv_res_t (*)(void))lv_func_ptr)();
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_mem_test_obj, 0, mp_lv_mem_test, lv_mem_test);
    

/*
 * lvgl extension definition for:
 * void *lv_mem_buf_get(uint32_t size)
 */
 
STATIC mp_obj_t mp_lv_mem_buf_get(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    uint32_t size = (uint32_t)mp_obj_get_int(mp_args[0]);
    void * _res = ((void *(*)(uint32_t))lv_func_ptr)(size);
    return ptr_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_mem_buf_get_obj, 1, mp_lv_mem_buf_get, lv_mem_buf_get);
    
/* Reusing funcptr_lv_async_cb_t for lv_mem_buf_release */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_mem_buf_release_obj, 1, mp_funcptr_lv_async_cb_t, lv_mem_buf_release);
    
/* Reusing lv_mem_init for lv_mem_buf_free_all */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_mem_buf_free_all_obj, 0, mp_lv_mem_init, lv_mem_buf_free_all);
    
/* Reusing lv_memcpy_small for lv_memcpy */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_memcpy_obj, 3, mp_lv_memcpy_small, lv_memcpy);
    

/*
 * lvgl extension definition for:
 * void lv_memset(void *dst, uint8_t v, size_t len)
 */
 
STATIC mp_obj_t mp_lv_memset(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    void *dst = mp_to_ptr(mp_args[0]);
    uint8_t v = (uint8_t)mp_obj_get_int(mp_args[1]);
    size_t len = (size_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(void *, uint8_t, size_t))lv_func_ptr)(dst, v, len);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_memset_obj, 3, mp_lv_memset, lv_memset);
    

/*
 * lvgl extension definition for:
 * void lv_memset_00(void *dst, size_t len)
 */
 
STATIC mp_obj_t mp_lv_memset_00(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    void *dst = mp_to_ptr(mp_args[0]);
    size_t len = (size_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(void *, size_t))lv_func_ptr)(dst, len);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_memset_00_obj, 2, mp_lv_memset_00, lv_memset_00);
    
/* Reusing lv_memset_00 for lv_memset_ff */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_memset_ff_obj, 2, mp_lv_memset_00, lv_memset_ff);
    

/*
 * Callback function async_xcb
 * void lv_async_cb_t(void *)
 */

STATIC void async_xcb_callback(void * arg0)
{
    mp_obj_t mp_args[1];
    mp_args[0] = ptr_to_mp((void*)arg0);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0);
    mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_async_xcb)) , 1, 0, mp_args);
    return;
}


/*
 * lvgl extension definition for:
 * lv_res_t lv_async_call(lv_async_cb_t async_xcb, void *user_data)
 */
 
STATIC mp_obj_t mp_lv_async_call(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    void *user_data = mp_to_ptr(mp_args[1]);
    void *async_xcb = mp_lv_callback(mp_args[0], &async_xcb_callback, MP_QSTR_async_xcb, &user_data);
    lv_res_t _res = ((lv_res_t (*)(lv_async_cb_t, void *))lv_func_ptr)(async_xcb, user_data);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_async_call_obj, 2, mp_lv_async_call, lv_async_call);
    
/* Reusing lv_async_call for lv_async_call_cancel */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_async_call_cancel_obj, 2, mp_lv_async_call, lv_async_call_cancel);
    

/*
 * Function NOT generated:
 * Callback function 'lv_anim_exec_xcb_t exec_cb' must receive a struct pointer with user_data member as its first argument!
 * lv_anim_exec_xcb_t exec_cb
 */
    

/*
 * lvgl extension definition for:
 * bool lv_anim_del(void *var, lv_anim_exec_xcb_t exec_cb)
 */
 
STATIC mp_obj_t mp_lv_anim_del(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    void *var = mp_to_ptr(mp_args[0]);
    lv_anim_exec_xcb_t exec_cb = mp_to_ptr(mp_args[1]);
    bool _res = ((bool (*)(void *, lv_anim_exec_xcb_t))lv_func_ptr)(var, exec_cb);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_anim_del_obj, 2, mp_lv_anim_del, lv_anim_del);
    
/* Reusing lv_mem_init for lv_anim_del_all */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_anim_del_all_obj, 0, mp_lv_mem_init, lv_anim_del_all);
    

/*
 * Function NOT generated:
 * Callback function 'lv_anim_exec_xcb_t exec_cb' must receive a struct pointer with user_data member as its first argument!
 * lv_anim_exec_xcb_t exec_cb
 */
    

/*
 * lvgl extension definition for:
 * lv_anim_t *lv_anim_get(void *var, lv_anim_exec_xcb_t exec_cb)
 */
 
STATIC mp_obj_t mp_lv_anim_get(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    void *var = mp_to_ptr(mp_args[0]);
    lv_anim_exec_xcb_t exec_cb = mp_to_ptr(mp_args[1]);
    lv_anim_t * _res = ((lv_anim_t *(*)(void *, lv_anim_exec_xcb_t))lv_func_ptr)(var, exec_cb);
    return mp_read_ptr_lv_anim_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_anim_get_obj, 2, mp_lv_anim_get, lv_anim_get);
    

/*
 * lvgl extension definition for:
 * struct _lv_timer_t *lv_anim_get_timer(void)
 */
 
STATIC mp_obj_t mp_lv_anim_get_timer(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    
    lv_timer_t * _res = ((struct _lv_timer_t *(*)(void))lv_func_ptr)();
    return mp_read_ptr_lv_timer_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_anim_get_timer_obj, 0, mp_lv_anim_get_timer, lv_anim_get_timer);
    

/*
 * lvgl extension definition for:
 * uint16_t lv_anim_count_running(void)
 */
 
STATIC mp_obj_t mp_lv_anim_count_running(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    
    uint16_t _res = ((uint16_t (*)(void))lv_func_ptr)();
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_anim_count_running_obj, 0, mp_lv_anim_count_running, lv_anim_count_running);
    

/*
 * lvgl extension definition for:
 * uint32_t lv_anim_speed_to_time(uint32_t speed, int32_t start, int32_t end)
 */
 
STATIC mp_obj_t mp_lv_anim_speed_to_time(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    uint32_t speed = (uint32_t)mp_obj_get_int(mp_args[0]);
    int32_t start = (int32_t)mp_obj_get_int(mp_args[1]);
    int32_t end = (int32_t)mp_obj_get_int(mp_args[2]);
    uint32_t _res = ((uint32_t (*)(uint32_t, int32_t, int32_t))lv_func_ptr)(speed, start, end);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_anim_speed_to_time_obj, 3, mp_lv_anim_speed_to_time, lv_anim_speed_to_time);
    
/* Reusing lv_mem_init for lv_anim_refr_now */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_anim_refr_now_obj, 0, mp_lv_mem_init, lv_anim_refr_now);
    

/*
 * lvgl extension definition for:
 * lv_anim_timeline_t *lv_anim_timeline_create(void)
 */
 
STATIC mp_obj_t mp_lv_anim_timeline_create(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    
    lv_anim_timeline_t * _res = ((lv_anim_timeline_t *(*)(void))lv_func_ptr)();
    return ptr_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_anim_timeline_create_obj, 0, mp_lv_anim_timeline_create, lv_anim_timeline_create);
    

/*
 * lvgl extension definition for:
 * void lv_anim_timeline_del(lv_anim_timeline_t *at)
 */
 
STATIC mp_obj_t mp_lv_anim_timeline_del(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_anim_timeline_t *at = mp_to_ptr(mp_args[0]);
    ((void (*)(lv_anim_timeline_t *))lv_func_ptr)(at);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_anim_timeline_del_obj, 1, mp_lv_anim_timeline_del, lv_anim_timeline_del);
    

/*
 * lvgl extension definition for:
 * void lv_anim_timeline_add(lv_anim_timeline_t *at, uint32_t start_time, lv_anim_t *a)
 */
 
STATIC mp_obj_t mp_lv_anim_timeline_add(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_anim_timeline_t *at = mp_to_ptr(mp_args[0]);
    uint32_t start_time = (uint32_t)mp_obj_get_int(mp_args[1]);
    lv_anim_t *a = mp_write_ptr_lv_anim_t(mp_args[2]);
    ((void (*)(lv_anim_timeline_t *, uint32_t, lv_anim_t *))lv_func_ptr)(at, start_time, a);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_anim_timeline_add_obj, 3, mp_lv_anim_timeline_add, lv_anim_timeline_add);
    

/*
 * lvgl extension definition for:
 * uint32_t lv_anim_timeline_start(lv_anim_timeline_t *at)
 */
 
STATIC mp_obj_t mp_lv_anim_timeline_start(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_anim_timeline_t *at = mp_to_ptr(mp_args[0]);
    uint32_t _res = ((uint32_t (*)(lv_anim_timeline_t *))lv_func_ptr)(at);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_anim_timeline_start_obj, 1, mp_lv_anim_timeline_start, lv_anim_timeline_start);
    
/* Reusing lv_anim_timeline_del for lv_anim_timeline_stop */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_anim_timeline_stop_obj, 1, mp_lv_anim_timeline_del, lv_anim_timeline_stop);
    

/*
 * lvgl extension definition for:
 * void lv_anim_timeline_set_reverse(lv_anim_timeline_t *at, bool reverse)
 */
 
STATIC mp_obj_t mp_lv_anim_timeline_set_reverse(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_anim_timeline_t *at = mp_to_ptr(mp_args[0]);
    bool reverse = mp_obj_is_true(mp_args[1]);
    ((void (*)(lv_anim_timeline_t *, bool))lv_func_ptr)(at, reverse);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_anim_timeline_set_reverse_obj, 2, mp_lv_anim_timeline_set_reverse, lv_anim_timeline_set_reverse);
    

/*
 * lvgl extension definition for:
 * void lv_anim_timeline_set_progress(lv_anim_timeline_t *at, uint16_t progress)
 */
 
STATIC mp_obj_t mp_lv_anim_timeline_set_progress(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_anim_timeline_t *at = mp_to_ptr(mp_args[0]);
    uint16_t progress = (uint16_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_anim_timeline_t *, uint16_t))lv_func_ptr)(at, progress);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_anim_timeline_set_progress_obj, 2, mp_lv_anim_timeline_set_progress, lv_anim_timeline_set_progress);
    
/* Reusing lv_anim_timeline_start for lv_anim_timeline_get_playtime */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_anim_timeline_get_playtime_obj, 1, mp_lv_anim_timeline_start, lv_anim_timeline_get_playtime);
    

/*
 * lvgl extension definition for:
 * bool lv_anim_timeline_get_reverse(lv_anim_timeline_t *at)
 */
 
STATIC mp_obj_t mp_lv_anim_timeline_get_reverse(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_anim_timeline_t *at = mp_to_ptr(mp_args[0]);
    bool _res = ((bool (*)(lv_anim_timeline_t *))lv_func_ptr)(at);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_anim_timeline_get_reverse_obj, 1, mp_lv_anim_timeline_get_reverse, lv_anim_timeline_get_reverse);
    

/*
 * Function NOT generated:
 * Cannot convert ellipsis param
 * int lv_snprintf(char *buffer, size_t count, const char *format, ...)
 */
    

/*
 * Function NOT generated:
 * Missing conversion to va_list
 * int lv_vsnprintf(char *buffer, size_t count, const char *format, va_list va)
 */
    

/*
 * lvgl extension definition for:
 * lv_color_t lv_color_hsv_to_rgb(uint16_t h, uint8_t s, uint8_t v)
 */
 
STATIC mp_obj_t mp_lv_color_hsv_to_rgb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    uint16_t h = (uint16_t)mp_obj_get_int(mp_args[0]);
    uint8_t s = (uint8_t)mp_obj_get_int(mp_args[1]);
    uint8_t v = (uint8_t)mp_obj_get_int(mp_args[2]);
    lv_color_t _res = ((lv_color_t (*)(uint16_t, uint8_t, uint8_t))lv_func_ptr)(h, s, v);
    return mp_read_lv_color16_t(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_color_hsv_to_rgb_obj, 3, mp_lv_color_hsv_to_rgb, lv_color_hsv_to_rgb);
    

/*
 * lvgl extension definition for:
 * lv_color_hsv_t lv_color_rgb_to_hsv(uint8_t r8, uint8_t g8, uint8_t b8)
 */
 
STATIC mp_obj_t mp_lv_color_rgb_to_hsv(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    uint8_t r8 = (uint8_t)mp_obj_get_int(mp_args[0]);
    uint8_t g8 = (uint8_t)mp_obj_get_int(mp_args[1]);
    uint8_t b8 = (uint8_t)mp_obj_get_int(mp_args[2]);
    lv_color_hsv_t _res = ((lv_color_hsv_t (*)(uint8_t, uint8_t, uint8_t))lv_func_ptr)(r8, g8, b8);
    return mp_read_lv_color_hsv_t(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_color_rgb_to_hsv_obj, 3, mp_lv_color_rgb_to_hsv, lv_color_rgb_to_hsv);
    

/*
 * lvgl extension definition for:
 * lv_color_t lv_palette_main(lv_palette_t p)
 */
 
STATIC mp_obj_t mp_lv_palette_main(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_palette_t p = (int)mp_obj_get_int(mp_args[0]);
    lv_color_t _res = ((lv_color_t (*)(lv_palette_t))lv_func_ptr)(p);
    return mp_read_lv_color16_t(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_palette_main_obj, 1, mp_lv_palette_main, lv_palette_main);
    

/*
 * lvgl extension definition for:
 * lv_color_t lv_palette_lighten(lv_palette_t p, uint8_t lvl)
 */
 
STATIC mp_obj_t mp_lv_palette_lighten(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_palette_t p = (int)mp_obj_get_int(mp_args[0]);
    uint8_t lvl = (uint8_t)mp_obj_get_int(mp_args[1]);
    lv_color_t _res = ((lv_color_t (*)(lv_palette_t, uint8_t))lv_func_ptr)(p, lvl);
    return mp_read_lv_color16_t(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_palette_lighten_obj, 2, mp_lv_palette_lighten, lv_palette_lighten);
    
/* Reusing lv_palette_lighten for lv_palette_darken */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_palette_darken_obj, 2, mp_lv_palette_lighten, lv_palette_darken);
    

/*
 * lvgl extension definition for:
 * void lv_txt_get_size(lv_point_t *size_res, const char *text, const lv_font_t *font, lv_coord_t letter_space, lv_coord_t line_space, lv_coord_t max_width, lv_text_flag_t flag)
 */
 
STATIC mp_obj_t mp_lv_txt_get_size(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_point_t *size_res = mp_write_ptr_lv_point_t(mp_args[0]);
    const char *text = (char*)convert_from_str(mp_args[1]);
    const lv_font_t *font = mp_write_ptr_lv_font_t(mp_args[2]);
    lv_coord_t letter_space = (int16_t)mp_obj_get_int(mp_args[3]);
    lv_coord_t line_space = (int16_t)mp_obj_get_int(mp_args[4]);
    lv_coord_t max_width = (int16_t)mp_obj_get_int(mp_args[5]);
    lv_text_flag_t flag = (uint8_t)mp_obj_get_int(mp_args[6]);
    ((void (*)(lv_point_t *, const char *, const lv_font_t *, lv_coord_t, lv_coord_t, lv_coord_t, lv_text_flag_t))lv_func_ptr)(size_res, text, font, letter_space, line_space, max_width, flag);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_txt_get_size_obj, 7, mp_lv_txt_get_size, lv_txt_get_size);
    

/*
 * lvgl extension definition for:
 * lv_coord_t lv_txt_get_width(const char *txt, uint32_t length, const lv_font_t *font, lv_coord_t letter_space, lv_text_flag_t flag)
 */
 
STATIC mp_obj_t mp_lv_txt_get_width(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const char *txt = (char*)convert_from_str(mp_args[0]);
    uint32_t length = (uint32_t)mp_obj_get_int(mp_args[1]);
    const lv_font_t *font = mp_write_ptr_lv_font_t(mp_args[2]);
    lv_coord_t letter_space = (int16_t)mp_obj_get_int(mp_args[3]);
    lv_text_flag_t flag = (uint8_t)mp_obj_get_int(mp_args[4]);
    lv_coord_t _res = ((lv_coord_t (*)(const char *, uint32_t, const lv_font_t *, lv_coord_t, lv_text_flag_t))lv_func_ptr)(txt, length, font, letter_space, flag);
    return mp_obj_new_int(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_txt_get_width_obj, 5, mp_lv_txt_get_width, lv_txt_get_width);
    

/*
 * lvgl extension definition for:
 * lv_style_prop_t lv_style_register_prop(uint8_t flag)
 */
 
STATIC mp_obj_t mp_lv_style_register_prop(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    uint8_t flag = (uint8_t)mp_obj_get_int(mp_args[0]);
    lv_style_prop_t _res = ((lv_style_prop_t (*)(uint8_t))lv_func_ptr)(flag);
    return mp_obj_new_int(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_style_register_prop_obj, 1, mp_lv_style_register_prop, lv_style_register_prop);
    

/*
 * lvgl extension definition for:
 * lv_style_prop_t lv_style_get_num_custom_props(void)
 */
 
STATIC mp_obj_t mp_lv_style_get_num_custom_props(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    
    lv_style_prop_t _res = ((lv_style_prop_t (*)(void))lv_func_ptr)();
    return mp_obj_new_int(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_style_get_num_custom_props_obj, 0, mp_lv_style_get_num_custom_props, lv_style_get_num_custom_props);
    

/*
 * lvgl extension definition for:
 * lv_style_value_t lv_style_prop_get_default(lv_style_prop_t prop)
 */
 
STATIC mp_obj_t mp_lv_style_prop_get_default(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_style_prop_t prop = (int)mp_obj_get_int(mp_args[0]);
    lv_style_value_t _res = ((lv_style_value_t (*)(lv_style_prop_t))lv_func_ptr)(prop);
    return mp_read_lv_style_value_t(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_style_prop_get_default_obj, 1, mp_lv_style_prop_get_default, lv_style_prop_get_default);
    

/*
 * lvgl extension definition for:
 * lv_fs_drv_t *lv_fs_get_drv(char letter)
 */
 
STATIC mp_obj_t mp_lv_fs_get_drv(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    char letter = (char)mp_obj_get_int(mp_args[0]);
    lv_fs_drv_t * _res = ((lv_fs_drv_t *(*)(char))lv_func_ptr)(letter);
    return mp_read_ptr_lv_fs_drv_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_fs_get_drv_obj, 1, mp_lv_fs_get_drv, lv_fs_get_drv);
    

/*
 * lvgl extension definition for:
 * bool lv_fs_is_ready(char letter)
 */
 
STATIC mp_obj_t mp_lv_fs_is_ready(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    char letter = (char)mp_obj_get_int(mp_args[0]);
    bool _res = ((bool (*)(char))lv_func_ptr)(letter);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_fs_is_ready_obj, 1, mp_lv_fs_is_ready, lv_fs_is_ready);
    

/*
 * lvgl extension definition for:
 * char *lv_fs_get_letters(char *buf)
 */
 
STATIC mp_obj_t mp_lv_fs_get_letters(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    char *buf = (char*)convert_from_str(mp_args[0]);
    char * _res = ((char *(*)(char *))lv_func_ptr)(buf);
    return convert_to_str((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_fs_get_letters_obj, 1, mp_lv_fs_get_letters, lv_fs_get_letters);
    

/*
 * lvgl extension definition for:
 * const char *lv_fs_get_ext(const char *fn)
 */
 
STATIC mp_obj_t mp_lv_fs_get_ext(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const char *fn = (char*)convert_from_str(mp_args[0]);
    const char * _res = ((const char *(*)(const char *))lv_func_ptr)(fn);
    return convert_to_str((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_fs_get_ext_obj, 1, mp_lv_fs_get_ext, lv_fs_get_ext);
    
/* Reusing lv_fs_get_letters for lv_fs_up */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_fs_up_obj, 1, mp_lv_fs_get_letters, lv_fs_up);
    
/* Reusing lv_fs_get_ext for lv_fs_get_last */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_fs_get_last_obj, 1, mp_lv_fs_get_ext, lv_fs_get_last);
    

/*
 * lvgl extension definition for:
 * uint32_t lv_layout_register(lv_layout_update_cb_t cb, void *user_data)
 */
 
STATIC mp_obj_t mp_lv_layout_register(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    void *user_data = mp_to_ptr(mp_args[1]);
    void *cb = mp_lv_callback(mp_args[0], &cb_callback, MP_QSTR_cb, &user_data);
    uint32_t _res = ((uint32_t (*)(lv_layout_update_cb_t, void *))lv_func_ptr)(cb, user_data);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_layout_register_obj, 2, mp_lv_layout_register, lv_layout_register);
    

/*
 * lvgl extension definition for:
 * lv_coord_t lv_clamp_width(lv_coord_t width, lv_coord_t min_width, lv_coord_t max_width, lv_coord_t ref_width)
 */
 
STATIC mp_obj_t mp_lv_clamp_width(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_coord_t width = (int16_t)mp_obj_get_int(mp_args[0]);
    lv_coord_t min_width = (int16_t)mp_obj_get_int(mp_args[1]);
    lv_coord_t max_width = (int16_t)mp_obj_get_int(mp_args[2]);
    lv_coord_t ref_width = (int16_t)mp_obj_get_int(mp_args[3]);
    lv_coord_t _res = ((lv_coord_t (*)(lv_coord_t, lv_coord_t, lv_coord_t, lv_coord_t))lv_func_ptr)(width, min_width, max_width, ref_width);
    return mp_obj_new_int(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_clamp_width_obj, 4, mp_lv_clamp_width, lv_clamp_width);
    
/* Reusing lv_clamp_width for lv_clamp_height */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_clamp_height_obj, 4, mp_lv_clamp_width, lv_clamp_height);
    

/*
 * lvgl extension definition for:
 * void lv_gradient_set_cache_size(size_t max_bytes)
 */
 
STATIC mp_obj_t mp_lv_gradient_set_cache_size(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    size_t max_bytes = (size_t)mp_obj_get_int(mp_args[0]);
    ((void (*)(size_t))lv_func_ptr)(max_bytes);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_gradient_set_cache_size_obj, 1, mp_lv_gradient_set_cache_size, lv_gradient_set_cache_size);
    
/* Reusing lv_mem_init for lv_gradient_free_cache */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_gradient_free_cache_obj, 0, mp_lv_mem_init, lv_gradient_free_cache);
    

/*
 * lvgl extension definition for:
 * void lv_draw_arc_get_area(lv_coord_t x, lv_coord_t y, uint16_t radius, uint16_t start_angle, uint16_t end_angle, lv_coord_t w, bool rounded, lv_area_t *area)
 */
 
STATIC mp_obj_t mp_lv_draw_arc_get_area(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_coord_t x = (int16_t)mp_obj_get_int(mp_args[0]);
    lv_coord_t y = (int16_t)mp_obj_get_int(mp_args[1]);
    uint16_t radius = (uint16_t)mp_obj_get_int(mp_args[2]);
    uint16_t start_angle = (uint16_t)mp_obj_get_int(mp_args[3]);
    uint16_t end_angle = (uint16_t)mp_obj_get_int(mp_args[4]);
    lv_coord_t w = (int16_t)mp_obj_get_int(mp_args[5]);
    bool rounded = mp_obj_is_true(mp_args[6]);
    lv_area_t *area = mp_write_ptr_lv_area_t(mp_args[7]);
    ((void (*)(lv_coord_t, lv_coord_t, uint16_t, uint16_t, uint16_t, lv_coord_t, bool, lv_area_t *))lv_func_ptr)(x, y, radius, start_angle, end_angle, w, rounded, area);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_draw_arc_get_area_obj, 8, mp_lv_draw_arc_get_area, lv_draw_arc_get_area);
    

/*
 * lvgl extension definition for:
 * int16_t lv_draw_mask_add(void *param, void *custom_id)
 */
 
STATIC mp_obj_t mp_lv_draw_mask_add(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    void *param = mp_to_ptr(mp_args[0]);
    void *custom_id = mp_to_ptr(mp_args[1]);
    int16_t _res = ((int16_t (*)(void *, void *))lv_func_ptr)(param, custom_id);
    return mp_obj_new_int(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_draw_mask_add_obj, 2, mp_lv_draw_mask_add, lv_draw_mask_add);
    

/*
 * lvgl extension definition for:
 * lv_draw_mask_res_t lv_draw_mask_apply(lv_opa_t *mask_buf, lv_coord_t abs_x, lv_coord_t abs_y, lv_coord_t len)
 */
 
STATIC mp_obj_t mp_lv_draw_mask_apply(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_opa_t *mask_buf = mp_to_ptr(mp_args[0]);
    lv_coord_t abs_x = (int16_t)mp_obj_get_int(mp_args[1]);
    lv_coord_t abs_y = (int16_t)mp_obj_get_int(mp_args[2]);
    lv_coord_t len = (int16_t)mp_obj_get_int(mp_args[3]);
    lv_draw_mask_res_t _res = ((lv_draw_mask_res_t (*)(lv_opa_t *, lv_coord_t, lv_coord_t, lv_coord_t))lv_func_ptr)(mask_buf, abs_x, abs_y, len);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_draw_mask_apply_obj, 4, mp_lv_draw_mask_apply, lv_draw_mask_apply);
    

/*
 * lvgl extension definition for:
 * lv_draw_mask_res_t lv_draw_mask_apply_ids(lv_opa_t *mask_buf, lv_coord_t abs_x, lv_coord_t abs_y, lv_coord_t len, const int16_t *ids, int16_t ids_count)
 */
 
STATIC mp_obj_t mp_lv_draw_mask_apply_ids(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_opa_t *mask_buf = mp_to_ptr(mp_args[0]);
    lv_coord_t abs_x = (int16_t)mp_obj_get_int(mp_args[1]);
    lv_coord_t abs_y = (int16_t)mp_obj_get_int(mp_args[2]);
    lv_coord_t len = (int16_t)mp_obj_get_int(mp_args[3]);
    const int16_t *ids = mp_to_ptr(mp_args[4]);
    int16_t ids_count = (int16_t)mp_obj_get_int(mp_args[5]);
    lv_draw_mask_res_t _res = ((lv_draw_mask_res_t (*)(lv_opa_t *, lv_coord_t, lv_coord_t, lv_coord_t, const int16_t *, int16_t))lv_func_ptr)(mask_buf, abs_x, abs_y, len, ids, ids_count);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_draw_mask_apply_ids_obj, 6, mp_lv_draw_mask_apply_ids, lv_draw_mask_apply_ids);
    

/*
 * lvgl extension definition for:
 * void *lv_draw_mask_remove_id(int16_t id)
 */
 
STATIC mp_obj_t mp_lv_draw_mask_remove_id(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    int16_t id = (int16_t)mp_obj_get_int(mp_args[0]);
    void * _res = ((void *(*)(int16_t))lv_func_ptr)(id);
    return ptr_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_draw_mask_remove_id_obj, 1, mp_lv_draw_mask_remove_id, lv_draw_mask_remove_id);
    

/*
 * lvgl extension definition for:
 * void *lv_draw_mask_remove_custom(void *custom_id)
 */
 
STATIC mp_obj_t mp_lv_draw_mask_remove_custom(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    void *custom_id = mp_to_ptr(mp_args[0]);
    void * _res = ((void *(*)(void *))lv_func_ptr)(custom_id);
    return ptr_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_draw_mask_remove_custom_obj, 1, mp_lv_draw_mask_remove_custom, lv_draw_mask_remove_custom);
    
/* Reusing funcptr_lv_async_cb_t for lv_draw_mask_free_param */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_draw_mask_free_param_obj, 1, mp_funcptr_lv_async_cb_t, lv_draw_mask_free_param);
    
/* Reusing lv_timer_get_idle for lv_draw_mask_get_cnt */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_draw_mask_get_cnt_obj, 0, mp_lv_timer_get_idle, lv_draw_mask_get_cnt);
    

/*
 * lvgl extension definition for:
 * bool lv_draw_mask_is_any(const lv_area_t *a)
 */
 
STATIC mp_obj_t mp_lv_draw_mask_is_any(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_area_t *a = mp_write_ptr_lv_area_t(mp_args[0]);
    bool _res = ((bool (*)(const lv_area_t *))lv_func_ptr)(a);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_draw_mask_is_any_obj, 1, mp_lv_draw_mask_is_any, lv_draw_mask_is_any);
    
/* Reusing lv_mem_init for lv_draw_init */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_draw_init_obj, 0, mp_lv_mem_init, lv_draw_init);
    

/*
 * lvgl extension definition for:
 * lv_disp_t *lv_disp_get_default(void)
 */
 
STATIC mp_obj_t mp_lv_disp_get_default(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    
    lv_disp_t * _res = ((lv_disp_t *(*)(void))lv_func_ptr)();
    return mp_read_ptr_lv_disp_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_disp_get_default_obj, 0, mp_lv_disp_get_default, lv_disp_get_default);
    

/*
 * lvgl extension definition for:
 * lv_res_t lv_event_send(struct _lv_obj_t *obj, lv_event_code_t event_code, void *param)
 */
 
STATIC mp_obj_t mp_lv_event_send(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_event_code_t event_code = (int)mp_obj_get_int(mp_args[1]);
    void *param = mp_to_ptr(mp_args[2]);
    lv_res_t _res = ((lv_res_t (*)(struct _lv_obj_t *, lv_event_code_t, void *))lv_func_ptr)(obj, event_code, param);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_event_send_obj, 3, mp_lv_event_send, lv_event_send);
    
/* Reusing lv_task_handler for lv_event_register_id */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_event_register_id_obj, 0, mp_lv_task_handler, lv_event_register_id);
    

/*
 * lvgl extension definition for:
 * lv_group_t *lv_group_create(void)
 */
 
STATIC mp_obj_t mp_lv_group_create(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    
    lv_group_t * _res = ((lv_group_t *(*)(void))lv_func_ptr)();
    return mp_read_ptr_lv_group_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_group_create_obj, 0, mp_lv_group_create, lv_group_create);
    
/* Reusing lv_group_create for lv_group_get_default */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_group_get_default_obj, 0, mp_lv_group_create, lv_group_get_default);
    
/* Reusing lv_obj_set_parent for lv_group_swap_obj */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_group_swap_obj_obj, 2, mp_lv_obj_set_parent, lv_group_swap_obj);
    
/* Reusing lv_obj_center for lv_group_remove_obj */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_group_remove_obj_obj, 1, mp_lv_obj_center, lv_group_remove_obj);
    
/* Reusing lv_obj_center for lv_group_focus_obj */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_group_focus_obj_obj, 1, mp_lv_obj_center, lv_group_focus_obj);
    
/* Reusing lv_mem_init for lv_init */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_init_obj, 0, mp_lv_mem_init, lv_init);
    
/* Reusing lv_mem_init for lv_deinit */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_deinit_obj, 0, mp_lv_mem_init, lv_deinit);
    

/*
 * lvgl extension definition for:
 * bool lv_is_initialized(void)
 */
 
STATIC mp_obj_t mp_lv_is_initialized(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    
    bool _res = ((bool (*)(void))lv_func_ptr)();
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_is_initialized_obj, 0, mp_lv_is_initialized, lv_is_initialized);
    
/* Reusing lv_timer_del for lv_indev_read_timer_cb */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_indev_read_timer_cb_obj, 1, mp_lv_timer_del, lv_indev_read_timer_cb);
    

/*
 * lvgl extension definition for:
 * lv_indev_t *lv_indev_get_act(void)
 */
 
STATIC mp_obj_t mp_lv_indev_get_act(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    
    lv_indev_t * _res = ((lv_indev_t *(*)(void))lv_func_ptr)();
    return mp_read_ptr_lv_indev_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_indev_get_act_obj, 0, mp_lv_indev_get_act, lv_indev_get_act);
    
/* Reusing lv_scr_act for lv_indev_get_obj_act */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_indev_get_obj_act_obj, 0, mp_lv_scr_act, lv_indev_get_obj_act);
    

/*
 * lvgl extension definition for:
 * lv_timer_t *lv_indev_get_read_timer(lv_disp_t *indev)
 */
 
STATIC mp_obj_t mp_lv_indev_get_read_timer(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_disp_t *indev = mp_write_ptr_lv_disp_t(mp_args[0]);
    lv_timer_t * _res = ((lv_timer_t *(*)(lv_disp_t *))lv_func_ptr)(indev);
    return mp_read_ptr_lv_timer_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_indev_get_read_timer_obj, 1, mp_lv_indev_get_read_timer, lv_indev_get_read_timer);
    

/*
 * lvgl extension definition for:
 * lv_obj_t *lv_indev_search_obj(lv_obj_t *obj, lv_point_t *point)
 */
 
STATIC mp_obj_t mp_lv_indev_search_obj(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_point_t *point = mp_write_ptr_lv_point_t(mp_args[1]);
    lv_obj_t * _res = ((lv_obj_t *(*)(lv_obj_t *, lv_point_t *))lv_func_ptr)(obj, point);
    return lv_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_indev_search_obj_obj, 2, mp_lv_indev_search_obj, lv_indev_search_obj);
    
/* Reusing lv_disp_remove for lv_refr_now */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_refr_now_obj, 1, mp_lv_disp_remove, lv_refr_now);
    

/*
 * lvgl extension definition for:
 * lv_theme_t *lv_theme_get_from_obj(lv_obj_t *obj)
 */
 
STATIC mp_obj_t mp_lv_theme_get_from_obj(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_theme_t * _res = ((lv_theme_t *(*)(lv_obj_t *))lv_func_ptr)(obj);
    return mp_read_ptr_lv_theme_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_theme_get_from_obj_obj, 1, mp_lv_theme_get_from_obj, lv_theme_get_from_obj);
    
/* Reusing lv_obj_move_foreground for lv_theme_apply */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_theme_apply_obj, 1, mp_lv_obj_move_foreground, lv_theme_apply);
    

/*
 * lvgl extension definition for:
 * const lv_font_t *lv_theme_get_font_small(lv_obj_t *obj)
 */
 
STATIC mp_obj_t mp_lv_theme_get_font_small(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    const lv_font_t * _res = ((const lv_font_t *(*)(lv_obj_t *))lv_func_ptr)(obj);
    return mp_read_ptr_lv_font_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_theme_get_font_small_obj, 1, mp_lv_theme_get_font_small, lv_theme_get_font_small);
    
/* Reusing lv_theme_get_font_small for lv_theme_get_font_normal */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_theme_get_font_normal_obj, 1, mp_lv_theme_get_font_small, lv_theme_get_font_normal);
    
/* Reusing lv_theme_get_font_small for lv_theme_get_font_large */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_theme_get_font_large_obj, 1, mp_lv_theme_get_font_small, lv_theme_get_font_large);
    
/* Reusing lv_colorwheel_get_rgb for lv_theme_get_color_primary */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_theme_get_color_primary_obj, 1, mp_lv_colorwheel_get_rgb, lv_theme_get_color_primary);
    
/* Reusing lv_colorwheel_get_rgb for lv_theme_get_color_secondary */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_theme_get_color_secondary_obj, 1, mp_lv_colorwheel_get_rgb, lv_theme_get_color_secondary);
    
/* Reusing lv_obj_move_foreground for lv_disp_load_scr */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_disp_load_scr_obj, 1, mp_lv_obj_move_foreground, lv_disp_load_scr);
    

/*
 * lvgl extension definition for:
 * void lv_scr_load_anim(lv_obj_t *scr, lv_scr_load_anim_t anim_type, uint32_t time, uint32_t delay, bool auto_del)
 */
 
STATIC mp_obj_t mp_lv_scr_load_anim(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *scr = mp_to_lv(mp_args[0]);
    lv_scr_load_anim_t anim_type = (int)mp_obj_get_int(mp_args[1]);
    uint32_t time = (uint32_t)mp_obj_get_int(mp_args[2]);
    uint32_t delay = (uint32_t)mp_obj_get_int(mp_args[3]);
    bool auto_del = mp_obj_is_true(mp_args[4]);
    ((void (*)(lv_obj_t *, lv_scr_load_anim_t, uint32_t, uint32_t, bool))lv_func_ptr)(scr, anim_type, time, delay, auto_del);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_scr_load_anim_obj, 5, mp_lv_scr_load_anim, lv_scr_load_anim);
    

/*
 * lvgl extension definition for:
 * lv_font_t *lv_font_load(const char *fontName)
 */
 
STATIC mp_obj_t mp_lv_font_load(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const char *fontName = (char*)convert_from_str(mp_args[0]);
    lv_font_t * _res = ((lv_font_t *(*)(const char *))lv_func_ptr)(fontName);
    return mp_read_ptr_lv_font_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_font_load_obj, 1, mp_lv_font_load, lv_font_load);
    

/*
 * lvgl extension definition for:
 * lv_img_dsc_t *lv_snapshot_take(lv_obj_t *obj, lv_img_cf_t cf)
 */
 
STATIC mp_obj_t mp_lv_snapshot_take(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_img_cf_t cf = (uint8_t)mp_obj_get_int(mp_args[1]);
    lv_img_dsc_t * _res = ((lv_img_dsc_t *(*)(lv_obj_t *, lv_img_cf_t))lv_func_ptr)(obj, cf);
    return mp_read_ptr_lv_img_dsc_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_snapshot_take_obj, 2, mp_lv_snapshot_take, lv_snapshot_take);
    
/* Reusing lv_img_buf_free for lv_snapshot_free */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_snapshot_free_obj, 1, mp_lv_img_buf_free, lv_snapshot_free);
    

/*
 * lvgl extension definition for:
 * uint32_t lv_snapshot_buf_size_needed(lv_obj_t *obj, lv_img_cf_t cf)
 */
 
STATIC mp_obj_t mp_lv_snapshot_buf_size_needed(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_img_cf_t cf = (uint8_t)mp_obj_get_int(mp_args[1]);
    uint32_t _res = ((uint32_t (*)(lv_obj_t *, lv_img_cf_t))lv_func_ptr)(obj, cf);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_snapshot_buf_size_needed_obj, 2, mp_lv_snapshot_buf_size_needed, lv_snapshot_buf_size_needed);
    

/*
 * lvgl extension definition for:
 * lv_res_t lv_snapshot_take_to_buf(lv_obj_t *obj, lv_img_cf_t cf, lv_img_dsc_t *dsc, void *buf, uint32_t buff_size)
 */
 
STATIC mp_obj_t mp_lv_snapshot_take_to_buf(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_img_cf_t cf = (uint8_t)mp_obj_get_int(mp_args[1]);
    lv_img_dsc_t *dsc = mp_write_ptr_lv_img_dsc_t(mp_args[2]);
    void *buf = mp_to_ptr(mp_args[3]);
    uint32_t buff_size = (uint32_t)mp_obj_get_int(mp_args[4]);
    lv_res_t _res = ((lv_res_t (*)(lv_obj_t *, lv_img_cf_t, lv_img_dsc_t *, void *, uint32_t))lv_func_ptr)(obj, cf, dsc, buf, buff_size);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_snapshot_take_to_buf_obj, 5, mp_lv_snapshot_take_to_buf, lv_snapshot_take_to_buf);
    
/* Reusing lv_mem_init for lv_flex_init */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_flex_init_obj, 0, mp_lv_mem_init, lv_flex_init);
    
/* Reusing lv_mem_init for lv_grid_init */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_grid_init_obj, 0, mp_lv_mem_init, lv_grid_init);
    
/* Reusing lv_mem_init for lv_fs_posix_init */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_fs_posix_init_obj, 0, mp_lv_mem_init, lv_fs_posix_init);
    

/*
 * lvgl extension definition for:
 * gd_GIF *gd_open_gif_file(const char *fname)
 */
 
STATIC mp_obj_t mp_gd_open_gif_file(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const char *fname = (char*)convert_from_str(mp_args[0]);
    gd_GIF * _res = ((gd_GIF *(*)(const char *))lv_func_ptr)(fname);
    return mp_read_ptr_gd_GIF((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_gd_open_gif_file_obj, 1, mp_gd_open_gif_file, gd_open_gif_file);
    

/*
 * lvgl extension definition for:
 * gd_GIF *gd_open_gif_data(const void *data)
 */
 
STATIC mp_obj_t mp_gd_open_gif_data(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const void *data = mp_to_ptr(mp_args[0]);
    gd_GIF * _res = ((gd_GIF *(*)(const void *))lv_func_ptr)(data);
    return mp_read_ptr_gd_GIF((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_gd_open_gif_data_obj, 1, mp_gd_open_gif_data, gd_open_gif_data);
    

/*
 * lvgl extension definition for:
 * lv_theme_t *lv_theme_mono_init(lv_disp_t *disp, bool dark_bg, const lv_font_t *font)
 */
 
STATIC mp_obj_t mp_lv_theme_mono_init(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_disp_t *disp = mp_write_ptr_lv_disp_t(mp_args[0]);
    bool dark_bg = mp_obj_is_true(mp_args[1]);
    const lv_font_t *font = mp_write_ptr_lv_font_t(mp_args[2]);
    lv_theme_t * _res = ((lv_theme_t *(*)(lv_disp_t *, bool, const lv_font_t *))lv_func_ptr)(disp, dark_bg, font);
    return mp_read_ptr_lv_theme_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_theme_mono_init_obj, 3, mp_lv_theme_mono_init, lv_theme_mono_init);
    
/* Reusing lv_is_initialized for lv_theme_mono_is_inited */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_theme_mono_is_inited_obj, 0, mp_lv_is_initialized, lv_theme_mono_is_inited);
    
/* Reusing lv_disp_get_theme for lv_theme_basic_init */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_theme_basic_init_obj, 1, mp_lv_disp_get_theme, lv_theme_basic_init);
    
/* Reusing lv_is_initialized for lv_theme_basic_is_inited */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_theme_basic_is_inited_obj, 0, mp_lv_is_initialized, lv_theme_basic_is_inited);
    
/* Reusing lv_mem_init for lv_extra_init */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_extra_init_obj, 0, mp_lv_mem_init, lv_extra_init);
    

/*
 * lvgl extension definition for:
 * char *lv_event_to_name(int event)
 */
 
STATIC mp_obj_t mp_lv_event_to_name(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    int event = (int)mp_obj_get_int(mp_args[0]);
    char * _res = ((char *(*)(int))lv_func_ptr)(event);
    return convert_to_str((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_event_to_name_obj, 1, mp_lv_event_to_name, lv_event_to_name);
    

/*
 * lvgl extension definition for:
 * lv_obj_t *lvsf_text_create2(lv_obj_t *parent, char *text, int x, int y, int angle, lv_color_t color, int size)
 */
 
STATIC mp_obj_t mp_lvsf_text_create2(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *parent = mp_to_lv(mp_args[0]);
    char *text = (char*)convert_from_str(mp_args[1]);
    int x = (int)mp_obj_get_int(mp_args[2]);
    int y = (int)mp_obj_get_int(mp_args[3]);
    int angle = (int)mp_obj_get_int(mp_args[4]);
    lv_color_t color = mp_write_lv_color16_t(mp_args[5]);
    int size = (int)mp_obj_get_int(mp_args[6]);
    lv_obj_t * _res = ((lv_obj_t *(*)(lv_obj_t *, char *, int, int, int, lv_color_t, int))lv_func_ptr)(parent, text, x, y, angle, color, size);
    return lv_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lvsf_text_create2_obj, 7, mp_lvsf_text_create2, lvsf_text_create2);
    

/*
 * lvgl extension definition for:
 * lv_obj_t *lvsf_curve_text(lv_obj_t *parent, char *text, int x, int y, int angle, int r, lv_color_t color, int size)
 */
 
STATIC mp_obj_t mp_lvsf_curve_text(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *parent = mp_to_lv(mp_args[0]);
    char *text = (char*)convert_from_str(mp_args[1]);
    int x = (int)mp_obj_get_int(mp_args[2]);
    int y = (int)mp_obj_get_int(mp_args[3]);
    int angle = (int)mp_obj_get_int(mp_args[4]);
    int r = (int)mp_obj_get_int(mp_args[5]);
    lv_color_t color = mp_write_lv_color16_t(mp_args[6]);
    int size = (int)mp_obj_get_int(mp_args[7]);
    lv_obj_t * _res = ((lv_obj_t *(*)(lv_obj_t *, char *, int, int, int, int, lv_color_t, int))lv_func_ptr)(parent, text, x, y, angle, r, color, size);
    return lv_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lvsf_curve_text_obj, 8, mp_lvsf_curve_text, lvsf_curve_text);
    

/*
 * lvgl extension definition for:
 * void lvsf_curve_draw_text(lv_obj_t *parent, char *text, int corner_startx, int corner_starty, int angle, int r, lv_color_t color, int size)
 */
 
STATIC mp_obj_t mp_lvsf_curve_draw_text(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *parent = mp_to_lv(mp_args[0]);
    char *text = (char*)convert_from_str(mp_args[1]);
    int corner_startx = (int)mp_obj_get_int(mp_args[2]);
    int corner_starty = (int)mp_obj_get_int(mp_args[3]);
    int angle = (int)mp_obj_get_int(mp_args[4]);
    int r = (int)mp_obj_get_int(mp_args[5]);
    lv_color_t color = mp_write_lv_color16_t(mp_args[6]);
    int size = (int)mp_obj_get_int(mp_args[7]);
    ((void (*)(lv_obj_t *, char *, int, int, int, int, lv_color_t, int))lv_func_ptr)(parent, text, corner_startx, corner_starty, angle, r, color, size);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lvsf_curve_draw_text_obj, 8, mp_lvsf_curve_draw_text, lvsf_curve_draw_text);
    

/*
 * lvgl extension definition for:
 * int lvsf_font_width(int font_size, char c)
 */
 
STATIC mp_obj_t mp_lvsf_font_width(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    int font_size = (int)mp_obj_get_int(mp_args[0]);
    char c = (char)mp_obj_get_int(mp_args[1]);
    int _res = ((int (*)(int, char))lv_func_ptr)(font_size, c);
    return mp_obj_new_int(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lvsf_font_width_obj, 2, mp_lvsf_font_width, lvsf_font_width);
    

/*
 * lvgl extension definition for:
 * int lvsf_font_height(int font_size)
 */
 
STATIC mp_obj_t mp_lvsf_font_height(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    int font_size = (int)mp_obj_get_int(mp_args[0]);
    int _res = ((int (*)(int))lv_func_ptr)(font_size);
    return mp_obj_new_int(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lvsf_font_height_obj, 1, mp_lvsf_font_height, lvsf_font_height);
    

/*
 * lvgl extension definition for:
 * void lvsf_canvas_rotate(lv_obj_t *canvas, lv_img_dsc_t *img, int16_t angle, int32_t zoom, lv_coord_t offset_x, lv_coord_t offset_y, int32_t pivot_x, int32_t pivot_y)
 */
 
STATIC mp_obj_t mp_lvsf_canvas_rotate(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *canvas = mp_to_lv(mp_args[0]);
    lv_img_dsc_t *img = mp_write_ptr_lv_img_dsc_t(mp_args[1]);
    int16_t angle = (int16_t)mp_obj_get_int(mp_args[2]);
    int32_t zoom = (int32_t)mp_obj_get_int(mp_args[3]);
    lv_coord_t offset_x = (int16_t)mp_obj_get_int(mp_args[4]);
    lv_coord_t offset_y = (int16_t)mp_obj_get_int(mp_args[5]);
    int32_t pivot_x = (int32_t)mp_obj_get_int(mp_args[6]);
    int32_t pivot_y = (int32_t)mp_obj_get_int(mp_args[7]);
    ((void (*)(lv_obj_t *, lv_img_dsc_t *, int16_t, int32_t, lv_coord_t, lv_coord_t, int32_t, int32_t))lv_func_ptr)(canvas, img, angle, zoom, offset_x, offset_y, pivot_x, pivot_y);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lvsf_canvas_rotate_obj, 8, mp_lvsf_canvas_rotate, lvsf_canvas_rotate);
    

/*
 * lvgl extension definition for:
 * lv_ex_data_t *lv_ex_data_create(const char *name, lv_ex_data_type_t type)
 */
 
STATIC mp_obj_t mp_lv_ex_data_create(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const char *name = (char*)convert_from_str(mp_args[0]);
    lv_ex_data_type_t type = (int)mp_obj_get_int(mp_args[1]);
    lv_ex_data_t * _res = ((lv_ex_data_t *(*)(const char *, lv_ex_data_type_t))lv_func_ptr)(name, type);
    return mp_read_ptr_lv_ex_data_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_ex_data_create_obj, 2, mp_lv_ex_data_create, lv_ex_data_create);
    
/* Reusing lv_mem_init for lv_ex_process_data */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_ex_process_data_obj, 0, mp_lv_mem_init, lv_ex_process_data);
    
/* Reusing lv_mem_init for lv_ex_data_pool_init */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_ex_data_pool_init_obj, 0, mp_lv_mem_init, lv_ex_data_pool_init);
    

/*
 * Function NOT generated:
 * Callback argument 'lv_key_handler_t h' cannot be the first argument! We assume the first argument contains the user_data
 * lv_key_handler_t h
 */
    

/*
 * lvgl extension definition for:
 * int32_t keypad_handler_register(lv_key_handler_t h)
 */
 
STATIC mp_obj_t mp_keypad_handler_register(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_key_handler_t h = mp_to_ptr(mp_args[0]);
    int32_t _res = ((int32_t (*)(lv_key_handler_t))lv_func_ptr)(h);
    return mp_obj_new_int(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_keypad_handler_register_obj, 1, mp_keypad_handler_register, keypad_handler_register);
    
/* Reusing keypad_handler_register for keypad_default_handler_register */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_keypad_default_handler_register_obj, 1, mp_keypad_handler_register, keypad_default_handler_register);
    
/* Reusing funcptr_lv_key_handler_t for keypad_do_event */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_keypad_do_event_obj, 2, mp_funcptr_lv_key_handler_t, keypad_do_event);
    

/*
 * lvgl extension definition for:
 * int32_t wheel_do_event(int16_t diff, lv_indev_state_t event)
 */
 
STATIC mp_obj_t mp_wheel_do_event(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    int16_t diff = (int16_t)mp_obj_get_int(mp_args[0]);
    lv_indev_state_t event = (int)mp_obj_get_int(mp_args[1]);
    int32_t _res = ((int32_t (*)(int16_t, lv_indev_state_t))lv_func_ptr)(diff, event);
    return mp_obj_new_int(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_wheel_do_event_obj, 2, mp_wheel_do_event, wheel_do_event);
    

/*
 * Function NOT generated:
 * Callback: user_data NOT FOUND! int32_t lv_defaultwheel_handler_t(int16_t diff, lv_indev_state_t event, void *user_data)
 * lv_defaultwheel_handler_t h
 */
    

/*
 * lvgl extension definition for:
 * int32_t wheel_default_handler_register(lv_defaultwheel_handler_t h, void *user_data)
 */
 
STATIC mp_obj_t mp_wheel_default_handler_register(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    void *user_data = mp_to_ptr(mp_args[1]);
    lv_defaultwheel_handler_t h = mp_to_ptr(mp_args[0]);
    int32_t _res = ((int32_t (*)(lv_defaultwheel_handler_t, void *))lv_func_ptr)(h, user_data);
    return mp_obj_new_int(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_wheel_default_handler_register_obj, 2, mp_wheel_default_handler_register, wheel_default_handler_register);
    
/* Reusing lv_obj_move_foreground for lvsf_gesture_init */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lvsf_gesture_init_obj, 1, mp_lv_obj_move_foreground, lvsf_gesture_init);
    
/* Reusing lv_mem_init for lvsf_gesture_deinit */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lvsf_gesture_deinit_obj, 0, mp_lv_mem_init, lvsf_gesture_deinit);
    

/*
 * lvgl extension definition for:
 * void lvsf_gesture_set_image(uint32_t idx, const void *src_img)
 */
 
STATIC mp_obj_t mp_lvsf_gesture_set_image(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    uint32_t idx = (uint32_t)mp_obj_get_int(mp_args[0]);
    const void *src_img = mp_to_ptr(mp_args[1]);
    ((void (*)(uint32_t, const void *))lv_func_ptr)(idx, src_img);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lvsf_gesture_set_image_obj, 2, mp_lvsf_gesture_set_image, lvsf_gesture_set_image);
    
/* Reusing lv_mem_init for lvsf_gesture_disable */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lvsf_gesture_disable_obj, 0, mp_lv_mem_init, lvsf_gesture_disable);
    
/* Reusing lv_mem_init for lvsf_gesture_enable */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lvsf_gesture_enable_obj, 0, mp_lv_mem_init, lvsf_gesture_enable);
    
/* Reusing lv_mem_buf_get for lv_get_emoji_by_unicode */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_get_emoji_by_unicode_obj, 1, mp_lv_mem_buf_get, lv_get_emoji_by_unicode);
    

/*
 * lvgl extension definition for:
 * void lv_theme_1_init()
 */
 
STATIC mp_obj_t mp_lv_theme_1_init(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    
    ((void (*)())lv_func_ptr)();
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_theme_1_init_obj, 0, mp_lv_theme_1_init, lv_theme_1_init);
    

/*
 * lvgl extension definition for:
 * lv_coord_t lv_get_ver_max()
 */
 
STATIC mp_obj_t mp_lv_get_ver_max(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    
    lv_coord_t _res = ((lv_coord_t (*)())lv_func_ptr)();
    return mp_obj_new_int(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_get_ver_max_obj, 0, mp_lv_get_ver_max, lv_get_ver_max);
    
/* Reusing lv_get_ver_max for lv_get_hor_max */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_get_hor_max_obj, 0, mp_lv_get_ver_max, lv_get_hor_max);
    

/*
 * lvgl extension definition for:
 * intent_t intent_init(const char *action)
 */
 
STATIC mp_obj_t mp_intent_init(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const char *action = (char*)convert_from_str(mp_args[0]);
    intent_t _res = ((intent_t (*)(const char *))lv_func_ptr)(action);
    return ptr_to_mp(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_intent_init_obj, 1, mp_intent_init, intent_init);
    

/*
 * lvgl extension definition for:
 * void intent_deinit(intent_t i)
 */
 
STATIC mp_obj_t mp_intent_deinit(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    intent_t i = mp_to_ptr(mp_args[0]);
    ((void (*)(intent_t))lv_func_ptr)(i);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_intent_deinit_obj, 1, mp_intent_deinit, intent_deinit);
    

/*
 * lvgl extension definition for:
 * int intent_set_string(intent_t i, const char *name, const char *value)
 */
 
STATIC mp_obj_t mp_intent_set_string(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    intent_t i = mp_to_ptr(mp_args[0]);
    const char *name = (char*)convert_from_str(mp_args[1]);
    const char *value = (char*)convert_from_str(mp_args[2]);
    int _res = ((int (*)(intent_t, const char *, const char *))lv_func_ptr)(i, name, value);
    return mp_obj_new_int(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_intent_set_string_obj, 3, mp_intent_set_string, intent_set_string);
    

/*
 * lvgl extension definition for:
 * const char *intent_get_string(intent_t i, const char *name)
 */
 
STATIC mp_obj_t mp_intent_get_string(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    intent_t i = mp_to_ptr(mp_args[0]);
    const char *name = (char*)convert_from_str(mp_args[1]);
    const char * _res = ((const char *(*)(intent_t, const char *))lv_func_ptr)(i, name);
    return convert_to_str((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_intent_get_string_obj, 2, mp_intent_get_string, intent_get_string);
    

/*
 * lvgl extension definition for:
 * int intent_set_uint32(intent_t i, const char *name, uint32_t value)
 */
 
STATIC mp_obj_t mp_intent_set_uint32(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    intent_t i = mp_to_ptr(mp_args[0]);
    const char *name = (char*)convert_from_str(mp_args[1]);
    uint32_t value = (uint32_t)mp_obj_get_int(mp_args[2]);
    int _res = ((int (*)(intent_t, const char *, uint32_t))lv_func_ptr)(i, name, value);
    return mp_obj_new_int(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_intent_set_uint32_obj, 3, mp_intent_set_uint32, intent_set_uint32);
    

/*
 * lvgl extension definition for:
 * uint32_t intent_get_uint32(intent_t i, const char *name, uint32_t err_value)
 */
 
STATIC mp_obj_t mp_intent_get_uint32(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    intent_t i = mp_to_ptr(mp_args[0]);
    const char *name = (char*)convert_from_str(mp_args[1]);
    uint32_t err_value = (uint32_t)mp_obj_get_int(mp_args[2]);
    uint32_t _res = ((uint32_t (*)(intent_t, const char *, uint32_t))lv_func_ptr)(i, name, err_value);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_intent_get_uint32_obj, 3, mp_intent_get_uint32, intent_get_uint32);
    

/*
 * lvgl extension definition for:
 * int intent_runapp(intent_t i)
 */
 
STATIC mp_obj_t mp_intent_runapp(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    intent_t i = mp_to_ptr(mp_args[0]);
    int _res = ((int (*)(intent_t))lv_func_ptr)(i);
    return mp_obj_new_int(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_intent_runapp_obj, 1, mp_intent_runapp, intent_runapp);
    
/* Reusing intent_deinit for printf_intent */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_printf_intent_obj, 1, mp_intent_deinit, printf_intent);
    
/* Reusing lv_mem_init for gui_app_init */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_gui_app_init_obj, 0, mp_lv_mem_init, gui_app_init);
    

/*
 * lvgl extension definition for:
 * int gui_app_run(const char *cmd)
 */
 
STATIC mp_obj_t mp_gui_app_run(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const char *cmd = (char*)convert_from_str(mp_args[0]);
    int _res = ((int (*)(const char *))lv_func_ptr)(cmd);
    return mp_obj_new_int(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_gui_app_run_obj, 1, mp_gui_app_run, gui_app_run);
    
/* Reusing gui_app_run for gui_app_exit */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_gui_app_exit_obj, 1, mp_gui_app_run, gui_app_exit);
    
/* Reusing lv_mem_init for gui_app_self_exit */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_gui_app_self_exit_obj, 0, mp_lv_mem_init, gui_app_self_exit);
    

/*
 * lvgl extension definition for:
 * bool gui_app_is_actived(char *id)
 */
 
STATIC mp_obj_t mp_gui_app_is_actived(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    char *id = (char*)convert_from_str(mp_args[0]);
    bool _res = ((bool (*)(char *))lv_func_ptr)(id);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_gui_app_is_actived_obj, 1, mp_gui_app_is_actived, gui_app_is_actived);
    

/*
 * lvgl extension definition for:
 * void gui_app_remove_page(const char *pg_id)
 */
 
STATIC mp_obj_t mp_gui_app_remove_page(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const char *pg_id = (char*)convert_from_str(mp_args[0]);
    ((void (*)(const char *))lv_func_ptr)(pg_id);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_gui_app_remove_page_obj, 1, mp_gui_app_remove_page, gui_app_remove_page);
    
/* Reusing gui_app_run for gui_app_goback_to_page */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_gui_app_goback_to_page_obj, 1, mp_gui_app_run, gui_app_goback_to_page);
    
/* Reusing lv_version_major for gui_app_goback */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_gui_app_goback_obj, 0, mp_lv_version_major, gui_app_goback);
    
/* Reusing lv_version_major for gui_app_manual_goback_anim */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_gui_app_manual_goback_anim_obj, 0, mp_lv_version_major, gui_app_manual_goback_anim);
    
/* Reusing lv_mem_init for gui_app_cleanup */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_gui_app_cleanup_obj, 0, mp_lv_mem_init, gui_app_cleanup);
    
/* Reusing lv_mem_init for gui_app_cleanup_now */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_gui_app_cleanup_now_obj, 0, mp_lv_mem_init, gui_app_cleanup_now);
    
/* Reusing gui_app_remove_page for gui_app_run_now */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_gui_app_run_now_obj, 1, mp_gui_app_remove_page, gui_app_run_now);
    
/* Reusing lv_is_initialized for gui_app_is_all_closed */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_gui_app_is_all_closed_obj, 0, mp_lv_is_initialized, gui_app_is_all_closed);
    

/*
 * lvgl extension definition for:
 * intent_t gui_app_get_intent(void)
 */
 
STATIC mp_obj_t mp_gui_app_get_intent(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    
    intent_t _res = ((intent_t (*)(void))lv_func_ptr)();
    return ptr_to_mp(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_gui_app_get_intent_obj, 0, mp_gui_app_get_intent, gui_app_get_intent);
    

/*
 * lvgl extension definition for:
 * void *gui_app_get_page_userdata(const char *pg_id)
 */
 
STATIC mp_obj_t mp_gui_app_get_page_userdata(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const char *pg_id = (char*)convert_from_str(mp_args[0]);
    void * _res = ((void *(*)(const char *))lv_func_ptr)(pg_id);
    return ptr_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_gui_app_get_page_userdata_obj, 1, mp_gui_app_get_page_userdata, gui_app_get_page_userdata);
    

/*
 * lvgl extension definition for:
 * int gui_app_set_page_userdata(const char *pg_id, void *usr_data)
 */
 
STATIC mp_obj_t mp_gui_app_set_page_userdata(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const char *pg_id = (char*)convert_from_str(mp_args[0]);
    void *usr_data = mp_to_ptr(mp_args[1]);
    int _res = ((int (*)(const char *, void *))lv_func_ptr)(pg_id, usr_data);
    return mp_obj_new_int(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_gui_app_set_page_userdata_obj, 2, mp_gui_app_set_page_userdata, gui_app_set_page_userdata);
    
/* Reusing lv_task_handler for gui_app_get_running_apps */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_gui_app_get_running_apps_obj, 0, mp_lv_task_handler, gui_app_get_running_apps);
    

/*
 * lvgl extension definition for:
 * lv_obj_t *gui_app_get_clock_parent()
 */
 
STATIC mp_obj_t mp_gui_app_get_clock_parent(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    
    lv_obj_t * _res = ((lv_obj_t *(*)())lv_func_ptr)();
    return lv_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_gui_app_get_clock_parent_obj, 0, mp_gui_app_get_clock_parent, gui_app_get_clock_parent);
    

/*
 * lvgl lv_font_montserrat_14 global definitions
 */

STATIC const mp_lv_struct_t mp_lv_font_montserrat_14 = {
    { &mp_lv_font_t_type },
    (lv_font_t*)&lv_font_montserrat_14
};
    

/*
 * lvgl lv_obj_class global definitions
 */

STATIC const mp_lv_struct_t mp_lv_obj_class = {
    { &mp_lv_obj_class_t_type },
    (lv_obj_class_t*)&lv_obj_class
};
    

/*
 * lvgl lv_arc_class global definitions
 */

STATIC const mp_lv_struct_t mp_lv_arc_class = {
    { &mp_lv_obj_class_t_type },
    (lv_obj_class_t*)&lv_arc_class
};
    

/*
 * lvgl lv_btn_class global definitions
 */

STATIC const mp_lv_struct_t mp_lv_btn_class = {
    { &mp_lv_obj_class_t_type },
    (lv_obj_class_t*)&lv_btn_class
};
    

/*
 * lvgl lv_img_class global definitions
 */

STATIC const mp_lv_struct_t mp_lv_img_class = {
    { &mp_lv_obj_class_t_type },
    (lv_obj_class_t*)&lv_img_class
};
    

/*
 * lvgl lv_label_class global definitions
 */

STATIC const mp_lv_struct_t mp_lv_label_class = {
    { &mp_lv_obj_class_t_type },
    (lv_obj_class_t*)&lv_label_class
};
    

/*
 * lvgl lv_line_class global definitions
 */

STATIC const mp_lv_struct_t mp_lv_line_class = {
    { &mp_lv_obj_class_t_type },
    (lv_obj_class_t*)&lv_line_class
};
    

/*
 * lvgl lv_table_class global definitions
 */

STATIC const mp_lv_struct_t mp_lv_table_class = {
    { &mp_lv_obj_class_t_type },
    (lv_obj_class_t*)&lv_table_class
};
    

/*
 * lvgl lv_checkbox_class global definitions
 */

STATIC const mp_lv_struct_t mp_lv_checkbox_class = {
    { &mp_lv_obj_class_t_type },
    (lv_obj_class_t*)&lv_checkbox_class
};
    

/*
 * lvgl lv_bar_class global definitions
 */

STATIC const mp_lv_struct_t mp_lv_bar_class = {
    { &mp_lv_obj_class_t_type },
    (lv_obj_class_t*)&lv_bar_class
};
    

/*
 * lvgl lv_slider_class global definitions
 */

STATIC const mp_lv_struct_t mp_lv_slider_class = {
    { &mp_lv_obj_class_t_type },
    (lv_obj_class_t*)&lv_slider_class
};
    

/*
 * lvgl lv_btnmatrix_class global definitions
 */

STATIC const mp_lv_struct_t mp_lv_btnmatrix_class = {
    { &mp_lv_obj_class_t_type },
    (lv_obj_class_t*)&lv_btnmatrix_class
};
    

/*
 * lvgl lv_dropdown_class global definitions
 */

STATIC const mp_lv_struct_t mp_lv_dropdown_class = {
    { &mp_lv_obj_class_t_type },
    (lv_obj_class_t*)&lv_dropdown_class
};
    

/*
 * lvgl lv_dropdownlist_class global definitions
 */

STATIC const mp_lv_struct_t mp_lv_dropdownlist_class = {
    { &mp_lv_obj_class_t_type },
    (lv_obj_class_t*)&lv_dropdownlist_class
};
    

/*
 * lvgl lv_roller_class global definitions
 */

STATIC const mp_lv_struct_t mp_lv_roller_class = {
    { &mp_lv_obj_class_t_type },
    (lv_obj_class_t*)&lv_roller_class
};
    

/*
 * lvgl lv_textarea_class global definitions
 */

STATIC const mp_lv_struct_t mp_lv_textarea_class = {
    { &mp_lv_obj_class_t_type },
    (lv_obj_class_t*)&lv_textarea_class
};
    

/*
 * lvgl lv_canvas_class global definitions
 */

STATIC const mp_lv_struct_t mp_lv_canvas_class = {
    { &mp_lv_obj_class_t_type },
    (lv_obj_class_t*)&lv_canvas_class
};
    

/*
 * lvgl lv_switch_class global definitions
 */

STATIC const mp_lv_struct_t mp_lv_switch_class = {
    { &mp_lv_obj_class_t_type },
    (lv_obj_class_t*)&lv_switch_class
};
    

/*
 * Function NOT generated:
 * Missing conversion to uint16_t when generating global LV_LAYOUT_FLEX
 * LV_LAYOUT_FLEX
 */
    

/*
 * Function NOT generated:
 * Missing conversion to lv_style_prop_t when generating global LV_STYLE_FLEX_FLOW
 * LV_STYLE_FLEX_FLOW
 */
    

/*
 * Function NOT generated:
 * Missing conversion to lv_style_prop_t when generating global LV_STYLE_FLEX_MAIN_PLACE
 * LV_STYLE_FLEX_MAIN_PLACE
 */
    

/*
 * Function NOT generated:
 * Missing conversion to lv_style_prop_t when generating global LV_STYLE_FLEX_CROSS_PLACE
 * LV_STYLE_FLEX_CROSS_PLACE
 */
    

/*
 * Function NOT generated:
 * Missing conversion to lv_style_prop_t when generating global LV_STYLE_FLEX_TRACK_PLACE
 * LV_STYLE_FLEX_TRACK_PLACE
 */
    

/*
 * Function NOT generated:
 * Missing conversion to lv_style_prop_t when generating global LV_STYLE_FLEX_GROW
 * LV_STYLE_FLEX_GROW
 */
    

/*
 * Function NOT generated:
 * Missing conversion to uint16_t when generating global LV_LAYOUT_GRID
 * LV_LAYOUT_GRID
 */
    

/*
 * Function NOT generated:
 * Missing conversion to lv_style_prop_t when generating global LV_STYLE_GRID_COLUMN_DSC_ARRAY
 * LV_STYLE_GRID_COLUMN_DSC_ARRAY
 */
    

/*
 * Function NOT generated:
 * Missing conversion to lv_style_prop_t when generating global LV_STYLE_GRID_COLUMN_ALIGN
 * LV_STYLE_GRID_COLUMN_ALIGN
 */
    

/*
 * Function NOT generated:
 * Missing conversion to lv_style_prop_t when generating global LV_STYLE_GRID_ROW_DSC_ARRAY
 * LV_STYLE_GRID_ROW_DSC_ARRAY
 */
    

/*
 * Function NOT generated:
 * Missing conversion to lv_style_prop_t when generating global LV_STYLE_GRID_ROW_ALIGN
 * LV_STYLE_GRID_ROW_ALIGN
 */
    

/*
 * Function NOT generated:
 * Missing conversion to lv_style_prop_t when generating global LV_STYLE_GRID_CELL_COLUMN_POS
 * LV_STYLE_GRID_CELL_COLUMN_POS
 */
    

/*
 * Function NOT generated:
 * Missing conversion to lv_style_prop_t when generating global LV_STYLE_GRID_CELL_COLUMN_SPAN
 * LV_STYLE_GRID_CELL_COLUMN_SPAN
 */
    

/*
 * Function NOT generated:
 * Missing conversion to lv_style_prop_t when generating global LV_STYLE_GRID_CELL_X_ALIGN
 * LV_STYLE_GRID_CELL_X_ALIGN
 */
    

/*
 * Function NOT generated:
 * Missing conversion to lv_style_prop_t when generating global LV_STYLE_GRID_CELL_ROW_POS
 * LV_STYLE_GRID_CELL_ROW_POS
 */
    

/*
 * Function NOT generated:
 * Missing conversion to lv_style_prop_t when generating global LV_STYLE_GRID_CELL_ROW_SPAN
 * LV_STYLE_GRID_CELL_ROW_SPAN
 */
    

/*
 * Function NOT generated:
 * Missing conversion to lv_style_prop_t when generating global LV_STYLE_GRID_CELL_Y_ALIGN
 * LV_STYLE_GRID_CELL_Y_ALIGN
 */
    

/*
 * lvgl lv_gif_class global definitions
 */

STATIC const mp_lv_struct_t mp_lv_gif_class = {
    { &mp_lv_obj_class_t_type },
    (lv_obj_class_t*)&lv_gif_class
};
    

/*
 * lvgl lv_qrcode_class global definitions
 */

STATIC const mp_lv_struct_t mp_lv_qrcode_class = {
    { &mp_lv_obj_class_t_type },
    (lv_obj_class_t*)&lv_qrcode_class
};
    

/*
 * lvgl lv_animimg_class global definitions
 */

STATIC const mp_lv_struct_t mp_lv_animimg_class = {
    { &mp_lv_obj_class_t_type },
    (lv_obj_class_t*)&lv_animimg_class
};
    

/*
 * lvgl lv_calendar_class global definitions
 */

STATIC const mp_lv_struct_t mp_lv_calendar_class = {
    { &mp_lv_obj_class_t_type },
    (lv_obj_class_t*)&lv_calendar_class
};
    

/*
 * lvgl lv_calendar_header_arrow_class global definitions
 */

STATIC const mp_lv_struct_t mp_lv_calendar_header_arrow_class = {
    { &mp_lv_obj_class_t_type },
    (lv_obj_class_t*)&lv_calendar_header_arrow_class
};
    

/*
 * lvgl lv_calendar_header_dropdown_class global definitions
 */

STATIC const mp_lv_struct_t mp_lv_calendar_header_dropdown_class = {
    { &mp_lv_obj_class_t_type },
    (lv_obj_class_t*)&lv_calendar_header_dropdown_class
};
    

/*
 * lvgl lv_chart_class global definitions
 */

STATIC const mp_lv_struct_t mp_lv_chart_class = {
    { &mp_lv_obj_class_t_type },
    (lv_obj_class_t*)&lv_chart_class
};
    

/*
 * lvgl lv_keyboard_class global definitions
 */

STATIC const mp_lv_struct_t mp_lv_keyboard_class = {
    { &mp_lv_obj_class_t_type },
    (lv_obj_class_t*)&lv_keyboard_class
};
    

/*
 * lvgl lv_list_class global definitions
 */

STATIC const mp_lv_struct_t mp_lv_list_class = {
    { &mp_lv_obj_class_t_type },
    (lv_obj_class_t*)&lv_list_class
};
    

/*
 * lvgl lv_list_text_class global definitions
 */

STATIC const mp_lv_struct_t mp_lv_list_text_class = {
    { &mp_lv_obj_class_t_type },
    (lv_obj_class_t*)&lv_list_text_class
};
    

/*
 * lvgl lv_list_btn_class global definitions
 */

STATIC const mp_lv_struct_t mp_lv_list_btn_class = {
    { &mp_lv_obj_class_t_type },
    (lv_obj_class_t*)&lv_list_btn_class
};
    

/*
 * lvgl lv_menu_class global definitions
 */

STATIC const mp_lv_struct_t mp_lv_menu_class = {
    { &mp_lv_obj_class_t_type },
    (lv_obj_class_t*)&lv_menu_class
};
    

/*
 * lvgl lv_menu_page_class global definitions
 */

STATIC const mp_lv_struct_t mp_lv_menu_page_class = {
    { &mp_lv_obj_class_t_type },
    (lv_obj_class_t*)&lv_menu_page_class
};
    

/*
 * lvgl lv_menu_cont_class global definitions
 */

STATIC const mp_lv_struct_t mp_lv_menu_cont_class = {
    { &mp_lv_obj_class_t_type },
    (lv_obj_class_t*)&lv_menu_cont_class
};
    

/*
 * lvgl lv_menu_section_class global definitions
 */

STATIC const mp_lv_struct_t mp_lv_menu_section_class = {
    { &mp_lv_obj_class_t_type },
    (lv_obj_class_t*)&lv_menu_section_class
};
    

/*
 * lvgl lv_menu_separator_class global definitions
 */

STATIC const mp_lv_struct_t mp_lv_menu_separator_class = {
    { &mp_lv_obj_class_t_type },
    (lv_obj_class_t*)&lv_menu_separator_class
};
    

/*
 * lvgl lv_menu_sidebar_cont_class global definitions
 */

STATIC const mp_lv_struct_t mp_lv_menu_sidebar_cont_class = {
    { &mp_lv_obj_class_t_type },
    (lv_obj_class_t*)&lv_menu_sidebar_cont_class
};
    

/*
 * lvgl lv_menu_main_cont_class global definitions
 */

STATIC const mp_lv_struct_t mp_lv_menu_main_cont_class = {
    { &mp_lv_obj_class_t_type },
    (lv_obj_class_t*)&lv_menu_main_cont_class
};
    

/*
 * lvgl lv_menu_sidebar_header_cont_class global definitions
 */

STATIC const mp_lv_struct_t mp_lv_menu_sidebar_header_cont_class = {
    { &mp_lv_obj_class_t_type },
    (lv_obj_class_t*)&lv_menu_sidebar_header_cont_class
};
    

/*
 * lvgl lv_menu_main_header_cont_class global definitions
 */

STATIC const mp_lv_struct_t mp_lv_menu_main_header_cont_class = {
    { &mp_lv_obj_class_t_type },
    (lv_obj_class_t*)&lv_menu_main_header_cont_class
};
    

/*
 * lvgl lv_msgbox_class global definitions
 */

STATIC const mp_lv_struct_t mp_lv_msgbox_class = {
    { &mp_lv_obj_class_t_type },
    (lv_obj_class_t*)&lv_msgbox_class
};
    

/*
 * lvgl lv_msgbox_content_class global definitions
 */

STATIC const mp_lv_struct_t mp_lv_msgbox_content_class = {
    { &mp_lv_obj_class_t_type },
    (lv_obj_class_t*)&lv_msgbox_content_class
};
    

/*
 * lvgl lv_msgbox_backdrop_class global definitions
 */

STATIC const mp_lv_struct_t mp_lv_msgbox_backdrop_class = {
    { &mp_lv_obj_class_t_type },
    (lv_obj_class_t*)&lv_msgbox_backdrop_class
};
    

/*
 * lvgl lv_meter_class global definitions
 */

STATIC const mp_lv_struct_t mp_lv_meter_class = {
    { &mp_lv_obj_class_t_type },
    (lv_obj_class_t*)&lv_meter_class
};
    

/*
 * lvgl lv_spinbox_class global definitions
 */

STATIC const mp_lv_struct_t mp_lv_spinbox_class = {
    { &mp_lv_obj_class_t_type },
    (lv_obj_class_t*)&lv_spinbox_class
};
    

/*
 * lvgl lv_spinner_class global definitions
 */

STATIC const mp_lv_struct_t mp_lv_spinner_class = {
    { &mp_lv_obj_class_t_type },
    (lv_obj_class_t*)&lv_spinner_class
};
    

/*
 * lvgl lv_tabview_class global definitions
 */

STATIC const mp_lv_struct_t mp_lv_tabview_class = {
    { &mp_lv_obj_class_t_type },
    (lv_obj_class_t*)&lv_tabview_class
};
    

/*
 * lvgl lv_tileview_class global definitions
 */

STATIC const mp_lv_struct_t mp_lv_tileview_class = {
    { &mp_lv_obj_class_t_type },
    (lv_obj_class_t*)&lv_tileview_class
};
    

/*
 * lvgl lv_tileview_tile_class global definitions
 */

STATIC const mp_lv_struct_t mp_lv_tileview_tile_class = {
    { &mp_lv_obj_class_t_type },
    (lv_obj_class_t*)&lv_tileview_tile_class
};
    

/*
 * lvgl lv_win_class global definitions
 */

STATIC const mp_lv_struct_t mp_lv_win_class = {
    { &mp_lv_obj_class_t_type },
    (lv_obj_class_t*)&lv_win_class
};
    

/*
 * lvgl lv_colorwheel_class global definitions
 */

STATIC const mp_lv_struct_t mp_lv_colorwheel_class = {
    { &mp_lv_obj_class_t_type },
    (lv_obj_class_t*)&lv_colorwheel_class
};
    

/*
 * lvgl lv_led_class global definitions
 */

STATIC const mp_lv_struct_t mp_lv_led_class = {
    { &mp_lv_obj_class_t_type },
    (lv_obj_class_t*)&lv_led_class
};
    

/*
 * lvgl lv_imgbtn_class global definitions
 */

STATIC const mp_lv_struct_t mp_lv_imgbtn_class = {
    { &mp_lv_obj_class_t_type },
    (lv_obj_class_t*)&lv_imgbtn_class
};
    

/*
 * lvgl lv_spangroup_class global definitions
 */

STATIC const mp_lv_struct_t mp_lv_spangroup_class = {
    { &mp_lv_obj_class_t_type },
    (lv_obj_class_t*)&lv_spangroup_class
};
    

/*
 * lvgl lv_lvsfheader_class global definitions
 */

STATIC const mp_lv_struct_t mp_lv_lvsfheader_class = {
    { &mp_lv_obj_class_t_type },
    (lv_obj_class_t*)&lv_lvsfheader_class
};
    

/*
 * lvgl lv_lvsfcomp_class global definitions
 */

STATIC const mp_lv_struct_t mp_lv_lvsfcomp_class = {
    { &mp_lv_obj_class_t_type },
    (lv_obj_class_t*)&lv_lvsfcomp_class
};
    

/*
 * lvgl lv_lvsfcorner_class global definitions
 */

STATIC const mp_lv_struct_t mp_lv_lvsfcorner_class = {
    { &mp_lv_obj_class_t_type },
    (lv_obj_class_t*)&lv_lvsfcorner_class
};
    

/*
 * lvgl lv_rlottie_class global definitions
 */

STATIC const mp_lv_struct_t mp_lv_rlottie_class = {
    { &mp_lv_obj_class_t_type },
    (lv_obj_class_t*)&lv_rlottie_class
};
    

/*
 * Callback function lv_font_t_get_glyph_dsc
 * bool get_glyph_dsc(const struct _lv_font_t *, lv_font_glyph_dsc_t *, uint32_t letter, uint32_t letter_next)
 */

STATIC bool lv_font_t_get_glyph_dsc_callback(const struct _lv_font_t * arg0, lv_font_glyph_dsc_t * arg1, uint32_t arg2, uint32_t arg3)
{
    mp_obj_t mp_args[4];
    mp_args[0] = mp_read_ptr_lv_font_t((void*)arg0);
    mp_args[1] = mp_read_ptr_lv_font_glyph_dsc_t((void*)arg1);
    mp_args[2] = mp_obj_new_int_from_uint(arg2);
    mp_args[3] = mp_obj_new_int_from_uint(arg3);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    mp_obj_t callback_result = mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_font_t_get_glyph_dsc)) , 4, 0, mp_args);
    return mp_obj_is_true(callback_result);
}


/*
 * Callback function lv_font_t_get_glyph_bitmap
 * const uint8_t *get_glyph_bitmap(const struct _lv_font_t *, uint32_t)
 */

STATIC const uint8_t * lv_font_t_get_glyph_bitmap_callback(const struct _lv_font_t * arg0, uint32_t arg1)
{
    mp_obj_t mp_args[2];
    mp_args[0] = mp_read_ptr_lv_font_t((void*)arg0);
    mp_args[1] = mp_obj_new_int_from_uint(arg1);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    mp_obj_t callback_result = mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_font_t_get_glyph_bitmap)) , 2, 0, mp_args);
    return mp_to_ptr(callback_result);
}


/*
 * Callback function lv_color_filter_dsc_t_filter_cb
 * lv_color_t lv_color_filter_cb_t(const struct _lv_color_filter_dsc_t *, lv_color_t, lv_opa_t)
 */

STATIC lv_color_t lv_color_filter_dsc_t_filter_cb_callback(const struct _lv_color_filter_dsc_t * arg0, lv_color_t arg1, lv_opa_t arg2)
{
    mp_obj_t mp_args[3];
    mp_args[0] = mp_read_ptr_lv_color_filter_dsc_t((void*)arg0);
    mp_args[1] = mp_read_lv_color16_t(arg1);
    mp_args[2] = mp_obj_new_int_from_uint(arg2);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    mp_obj_t callback_result = mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_color_filter_dsc_t_filter_cb)) , 3, 0, mp_args);
    return mp_write_lv_color16_t(callback_result);
}


/*
 * Callback function lv_style_transition_dsc_t_path_xcb
 * int32_t lv_anim_path_cb_t(const struct _lv_anim_t *)
 */

STATIC int32_t lv_style_transition_dsc_t_path_xcb_callback(const struct _lv_anim_t * arg0)
{
    mp_obj_t mp_args[1];
    mp_args[0] = mp_read_ptr_lv_anim_t((void*)arg0);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    mp_obj_t callback_result = mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_style_transition_dsc_t_path_xcb)) , 1, 0, mp_args);
    return (int32_t)mp_obj_get_int(callback_result);
}


/*
 * Callback function lv_disp_drv_t_flush_cb
 * void flush_cb(struct _lv_disp_drv_t *disp_drv, const lv_area_t *area, lv_color_t *color_p)
 */

STATIC void lv_disp_drv_t_flush_cb_callback(struct _lv_disp_drv_t * arg0, const lv_area_t * arg1, lv_color_t * arg2)
{
    mp_obj_t mp_args[3];
    mp_args[0] = mp_read_ptr_lv_disp_drv_t((void*)arg0);
    mp_args[1] = mp_read_ptr_lv_area_t((void*)arg1);
    mp_args[2] = mp_read_ptr_lv_color16_t((void*)arg2);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_disp_drv_t_flush_cb)) , 3, 0, mp_args);
    return;
}


/*
 * Callback function lv_disp_drv_t_rounder_cb
 * void rounder_cb(struct _lv_disp_drv_t *disp_drv, lv_area_t *area)
 */

STATIC void lv_disp_drv_t_rounder_cb_callback(struct _lv_disp_drv_t * arg0, lv_area_t * arg1)
{
    mp_obj_t mp_args[2];
    mp_args[0] = mp_read_ptr_lv_disp_drv_t((void*)arg0);
    mp_args[1] = mp_read_ptr_lv_area_t((void*)arg1);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_disp_drv_t_rounder_cb)) , 2, 0, mp_args);
    return;
}


/*
 * Callback function lv_disp_drv_t_set_px_cb
 * void set_px_cb(struct _lv_disp_drv_t *disp_drv, uint8_t *buf, lv_coord_t buf_w, lv_coord_t x, lv_coord_t y, lv_color_t color, lv_opa_t opa)
 */

STATIC void lv_disp_drv_t_set_px_cb_callback(struct _lv_disp_drv_t * arg0, uint8_t * arg1, lv_coord_t arg2, lv_coord_t arg3, lv_coord_t arg4, lv_color_t arg5, lv_opa_t arg6)
{
    mp_obj_t mp_args[7];
    mp_args[0] = mp_read_ptr_lv_disp_drv_t((void*)arg0);
    mp_args[1] = ptr_to_mp((void*)arg1);
    mp_args[2] = mp_obj_new_int(arg2);
    mp_args[3] = mp_obj_new_int(arg3);
    mp_args[4] = mp_obj_new_int(arg4);
    mp_args[5] = mp_read_lv_color16_t(arg5);
    mp_args[6] = mp_obj_new_int_from_uint(arg6);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_disp_drv_t_set_px_cb)) , 7, 0, mp_args);
    return;
}


/*
 * Callback function lv_disp_drv_t_clear_cb
 * void clear_cb(struct _lv_disp_drv_t *disp_drv, uint8_t *buf, uint32_t size)
 */

STATIC void lv_disp_drv_t_clear_cb_callback(struct _lv_disp_drv_t * arg0, uint8_t * arg1, uint32_t arg2)
{
    mp_obj_t mp_args[3];
    mp_args[0] = mp_read_ptr_lv_disp_drv_t((void*)arg0);
    mp_args[1] = ptr_to_mp((void*)arg1);
    mp_args[2] = mp_obj_new_int_from_uint(arg2);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_disp_drv_t_clear_cb)) , 3, 0, mp_args);
    return;
}


/*
 * Callback function lv_disp_drv_t_monitor_cb
 * void monitor_cb(struct _lv_disp_drv_t *disp_drv, uint32_t time, uint32_t px)
 */

STATIC void lv_disp_drv_t_monitor_cb_callback(struct _lv_disp_drv_t * arg0, uint32_t arg1, uint32_t arg2)
{
    mp_obj_t mp_args[3];
    mp_args[0] = mp_read_ptr_lv_disp_drv_t((void*)arg0);
    mp_args[1] = mp_obj_new_int_from_uint(arg1);
    mp_args[2] = mp_obj_new_int_from_uint(arg2);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_disp_drv_t_monitor_cb)) , 3, 0, mp_args);
    return;
}


/*
 * Callback function lv_disp_drv_t_wait_cb
 * void wait_cb(struct _lv_disp_drv_t *disp_drv)
 */

STATIC void lv_disp_drv_t_wait_cb_callback(struct _lv_disp_drv_t * arg0)
{
    mp_obj_t mp_args[1];
    mp_args[0] = mp_read_ptr_lv_disp_drv_t((void*)arg0);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_disp_drv_t_wait_cb)) , 1, 0, mp_args);
    return;
}


/*
 * Callback function lv_disp_drv_t_clean_dcache_cb
 * void clean_dcache_cb(struct _lv_disp_drv_t *disp_drv)
 */

STATIC void lv_disp_drv_t_clean_dcache_cb_callback(struct _lv_disp_drv_t * arg0)
{
    mp_obj_t mp_args[1];
    mp_args[0] = mp_read_ptr_lv_disp_drv_t((void*)arg0);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_disp_drv_t_clean_dcache_cb)) , 1, 0, mp_args);
    return;
}


/*
 * Callback function lv_disp_drv_t_drv_update_cb
 * void drv_update_cb(struct _lv_disp_drv_t *disp_drv)
 */

STATIC void lv_disp_drv_t_drv_update_cb_callback(struct _lv_disp_drv_t * arg0)
{
    mp_obj_t mp_args[1];
    mp_args[0] = mp_read_ptr_lv_disp_drv_t((void*)arg0);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_disp_drv_t_drv_update_cb)) , 1, 0, mp_args);
    return;
}


/*
 * Callback function lv_disp_drv_t_render_start_cb
 * void render_start_cb(struct _lv_disp_drv_t *disp_drv)
 */

STATIC void lv_disp_drv_t_render_start_cb_callback(struct _lv_disp_drv_t * arg0)
{
    mp_obj_t mp_args[1];
    mp_args[0] = mp_read_ptr_lv_disp_drv_t((void*)arg0);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_disp_drv_t_render_start_cb)) , 1, 0, mp_args);
    return;
}


/*
 * Callback function lv_draw_ctx_t_draw_rect
 * void draw_rect(struct _lv_draw_ctx_t *draw_ctx, const lv_draw_rect_dsc_t *dsc, const lv_area_t *coords)
 */

STATIC void lv_draw_ctx_t_draw_rect_callback(struct _lv_draw_ctx_t * arg0, const lv_draw_rect_dsc_t * arg1, const lv_area_t * arg2)
{
    mp_obj_t mp_args[3];
    mp_args[0] = mp_read_ptr_lv_draw_ctx_t((void*)arg0);
    mp_args[1] = mp_read_ptr_lv_draw_rect_dsc_t((void*)arg1);
    mp_args[2] = mp_read_ptr_lv_area_t((void*)arg2);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_draw_ctx_t_draw_rect)) , 3, 0, mp_args);
    return;
}


/*
 * Callback function lv_draw_ctx_t_draw_arc
 * void draw_arc(struct _lv_draw_ctx_t *draw_ctx, const lv_draw_arc_dsc_t *dsc, const lv_point_t *center, uint16_t radius, uint16_t start_angle, uint16_t end_angle)
 */

STATIC void lv_draw_ctx_t_draw_arc_callback(struct _lv_draw_ctx_t * arg0, const lv_draw_arc_dsc_t * arg1, const lv_point_t * arg2, uint16_t arg3, uint16_t arg4, uint16_t arg5)
{
    mp_obj_t mp_args[6];
    mp_args[0] = mp_read_ptr_lv_draw_ctx_t((void*)arg0);
    mp_args[1] = mp_read_ptr_lv_draw_arc_dsc_t((void*)arg1);
    mp_args[2] = mp_read_ptr_lv_point_t((void*)arg2);
    mp_args[3] = mp_obj_new_int_from_uint(arg3);
    mp_args[4] = mp_obj_new_int_from_uint(arg4);
    mp_args[5] = mp_obj_new_int_from_uint(arg5);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_draw_ctx_t_draw_arc)) , 6, 0, mp_args);
    return;
}


/*
 * Callback function lv_draw_ctx_t_draw_img_decoded
 * void draw_img_decoded(struct _lv_draw_ctx_t *draw_ctx, const lv_draw_img_dsc_t *dsc, const lv_area_t *coords, const uint8_t *map_p, lv_img_cf_t color_format)
 */

STATIC void lv_draw_ctx_t_draw_img_decoded_callback(struct _lv_draw_ctx_t * arg0, const lv_draw_img_dsc_t * arg1, const lv_area_t * arg2, const uint8_t * arg3, lv_img_cf_t arg4)
{
    mp_obj_t mp_args[5];
    mp_args[0] = mp_read_ptr_lv_draw_ctx_t((void*)arg0);
    mp_args[1] = mp_read_ptr_lv_draw_img_dsc_t((void*)arg1);
    mp_args[2] = mp_read_ptr_lv_area_t((void*)arg2);
    mp_args[3] = ptr_to_mp((void*)arg3);
    mp_args[4] = mp_obj_new_int_from_uint(arg4);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_draw_ctx_t_draw_img_decoded)) , 5, 0, mp_args);
    return;
}


/*
 * Callback function lv_draw_ctx_t_draw_img
 * lv_res_t draw_img(struct _lv_draw_ctx_t *draw_ctx, const lv_draw_img_dsc_t *draw_dsc, const lv_area_t *coords, const void *src)
 */

STATIC lv_res_t lv_draw_ctx_t_draw_img_callback(struct _lv_draw_ctx_t * arg0, const lv_draw_img_dsc_t * arg1, const lv_area_t * arg2, const void * arg3)
{
    mp_obj_t mp_args[4];
    mp_args[0] = mp_read_ptr_lv_draw_ctx_t((void*)arg0);
    mp_args[1] = mp_read_ptr_lv_draw_img_dsc_t((void*)arg1);
    mp_args[2] = mp_read_ptr_lv_area_t((void*)arg2);
    mp_args[3] = ptr_to_mp((void*)arg3);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    mp_obj_t callback_result = mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_draw_ctx_t_draw_img)) , 4, 0, mp_args);
    return (uint8_t)mp_obj_get_int(callback_result);
}


/*
 * Callback function lv_draw_ctx_t_draw_letter
 * void draw_letter(struct _lv_draw_ctx_t *draw_ctx, const lv_draw_label_dsc_t *dsc, const lv_point_t *pos_p, uint32_t letter)
 */

STATIC void lv_draw_ctx_t_draw_letter_callback(struct _lv_draw_ctx_t * arg0, const lv_draw_label_dsc_t * arg1, const lv_point_t * arg2, uint32_t arg3)
{
    mp_obj_t mp_args[4];
    mp_args[0] = mp_read_ptr_lv_draw_ctx_t((void*)arg0);
    mp_args[1] = mp_read_ptr_lv_draw_label_dsc_t((void*)arg1);
    mp_args[2] = mp_read_ptr_lv_point_t((void*)arg2);
    mp_args[3] = mp_obj_new_int_from_uint(arg3);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_draw_ctx_t_draw_letter)) , 4, 0, mp_args);
    return;
}


/*
 * Callback function lv_draw_ctx_t_draw_line
 * void draw_line(struct _lv_draw_ctx_t *draw_ctx, const lv_draw_line_dsc_t *dsc, const lv_point_t *point1, const lv_point_t *point2)
 */

STATIC void lv_draw_ctx_t_draw_line_callback(struct _lv_draw_ctx_t * arg0, const lv_draw_line_dsc_t * arg1, const lv_point_t * arg2, const lv_point_t * arg3)
{
    mp_obj_t mp_args[4];
    mp_args[0] = mp_read_ptr_lv_draw_ctx_t((void*)arg0);
    mp_args[1] = mp_read_ptr_lv_draw_line_dsc_t((void*)arg1);
    mp_args[2] = mp_read_ptr_lv_point_t((void*)arg2);
    mp_args[3] = mp_read_ptr_lv_point_t((void*)arg3);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_draw_ctx_t_draw_line)) , 4, 0, mp_args);
    return;
}


/*
 * Callback function lv_draw_ctx_t_draw_polygon
 * void draw_polygon(struct _lv_draw_ctx_t *draw_ctx, const lv_draw_rect_dsc_t *draw_dsc, const lv_point_t *points, uint16_t point_cnt)
 */

STATIC void lv_draw_ctx_t_draw_polygon_callback(struct _lv_draw_ctx_t * arg0, const lv_draw_rect_dsc_t * arg1, const lv_point_t * arg2, uint16_t arg3)
{
    mp_obj_t mp_args[4];
    mp_args[0] = mp_read_ptr_lv_draw_ctx_t((void*)arg0);
    mp_args[1] = mp_read_ptr_lv_draw_rect_dsc_t((void*)arg1);
    mp_args[2] = mp_read_ptr_lv_point_t((void*)arg2);
    mp_args[3] = mp_obj_new_int_from_uint(arg3);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_draw_ctx_t_draw_polygon)) , 4, 0, mp_args);
    return;
}


/*
 * Callback function lv_draw_ctx_t_draw_transform
 * void draw_transform(struct _lv_draw_ctx_t *draw_ctx, const lv_area_t *dest_area, const void *src_buf, lv_coord_t src_w, lv_coord_t src_h, lv_coord_t src_stride, const lv_draw_img_dsc_t *draw_dsc, lv_img_cf_t cf, lv_color_t *cbuf, lv_opa_t *abuf)
 */

STATIC void lv_draw_ctx_t_draw_transform_callback(struct _lv_draw_ctx_t * arg0, const lv_area_t * arg1, const void * arg2, lv_coord_t arg3, lv_coord_t arg4, lv_coord_t arg5, const lv_draw_img_dsc_t * arg6, lv_img_cf_t arg7, lv_color_t * arg8, lv_opa_t * arg9)
{
    mp_obj_t mp_args[10];
    mp_args[0] = mp_read_ptr_lv_draw_ctx_t((void*)arg0);
    mp_args[1] = mp_read_ptr_lv_area_t((void*)arg1);
    mp_args[2] = ptr_to_mp((void*)arg2);
    mp_args[3] = mp_obj_new_int(arg3);
    mp_args[4] = mp_obj_new_int(arg4);
    mp_args[5] = mp_obj_new_int(arg5);
    mp_args[6] = mp_read_ptr_lv_draw_img_dsc_t((void*)arg6);
    mp_args[7] = mp_obj_new_int_from_uint(arg7);
    mp_args[8] = mp_read_ptr_lv_color16_t((void*)arg8);
    mp_args[9] = ptr_to_mp((void*)arg9);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_draw_ctx_t_draw_transform)) , 10, 0, mp_args);
    return;
}


/*
 * Callback function lv_draw_ctx_t_draw_bg
 * void draw_bg(struct _lv_draw_ctx_t *draw_ctx, const lv_draw_rect_dsc_t *draw_dsc, const lv_area_t *coords)
 */

STATIC void lv_draw_ctx_t_draw_bg_callback(struct _lv_draw_ctx_t * arg0, const lv_draw_rect_dsc_t * arg1, const lv_area_t * arg2)
{
    mp_obj_t mp_args[3];
    mp_args[0] = mp_read_ptr_lv_draw_ctx_t((void*)arg0);
    mp_args[1] = mp_read_ptr_lv_draw_rect_dsc_t((void*)arg1);
    mp_args[2] = mp_read_ptr_lv_area_t((void*)arg2);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_draw_ctx_t_draw_bg)) , 3, 0, mp_args);
    return;
}


/*
 * Callback function lv_draw_ctx_t_wait_for_finish
 * void wait_for_finish(struct _lv_draw_ctx_t *draw_ctx)
 */

STATIC void lv_draw_ctx_t_wait_for_finish_callback(struct _lv_draw_ctx_t * arg0)
{
    mp_obj_t mp_args[1];
    mp_args[0] = mp_read_ptr_lv_draw_ctx_t((void*)arg0);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_draw_ctx_t_wait_for_finish)) , 1, 0, mp_args);
    return;
}


/*
 * Callback function lv_draw_ctx_t_buffer_copy
 * void buffer_copy(struct _lv_draw_ctx_t *draw_ctx, void *dest_buf, lv_coord_t dest_stride, const lv_area_t *dest_area, void *src_buf, lv_coord_t src_stride, const lv_area_t *src_area)
 */

STATIC void lv_draw_ctx_t_buffer_copy_callback(struct _lv_draw_ctx_t * arg0, void * arg1, lv_coord_t arg2, const lv_area_t * arg3, void * arg4, lv_coord_t arg5, const lv_area_t * arg6)
{
    mp_obj_t mp_args[7];
    mp_args[0] = mp_read_ptr_lv_draw_ctx_t((void*)arg0);
    mp_args[1] = ptr_to_mp((void*)arg1);
    mp_args[2] = mp_obj_new_int(arg2);
    mp_args[3] = mp_read_ptr_lv_area_t((void*)arg3);
    mp_args[4] = ptr_to_mp((void*)arg4);
    mp_args[5] = mp_obj_new_int(arg5);
    mp_args[6] = mp_read_ptr_lv_area_t((void*)arg6);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_draw_ctx_t_buffer_copy)) , 7, 0, mp_args);
    return;
}


/*
 * Callback function lv_draw_ctx_t_layer_init
 * struct _lv_draw_layer_ctx_t *layer_init(struct _lv_draw_ctx_t *draw_ctx, struct _lv_draw_layer_ctx_t *layer_ctx, lv_draw_layer_flags_t flags)
 */

STATIC lv_draw_layer_ctx_t * lv_draw_ctx_t_layer_init_callback(struct _lv_draw_ctx_t * arg0, struct _lv_draw_layer_ctx_t * arg1, lv_draw_layer_flags_t arg2)
{
    mp_obj_t mp_args[3];
    mp_args[0] = mp_read_ptr_lv_draw_ctx_t((void*)arg0);
    mp_args[1] = mp_read_ptr_lv_draw_layer_ctx_t((void*)arg1);
    mp_args[2] = mp_obj_new_int(arg2);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    mp_obj_t callback_result = mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_draw_ctx_t_layer_init)) , 3, 0, mp_args);
    return mp_write_ptr_lv_draw_layer_ctx_t(callback_result);
}


/*
 * Callback function lv_draw_ctx_t_layer_adjust
 * void layer_adjust(struct _lv_draw_ctx_t *draw_ctx, struct _lv_draw_layer_ctx_t *layer_ctx, lv_draw_layer_flags_t flags)
 */

STATIC void lv_draw_ctx_t_layer_adjust_callback(struct _lv_draw_ctx_t * arg0, struct _lv_draw_layer_ctx_t * arg1, lv_draw_layer_flags_t arg2)
{
    mp_obj_t mp_args[3];
    mp_args[0] = mp_read_ptr_lv_draw_ctx_t((void*)arg0);
    mp_args[1] = mp_read_ptr_lv_draw_layer_ctx_t((void*)arg1);
    mp_args[2] = mp_obj_new_int(arg2);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_draw_ctx_t_layer_adjust)) , 3, 0, mp_args);
    return;
}


/*
 * Callback function lv_draw_ctx_t_layer_blend
 * void layer_blend(struct _lv_draw_ctx_t *draw_ctx, struct _lv_draw_layer_ctx_t *layer_ctx, const lv_draw_img_dsc_t *draw_dsc)
 */

STATIC void lv_draw_ctx_t_layer_blend_callback(struct _lv_draw_ctx_t * arg0, struct _lv_draw_layer_ctx_t * arg1, const lv_draw_img_dsc_t * arg2)
{
    mp_obj_t mp_args[3];
    mp_args[0] = mp_read_ptr_lv_draw_ctx_t((void*)arg0);
    mp_args[1] = mp_read_ptr_lv_draw_layer_ctx_t((void*)arg1);
    mp_args[2] = mp_read_ptr_lv_draw_img_dsc_t((void*)arg2);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_draw_ctx_t_layer_blend)) , 3, 0, mp_args);
    return;
}


/*
 * Callback function lv_draw_ctx_t_layer_destroy
 * void layer_destroy(struct _lv_draw_ctx_t *draw_ctx, lv_draw_layer_ctx_t *layer_ctx)
 */

STATIC void lv_draw_ctx_t_layer_destroy_callback(struct _lv_draw_ctx_t * arg0, lv_draw_layer_ctx_t * arg1)
{
    mp_obj_t mp_args[2];
    mp_args[0] = mp_read_ptr_lv_draw_ctx_t((void*)arg0);
    mp_args[1] = mp_read_ptr_lv_draw_layer_ctx_t((void*)arg1);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_draw_ctx_t_layer_destroy)) , 2, 0, mp_args);
    return;
}


/*
 * Callback function lv_disp_drv_t_draw_ctx_init
 * void draw_ctx_init(struct _lv_disp_drv_t *disp_drv, lv_draw_ctx_t *draw_ctx)
 */

STATIC void lv_disp_drv_t_draw_ctx_init_callback(struct _lv_disp_drv_t * arg0, lv_draw_ctx_t * arg1)
{
    mp_obj_t mp_args[2];
    mp_args[0] = mp_read_ptr_lv_disp_drv_t((void*)arg0);
    mp_args[1] = mp_read_ptr_lv_draw_ctx_t((void*)arg1);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_disp_drv_t_draw_ctx_init)) , 2, 0, mp_args);
    return;
}


/*
 * Callback function lv_disp_drv_t_draw_ctx_deinit
 * void draw_ctx_deinit(struct _lv_disp_drv_t *disp_drv, lv_draw_ctx_t *draw_ctx)
 */

STATIC void lv_disp_drv_t_draw_ctx_deinit_callback(struct _lv_disp_drv_t * arg0, lv_draw_ctx_t * arg1)
{
    mp_obj_t mp_args[2];
    mp_args[0] = mp_read_ptr_lv_disp_drv_t((void*)arg0);
    mp_args[1] = mp_read_ptr_lv_draw_ctx_t((void*)arg1);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_disp_drv_t_draw_ctx_deinit)) , 2, 0, mp_args);
    return;
}


/*
 * Callback function lv_obj_class_t_constructor_cb
 * void constructor_cb(const struct _lv_obj_class_t *class_p, struct _lv_obj_t *obj)
 */

STATIC void lv_obj_class_t_constructor_cb_callback(const struct _lv_obj_class_t * arg0, struct _lv_obj_t * arg1)
{
    mp_obj_t mp_args[2];
    mp_args[0] = mp_read_ptr_lv_obj_class_t((void*)arg0);
    mp_args[1] = lv_to_mp((void*)arg1);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_obj_class_t_constructor_cb)) , 2, 0, mp_args);
    return;
}


/*
 * Callback function lv_obj_class_t_destructor_cb
 * void destructor_cb(const struct _lv_obj_class_t *class_p, struct _lv_obj_t *obj)
 */

STATIC void lv_obj_class_t_destructor_cb_callback(const struct _lv_obj_class_t * arg0, struct _lv_obj_t * arg1)
{
    mp_obj_t mp_args[2];
    mp_args[0] = mp_read_ptr_lv_obj_class_t((void*)arg0);
    mp_args[1] = lv_to_mp((void*)arg1);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_obj_class_t_destructor_cb)) , 2, 0, mp_args);
    return;
}


/*
 * Callback function lv_obj_class_t_event_cb
 * void event_cb(const struct _lv_obj_class_t *class_p, struct _lv_event_t *e)
 */

STATIC void lv_obj_class_t_event_cb_callback(const struct _lv_obj_class_t * arg0, struct _lv_event_t * arg1)
{
    mp_obj_t mp_args[2];
    mp_args[0] = mp_read_ptr_lv_obj_class_t((void*)arg0);
    mp_args[1] = mp_read_ptr_lv_event_t((void*)arg1);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_obj_class_t_event_cb)) , 2, 0, mp_args);
    return;
}


/*
 * Callback function lv_fs_drv_t_ready_cb
 * bool ready_cb(struct _lv_fs_drv_t *drv)
 */

STATIC bool lv_fs_drv_t_ready_cb_callback(struct _lv_fs_drv_t * arg0)
{
    mp_obj_t mp_args[1];
    mp_args[0] = mp_read_ptr_lv_fs_drv_t((void*)arg0);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    mp_obj_t callback_result = mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_fs_drv_t_ready_cb)) , 1, 0, mp_args);
    return mp_obj_is_true(callback_result);
}


/*
 * Callback function lv_fs_drv_t_open_cb
 * void *open_cb(struct _lv_fs_drv_t *drv, const char *path, lv_fs_mode_t mode)
 */

STATIC void * lv_fs_drv_t_open_cb_callback(struct _lv_fs_drv_t * arg0, const char * arg1, lv_fs_mode_t arg2)
{
    mp_obj_t mp_args[3];
    mp_args[0] = mp_read_ptr_lv_fs_drv_t((void*)arg0);
    mp_args[1] = convert_to_str((void*)arg1);
    mp_args[2] = mp_obj_new_int_from_uint(arg2);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    mp_obj_t callback_result = mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_fs_drv_t_open_cb)) , 3, 0, mp_args);
    return mp_to_ptr(callback_result);
}


/*
 * Callback function lv_fs_drv_t_close_cb
 * lv_fs_res_t close_cb(struct _lv_fs_drv_t *drv, void *file_p)
 */

STATIC lv_fs_res_t lv_fs_drv_t_close_cb_callback(struct _lv_fs_drv_t * arg0, void * arg1)
{
    mp_obj_t mp_args[2];
    mp_args[0] = mp_read_ptr_lv_fs_drv_t((void*)arg0);
    mp_args[1] = ptr_to_mp((void*)arg1);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    mp_obj_t callback_result = mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_fs_drv_t_close_cb)) , 2, 0, mp_args);
    return (uint8_t)mp_obj_get_int(callback_result);
}


/*
 * Callback function lv_fs_drv_t_read_cb
 * lv_fs_res_t read_cb(struct _lv_fs_drv_t *drv, void *file_p, void *buf, uint32_t btr, uint32_t *br)
 */

STATIC lv_fs_res_t lv_fs_drv_t_read_cb_callback(struct _lv_fs_drv_t * arg0, void * arg1, void * arg2, uint32_t arg3, uint32_t * arg4)
{
    mp_obj_t mp_args[5];
    mp_args[0] = mp_read_ptr_lv_fs_drv_t((void*)arg0);
    mp_args[1] = ptr_to_mp((void*)arg1);
    mp_args[2] = ptr_to_mp((void*)arg2);
    mp_args[3] = mp_obj_new_int_from_uint(arg3);
    mp_args[4] = ptr_to_mp((void*)arg4);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    mp_obj_t callback_result = mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_fs_drv_t_read_cb)) , 5, 0, mp_args);
    return (uint8_t)mp_obj_get_int(callback_result);
}


/*
 * Callback function lv_fs_drv_t_write_cb
 * lv_fs_res_t write_cb(struct _lv_fs_drv_t *drv, void *file_p, const void *buf, uint32_t btw, uint32_t *bw)
 */

STATIC lv_fs_res_t lv_fs_drv_t_write_cb_callback(struct _lv_fs_drv_t * arg0, void * arg1, const void * arg2, uint32_t arg3, uint32_t * arg4)
{
    mp_obj_t mp_args[5];
    mp_args[0] = mp_read_ptr_lv_fs_drv_t((void*)arg0);
    mp_args[1] = ptr_to_mp((void*)arg1);
    mp_args[2] = ptr_to_mp((void*)arg2);
    mp_args[3] = mp_obj_new_int_from_uint(arg3);
    mp_args[4] = ptr_to_mp((void*)arg4);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    mp_obj_t callback_result = mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_fs_drv_t_write_cb)) , 5, 0, mp_args);
    return (uint8_t)mp_obj_get_int(callback_result);
}


/*
 * Callback function lv_fs_drv_t_seek_cb
 * lv_fs_res_t seek_cb(struct _lv_fs_drv_t *drv, void *file_p, uint32_t pos, lv_fs_whence_t whence)
 */

STATIC lv_fs_res_t lv_fs_drv_t_seek_cb_callback(struct _lv_fs_drv_t * arg0, void * arg1, uint32_t arg2, lv_fs_whence_t arg3)
{
    mp_obj_t mp_args[4];
    mp_args[0] = mp_read_ptr_lv_fs_drv_t((void*)arg0);
    mp_args[1] = ptr_to_mp((void*)arg1);
    mp_args[2] = mp_obj_new_int_from_uint(arg2);
    mp_args[3] = mp_obj_new_int(arg3);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    mp_obj_t callback_result = mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_fs_drv_t_seek_cb)) , 4, 0, mp_args);
    return (uint8_t)mp_obj_get_int(callback_result);
}


/*
 * Callback function lv_fs_drv_t_tell_cb
 * lv_fs_res_t tell_cb(struct _lv_fs_drv_t *drv, void *file_p, uint32_t *pos_p)
 */

STATIC lv_fs_res_t lv_fs_drv_t_tell_cb_callback(struct _lv_fs_drv_t * arg0, void * arg1, uint32_t * arg2)
{
    mp_obj_t mp_args[3];
    mp_args[0] = mp_read_ptr_lv_fs_drv_t((void*)arg0);
    mp_args[1] = ptr_to_mp((void*)arg1);
    mp_args[2] = ptr_to_mp((void*)arg2);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    mp_obj_t callback_result = mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_fs_drv_t_tell_cb)) , 3, 0, mp_args);
    return (uint8_t)mp_obj_get_int(callback_result);
}


/*
 * Callback function lv_fs_drv_t_dir_open_cb
 * void *dir_open_cb(struct _lv_fs_drv_t *drv, const char *path)
 */

STATIC void * lv_fs_drv_t_dir_open_cb_callback(struct _lv_fs_drv_t * arg0, const char * arg1)
{
    mp_obj_t mp_args[2];
    mp_args[0] = mp_read_ptr_lv_fs_drv_t((void*)arg0);
    mp_args[1] = convert_to_str((void*)arg1);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    mp_obj_t callback_result = mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_fs_drv_t_dir_open_cb)) , 2, 0, mp_args);
    return mp_to_ptr(callback_result);
}


/*
 * Callback function lv_fs_drv_t_dir_read_cb
 * lv_fs_res_t dir_read_cb(struct _lv_fs_drv_t *drv, void *rddir_p, char *fn)
 */

STATIC lv_fs_res_t lv_fs_drv_t_dir_read_cb_callback(struct _lv_fs_drv_t * arg0, void * arg1, char * arg2)
{
    mp_obj_t mp_args[3];
    mp_args[0] = mp_read_ptr_lv_fs_drv_t((void*)arg0);
    mp_args[1] = ptr_to_mp((void*)arg1);
    mp_args[2] = convert_to_str((void*)arg2);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    mp_obj_t callback_result = mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_fs_drv_t_dir_read_cb)) , 3, 0, mp_args);
    return (uint8_t)mp_obj_get_int(callback_result);
}


/*
 * Callback function lv_fs_drv_t_dir_close_cb
 * lv_fs_res_t dir_close_cb(struct _lv_fs_drv_t *drv, void *rddir_p)
 */

STATIC lv_fs_res_t lv_fs_drv_t_dir_close_cb_callback(struct _lv_fs_drv_t * arg0, void * arg1)
{
    mp_obj_t mp_args[2];
    mp_args[0] = mp_read_ptr_lv_fs_drv_t((void*)arg0);
    mp_args[1] = ptr_to_mp((void*)arg1);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    mp_obj_t callback_result = mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_fs_drv_t_dir_close_cb)) , 2, 0, mp_args);
    return (uint8_t)mp_obj_get_int(callback_result);
}


/*
 * Function NOT generated:
 * Callback: user_data NOT FOUND! lv_draw_mask_res_t lv_draw_mask_xcb_t(lv_opa_t *mask_buf, lv_coord_t abs_x, lv_coord_t abs_y, lv_coord_t len, void *p)
 * lv_draw_mask_res_t lv_draw_mask_xcb_t(lv_opa_t *mask_buf, lv_coord_t abs_x, lv_coord_t abs_y, lv_coord_t len, void *p)
 */
    

/*
 * Callback function lv_indev_drv_t_read_cb
 * void read_cb(struct _lv_indev_drv_t *indev_drv, lv_indev_data_t *data)
 */

STATIC void lv_indev_drv_t_read_cb_callback(struct _lv_indev_drv_t * arg0, lv_indev_data_t * arg1)
{
    mp_obj_t mp_args[2];
    mp_args[0] = mp_read_ptr_lv_indev_drv_t((void*)arg0);
    mp_args[1] = mp_read_ptr_lv_indev_data_t((void*)arg1);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_indev_drv_t_read_cb)) , 2, 0, mp_args);
    return;
}


/*
 * Callback function lv_indev_drv_t_feedback_cb
 * void feedback_cb(struct _lv_indev_drv_t *, uint8_t)
 */

STATIC void lv_indev_drv_t_feedback_cb_callback(struct _lv_indev_drv_t * arg0, uint8_t arg1)
{
    mp_obj_t mp_args[2];
    mp_args[0] = mp_read_ptr_lv_indev_drv_t((void*)arg0);
    mp_args[1] = mp_obj_new_int_from_uint(arg1);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_indev_drv_t_feedback_cb)) , 2, 0, mp_args);
    return;
}


/*
 * Function NOT generated:
 * Callback: user_data NOT FOUND! void plain_text(struct gd_GIF *gif, uint16_t tx, uint16_t ty, uint16_t tw, uint16_t th, uint8_t cw, uint8_t ch, uint8_t fg, uint8_t bg)
 * void plain_text(struct gd_GIF *gif, uint16_t tx, uint16_t ty, uint16_t tw, uint16_t th, uint8_t cw, uint8_t ch, uint8_t fg, uint8_t bg)
 */
    

/*
 * Function NOT generated:
 * Callback: user_data NOT FOUND! void comment(struct gd_GIF *gif)
 * void comment(struct gd_GIF *gif)
 */
    

/*
 * Function NOT generated:
 * Callback: user_data NOT FOUND! void application(struct gd_GIF *gif, char id[8], char auth[3])
 * void application(struct gd_GIF *gif, char id[8], char auth[3])
 */
    


/*
 * lvgl module definitions
 */

STATIC const mp_rom_map_elem_t lvgl_globals_table[] = {
    { MP_ROM_QSTR(MP_QSTR___name__), MP_ROM_QSTR(MP_QSTR_lvgl) },
    { MP_ROM_QSTR(MP_QSTR_obj), MP_ROM_PTR(&mp_obj_type) },
    { MP_ROM_QSTR(MP_QSTR_arc), MP_ROM_PTR(&mp_arc_type) },
    { MP_ROM_QSTR(MP_QSTR_btn), MP_ROM_PTR(&mp_btn_type) },
    { MP_ROM_QSTR(MP_QSTR_img), MP_ROM_PTR(&mp_img_type) },
    { MP_ROM_QSTR(MP_QSTR_label), MP_ROM_PTR(&mp_label_type) },
    { MP_ROM_QSTR(MP_QSTR_line), MP_ROM_PTR(&mp_line_type) },
    { MP_ROM_QSTR(MP_QSTR_table), MP_ROM_PTR(&mp_table_type) },
    { MP_ROM_QSTR(MP_QSTR_checkbox), MP_ROM_PTR(&mp_checkbox_type) },
    { MP_ROM_QSTR(MP_QSTR_bar), MP_ROM_PTR(&mp_bar_type) },
    { MP_ROM_QSTR(MP_QSTR_slider), MP_ROM_PTR(&mp_slider_type) },
    { MP_ROM_QSTR(MP_QSTR_btnmatrix), MP_ROM_PTR(&mp_btnmatrix_type) },
    { MP_ROM_QSTR(MP_QSTR_dropdown), MP_ROM_PTR(&mp_dropdown_type) },
    { MP_ROM_QSTR(MP_QSTR_roller), MP_ROM_PTR(&mp_roller_type) },
    { MP_ROM_QSTR(MP_QSTR_textarea), MP_ROM_PTR(&mp_textarea_type) },
    { MP_ROM_QSTR(MP_QSTR_canvas), MP_ROM_PTR(&mp_canvas_type) },
    { MP_ROM_QSTR(MP_QSTR_switch), MP_ROM_PTR(&mp_switch_type) },
    { MP_ROM_QSTR(MP_QSTR_gif), MP_ROM_PTR(&mp_gif_type) },
    { MP_ROM_QSTR(MP_QSTR_qrcode), MP_ROM_PTR(&mp_qrcode_type) },
    { MP_ROM_QSTR(MP_QSTR_animimg), MP_ROM_PTR(&mp_animimg_type) },
    { MP_ROM_QSTR(MP_QSTR_calendar), MP_ROM_PTR(&mp_calendar_type) },
    { MP_ROM_QSTR(MP_QSTR_chart), MP_ROM_PTR(&mp_chart_type) },
    { MP_ROM_QSTR(MP_QSTR_keyboard), MP_ROM_PTR(&mp_keyboard_type) },
    { MP_ROM_QSTR(MP_QSTR_list), MP_ROM_PTR(&mp_list_type) },
    { MP_ROM_QSTR(MP_QSTR_menu), MP_ROM_PTR(&mp_menu_type) },
    { MP_ROM_QSTR(MP_QSTR_msgbox), MP_ROM_PTR(&mp_msgbox_type) },
    { MP_ROM_QSTR(MP_QSTR_meter), MP_ROM_PTR(&mp_meter_type) },
    { MP_ROM_QSTR(MP_QSTR_spinbox), MP_ROM_PTR(&mp_spinbox_type) },
    { MP_ROM_QSTR(MP_QSTR_spinner), MP_ROM_PTR(&mp_spinner_type) },
    { MP_ROM_QSTR(MP_QSTR_tabview), MP_ROM_PTR(&mp_tabview_type) },
    { MP_ROM_QSTR(MP_QSTR_tileview), MP_ROM_PTR(&mp_tileview_type) },
    { MP_ROM_QSTR(MP_QSTR_win), MP_ROM_PTR(&mp_win_type) },
    { MP_ROM_QSTR(MP_QSTR_colorwheel), MP_ROM_PTR(&mp_colorwheel_type) },
    { MP_ROM_QSTR(MP_QSTR_led), MP_ROM_PTR(&mp_led_type) },
    { MP_ROM_QSTR(MP_QSTR_imgbtn), MP_ROM_PTR(&mp_imgbtn_type) },
    { MP_ROM_QSTR(MP_QSTR_spangroup), MP_ROM_PTR(&mp_spangroup_type) },
    { MP_ROM_QSTR(MP_QSTR_lvsfheader), MP_ROM_PTR(&mp_lvsfheader_type) },
    { MP_ROM_QSTR(MP_QSTR_lvsfpopup), MP_ROM_PTR(&mp_lvsfpopup_type) },
    { MP_ROM_QSTR(MP_QSTR_lvsfcomp), MP_ROM_PTR(&mp_lvsfcomp_type) },
    { MP_ROM_QSTR(MP_QSTR_lvsfcorner), MP_ROM_PTR(&mp_lvsfcorner_type) },
    { MP_ROM_QSTR(MP_QSTR_lvsfbarcode), MP_ROM_PTR(&mp_lvsfbarcode_type) },
    { MP_ROM_QSTR(MP_QSTR_analogclk), MP_ROM_PTR(&mp_analogclk_type) },
    { MP_ROM_QSTR(MP_QSTR_idximg), MP_ROM_PTR(&mp_idximg_type) },
    { MP_ROM_QSTR(MP_QSTR_lvsfcurve), MP_ROM_PTR(&mp_lvsfcurve_type) },
    { MP_ROM_QSTR(MP_QSTR_lvsfaezip), MP_ROM_PTR(&mp_lvsfaezip_type) },
    { MP_ROM_QSTR(MP_QSTR_rlottie), MP_ROM_PTR(&mp_rlottie_type) },
    
    { MP_ROM_QSTR(MP_QSTR_timer_handler_run_in_period), MP_ROM_PTR(&mp_lv_timer_handler_run_in_period_obj) },
    { MP_ROM_QSTR(MP_QSTR_trigo_cos), MP_ROM_PTR(&mp_lv_trigo_cos_obj) },
    { MP_ROM_QSTR(MP_QSTR_memcpy_small), MP_ROM_PTR(&mp_lv_memcpy_small_obj) },
    { MP_ROM_QSTR(MP_QSTR_pct), MP_ROM_PTR(&mp_lv_pct_obj) },
    { MP_ROM_QSTR(MP_QSTR_font_default), MP_ROM_PTR(&mp_lv_font_default_obj) },
    { MP_ROM_QSTR(MP_QSTR_color_mix_premult), MP_ROM_PTR(&mp_lv_color_mix_premult_obj) },
    { MP_ROM_QSTR(MP_QSTR_color_make), MP_ROM_PTR(&mp_lv_color_make_obj) },
    { MP_ROM_QSTR(MP_QSTR_color_hex), MP_ROM_PTR(&mp_lv_color_hex_obj) },
    { MP_ROM_QSTR(MP_QSTR_color_hex3), MP_ROM_PTR(&mp_lv_color_hex3_obj) },
    { MP_ROM_QSTR(MP_QSTR_color_chroma_key), MP_ROM_PTR(&mp_lv_color_chroma_key_obj) },
    { MP_ROM_QSTR(MP_QSTR_color_white), MP_ROM_PTR(&mp_lv_color_white_obj) },
    { MP_ROM_QSTR(MP_QSTR_color_black), MP_ROM_PTR(&mp_lv_color_black_obj) },
    { MP_ROM_QSTR(MP_QSTR_bidi_calculate_align), MP_ROM_PTR(&mp_lv_bidi_calculate_align_obj) },
    { MP_ROM_QSTR(MP_QSTR_style_prop_has_flag), MP_ROM_PTR(&mp_lv_style_prop_has_flag_obj) },
    { MP_ROM_QSTR(MP_QSTR_scr_act), MP_ROM_PTR(&mp_lv_scr_act_obj) },
    { MP_ROM_QSTR(MP_QSTR_layer_top), MP_ROM_PTR(&mp_lv_layer_top_obj) },
    { MP_ROM_QSTR(MP_QSTR_layer_sys), MP_ROM_PTR(&mp_lv_layer_sys_obj) },
    { MP_ROM_QSTR(MP_QSTR_scr_load), MP_ROM_PTR(&mp_lv_scr_load_obj) },
    { MP_ROM_QSTR(MP_QSTR_dpx), MP_ROM_PTR(&mp_lv_dpx_obj) },
    { MP_ROM_QSTR(MP_QSTR_task_handler), MP_ROM_PTR(&mp_lv_task_handler_obj) },
    { MP_ROM_QSTR(MP_QSTR_grid_fr), MP_ROM_PTR(&mp_lv_grid_fr_obj) },
    { MP_ROM_QSTR(MP_QSTR_version_major), MP_ROM_PTR(&mp_lv_version_major_obj) },
    { MP_ROM_QSTR(MP_QSTR_version_minor), MP_ROM_PTR(&mp_lv_version_minor_obj) },
    { MP_ROM_QSTR(MP_QSTR_version_patch), MP_ROM_PTR(&mp_lv_version_patch_obj) },
    { MP_ROM_QSTR(MP_QSTR_version_info), MP_ROM_PTR(&mp_lv_version_info_obj) },
    { MP_ROM_QSTR(MP_QSTR_tick_inc), MP_ROM_PTR(&mp_lv_tick_inc_obj) },
    { MP_ROM_QSTR(MP_QSTR_tick_get), MP_ROM_PTR(&mp_lv_tick_get_obj) },
    { MP_ROM_QSTR(MP_QSTR_tick_elaps), MP_ROM_PTR(&mp_lv_tick_elaps_obj) },
    { MP_ROM_QSTR(MP_QSTR_timer_handler), MP_ROM_PTR(&mp_lv_timer_handler_obj) },
    { MP_ROM_QSTR(MP_QSTR_timer_create_basic), MP_ROM_PTR(&mp_lv_timer_create_basic_obj) },
    { MP_ROM_QSTR(MP_QSTR_timer_create), MP_ROM_PTR(&mp_lv_timer_create_obj) },
    { MP_ROM_QSTR(MP_QSTR_timer_enable), MP_ROM_PTR(&mp_lv_timer_enable_obj) },
    { MP_ROM_QSTR(MP_QSTR_timer_get_idle), MP_ROM_PTR(&mp_lv_timer_get_idle_obj) },
    { MP_ROM_QSTR(MP_QSTR_trigo_sin), MP_ROM_PTR(&mp_lv_trigo_sin_obj) },
    { MP_ROM_QSTR(MP_QSTR_bezier3), MP_ROM_PTR(&mp_lv_bezier3_obj) },
    { MP_ROM_QSTR(MP_QSTR_atan2), MP_ROM_PTR(&mp_lv_atan2_obj) },
    { MP_ROM_QSTR(MP_QSTR_sqrt), MP_ROM_PTR(&mp_lv_sqrt_obj) },
    { MP_ROM_QSTR(MP_QSTR_pow), MP_ROM_PTR(&mp_lv_pow_obj) },
    { MP_ROM_QSTR(MP_QSTR_map), MP_ROM_PTR(&mp_lv_map_obj) },
    { MP_ROM_QSTR(MP_QSTR_rand), MP_ROM_PTR(&mp_lv_rand_obj) },
    { MP_ROM_QSTR(MP_QSTR_mem_init), MP_ROM_PTR(&mp_lv_mem_init_obj) },
    { MP_ROM_QSTR(MP_QSTR_mem_deinit), MP_ROM_PTR(&mp_lv_mem_deinit_obj) },
    { MP_ROM_QSTR(MP_QSTR_mem_alloc), MP_ROM_PTR(&mp_lv_mem_alloc_obj) },
    { MP_ROM_QSTR(MP_QSTR_mem_free), MP_ROM_PTR(&mp_lv_mem_free_obj) },
    { MP_ROM_QSTR(MP_QSTR_mem_realloc), MP_ROM_PTR(&mp_lv_mem_realloc_obj) },
    { MP_ROM_QSTR(MP_QSTR_mem_test), MP_ROM_PTR(&mp_lv_mem_test_obj) },
    { MP_ROM_QSTR(MP_QSTR_mem_buf_get), MP_ROM_PTR(&mp_lv_mem_buf_get_obj) },
    { MP_ROM_QSTR(MP_QSTR_mem_buf_release), MP_ROM_PTR(&mp_lv_mem_buf_release_obj) },
    { MP_ROM_QSTR(MP_QSTR_mem_buf_free_all), MP_ROM_PTR(&mp_lv_mem_buf_free_all_obj) },
    { MP_ROM_QSTR(MP_QSTR_memcpy), MP_ROM_PTR(&mp_lv_memcpy_obj) },
    { MP_ROM_QSTR(MP_QSTR_memset), MP_ROM_PTR(&mp_lv_memset_obj) },
    { MP_ROM_QSTR(MP_QSTR_memset_00), MP_ROM_PTR(&mp_lv_memset_00_obj) },
    { MP_ROM_QSTR(MP_QSTR_memset_ff), MP_ROM_PTR(&mp_lv_memset_ff_obj) },
    { MP_ROM_QSTR(MP_QSTR_async_call), MP_ROM_PTR(&mp_lv_async_call_obj) },
    { MP_ROM_QSTR(MP_QSTR_async_call_cancel), MP_ROM_PTR(&mp_lv_async_call_cancel_obj) },
    { MP_ROM_QSTR(MP_QSTR_anim_del), MP_ROM_PTR(&mp_lv_anim_del_obj) },
    { MP_ROM_QSTR(MP_QSTR_anim_del_all), MP_ROM_PTR(&mp_lv_anim_del_all_obj) },
    { MP_ROM_QSTR(MP_QSTR_anim_get), MP_ROM_PTR(&mp_lv_anim_get_obj) },
    { MP_ROM_QSTR(MP_QSTR_anim_get_timer), MP_ROM_PTR(&mp_lv_anim_get_timer_obj) },
    { MP_ROM_QSTR(MP_QSTR_anim_count_running), MP_ROM_PTR(&mp_lv_anim_count_running_obj) },
    { MP_ROM_QSTR(MP_QSTR_anim_speed_to_time), MP_ROM_PTR(&mp_lv_anim_speed_to_time_obj) },
    { MP_ROM_QSTR(MP_QSTR_anim_refr_now), MP_ROM_PTR(&mp_lv_anim_refr_now_obj) },
    { MP_ROM_QSTR(MP_QSTR_anim_timeline_create), MP_ROM_PTR(&mp_lv_anim_timeline_create_obj) },
    { MP_ROM_QSTR(MP_QSTR_anim_timeline_del), MP_ROM_PTR(&mp_lv_anim_timeline_del_obj) },
    { MP_ROM_QSTR(MP_QSTR_anim_timeline_add), MP_ROM_PTR(&mp_lv_anim_timeline_add_obj) },
    { MP_ROM_QSTR(MP_QSTR_anim_timeline_start), MP_ROM_PTR(&mp_lv_anim_timeline_start_obj) },
    { MP_ROM_QSTR(MP_QSTR_anim_timeline_stop), MP_ROM_PTR(&mp_lv_anim_timeline_stop_obj) },
    { MP_ROM_QSTR(MP_QSTR_anim_timeline_set_reverse), MP_ROM_PTR(&mp_lv_anim_timeline_set_reverse_obj) },
    { MP_ROM_QSTR(MP_QSTR_anim_timeline_set_progress), MP_ROM_PTR(&mp_lv_anim_timeline_set_progress_obj) },
    { MP_ROM_QSTR(MP_QSTR_anim_timeline_get_playtime), MP_ROM_PTR(&mp_lv_anim_timeline_get_playtime_obj) },
    { MP_ROM_QSTR(MP_QSTR_anim_timeline_get_reverse), MP_ROM_PTR(&mp_lv_anim_timeline_get_reverse_obj) },
    { MP_ROM_QSTR(MP_QSTR_color_hsv_to_rgb), MP_ROM_PTR(&mp_lv_color_hsv_to_rgb_obj) },
    { MP_ROM_QSTR(MP_QSTR_color_rgb_to_hsv), MP_ROM_PTR(&mp_lv_color_rgb_to_hsv_obj) },
    { MP_ROM_QSTR(MP_QSTR_palette_main), MP_ROM_PTR(&mp_lv_palette_main_obj) },
    { MP_ROM_QSTR(MP_QSTR_palette_lighten), MP_ROM_PTR(&mp_lv_palette_lighten_obj) },
    { MP_ROM_QSTR(MP_QSTR_palette_darken), MP_ROM_PTR(&mp_lv_palette_darken_obj) },
    { MP_ROM_QSTR(MP_QSTR_txt_get_size), MP_ROM_PTR(&mp_lv_txt_get_size_obj) },
    { MP_ROM_QSTR(MP_QSTR_txt_get_width), MP_ROM_PTR(&mp_lv_txt_get_width_obj) },
    { MP_ROM_QSTR(MP_QSTR_style_register_prop), MP_ROM_PTR(&mp_lv_style_register_prop_obj) },
    { MP_ROM_QSTR(MP_QSTR_style_get_num_custom_props), MP_ROM_PTR(&mp_lv_style_get_num_custom_props_obj) },
    { MP_ROM_QSTR(MP_QSTR_style_prop_get_default), MP_ROM_PTR(&mp_lv_style_prop_get_default_obj) },
    { MP_ROM_QSTR(MP_QSTR_fs_get_drv), MP_ROM_PTR(&mp_lv_fs_get_drv_obj) },
    { MP_ROM_QSTR(MP_QSTR_fs_is_ready), MP_ROM_PTR(&mp_lv_fs_is_ready_obj) },
    { MP_ROM_QSTR(MP_QSTR_fs_get_letters), MP_ROM_PTR(&mp_lv_fs_get_letters_obj) },
    { MP_ROM_QSTR(MP_QSTR_fs_get_ext), MP_ROM_PTR(&mp_lv_fs_get_ext_obj) },
    { MP_ROM_QSTR(MP_QSTR_fs_up), MP_ROM_PTR(&mp_lv_fs_up_obj) },
    { MP_ROM_QSTR(MP_QSTR_fs_get_last), MP_ROM_PTR(&mp_lv_fs_get_last_obj) },
    { MP_ROM_QSTR(MP_QSTR_layout_register), MP_ROM_PTR(&mp_lv_layout_register_obj) },
    { MP_ROM_QSTR(MP_QSTR_clamp_width), MP_ROM_PTR(&mp_lv_clamp_width_obj) },
    { MP_ROM_QSTR(MP_QSTR_clamp_height), MP_ROM_PTR(&mp_lv_clamp_height_obj) },
    { MP_ROM_QSTR(MP_QSTR_gradient_set_cache_size), MP_ROM_PTR(&mp_lv_gradient_set_cache_size_obj) },
    { MP_ROM_QSTR(MP_QSTR_gradient_free_cache), MP_ROM_PTR(&mp_lv_gradient_free_cache_obj) },
    { MP_ROM_QSTR(MP_QSTR_draw_arc_get_area), MP_ROM_PTR(&mp_lv_draw_arc_get_area_obj) },
    { MP_ROM_QSTR(MP_QSTR_draw_mask_add), MP_ROM_PTR(&mp_lv_draw_mask_add_obj) },
    { MP_ROM_QSTR(MP_QSTR_draw_mask_apply), MP_ROM_PTR(&mp_lv_draw_mask_apply_obj) },
    { MP_ROM_QSTR(MP_QSTR_draw_mask_apply_ids), MP_ROM_PTR(&mp_lv_draw_mask_apply_ids_obj) },
    { MP_ROM_QSTR(MP_QSTR_draw_mask_remove_id), MP_ROM_PTR(&mp_lv_draw_mask_remove_id_obj) },
    { MP_ROM_QSTR(MP_QSTR_draw_mask_remove_custom), MP_ROM_PTR(&mp_lv_draw_mask_remove_custom_obj) },
    { MP_ROM_QSTR(MP_QSTR_draw_mask_free_param), MP_ROM_PTR(&mp_lv_draw_mask_free_param_obj) },
    { MP_ROM_QSTR(MP_QSTR_draw_mask_get_cnt), MP_ROM_PTR(&mp_lv_draw_mask_get_cnt_obj) },
    { MP_ROM_QSTR(MP_QSTR_draw_mask_is_any), MP_ROM_PTR(&mp_lv_draw_mask_is_any_obj) },
    { MP_ROM_QSTR(MP_QSTR_draw_init), MP_ROM_PTR(&mp_lv_draw_init_obj) },
    { MP_ROM_QSTR(MP_QSTR_disp_get_default), MP_ROM_PTR(&mp_lv_disp_get_default_obj) },
    { MP_ROM_QSTR(MP_QSTR_event_send), MP_ROM_PTR(&mp_lv_event_send_obj) },
    { MP_ROM_QSTR(MP_QSTR_event_register_id), MP_ROM_PTR(&mp_lv_event_register_id_obj) },
    { MP_ROM_QSTR(MP_QSTR_group_create), MP_ROM_PTR(&mp_lv_group_create_obj) },
    { MP_ROM_QSTR(MP_QSTR_group_get_default), MP_ROM_PTR(&mp_lv_group_get_default_obj) },
    { MP_ROM_QSTR(MP_QSTR_group_swap_obj), MP_ROM_PTR(&mp_lv_group_swap_obj_obj) },
    { MP_ROM_QSTR(MP_QSTR_group_remove_obj), MP_ROM_PTR(&mp_lv_group_remove_obj_obj) },
    { MP_ROM_QSTR(MP_QSTR_group_focus_obj), MP_ROM_PTR(&mp_lv_group_focus_obj_obj) },
    { MP_ROM_QSTR(MP_QSTR_init), MP_ROM_PTR(&mp_lv_init_obj) },
    { MP_ROM_QSTR(MP_QSTR_deinit), MP_ROM_PTR(&mp_lv_deinit_obj) },
    { MP_ROM_QSTR(MP_QSTR_is_initialized), MP_ROM_PTR(&mp_lv_is_initialized_obj) },
    { MP_ROM_QSTR(MP_QSTR_indev_read_timer_cb), MP_ROM_PTR(&mp_lv_indev_read_timer_cb_obj) },
    { MP_ROM_QSTR(MP_QSTR_indev_get_act), MP_ROM_PTR(&mp_lv_indev_get_act_obj) },
    { MP_ROM_QSTR(MP_QSTR_indev_get_obj_act), MP_ROM_PTR(&mp_lv_indev_get_obj_act_obj) },
    { MP_ROM_QSTR(MP_QSTR_indev_get_read_timer), MP_ROM_PTR(&mp_lv_indev_get_read_timer_obj) },
    { MP_ROM_QSTR(MP_QSTR_indev_search_obj), MP_ROM_PTR(&mp_lv_indev_search_obj_obj) },
    { MP_ROM_QSTR(MP_QSTR_refr_now), MP_ROM_PTR(&mp_lv_refr_now_obj) },
    { MP_ROM_QSTR(MP_QSTR_theme_get_from_obj), MP_ROM_PTR(&mp_lv_theme_get_from_obj_obj) },
    { MP_ROM_QSTR(MP_QSTR_theme_apply), MP_ROM_PTR(&mp_lv_theme_apply_obj) },
    { MP_ROM_QSTR(MP_QSTR_theme_get_font_small), MP_ROM_PTR(&mp_lv_theme_get_font_small_obj) },
    { MP_ROM_QSTR(MP_QSTR_theme_get_font_normal), MP_ROM_PTR(&mp_lv_theme_get_font_normal_obj) },
    { MP_ROM_QSTR(MP_QSTR_theme_get_font_large), MP_ROM_PTR(&mp_lv_theme_get_font_large_obj) },
    { MP_ROM_QSTR(MP_QSTR_theme_get_color_primary), MP_ROM_PTR(&mp_lv_theme_get_color_primary_obj) },
    { MP_ROM_QSTR(MP_QSTR_theme_get_color_secondary), MP_ROM_PTR(&mp_lv_theme_get_color_secondary_obj) },
    { MP_ROM_QSTR(MP_QSTR_disp_load_scr), MP_ROM_PTR(&mp_lv_disp_load_scr_obj) },
    { MP_ROM_QSTR(MP_QSTR_scr_load_anim), MP_ROM_PTR(&mp_lv_scr_load_anim_obj) },
    { MP_ROM_QSTR(MP_QSTR_font_load), MP_ROM_PTR(&mp_lv_font_load_obj) },
    { MP_ROM_QSTR(MP_QSTR_snapshot_take), MP_ROM_PTR(&mp_lv_snapshot_take_obj) },
    { MP_ROM_QSTR(MP_QSTR_snapshot_free), MP_ROM_PTR(&mp_lv_snapshot_free_obj) },
    { MP_ROM_QSTR(MP_QSTR_snapshot_buf_size_needed), MP_ROM_PTR(&mp_lv_snapshot_buf_size_needed_obj) },
    { MP_ROM_QSTR(MP_QSTR_snapshot_take_to_buf), MP_ROM_PTR(&mp_lv_snapshot_take_to_buf_obj) },
    { MP_ROM_QSTR(MP_QSTR_flex_init), MP_ROM_PTR(&mp_lv_flex_init_obj) },
    { MP_ROM_QSTR(MP_QSTR_grid_init), MP_ROM_PTR(&mp_lv_grid_init_obj) },
    { MP_ROM_QSTR(MP_QSTR_fs_posix_init), MP_ROM_PTR(&mp_lv_fs_posix_init_obj) },
    { MP_ROM_QSTR(MP_QSTR_gd_open_gif_file), MP_ROM_PTR(&mp_gd_open_gif_file_obj) },
    { MP_ROM_QSTR(MP_QSTR_gd_open_gif_data), MP_ROM_PTR(&mp_gd_open_gif_data_obj) },
    { MP_ROM_QSTR(MP_QSTR_theme_mono_init), MP_ROM_PTR(&mp_lv_theme_mono_init_obj) },
    { MP_ROM_QSTR(MP_QSTR_theme_mono_is_inited), MP_ROM_PTR(&mp_lv_theme_mono_is_inited_obj) },
    { MP_ROM_QSTR(MP_QSTR_theme_basic_init), MP_ROM_PTR(&mp_lv_theme_basic_init_obj) },
    { MP_ROM_QSTR(MP_QSTR_theme_basic_is_inited), MP_ROM_PTR(&mp_lv_theme_basic_is_inited_obj) },
    { MP_ROM_QSTR(MP_QSTR_extra_init), MP_ROM_PTR(&mp_lv_extra_init_obj) },
    { MP_ROM_QSTR(MP_QSTR_event_to_name), MP_ROM_PTR(&mp_lv_event_to_name_obj) },
    { MP_ROM_QSTR(MP_QSTR_lvsf_text_create2), MP_ROM_PTR(&mp_lvsf_text_create2_obj) },
    { MP_ROM_QSTR(MP_QSTR_lvsf_curve_text), MP_ROM_PTR(&mp_lvsf_curve_text_obj) },
    { MP_ROM_QSTR(MP_QSTR_lvsf_curve_draw_text), MP_ROM_PTR(&mp_lvsf_curve_draw_text_obj) },
    { MP_ROM_QSTR(MP_QSTR_lvsf_font_width), MP_ROM_PTR(&mp_lvsf_font_width_obj) },
    { MP_ROM_QSTR(MP_QSTR_lvsf_font_height), MP_ROM_PTR(&mp_lvsf_font_height_obj) },
    { MP_ROM_QSTR(MP_QSTR_lvsf_canvas_rotate), MP_ROM_PTR(&mp_lvsf_canvas_rotate_obj) },
    { MP_ROM_QSTR(MP_QSTR_ex_data_create), MP_ROM_PTR(&mp_lv_ex_data_create_obj) },
    { MP_ROM_QSTR(MP_QSTR_ex_process_data), MP_ROM_PTR(&mp_lv_ex_process_data_obj) },
    { MP_ROM_QSTR(MP_QSTR_ex_data_pool_init), MP_ROM_PTR(&mp_lv_ex_data_pool_init_obj) },
    { MP_ROM_QSTR(MP_QSTR_keypad_handler_register), MP_ROM_PTR(&mp_keypad_handler_register_obj) },
    { MP_ROM_QSTR(MP_QSTR_keypad_default_handler_register), MP_ROM_PTR(&mp_keypad_default_handler_register_obj) },
    { MP_ROM_QSTR(MP_QSTR_keypad_do_event), MP_ROM_PTR(&mp_keypad_do_event_obj) },
    { MP_ROM_QSTR(MP_QSTR_wheel_do_event), MP_ROM_PTR(&mp_wheel_do_event_obj) },
    { MP_ROM_QSTR(MP_QSTR_wheel_default_handler_register), MP_ROM_PTR(&mp_wheel_default_handler_register_obj) },
    { MP_ROM_QSTR(MP_QSTR_lvsf_gesture_init), MP_ROM_PTR(&mp_lvsf_gesture_init_obj) },
    { MP_ROM_QSTR(MP_QSTR_lvsf_gesture_deinit), MP_ROM_PTR(&mp_lvsf_gesture_deinit_obj) },
    { MP_ROM_QSTR(MP_QSTR_lvsf_gesture_set_image), MP_ROM_PTR(&mp_lvsf_gesture_set_image_obj) },
    { MP_ROM_QSTR(MP_QSTR_lvsf_gesture_disable), MP_ROM_PTR(&mp_lvsf_gesture_disable_obj) },
    { MP_ROM_QSTR(MP_QSTR_lvsf_gesture_enable), MP_ROM_PTR(&mp_lvsf_gesture_enable_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_emoji_by_unicode), MP_ROM_PTR(&mp_lv_get_emoji_by_unicode_obj) },
    { MP_ROM_QSTR(MP_QSTR_theme_1_init), MP_ROM_PTR(&mp_lv_theme_1_init_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_ver_max), MP_ROM_PTR(&mp_lv_get_ver_max_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_hor_max), MP_ROM_PTR(&mp_lv_get_hor_max_obj) },
    { MP_ROM_QSTR(MP_QSTR_trigo_sin), MP_ROM_PTR(&mp_lv_trigo_sin_obj) },
    { MP_ROM_QSTR(MP_QSTR_intent_init), MP_ROM_PTR(&mp_intent_init_obj) },
    { MP_ROM_QSTR(MP_QSTR_intent_deinit), MP_ROM_PTR(&mp_intent_deinit_obj) },
    { MP_ROM_QSTR(MP_QSTR_intent_set_string), MP_ROM_PTR(&mp_intent_set_string_obj) },
    { MP_ROM_QSTR(MP_QSTR_intent_get_string), MP_ROM_PTR(&mp_intent_get_string_obj) },
    { MP_ROM_QSTR(MP_QSTR_intent_set_uint32), MP_ROM_PTR(&mp_intent_set_uint32_obj) },
    { MP_ROM_QSTR(MP_QSTR_intent_get_uint32), MP_ROM_PTR(&mp_intent_get_uint32_obj) },
    { MP_ROM_QSTR(MP_QSTR_intent_runapp), MP_ROM_PTR(&mp_intent_runapp_obj) },
    { MP_ROM_QSTR(MP_QSTR_printf_intent), MP_ROM_PTR(&mp_printf_intent_obj) },
    { MP_ROM_QSTR(MP_QSTR_gui_app_init), MP_ROM_PTR(&mp_gui_app_init_obj) },
    { MP_ROM_QSTR(MP_QSTR_gui_app_run), MP_ROM_PTR(&mp_gui_app_run_obj) },
    { MP_ROM_QSTR(MP_QSTR_gui_app_exit), MP_ROM_PTR(&mp_gui_app_exit_obj) },
    { MP_ROM_QSTR(MP_QSTR_gui_app_self_exit), MP_ROM_PTR(&mp_gui_app_self_exit_obj) },
    { MP_ROM_QSTR(MP_QSTR_gui_app_is_actived), MP_ROM_PTR(&mp_gui_app_is_actived_obj) },
    { MP_ROM_QSTR(MP_QSTR_gui_app_remove_page), MP_ROM_PTR(&mp_gui_app_remove_page_obj) },
    { MP_ROM_QSTR(MP_QSTR_gui_app_goback_to_page), MP_ROM_PTR(&mp_gui_app_goback_to_page_obj) },
    { MP_ROM_QSTR(MP_QSTR_gui_app_goback), MP_ROM_PTR(&mp_gui_app_goback_obj) },
    { MP_ROM_QSTR(MP_QSTR_gui_app_manual_goback_anim), MP_ROM_PTR(&mp_gui_app_manual_goback_anim_obj) },
    { MP_ROM_QSTR(MP_QSTR_gui_app_cleanup), MP_ROM_PTR(&mp_gui_app_cleanup_obj) },
    { MP_ROM_QSTR(MP_QSTR_gui_app_cleanup_now), MP_ROM_PTR(&mp_gui_app_cleanup_now_obj) },
    { MP_ROM_QSTR(MP_QSTR_gui_app_run_now), MP_ROM_PTR(&mp_gui_app_run_now_obj) },
    { MP_ROM_QSTR(MP_QSTR_gui_app_is_all_closed), MP_ROM_PTR(&mp_gui_app_is_all_closed_obj) },
    { MP_ROM_QSTR(MP_QSTR_gui_app_get_intent), MP_ROM_PTR(&mp_gui_app_get_intent_obj) },
    { MP_ROM_QSTR(MP_QSTR_gui_app_get_page_userdata), MP_ROM_PTR(&mp_gui_app_get_page_userdata_obj) },
    { MP_ROM_QSTR(MP_QSTR_gui_app_set_page_userdata), MP_ROM_PTR(&mp_gui_app_set_page_userdata_obj) },
    { MP_ROM_QSTR(MP_QSTR_gui_app_get_running_apps), MP_ROM_PTR(&mp_gui_app_get_running_apps_obj) },
    { MP_ROM_QSTR(MP_QSTR_gui_app_get_clock_parent), MP_ROM_PTR(&mp_gui_app_get_clock_parent_obj) },
    
    { MP_ROM_QSTR(MP_QSTR_RES), MP_ROM_PTR(&mp_LV_RES_type) },
    { MP_ROM_QSTR(MP_QSTR_ALIGN), MP_ROM_PTR(&mp_LV_ALIGN_type) },
    { MP_ROM_QSTR(MP_QSTR_DIR), MP_ROM_PTR(&mp_LV_DIR_type) },
    { MP_ROM_QSTR(MP_QSTR_FONT_SUBPX), MP_ROM_PTR(&mp_LV_FONT_SUBPX_type) },
    { MP_ROM_QSTR(MP_QSTR_OPA), MP_ROM_PTR(&mp_LV_OPA_type) },
    { MP_ROM_QSTR(MP_QSTR_TEXT_FLAG), MP_ROM_PTR(&mp_LV_TEXT_FLAG_type) },
    { MP_ROM_QSTR(MP_QSTR_TEXT_CMD_STATE), MP_ROM_PTR(&mp_LV_TEXT_CMD_STATE_type) },
    { MP_ROM_QSTR(MP_QSTR_TEXT_ALIGN), MP_ROM_PTR(&mp_LV_TEXT_ALIGN_type) },
    { MP_ROM_QSTR(MP_QSTR_BASE_DIR), MP_ROM_PTR(&mp_LV_BASE_DIR_type) },
    { MP_ROM_QSTR(MP_QSTR_BLEND_MODE), MP_ROM_PTR(&mp_LV_BLEND_MODE_type) },
    { MP_ROM_QSTR(MP_QSTR_TEXT_DECOR), MP_ROM_PTR(&mp_LV_TEXT_DECOR_type) },
    { MP_ROM_QSTR(MP_QSTR_BORDER_SIDE), MP_ROM_PTR(&mp_LV_BORDER_SIDE_type) },
    { MP_ROM_QSTR(MP_QSTR_GRAD_DIR), MP_ROM_PTR(&mp_LV_GRAD_DIR_type) },
    { MP_ROM_QSTR(MP_QSTR_DITHER), MP_ROM_PTR(&mp_LV_DITHER_type) },
    { MP_ROM_QSTR(MP_QSTR_STYLE_RES), MP_ROM_PTR(&mp_LV_STYLE_RES_type) },
    { MP_ROM_QSTR(MP_QSTR_FS_RES), MP_ROM_PTR(&mp_LV_FS_RES_type) },
    { MP_ROM_QSTR(MP_QSTR_FS_MODE), MP_ROM_PTR(&mp_LV_FS_MODE_type) },
    { MP_ROM_QSTR(MP_QSTR_DRAW_MASK_RES), MP_ROM_PTR(&mp_LV_DRAW_MASK_RES_type) },
    { MP_ROM_QSTR(MP_QSTR_DRAW_MASK_TYPE), MP_ROM_PTR(&mp_LV_DRAW_MASK_TYPE_type) },
    { MP_ROM_QSTR(MP_QSTR_DRAW_MASK_LINE_SIDE), MP_ROM_PTR(&mp_LV_DRAW_MASK_LINE_SIDE_type) },
    { MP_ROM_QSTR(MP_QSTR_STATE), MP_ROM_PTR(&mp_LV_STATE_type) },
    { MP_ROM_QSTR(MP_QSTR_PART), MP_ROM_PTR(&mp_LV_PART_type) },
    { MP_ROM_QSTR(MP_QSTR_SCROLLBAR_MODE), MP_ROM_PTR(&mp_LV_SCROLLBAR_MODE_type) },
    { MP_ROM_QSTR(MP_QSTR_SCROLL_SNAP), MP_ROM_PTR(&mp_LV_SCROLL_SNAP_type) },
    { MP_ROM_QSTR(MP_QSTR_KEY), MP_ROM_PTR(&mp_LV_KEY_type) },
    { MP_ROM_QSTR(MP_QSTR_FONT_FMT_TXT_CMAP), MP_ROM_PTR(&mp_LV_FONT_FMT_TXT_CMAP_type) },
    { MP_ROM_QSTR(MP_QSTR_PART_TEXTAREA), MP_ROM_PTR(&mp_LV_PART_TEXTAREA_type) },
    { MP_ROM_QSTR(MP_QSTR_ANIM_IMG_PART), MP_ROM_PTR(&mp_LV_ANIM_IMG_PART_type) },
    { MP_ROM_QSTR(MP_QSTR_SPAN_OVERFLOW), MP_ROM_PTR(&mp_LV_SPAN_OVERFLOW_type) },
    { MP_ROM_QSTR(MP_QSTR_SPAN_MODE), MP_ROM_PTR(&mp_LV_SPAN_MODE_type) },
    { MP_ROM_QSTR(MP_QSTR_LVSF_HEADER), MP_ROM_PTR(&mp_LVSF_HEADER_type) },
    { MP_ROM_QSTR(MP_QSTR_ANIM), MP_ROM_PTR(&mp_LV_ANIM_type) },
    { MP_ROM_QSTR(MP_QSTR_PALETTE), MP_ROM_PTR(&mp_LV_PALETTE_type) },
    { MP_ROM_QSTR(MP_QSTR_STYLE), MP_ROM_PTR(&mp_LV_STYLE_type) },
    { MP_ROM_QSTR(MP_QSTR_FS_SEEK), MP_ROM_PTR(&mp_LV_FS_SEEK_type) },
    { MP_ROM_QSTR(MP_QSTR_DRAW_LAYER_FLAG), MP_ROM_PTR(&mp_LV_DRAW_LAYER_FLAG_type) },
    { MP_ROM_QSTR(MP_QSTR_DISP_ROT), MP_ROM_PTR(&mp_LV_DISP_ROT_type) },
    { MP_ROM_QSTR(MP_QSTR_INDEV_TYPE), MP_ROM_PTR(&mp_LV_INDEV_TYPE_type) },
    { MP_ROM_QSTR(MP_QSTR_INDEV_STATE), MP_ROM_PTR(&mp_LV_INDEV_STATE_type) },
    { MP_ROM_QSTR(MP_QSTR_COVER_RES), MP_ROM_PTR(&mp_LV_COVER_RES_type) },
    { MP_ROM_QSTR(MP_QSTR_LAYER_TYPE), MP_ROM_PTR(&mp_LV_LAYER_TYPE_type) },
    { MP_ROM_QSTR(MP_QSTR_EVENT), MP_ROM_PTR(&mp_LV_EVENT_type) },
    { MP_ROM_QSTR(MP_QSTR_GROUP_REFOCUS_POLICY), MP_ROM_PTR(&mp_LV_GROUP_REFOCUS_POLICY_type) },
    { MP_ROM_QSTR(MP_QSTR_SCR_LOAD_ANIM), MP_ROM_PTR(&mp_LV_SCR_LOAD_ANIM_type) },
    { MP_ROM_QSTR(MP_QSTR_FONT_FMT_TXT), MP_ROM_PTR(&mp_LV_FONT_FMT_TXT_type) },
    { MP_ROM_QSTR(MP_QSTR_FLEX_ALIGN), MP_ROM_PTR(&mp_LV_FLEX_ALIGN_type) },
    { MP_ROM_QSTR(MP_QSTR_FLEX_FLOW), MP_ROM_PTR(&mp_LV_FLEX_FLOW_type) },
    { MP_ROM_QSTR(MP_QSTR_GRID_ALIGN), MP_ROM_PTR(&mp_LV_GRID_ALIGN_type) },
    { MP_ROM_QSTR(MP_QSTR_EX_DATA), MP_ROM_PTR(&mp_LV_EX_DATA_type) },
    { MP_ROM_QSTR(MP_QSTR_LVSF_COMP), MP_ROM_PTR(&mp_LVSF_COMP_type) },
    { MP_ROM_QSTR(MP_QSTR_GUI_APP_MSG), MP_ROM_PTR(&mp_GUI_APP_MSG_type) },
    { MP_ROM_QSTR(MP_QSTR_SYMBOL), MP_ROM_PTR(&mp_LV_SYMBOL_type) },
    
    { MP_ROM_QSTR(MP_QSTR_C_Pointer), MP_ROM_PTR(&mp_C_Pointer_type) },
    { MP_ROM_QSTR(MP_QSTR_color16_t), MP_ROM_PTR(&mp_lv_color16_t_type) },
    { MP_ROM_QSTR(MP_QSTR_color16_ch_t), MP_ROM_PTR(&mp_lv_color16_ch_t_type) },
    { MP_ROM_QSTR(MP_QSTR_grad_dsc_t), MP_ROM_PTR(&mp_lv_grad_dsc_t_type) },
    { MP_ROM_QSTR(MP_QSTR_gradient_stop_t), MP_ROM_PTR(&mp_lv_gradient_stop_t_type) },
    { MP_ROM_QSTR(MP_QSTR_font_t), MP_ROM_PTR(&mp_lv_font_t_type) },
    { MP_ROM_QSTR(MP_QSTR_font_glyph_dsc_t), MP_ROM_PTR(&mp_lv_font_glyph_dsc_t_type) },
    { MP_ROM_QSTR(MP_QSTR_color_filter_dsc_t), MP_ROM_PTR(&mp_lv_color_filter_dsc_t_type) },
    { MP_ROM_QSTR(MP_QSTR_anim_t), MP_ROM_PTR(&mp_lv_anim_t_type) },
    { MP_ROM_QSTR(MP_QSTR_style_transition_dsc_t), MP_ROM_PTR(&mp_lv_style_transition_dsc_t_type) },
    { MP_ROM_QSTR(MP_QSTR_area_t), MP_ROM_PTR(&mp_lv_area_t_type) },
    { MP_ROM_QSTR(MP_QSTR_point_t), MP_ROM_PTR(&mp_lv_point_t_type) },
    { MP_ROM_QSTR(MP_QSTR_disp_t), MP_ROM_PTR(&mp_lv_disp_t_type) },
    { MP_ROM_QSTR(MP_QSTR_disp_drv_t), MP_ROM_PTR(&mp_lv_disp_drv_t_type) },
    { MP_ROM_QSTR(MP_QSTR_disp_draw_buf_t), MP_ROM_PTR(&mp_lv_disp_draw_buf_t_type) },
    { MP_ROM_QSTR(MP_QSTR_draw_ctx_t), MP_ROM_PTR(&mp_lv_draw_ctx_t_type) },
    { MP_ROM_QSTR(MP_QSTR_draw_rect_dsc_t), MP_ROM_PTR(&mp_lv_draw_rect_dsc_t_type) },
    { MP_ROM_QSTR(MP_QSTR_draw_arc_dsc_t), MP_ROM_PTR(&mp_lv_draw_arc_dsc_t_type) },
    { MP_ROM_QSTR(MP_QSTR_draw_img_dsc_t), MP_ROM_PTR(&mp_lv_draw_img_dsc_t_type) },
    { MP_ROM_QSTR(MP_QSTR_draw_label_dsc_t), MP_ROM_PTR(&mp_lv_draw_label_dsc_t_type) },
    { MP_ROM_QSTR(MP_QSTR_draw_line_dsc_t), MP_ROM_PTR(&mp_lv_draw_line_dsc_t_type) },
    { MP_ROM_QSTR(MP_QSTR_draw_layer_ctx_t), MP_ROM_PTR(&mp_lv_draw_layer_ctx_t_type) },
    { MP_ROM_QSTR(MP_QSTR_draw_layer_ctx_original_t), MP_ROM_PTR(&mp_lv_draw_layer_ctx_original_t_type) },
    { MP_ROM_QSTR(MP_QSTR_timer_t), MP_ROM_PTR(&mp_lv_timer_t_type) },
    { MP_ROM_QSTR(MP_QSTR_theme_t), MP_ROM_PTR(&mp_lv_theme_t_type) },
    { MP_ROM_QSTR(MP_QSTR_style_t), MP_ROM_PTR(&mp_lv_style_t_type) },
    { MP_ROM_QSTR(MP_QSTR_style_v_p_t), MP_ROM_PTR(&mp_lv_style_v_p_t_type) },
    { MP_ROM_QSTR(MP_QSTR_style_value_t), MP_ROM_PTR(&mp_lv_style_value_t_type) },
    { MP_ROM_QSTR(MP_QSTR_style_const_prop_t), MP_ROM_PTR(&mp_lv_style_const_prop_t_type) },
    { MP_ROM_QSTR(MP_QSTR_obj_draw_part_dsc_t), MP_ROM_PTR(&mp_lv_obj_draw_part_dsc_t_type) },
    { MP_ROM_QSTR(MP_QSTR_obj_class_t), MP_ROM_PTR(&mp_lv_obj_class_t_type) },
    { MP_ROM_QSTR(MP_QSTR_event_t), MP_ROM_PTR(&mp_lv_event_t_type) },
    { MP_ROM_QSTR(MP_QSTR_img_dsc_t), MP_ROM_PTR(&mp_lv_img_dsc_t_type) },
    { MP_ROM_QSTR(MP_QSTR_img_header_t), MP_ROM_PTR(&mp_lv_img_header_t_type) },
    { MP_ROM_QSTR(MP_QSTR_img_decoder_dsc_t), MP_ROM_PTR(&mp_lv_img_decoder_dsc_t_type) },
    { MP_ROM_QSTR(MP_QSTR_img_decoder_t), MP_ROM_PTR(&mp_lv_img_decoder_t_type) },
    { MP_ROM_QSTR(MP_QSTR_calendar_date_t), MP_ROM_PTR(&mp_lv_calendar_date_t_type) },
    { MP_ROM_QSTR(MP_QSTR_chart_series_t), MP_ROM_PTR(&mp_lv_chart_series_t_type) },
    { MP_ROM_QSTR(MP_QSTR_chart_cursor_t), MP_ROM_PTR(&mp_lv_chart_cursor_t_type) },
    { MP_ROM_QSTR(MP_QSTR_meter_scale_t), MP_ROM_PTR(&mp_lv_meter_scale_t_type) },
    { MP_ROM_QSTR(MP_QSTR_meter_indicator_t), MP_ROM_PTR(&mp_lv_meter_indicator_t_type) },
    { MP_ROM_QSTR(MP_QSTR_meter_indicator_type_data_t), MP_ROM_PTR(&mp_lv_meter_indicator_type_data_t_type) },
    { MP_ROM_QSTR(MP_QSTR_meter_indicator_type_data_needle_img_t), MP_ROM_PTR(&mp_lv_meter_indicator_type_data_needle_img_t_type) },
    { MP_ROM_QSTR(MP_QSTR_meter_indicator_type_data_needle_line_t), MP_ROM_PTR(&mp_lv_meter_indicator_type_data_needle_line_t_type) },
    { MP_ROM_QSTR(MP_QSTR_meter_indicator_type_data_arc_t), MP_ROM_PTR(&mp_lv_meter_indicator_type_data_arc_t_type) },
    { MP_ROM_QSTR(MP_QSTR_meter_indicator_type_data_scale_lines_t), MP_ROM_PTR(&mp_lv_meter_indicator_type_data_scale_lines_t_type) },
    { MP_ROM_QSTR(MP_QSTR_color_hsv_t), MP_ROM_PTR(&mp_lv_color_hsv_t_type) },
    { MP_ROM_QSTR(MP_QSTR_span_t), MP_ROM_PTR(&mp_lv_span_t_type) },
    { MP_ROM_QSTR(MP_QSTR_mem_monitor_t), MP_ROM_PTR(&mp_lv_mem_monitor_t_type) },
    { MP_ROM_QSTR(MP_QSTR_fs_drv_t), MP_ROM_PTR(&mp_lv_fs_drv_t_type) },
    { MP_ROM_QSTR(MP_QSTR_fs_file_t), MP_ROM_PTR(&mp_lv_fs_file_t_type) },
    { MP_ROM_QSTR(MP_QSTR_fs_file_cache_t), MP_ROM_PTR(&mp_lv_fs_file_cache_t_type) },
    { MP_ROM_QSTR(MP_QSTR_fs_dir_t), MP_ROM_PTR(&mp_lv_fs_dir_t_type) },
    { MP_ROM_QSTR(MP_QSTR_grad_t), MP_ROM_PTR(&mp_lv_grad_t_type) },
    { MP_ROM_QSTR(MP_QSTR_draw_mask_line_param_t), MP_ROM_PTR(&mp_lv_draw_mask_line_param_t_type) },
    { MP_ROM_QSTR(MP_QSTR__lv_draw_mask_common_dsc_t), MP_ROM_PTR(&mp__lv_draw_mask_common_dsc_t_type) },
    { MP_ROM_QSTR(MP_QSTR_draw_mask_line_param_cfg_t), MP_ROM_PTR(&mp_lv_draw_mask_line_param_cfg_t_type) },
    { MP_ROM_QSTR(MP_QSTR_draw_mask_angle_param_t), MP_ROM_PTR(&mp_lv_draw_mask_angle_param_t_type) },
    { MP_ROM_QSTR(MP_QSTR_draw_mask_angle_param_cfg_t), MP_ROM_PTR(&mp_lv_draw_mask_angle_param_cfg_t_type) },
    { MP_ROM_QSTR(MP_QSTR_draw_mask_radius_param_t), MP_ROM_PTR(&mp_lv_draw_mask_radius_param_t_type) },
    { MP_ROM_QSTR(MP_QSTR_draw_mask_radius_param_cfg_t), MP_ROM_PTR(&mp_lv_draw_mask_radius_param_cfg_t_type) },
    { MP_ROM_QSTR(MP_QSTR__lv_draw_mask_radius_circle_dsc_t), MP_ROM_PTR(&mp__lv_draw_mask_radius_circle_dsc_t_type) },
    { MP_ROM_QSTR(MP_QSTR_draw_mask_fade_param_t), MP_ROM_PTR(&mp_lv_draw_mask_fade_param_t_type) },
    { MP_ROM_QSTR(MP_QSTR_draw_mask_fade_param_cfg_t), MP_ROM_PTR(&mp_lv_draw_mask_fade_param_cfg_t_type) },
    { MP_ROM_QSTR(MP_QSTR_draw_mask_map_param_t), MP_ROM_PTR(&mp_lv_draw_mask_map_param_t_type) },
    { MP_ROM_QSTR(MP_QSTR_draw_mask_map_param_cfg_t), MP_ROM_PTR(&mp_lv_draw_mask_map_param_cfg_t_type) },
    { MP_ROM_QSTR(MP_QSTR_draw_mask_polygon_param_t), MP_ROM_PTR(&mp_lv_draw_mask_polygon_param_t_type) },
    { MP_ROM_QSTR(MP_QSTR_draw_mask_polygon_param_cfg_t), MP_ROM_PTR(&mp_lv_draw_mask_polygon_param_cfg_t_type) },
    { MP_ROM_QSTR(MP_QSTR_indev_drv_t), MP_ROM_PTR(&mp_lv_indev_drv_t_type) },
    { MP_ROM_QSTR(MP_QSTR_indev_data_t), MP_ROM_PTR(&mp_lv_indev_data_t_type) },
    { MP_ROM_QSTR(MP_QSTR_indev_t), MP_ROM_PTR(&mp_lv_indev_t_type) },
    { MP_ROM_QSTR(MP_QSTR__lv_indev_proc_t), MP_ROM_PTR(&mp__lv_indev_proc_t_type) },
    { MP_ROM_QSTR(MP_QSTR__lv_indev_proc_types_t), MP_ROM_PTR(&mp__lv_indev_proc_types_t_type) },
    { MP_ROM_QSTR(MP_QSTR__lv_indev_proc_types_pointer_t), MP_ROM_PTR(&mp__lv_indev_proc_types_pointer_t_type) },
    { MP_ROM_QSTR(MP_QSTR__lv_indev_proc_types_keypad_t), MP_ROM_PTR(&mp__lv_indev_proc_types_keypad_t_type) },
    { MP_ROM_QSTR(MP_QSTR_group_t), MP_ROM_PTR(&mp_lv_group_t_type) },
    { MP_ROM_QSTR(MP_QSTR_ll_t), MP_ROM_PTR(&mp_lv_ll_t_type) },
    { MP_ROM_QSTR(MP_QSTR_gd_GIF), MP_ROM_PTR(&mp_gd_GIF_type) },
    { MP_ROM_QSTR(MP_QSTR_gd_GCE), MP_ROM_PTR(&mp_gd_GCE_type) },
    { MP_ROM_QSTR(MP_QSTR_gd_Palette), MP_ROM_PTR(&mp_gd_Palette_type) },
    { MP_ROM_QSTR(MP_QSTR_ex_data_t), MP_ROM_PTR(&mp_lv_ex_data_t_type) },
    { MP_ROM_QSTR(MP_QSTR_ex_data_value_t), MP_ROM_PTR(&mp_lv_ex_data_value_t_type) },
    { MP_ROM_QSTR(MP_QSTR_draw_label_hint_t), MP_ROM_PTR(&mp_lv_draw_label_hint_t_type) },
    { MP_ROM_QSTR(MP_QSTR_hit_test_info_t), MP_ROM_PTR(&mp_lv_hit_test_info_t_type) },
    { MP_ROM_QSTR(MP_QSTR_ex_binding_t), MP_ROM_PTR(&mp_lv_ex_binding_t_type) },
    { MP_ROM_QSTR(MP_QSTR_sqrt_res_t), MP_ROM_PTR(&mp_lv_sqrt_res_t_type) },
    
    { MP_ROM_QSTR(MP_QSTR_color_t), MP_ROM_PTR(&mp_lv_color16_t_type) },
    
    { MP_ROM_QSTR(MP_QSTR_font_montserrat_14), MP_ROM_PTR(&mp_lv_font_montserrat_14) },
    { MP_ROM_QSTR(MP_QSTR_obj_class), MP_ROM_PTR(&mp_lv_obj_class) },
    { MP_ROM_QSTR(MP_QSTR_arc_class), MP_ROM_PTR(&mp_lv_arc_class) },
    { MP_ROM_QSTR(MP_QSTR_btn_class), MP_ROM_PTR(&mp_lv_btn_class) },
    { MP_ROM_QSTR(MP_QSTR_img_class), MP_ROM_PTR(&mp_lv_img_class) },
    { MP_ROM_QSTR(MP_QSTR_label_class), MP_ROM_PTR(&mp_lv_label_class) },
    { MP_ROM_QSTR(MP_QSTR_line_class), MP_ROM_PTR(&mp_lv_line_class) },
    { MP_ROM_QSTR(MP_QSTR_table_class), MP_ROM_PTR(&mp_lv_table_class) },
    { MP_ROM_QSTR(MP_QSTR_checkbox_class), MP_ROM_PTR(&mp_lv_checkbox_class) },
    { MP_ROM_QSTR(MP_QSTR_bar_class), MP_ROM_PTR(&mp_lv_bar_class) },
    { MP_ROM_QSTR(MP_QSTR_slider_class), MP_ROM_PTR(&mp_lv_slider_class) },
    { MP_ROM_QSTR(MP_QSTR_btnmatrix_class), MP_ROM_PTR(&mp_lv_btnmatrix_class) },
    { MP_ROM_QSTR(MP_QSTR_dropdown_class), MP_ROM_PTR(&mp_lv_dropdown_class) },
    { MP_ROM_QSTR(MP_QSTR_dropdownlist_class), MP_ROM_PTR(&mp_lv_dropdownlist_class) },
    { MP_ROM_QSTR(MP_QSTR_roller_class), MP_ROM_PTR(&mp_lv_roller_class) },
    { MP_ROM_QSTR(MP_QSTR_textarea_class), MP_ROM_PTR(&mp_lv_textarea_class) },
    { MP_ROM_QSTR(MP_QSTR_canvas_class), MP_ROM_PTR(&mp_lv_canvas_class) },
    { MP_ROM_QSTR(MP_QSTR_switch_class), MP_ROM_PTR(&mp_lv_switch_class) },
    { MP_ROM_QSTR(MP_QSTR_gif_class), MP_ROM_PTR(&mp_lv_gif_class) },
    { MP_ROM_QSTR(MP_QSTR_qrcode_class), MP_ROM_PTR(&mp_lv_qrcode_class) },
    { MP_ROM_QSTR(MP_QSTR_animimg_class), MP_ROM_PTR(&mp_lv_animimg_class) },
    { MP_ROM_QSTR(MP_QSTR_calendar_class), MP_ROM_PTR(&mp_lv_calendar_class) },
    { MP_ROM_QSTR(MP_QSTR_calendar_header_arrow_class), MP_ROM_PTR(&mp_lv_calendar_header_arrow_class) },
    { MP_ROM_QSTR(MP_QSTR_calendar_header_dropdown_class), MP_ROM_PTR(&mp_lv_calendar_header_dropdown_class) },
    { MP_ROM_QSTR(MP_QSTR_chart_class), MP_ROM_PTR(&mp_lv_chart_class) },
    { MP_ROM_QSTR(MP_QSTR_keyboard_class), MP_ROM_PTR(&mp_lv_keyboard_class) },
    { MP_ROM_QSTR(MP_QSTR_list_class), MP_ROM_PTR(&mp_lv_list_class) },
    { MP_ROM_QSTR(MP_QSTR_list_text_class), MP_ROM_PTR(&mp_lv_list_text_class) },
    { MP_ROM_QSTR(MP_QSTR_list_btn_class), MP_ROM_PTR(&mp_lv_list_btn_class) },
    { MP_ROM_QSTR(MP_QSTR_menu_class), MP_ROM_PTR(&mp_lv_menu_class) },
    { MP_ROM_QSTR(MP_QSTR_menu_page_class), MP_ROM_PTR(&mp_lv_menu_page_class) },
    { MP_ROM_QSTR(MP_QSTR_menu_cont_class), MP_ROM_PTR(&mp_lv_menu_cont_class) },
    { MP_ROM_QSTR(MP_QSTR_menu_section_class), MP_ROM_PTR(&mp_lv_menu_section_class) },
    { MP_ROM_QSTR(MP_QSTR_menu_separator_class), MP_ROM_PTR(&mp_lv_menu_separator_class) },
    { MP_ROM_QSTR(MP_QSTR_menu_sidebar_cont_class), MP_ROM_PTR(&mp_lv_menu_sidebar_cont_class) },
    { MP_ROM_QSTR(MP_QSTR_menu_main_cont_class), MP_ROM_PTR(&mp_lv_menu_main_cont_class) },
    { MP_ROM_QSTR(MP_QSTR_menu_sidebar_header_cont_class), MP_ROM_PTR(&mp_lv_menu_sidebar_header_cont_class) },
    { MP_ROM_QSTR(MP_QSTR_menu_main_header_cont_class), MP_ROM_PTR(&mp_lv_menu_main_header_cont_class) },
    { MP_ROM_QSTR(MP_QSTR_msgbox_class), MP_ROM_PTR(&mp_lv_msgbox_class) },
    { MP_ROM_QSTR(MP_QSTR_msgbox_content_class), MP_ROM_PTR(&mp_lv_msgbox_content_class) },
    { MP_ROM_QSTR(MP_QSTR_msgbox_backdrop_class), MP_ROM_PTR(&mp_lv_msgbox_backdrop_class) },
    { MP_ROM_QSTR(MP_QSTR_meter_class), MP_ROM_PTR(&mp_lv_meter_class) },
    { MP_ROM_QSTR(MP_QSTR_spinbox_class), MP_ROM_PTR(&mp_lv_spinbox_class) },
    { MP_ROM_QSTR(MP_QSTR_spinner_class), MP_ROM_PTR(&mp_lv_spinner_class) },
    { MP_ROM_QSTR(MP_QSTR_tabview_class), MP_ROM_PTR(&mp_lv_tabview_class) },
    { MP_ROM_QSTR(MP_QSTR_tileview_class), MP_ROM_PTR(&mp_lv_tileview_class) },
    { MP_ROM_QSTR(MP_QSTR_tileview_tile_class), MP_ROM_PTR(&mp_lv_tileview_tile_class) },
    { MP_ROM_QSTR(MP_QSTR_win_class), MP_ROM_PTR(&mp_lv_win_class) },
    { MP_ROM_QSTR(MP_QSTR_colorwheel_class), MP_ROM_PTR(&mp_lv_colorwheel_class) },
    { MP_ROM_QSTR(MP_QSTR_led_class), MP_ROM_PTR(&mp_lv_led_class) },
    { MP_ROM_QSTR(MP_QSTR_imgbtn_class), MP_ROM_PTR(&mp_lv_imgbtn_class) },
    { MP_ROM_QSTR(MP_QSTR_spangroup_class), MP_ROM_PTR(&mp_lv_spangroup_class) },
    { MP_ROM_QSTR(MP_QSTR_lvsfheader_class), MP_ROM_PTR(&mp_lv_lvsfheader_class) },
    { MP_ROM_QSTR(MP_QSTR_lvsfcomp_class), MP_ROM_PTR(&mp_lv_lvsfcomp_class) },
    { MP_ROM_QSTR(MP_QSTR_lvsfcorner_class), MP_ROM_PTR(&mp_lv_lvsfcorner_class) },
    { MP_ROM_QSTR(MP_QSTR_rlottie_class), MP_ROM_PTR(&mp_lv_rlottie_class) },
    
    
};


STATIC MP_DEFINE_CONST_DICT (
    mp_module_lvgl_globals,
    lvgl_globals_table
);

const mp_obj_module_t mp_module_lvgl = {
    .base = { &mp_type_module },
    .globals = (mp_obj_dict_t*)&mp_module_lvgl_globals
};

